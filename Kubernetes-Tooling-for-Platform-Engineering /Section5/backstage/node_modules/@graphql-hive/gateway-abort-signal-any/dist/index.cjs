'use strict';

function isAbortSignalFromAny(signal) {
  return signal != null && "signals" in signal && "addSignals" in signal;
}
function abortSignalAny(givenSignals) {
  const signals = /* @__PURE__ */ new Set();
  let singleSignal;
  for (const signal of givenSignals) {
    if (isAbortSignalFromAny(signal)) {
      for (const childSignal of signal.signals) {
        singleSignal = childSignal;
        signals.add(childSignal);
      }
    } else {
      singleSignal = signal;
      signals.add(signal);
    }
  }
  if (signals.size < 2) {
    return singleSignal;
  }
  if (signals.size === 0) {
    return void 0;
  }
  const ctrl = new AbortController();
  function onAbort(ev) {
    const signal = ev.target || this;
    ctrl.abort(signal.reason);
    for (const signal2 of signals) {
      signal2.removeEventListener("abort", onAbort);
    }
  }
  for (const signal of signals) {
    signal.addEventListener("abort", onAbort, { once: true });
  }
  Object.defineProperties(ctrl.signal, {
    signals: { value: signals },
    addSignals: {
      value(newSignals) {
        for (const signal of newSignals) {
          if (isAbortSignalFromAny(signal)) {
            for (const childSignal of signal.signals) {
              if (!signals.has(childSignal)) {
                signals.add(childSignal);
                childSignal.addEventListener("abort", onAbort, { once: true });
              }
            }
          } else {
            if (!signals.has(signal)) {
              signals.add(signal);
              signal.addEventListener("abort", onAbort, { once: true });
            }
          }
        }
      }
    }
  });
  return ctrl.signal;
}

exports.abortSignalAny = abortSignalAny;
exports.isAbortSignalFromAny = isAbortSignalFromAny;
