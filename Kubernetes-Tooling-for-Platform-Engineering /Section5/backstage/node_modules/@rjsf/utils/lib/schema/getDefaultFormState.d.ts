import { Experimental_CustomMergeAllOf, Experimental_DefaultFormStateBehavior, FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';
/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.
 */
export declare enum AdditionalItemsHandling {
    Ignore = 0,
    Invert = 1,
    Fallback = 2
}
/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
 * `additionalItems` enum and the value of `idx`. There are four possible returns:
 * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
 *    index and not a boolean, otherwise it falls through to 3.
 * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually
 *    is a schema, otherwise it falls through to 3.
 * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then
 *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.
 * 4. {} is returned representing an empty schema
 *
 * @param schema - The schema from which to get the particular item
 * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?
 * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array
 * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers
 */
export declare function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(schema: S, additionalItems?: AdditionalItemsHandling, idx?: number): S;
interface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {
    /** Any defaults provided by the parent field in the schema */
    parentDefaults?: T;
    /** The options root schema, used to primarily to look up `$ref`s */
    rootSchema?: S;
    /** The current formData, if any, onto which to provide any missing defaults */
    rawFormData?: T;
    /** Optional flag, if true, cause undefined values to be added as defaults.
     *          If "excludeObjectChildren", cause undefined values for this object and pass `includeUndefinedValues` as
     *          false when computing defaults for any nested object properties.
     */
    includeUndefinedValues?: boolean | 'excludeObjectChildren';
    /** The list of ref names currently being recursed, used to prevent infinite recursion */
    _recurseList?: string[];
    /** Optional configuration object, if provided, allows users to override default form state behavior */
    experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;
    /** Optional function that allows for custom merging of `allOf` schemas */
    experimental_customMergeAllOf?: Experimental_CustomMergeAllOf<S>;
    /** Optional flag, if true, indicates this schema was required in the parent schema. */
    required?: boolean;
}
/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into
 * each level of the schema, recursively, to fill out every level of defaults provided by the schema.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param rawSchema - The schema for which the default state is desired
 * @param {ComputeDefaultsProps} computeDefaultsProps - Optional props for this function
 * @returns - The resulting `formData` with all the defaults provided
 */
export declare function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(validator: ValidatorType<T, S, F>, rawSchema: S, computeDefaultsProps?: ComputeDefaultsProps<T, S>): T | T[] | undefined;
/** Computes the default value for objects.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param rawSchema - The schema for which the default state is desired
 * @param {ComputeDefaultsProps} computeDefaultsProps - Optional props for this function
 * @param defaults - Optional props for this function
 * @returns - The default value based on the schema type if they are defined for object or array schemas.
 */
export declare function getObjectDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(validator: ValidatorType<T, S, F>, rawSchema: S, { rawFormData, rootSchema, includeUndefinedValues, _recurseList, experimental_defaultFormStateBehavior, experimental_customMergeAllOf, required, }?: ComputeDefaultsProps<T, S>, defaults?: T | T[] | undefined): T;
/** Computes the default value for arrays.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param rawSchema - The schema for which the default state is desired
 * @param {ComputeDefaultsProps} computeDefaultsProps - Optional props for this function
 * @param defaults - Optional props for this function
 * @returns - The default value based on the schema type if they are defined for object or array schemas.
 */
export declare function getArrayDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(validator: ValidatorType<T, S, F>, rawSchema: S, { rawFormData, rootSchema, _recurseList, experimental_defaultFormStateBehavior, experimental_customMergeAllOf, required, }?: ComputeDefaultsProps<T, S>, defaults?: T | T[] | undefined): T | T[] | undefined;
/** Computes the default value based on the schema type.
 *
 * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary
 * @param rawSchema - The schema for which the default state is desired
 * @param {ComputeDefaultsProps} computeDefaultsProps - Optional props for this function
 * @param defaults - Optional props for this function
 * @returns - The default value based on the schema type if they are defined for object or array schemas.
 */
export declare function getDefaultBasedOnSchemaType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(validator: ValidatorType<T, S, F>, rawSchema: S, computeDefaultsProps?: ComputeDefaultsProps<T, S>, defaults?: T | T[] | undefined): T | T[] | void;
/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
 * computed to have defaults provided in the `schema`.
 *
 * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary
 * @param theSchema - The schema for which the default state is desired
 * @param [formData] - The current formData, if any, onto which to provide any missing defaults
 * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s
 * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
 *          If "excludeObjectChildren", cause undefined values for this object and pass `includeUndefinedValues` as
 *          false when computing defaults for any nested object properties.
 * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
 * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
 * @returns - The resulting `formData` with all the defaults provided
 */
export default function getDefaultFormState<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(validator: ValidatorType<T, S, F>, theSchema: S, formData?: T, rootSchema?: S, includeUndefinedValues?: boolean | 'excludeObjectChildren', experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior, experimental_customMergeAllOf?: Experimental_CustomMergeAllOf<S>): T | T[] | undefined;
export {};
