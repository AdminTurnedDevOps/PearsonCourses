{
  "version": 3,
  "sources": ["../src/validator.ts", "../src/createAjvInstance.ts", "../src/processRawValidationErrors.ts", "../src/customizeValidator.ts", "../src/precompiledValidator.ts", "../src/createPrecompiledValidator.ts", "../src/index.ts"],
  "sourcesContent": ["import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\nimport {\n  CustomValidator,\n  deepEquals,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  ID_KEY,\n  RJSFSchema,\n  ROOT_SCHEMA_PREFIX,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  withIdRefPrefix,\n  hashForSchema,\n} from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport createAjvInstance from './createAjvInstance';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n\n  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.\n   */\n  reset() {\n    this.ajv.removeSchema();\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema[ID_KEY]) {\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        // Missing properties need to be enclosed with quotes so that\n        // `AJV8Validator#transformRJSFValidationErrors` replaces property names\n        // with `title` or `ui:title`. See #4348, #4349, and #4387.\n        (compiledValidator.errors ?? []).forEach((error) => {\n          if (error.params?.missingProperty) {\n            error.params.missingProperty = `'${error.params.missingProperty}'`;\n          }\n        });\n        this.localizer(compiledValidator.errors);\n        // Revert to originals\n        (compiledValidator.errors ?? []).forEach((error) => {\n          if (error.params?.missingProperty) {\n            error.params.missingProperty = error.params.missingProperty.slice(1, -1);\n          }\n        });\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /**\n   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  handleSchemaUpdate(rootSchema: S): void {\n    const rootSchemaId = rootSchema[ID_KEY] ?? ROOT_SCHEMA_PREFIX;\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // if schema validator instance doesn't exist, add it.\n    // else if the root schemas don't match, we should remove and add the root schema so we don't have to remove and recompile the schema every run.\n    if (this.ajv.getSchema(rootSchemaId) === undefined) {\n      this.ajv.addSchema(rootSchema, rootSchemaId);\n    } else if (!deepEquals(rootSchema, this.ajv.getSchema(rootSchemaId)?.schema)) {\n      this.ajv.removeSchema(rootSchemaId);\n      this.ajv.addSchema(rootSchema, rootSchemaId);\n    }\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    try {\n      this.handleSchemaUpdate(rootSchema);\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const schemaWithIdRefPrefix = withIdRefPrefix<S>(schema) as S;\n      const schemaId = schemaWithIdRefPrefix[ID_KEY] ?? hashForSchema(schemaWithIdRefPrefix);\n      let compiledValidator: ValidateFunction | undefined;\n      compiledValidator = this.ajv.getSchema(schemaId);\n      if (compiledValidator === undefined) {\n        // Add schema by an explicit ID so it can be fetched later\n        // Fall back to using compile if necessary\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\n        compiledValidator =\n          this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||\n          this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    }\n  }\n}\n", "import Ajv, { Options } from 'ajv';\nimport addFormats, { FormatsPluginOptions } from 'ajv-formats';\nimport isObject from 'lodash/isObject';\n\nimport { CustomValidatorOptionsType } from './types';\nimport { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITIONAL_PROPERTIES_FLAG } from '@rjsf/utils';\n\nexport const AJV_CONFIG: Options = {\n  allErrors: true,\n  multipleOfPrecision: 8,\n  strict: false,\n  verbose: true,\n  discriminator: false, // TODO enable this in V6\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType['additionalMetaSchemas'],\n  customFormats?: CustomValidatorOptionsType['customFormats'],\n  ajvOptionsOverrides: CustomValidatorOptionsType['ajvOptionsOverrides'] = {},\n  ajvFormatOptions?: FormatsPluginOptions | false,\n  AjvClass: typeof Ajv = Ajv\n) {\n  const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n  if (ajvFormatOptions) {\n    addFormats(ajv, ajvFormatOptions);\n  } else if (ajvFormatOptions !== false) {\n    addFormats(ajv);\n  }\n\n  // add custom formats\n  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);\n  ajv.addFormat('color', COLOR_FORMAT_REGEX);\n\n  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\n  ajv.addKeyword(RJSF_ADDITIONAL_PROPERTIES_FLAG);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n", "import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport {\n  createErrorHandler,\n  CustomValidator,\n  ErrorTransformer,\n  FormContextType,\n  getDefaultFormState,\n  getUiOptions,\n  PROPERTIES_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  toErrorSchema,\n  UiSchema,\n  unwrapErrorHandler,\n  validationDataMerge,\n  ValidatorType,\n} from '@rjsf/utils';\n\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\n\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\n  return errors.map((e: ErrorObject) => {\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n    let { message = '' } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty: string = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        message = message.replace(`'${currentProperty}'`, `'${uiSchemaTitle}'`);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n        if (parentSchemaTitle) {\n          message = message.replace(`'${currentProperty}'`, `'${parentSchemaTitle}'`);\n        }\n      }\n\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema?.title;\n\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack,\n      schemaPath,\n    };\n  });\n}\n\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rawErrors: RawValidationErrorsType<ErrorObject>,\n  formData: T | undefined,\n  schema: S,\n  customValidate?: CustomValidator<T, S, F>,\n  transformErrors?: ErrorTransformer<T, S, F>,\n  uiSchema?: UiSchema<T, S, F>\n) {\n  const { validationError: invalidSchemaError } = rawErrors;\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\n\n  if (invalidSchemaError) {\n    errors = [...errors, { stack: invalidSchemaError!.message }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n\n  let errorSchema = toErrorSchema<T>(errors);\n\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError!.message],\n      },\n    };\n  }\n\n  if (typeof customValidate !== 'function') {\n    return { errors, errorSchema };\n  }\n\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\n\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema } from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport AJV8Validator from './validator';\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV\n * validation.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The custom validator implementation resulting from the set of parameters provided\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(options: CustomValidatorOptionsType = {}, localizer?: Localizer) {\n  return new AJV8Validator<T, S, F>(options, localizer);\n}\n", "import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  hashForSchema,\n  ID_KEY,\n  JUNK_OPTION_ID,\n  RJSFSchema,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  retrieveSchema,\n} from '@rjsf/utils';\n\nimport { CompiledValidateFunction, Localizer, ValidatorFunctions } from './types';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the\n * `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.\n */\nexport default class AJV8PrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> implements ValidatorType<T, S, F>\n{\n  /** The root schema object used to construct this validator\n   *\n   * @private\n   */\n  readonly rootSchema: S;\n\n  /** The `ValidatorFunctions` map used to construct this validator\n   *\n   * @private\n   */\n  readonly validateFns: ValidatorFunctions;\n\n  /** The main validator function associated with the base schema in the `precompiledValidator`\n   *\n   * @private\n   */\n  readonly mainValidator: CompiledValidateFunction;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`\n   *\n   * @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function\n   * @param rootSchema - The root schema that was used with the `compileSchema()` function\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   * @throws - Error when the base schema of the precompiled validator does not have a matching validator function\n   */\n  constructor(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer) {\n    this.rootSchema = rootSchema;\n    this.validateFns = validateFns;\n    this.localizer = localizer;\n    this.mainValidator = this.getValidator(rootSchema);\n  }\n\n  /** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator\n   * functions.\n   *\n   * @param schema - The schema for which a precompiled validator function is desired\n   * @returns - The precompiled validator function associated with this schema\n   */\n  getValidator(schema: S) {\n    const key = get(schema, ID_KEY) || hashForSchema(schema);\n    const validator = this.validateFns[key];\n    if (!validator) {\n      throw new Error(`No precompiled validator function was found for the given schema for \"${key}\"`);\n    }\n    return validator;\n  }\n\n  /** Ensures that the validator is using the same schema as the root schema used to construct the precompiled\n   * validator. It first compares the given `schema` against the root schema and if they aren't the same, then it\n   * checks against the resolved root schema, on the chance that a resolved version of the root schema was passed in\n   * instead of the raw root schema.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param [formData] - The form data to validate if any\n   */\n  ensureSameRootSchema(schema: S, formData?: T) {\n    if (!isEqual(schema, this.rootSchema)) {\n      // Resolve the root schema with the passed in form data since that may affect the resolution\n      const resolvedRootSchema = retrieveSchema(this, this.rootSchema, this.rootSchema, formData);\n      if (!isEqual(schema, resolvedRootSchema)) {\n        throw new Error(\n          'The schema associated with the precompiled validator differs from the rootSchema provided for validation'\n        );\n      }\n    }\n    return true;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param [formData] - The form data to validate, if any\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    this.ensureSameRootSchema(schema, formData);\n    this.mainValidator(formData);\n\n    if (typeof this.localizer === 'function') {\n      this.localizer(this.mainValidator.errors);\n    }\n    const errors = this.mainValidator.errors || undefined;\n\n    // Clear errors to prevent persistent errors, see #1104\n    this.mainValidator.errors = null;\n\n    return { errors: errors as unknown as Result[] };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is\n   * invalid, then this function will return false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   * @returns - true if the formData validates against the schema, false otherwise\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there\n   *        isn't a precompiled validator function associated with the schema\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    this.ensureSameRootSchema(rootSchema, formData);\n    if (get(schema, ID_KEY) === JUNK_OPTION_ID) {\n      return false;\n    }\n    const validator = this.getValidator(schema);\n    return validator(formData);\n  }\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '@rjsf/utils';\n\nimport { Localizer, ValidatorFunctions } from './types';\nimport AJV8PrecompiledValidator from './precompiledValidator';\n\n/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`\n * is provided, it is used to translate the messages generated by the underlying AJV validation.\n *\n * NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via\n * the `compileSchemaValidators()` function.\n *\n * @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function\n * @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The precompiled validator implementation resulting from the set of parameters provided\n */\nexport default function createPrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer): ValidatorType<T, S, F> {\n  return new AJV8PrecompiledValidator<T, S, F>(validateFns, rootSchema, localizer);\n}\n", "import customizeValidator from './customizeValidator';\nimport createPrecompiledValidator from './createPrecompiledValidator';\n\nexport { customizeValidator, createPrecompiledValidator };\nexport * from './types';\n\nexport default customizeValidator();\n"],
  "mappings": "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",
  "names": ["get", "hashForSchema", "ID_KEY", "toErrorList", "get", "ID_KEY", "hashForSchema", "toErrorList"]
}
