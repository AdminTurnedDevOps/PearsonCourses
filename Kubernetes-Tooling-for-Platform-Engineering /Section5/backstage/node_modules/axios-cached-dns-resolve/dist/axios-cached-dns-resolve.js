'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stats = exports.cacheConfig = exports.config = undefined;
exports.init = init;
exports.startBackgroundRefresh = startBackgroundRefresh;
exports.startPeriodicCachePrune = startPeriodicCachePrune;
exports.getStats = getStats;
exports.getDnsCacheEntries = getDnsCacheEntries;
exports.registerInterceptor = registerInterceptor;
exports.getAddress = getAddress;
exports.backgroundRefresh = backgroundRefresh;

var _dns = require('dns');

var _dns2 = _interopRequireDefault(_dns);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _jsonStringifySafe = require('json-stringify-safe');

var _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

var _logging = require('./logging');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-plusplus */
var util = require('util');

var dnsResolve = util.promisify(_dns2.default.resolve);

var config = exports.config = {
  disabled: process.env.AXIOS_DNS_DISABLE === 'true',
  dnsTtlMs: process.env.AXIOS_DNS_CACHE_TTL_MS || 5000, // when to refresh actively used dns entries (5 sec)
  cacheGraceExpireMultiplier: process.env.AXIOS_DNS_CACHE_EXPIRE_MULTIPLIER || 2, // maximum grace to use entry beyond TTL
  dnsIdleTtlMs: process.env.AXIOS_DNS_CACHE_IDLE_TTL_MS || 1000 * 60 * 60, // when to remove entry entirely if not being used (1 hour)
  backgroundScanMs: process.env.AXIOS_DNS_BACKGROUND_SCAN_MS || 2400, // how frequently to scan for expired TTL and refresh (2.4 sec)
  dnsCacheSize: process.env.AXIOS_DNS_CACHE_SIZE || 100, // maximum number of entries to keep in cache
  // pino logging options
  logging: {
    name: 'axios-cache-dns-resolve',
    // enabled: true,
    level: process.env.AXIOS_DNS_LOG_LEVEL || 'info', // default 'info' others trace, debug, info, warn, error, and fatal
    // timestamp: true,
    prettyPrint: process.env.NODE_ENV === 'DEBUG' || false,
    useLevelLabels: true
  },
  cache: undefined
};

var cacheConfig = exports.cacheConfig = {
  max: config.dnsCacheSize,
  maxAge: config.dnsTtlMs * config.cacheGraceExpireMultiplier // grace for refresh
};

var stats = exports.stats = {
  dnsEntries: 0,
  refreshed: 0,
  hits: 0,
  misses: 0,
  idleExpired: 0,
  errors: 0,
  lastError: 0,
  lastErrorTs: 0
};

var log = void 0;
var backgroundRefreshId = void 0;
var cachePruneId = void 0;

init();

function init() {
  log = (0, _logging.init)(config.logging);

  if (config.cache) return;

  config.cache = new _lruCache2.default(cacheConfig);

  startBackgroundRefresh();
  startPeriodicCachePrune();
  cachePruneId = setInterval(function () {
    return config.cache.prune();
  }, config.dnsIdleTtlMs);
}

function startBackgroundRefresh() {
  if (backgroundRefreshId) clearInterval(backgroundRefreshId);
  backgroundRefreshId = setInterval(backgroundRefresh, config.backgroundScanMs);
}

function startPeriodicCachePrune() {
  if (cachePruneId) clearInterval(cachePruneId);
  cachePruneId = setInterval(function () {
    return config.cache.prune();
  }, config.dnsIdleTtlMs);
}

function getStats() {
  stats.dnsEntries = config.cache.length;
  return stats;
}

function getDnsCacheEntries() {
  return config.cache.values();
}

// const dnsEntry = {
//   host: 'www.amazon.com',
//   ips: [
//     '52.54.40.141',
//     '34.205.98.207',
//     '3.82.118.51',
//   ],
//   nextIdx: 0,
//   lastUsedTs: 1555771516581, Date.now()
//   updatedTs: 1555771516581,
// }

function registerInterceptor(axios) {
  if (config.disabled || !axios || !axios.interceptors) return; // supertest
  axios.interceptors.request.use(async function (reqConfig) {
    var url = void 0;
    if (reqConfig.baseURL) {
      url = _url2.default.parse(reqConfig.baseURL);
    } else {
      url = _url2.default.parse(reqConfig.url);
    }

    if (_net2.default.isIP(url.hostname)) return reqConfig; // skip

    reqConfig.headers.Host = url.hostname; // set hostname in header

    url.hostname = await getAddress(url.hostname);
    delete url.host; // clear hostname

    if (reqConfig.baseURL) {
      reqConfig.baseURL = _url2.default.format(url);
    } else {
      reqConfig.url = _url2.default.format(url);
    }

    return reqConfig;
  });
}

async function getAddress(host) {
  var dnsEntry = config.cache.get(host);
  if (dnsEntry) {
    ++stats.hits;
    dnsEntry.lastUsedTs = Date.now();
    // eslint-disable-next-line no-plusplus
    var _ip = dnsEntry.ips[dnsEntry.nextIdx++ % dnsEntry.ips.length]; // round-robin
    config.cache.set(host, dnsEntry);
    return _ip;
  }
  ++stats.misses;
  if (log.isLevelEnabled('debug')) log.debug('cache miss ' + host);

  var ips = await dnsResolve(host);
  dnsEntry = {
    host: host,
    ips: ips,
    nextIdx: 0,
    lastUsedTs: Date.now(),
    updatedTs: Date.now()
    // eslint-disable-next-line no-plusplus
  };var ip = dnsEntry.ips[dnsEntry.nextIdx++ % dnsEntry.ips.length]; // round-robin
  config.cache.set(host, dnsEntry);
  return ip;
}

var backgroundRefreshing = false;
async function backgroundRefresh() {
  if (backgroundRefreshing) return; // don't start again if currently iterating slowly
  backgroundRefreshing = true;
  try {
    config.cache.forEach(async function (value, key) {
      try {
        if (value.updatedTs + config.dnsTtlMs > Date.now()) {
          return; // continue/skip
        }
        if (value.lastUsedTs + config.dnsIdleTtlMs <= Date.now()) {
          ++stats.idleExpired;
          config.cache.del(key);
          return; // continue
        }

        var ips = await dnsResolve(value.host);
        value.ips = ips;
        value.updatedTs = Date.now();
        config.cache.set(key, value);
        ++stats.refreshed;
      } catch (err) {
        // best effort
        recordError(err, 'Error backgroundRefresh host: ' + key + ', ' + (0, _jsonStringifySafe2.default)(value) + ', ' + err.message);
      }
    });
  } catch (err) {
    // best effort
    recordError(err, 'Error backgroundRefresh, ' + err.message);
  } finally {
    backgroundRefreshing = false;
  }
}

function recordError(err, errMesg) {
  ++stats.errors;
  stats.lastError = err;
  stats.lastErrorTs = new Date().toISOString();
  log.error(err, errMesg);
}
/* eslint-enable no-plusplus */