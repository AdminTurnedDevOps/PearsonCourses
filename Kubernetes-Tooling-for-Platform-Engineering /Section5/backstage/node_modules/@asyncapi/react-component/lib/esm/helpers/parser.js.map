{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../src/helpers/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Parser as AsyncapiParser,\n  Diagnostic,\n  DiagnosticSeverity,\n  fromURL,\n} from '@asyncapi/parser';\nimport { OpenAPISchemaParser } from '@asyncapi/openapi-schema-parser';\nimport { ProtoBuffSchemaParser } from '@asyncapi/protobuf-schema-parser';\nimport { AvroSchemaParser } from '@asyncapi/avro-schema-parser';\n\nimport {\n  ErrorObject,\n  ParserReturn,\n  FetchingSchemaInterface,\n  ValidationError,\n} from '../types';\n\nimport { VALIDATION_ERRORS_TYPE } from '../constants';\n\nconst asyncapiParser = new AsyncapiParser();\nasyncapiParser.registerSchemaParser(OpenAPISchemaParser());\nasyncapiParser.registerSchemaParser(AvroSchemaParser());\nasyncapiParser.registerSchemaParser(ProtoBuffSchemaParser());\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class Parser {\n  static async parse(\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents, @typescript-eslint/no-explicit-any\n    content: string | any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parserOptions?: any,\n  ): Promise<ParserReturn> {\n    try {\n      const { document, diagnostics } = await asyncapiParser.parse(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        content,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        parserOptions,\n      );\n\n      if (document === undefined) {\n        throw this.convertDiagnosticToErrorObject(diagnostics, [0]);\n      }\n\n      return { asyncapi: document };\n    } catch (err) {\n      return this.handleError(err as ErrorObject);\n    }\n  }\n\n  static async parseFromUrl(\n    arg: FetchingSchemaInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parserOptions?: any,\n  ): Promise<ParserReturn> {\n    try {\n      const fromResult = fromURL(\n        asyncapiParser,\n        arg.url,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arg.requestOptions as any,\n      );\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      const { document, diagnostics } = await fromResult.parse(parserOptions);\n\n      if (document == undefined) {\n        // this means there are errors in the document.\n        // so we gather all the severity 0 diagnostics and throw them as errors\n        throw this.convertDiagnosticToErrorObject(diagnostics, [0]);\n      }\n\n      return { asyncapi: document, error: undefined };\n    } catch (err) {\n      return this.handleError(err as ErrorObject);\n    }\n  }\n\n  static readonly convertDiagnosticToErrorObject = (\n    diagnostics: Diagnostic[],\n    severities: DiagnosticSeverity[],\n  ): ErrorObject => {\n    const error: ErrorObject = {\n      title: 'There are errors in your Asyncapi document',\n      type: 'VALIDATION_ERRORS_TYPE',\n      validationErrors: [],\n    };\n    diagnostics.forEach((diagnostic) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n      if (severities.includes(diagnostic.severity)) {\n        const tempObj: ValidationError = {\n          title: diagnostic.message,\n          location: {\n            jsonPointer: '/' + diagnostic.path.join('/'),\n            startLine: diagnostic.range.start.line,\n            startColumn: diagnostic.range.start.character,\n            // as of @asyncapi/parser 3.3.0 offset of 1 correctly shows the error line\n            startOffset: 1,\n            endLine: diagnostic.range.end.line,\n            endColumn: diagnostic.range.end.character,\n            endOffset: 0,\n          },\n        };\n        error.validationErrors?.push(tempObj);\n      }\n    });\n    return error;\n  };\n\n  private static handleError = (err: ErrorObject): ParserReturn => {\n    if (err.type === VALIDATION_ERRORS_TYPE) {\n      return {\n        error: err,\n      };\n    }\n    return { error: err };\n  };\n}\n"]}