var b = Object.defineProperty;
var r = (n, l) => b(n, "name", { value: l, configurable: !0 });
import { getNamedType as u, GraphQLInputObjectType as v, getNullableType as k, GraphQLList as F, GraphQLEnumType as S, SchemaMetaFieldDef as y, TypeMetaFieldDef as D, TypeNameMetaFieldDef as m, isCompositeType as h } from "graphql";
import { f as j } from "./forEachState.es.js";
function E(n, l) {
  const e = {
    schema: n,
    type: null,
    parentType: null,
    inputType: null,
    directiveDef: null,
    fieldDef: null,
    argDef: null,
    argDefs: null,
    objectFieldDefs: null
  };
  return j(l, (i) => {
    var a, p;
    switch (i.kind) {
      case "Query":
      case "ShortQuery":
        e.type = n.getQueryType();
        break;
      case "Mutation":
        e.type = n.getMutationType();
        break;
      case "Subscription":
        e.type = n.getSubscriptionType();
        break;
      case "InlineFragment":
      case "FragmentDefinition":
        i.type && (e.type = n.getType(i.type));
        break;
      case "Field":
      case "AliasedField":
        e.fieldDef = e.type && i.name ? T(n, e.parentType, i.name) : null, e.type = (a = e.fieldDef) === null || a === void 0 ? void 0 : a.type;
        break;
      case "SelectionSet":
        e.parentType = e.type ? u(e.type) : null;
        break;
      case "Directive":
        e.directiveDef = i.name ? n.getDirective(i.name) : null;
        break;
      case "Arguments":
        const f = i.prevState ? i.prevState.kind === "Field" ? e.fieldDef : i.prevState.kind === "Directive" ? e.directiveDef : i.prevState.kind === "AliasedField" ? i.prevState.name && T(n, e.parentType, i.prevState.name) : null : null;
        e.argDefs = f ? f.args : null;
        break;
      case "Argument":
        if (e.argDef = null, e.argDefs) {
          for (let t = 0; t < e.argDefs.length; t++)
            if (e.argDefs[t].name === i.name) {
              e.argDef = e.argDefs[t];
              break;
            }
        }
        e.inputType = (p = e.argDef) === null || p === void 0 ? void 0 : p.type;
        break;
      case "EnumValue":
        const d = e.inputType ? u(e.inputType) : null;
        e.enumValue = d instanceof S ? Q(d.getValues(), (t) => t.value === i.name) : null;
        break;
      case "ListValue":
        const g = e.inputType ? k(e.inputType) : null;
        e.inputType = g instanceof F ? g.ofType : null;
        break;
      case "ObjectValue":
        const s = e.inputType ? u(e.inputType) : null;
        e.objectFieldDefs = s instanceof v ? s.getFields() : null;
        break;
      case "ObjectField":
        const c = i.name && e.objectFieldDefs ? e.objectFieldDefs[i.name] : null;
        e.inputType = c == null ? void 0 : c.type;
        break;
      case "NamedType":
        e.type = i.name ? n.getType(i.name) : null;
        break;
    }
  }), e;
}
r(E, "getTypeInfo");
function T(n, l, e) {
  if (e === y.name && n.getQueryType() === l)
    return y;
  if (e === D.name && n.getQueryType() === l)
    return D;
  if (e === m.name && h(l))
    return m;
  if (l && l.getFields)
    return l.getFields()[e];
}
r(T, "getFieldDef");
function Q(n, l) {
  for (let e = 0; e < n.length; e++)
    if (l(n[e]))
      return n[e];
}
r(Q, "find");
function L(n) {
  return {
    kind: "Field",
    schema: n.schema,
    field: n.fieldDef,
    type: o(n.fieldDef) ? null : n.parentType
  };
}
r(L, "getFieldReference");
function R(n) {
  return {
    kind: "Directive",
    schema: n.schema,
    directive: n.directiveDef
  };
}
r(R, "getDirectiveReference");
function _(n) {
  return n.directiveDef ? {
    kind: "Argument",
    schema: n.schema,
    argument: n.argDef,
    directive: n.directiveDef
  } : {
    kind: "Argument",
    schema: n.schema,
    argument: n.argDef,
    field: n.fieldDef,
    type: o(n.fieldDef) ? null : n.parentType
  };
}
r(_, "getArgumentReference");
function G(n) {
  return {
    kind: "EnumValue",
    value: n.enumValue || void 0,
    type: n.inputType ? u(n.inputType) : void 0
  };
}
r(G, "getEnumValueReference");
function O(n, l) {
  return {
    kind: "Type",
    schema: n.schema,
    type: l || n.type
  };
}
r(O, "getTypeReference");
function o(n) {
  return n.name.slice(0, 2) === "__";
}
r(o, "isMetaField");
export {
  L as a,
  R as b,
  _ as c,
  G as d,
  O as e,
  E as g
};
//# sourceMappingURL=SchemaReference.es.js.map
