{"version":3,"file":"crypto.js","sourceRoot":"","sources":["../src/crypto.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AACjC,uCAA2C;AAE3C;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,gBAAgB,GACpB,oHAAoH,CAAC;AACvH,MAAM,YAAY,GAChB,gFAAgF,CAAC,CAAC,wCAAwC;AAE5H;;;;;;;;;;;;;GAaG;AACH,MAAM,gBAAgB,GAAG,CAAC,GAAW,EAAU,EAAE;;IAC/C,OAAO,GAAG,CACR,MAAA,GAAG;SACA,IAAI,EAAE;SACN,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;SAC3B,KAAK,CAAC,UAAU,CAAC,mCAAI,EAAE,CAC3B,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;AACnB,CAAC,CAAC;AAEF;;GAEG;AACI,MAAM,YAAY,GAAG,CAAC,OAAwB,EAAE,QAAkB,EAAU,EAAE;IACnF,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;IAChF,IAAA,wBAAc,EAAC,OAAO,EAAE,yBAAyB,CAAC,CAAC;IAEnD,IAAI,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC;IACnC,CAAC;IAED,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC5C,IAAA,wBAAc,EAAC,QAAQ,IAAI,SAAS,EAAE,kDAAkD,CAAC,CAAC;IAE1F,MAAM,GAAG,GAAG,cAAc,QAAQ,UAAU,OAAO,cAAc,QAAQ,OAAO,CAAC;IAEjF,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC;AAC/B,CAAC,CAAC;AAdW,QAAA,YAAY,gBAcvB;AAEK,MAAM,gBAAgB,GAAG,GAAW,EAAE;IAC3C,OAAO,GAAG,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AACtD,CAAC,CAAC;AAFW,QAAA,gBAAgB,oBAE3B;AAEK,MAAM,uBAAuB,GAAG,CAAC,WAAmB,EAAU,EAAE;IACrE,OAAO,WAAW;SACf,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;SAC3B,OAAO,CAAC,oCAAoC,EAAE,EAAE,CAAC;SACjD,OAAO,CAAC,kCAAkC,EAAE,EAAE,CAAC,CAAC;AACrD,CAAC,CAAC;AALW,QAAA,uBAAuB,2BAKlC","sourcesContent":["import * as crypto from \"crypto\";\nimport { assertRequired } from \"./utility\";\nimport { PemLabel } from \"./types\";\n/**\n * PEM format has wide range of usages, but this library\n * is enforcing RFC7468 which focuses on PKIX, PKCS and CMS.\n *\n * https://www.rfc-editor.org/rfc/rfc7468\n *\n * PEM_FORMAT_REGEX is validating given PEM file against RFC7468 'stricttextualmsg' definition.\n *\n * With few exceptions;\n *  - 'posteb' MAY have 'eol', but it is not mandatory.\n *  - 'preeb' and 'posteb' lines are limited to 64 characters, but\n *     should not cause any issues in context of PKIX, PKCS and CMS.\n *\n * normalizePemFile() -function is returning PEM files conforming\n * RFC7468 'stricttextualmsg' definition.\n *\n * With couple of notes:\n *  - 'eol' is normalized to '\\n'\n */\nconst PEM_FORMAT_REGEX =\n  /^(-----BEGIN [A-Z\\x20]{1,48}-----(\\r\\n|\\r|\\n){1}.*(\\r\\n|\\r|\\n){1}-----END [A-Z\\x20]{1,48}-----(\\r\\n|\\r|\\n){0,1})$/s;\nconst BASE64_REGEX =\n  /^(?:[A-Za-z0-9\\+\\/]{4}\\n{0,1})*(?:[A-Za-z0-9\\+\\/]{2}==|[A-Za-z0-9\\+\\/]{3}=)?$/s; // eslint-disable-line no-useless-escape\n\n/**\n * -----BEGIN [LABEL]-----\n * base64([DATA])\n * -----END [LABEL]-----\n *\n * Above is shown what PEM file looks like. As can be seen, base64 data\n * can be in single line or multiple lines.\n *\n * This function normalizes PEM presentation to;\n *  - contain PEM header and footer as they are given\n *  - normalize line endings to '\\n'\n *  - normalize line length to maximum of 64 characters\n *  - ensure that 'preeb' has line ending '\\n'\n */\nconst normalizePemFile = (pem: string): string => {\n  return `${(\n    pem\n      .trim()\n      .replace(/(\\r\\n|\\r)/g, \"\\n\")\n      .match(/.{1,64}/g) ?? []\n  ).join(\"\\n\")}\\n`;\n};\n\n/**\n * This function currently expects to get data in PEM format or in base64 format.\n */\nexport const keyInfoToPem = (keyInfo: string | Buffer, pemLabel: PemLabel): string => {\n  const keyData = Buffer.isBuffer(keyInfo) ? keyInfo.toString(\"latin1\") : keyInfo;\n  assertRequired(keyData, \"keyInfo is not provided\");\n\n  if (PEM_FORMAT_REGEX.test(keyData)) {\n    return normalizePemFile(keyData);\n  }\n\n  const isBase64 = BASE64_REGEX.test(keyData);\n  assertRequired(isBase64 || undefined, \"keyInfo is not in PEM format or in base64 format\");\n\n  const pem = `-----BEGIN ${pemLabel}-----\\n${keyInfo}\\n-----END ${pemLabel}-----`;\n\n  return normalizePemFile(pem);\n};\n\nexport const generateUniqueId = (): string => {\n  return \"_\" + crypto.randomBytes(20).toString(\"hex\");\n};\n\nexport const stripPemHeaderAndFooter = (certificate: string): string => {\n  return certificate\n    .replace(/(\\r\\n|\\r)/g, \"\\n\")\n    .replace(/-----BEGIN [A-Z\\x20]{1,48}-----\\n?/, \"\")\n    .replace(/-----END [A-Z\\x20]{1,48}-----\\n?/, \"\");\n};\n"]}