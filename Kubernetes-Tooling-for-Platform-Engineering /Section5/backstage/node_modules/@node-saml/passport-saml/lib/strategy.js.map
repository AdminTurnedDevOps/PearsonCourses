{"version":3,"file":"strategy.js","sourceRoot":"","sources":["../src/strategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { Strategy as PassportStrategy } from \"passport-strategy\";\nimport { strict as assert } from \"assert\";\nimport * as url from \"url\";\nimport { Profile, SAML } from \"@node-saml/node-saml\";\nimport { PassportSamlConfig } from \"./types\";\nimport {\n  AuthenticateOptions,\n  RequestWithUser,\n  User,\n  VerifiedCallback,\n  VerifyWithoutRequest,\n  VerifyWithRequest,\n} from \"./types\";\nimport { Request } from \"express\";\n\nexport abstract class AbstractStrategy extends PassportStrategy {\n  static readonly newSamlProviderOnConstruct: boolean;\n\n  name: string;\n  _signonVerify: VerifyWithRequest | VerifyWithoutRequest;\n  _logoutVerify: VerifyWithRequest | VerifyWithoutRequest;\n  _saml: SAML | undefined;\n  _passReqToCallback?: boolean;\n\n  constructor(\n    options: PassportSamlConfig,\n    signonVerify: VerifyWithRequest,\n    logoutVerify: VerifyWithRequest,\n  );\n  constructor(\n    options: PassportSamlConfig,\n    signonVerify: VerifyWithoutRequest,\n    logoutVerify: VerifyWithoutRequest,\n  );\n  constructor(options: PassportSamlConfig, signonVerify: never, logoutVerify: never) {\n    super();\n    if (typeof options === \"function\") {\n      throw new Error(\"Mandatory SAML options missing\");\n    }\n\n    if (!signonVerify || typeof signonVerify != \"function\") {\n      throw new Error(\"SAML authentication strategy requires a verify function\");\n    }\n\n    // Customizing the name can be useful to support multiple SAML configurations at the same time.\n    // Unlike other options, this one gets deleted instead of passed along.\n    if (options.name) {\n      this.name = options.name;\n    } else {\n      this.name = \"saml\";\n    }\n\n    this._signonVerify = signonVerify;\n    this._logoutVerify = logoutVerify;\n    if ((this.constructor as typeof Strategy).newSamlProviderOnConstruct) {\n      this._saml = new SAML(options);\n    }\n    this._passReqToCallback = !!options.passReqToCallback;\n  }\n\n  authenticate(req: Request, options: AuthenticateOptions): void {\n    if (this._saml == null) {\n      throw new Error(\"Can't get authenticate without a SAML provider defined.\");\n    }\n\n    options.samlFallback = options.samlFallback || \"login-request\";\n    const validateCallback = async ({\n      profile,\n      loggedOut,\n    }: {\n      profile: Profile | null;\n      loggedOut: boolean;\n    }) => {\n      if (loggedOut) {\n        if (profile != null) {\n          // When logging out a user, use the consumer's `validate` function to check that\n          // the `profile` associated with the logout request resolves to the same user\n          // as the `profile` associated with the current session.\n          const verified = async (logoutUser?: User) => {\n            let userMatch = true;\n            try {\n              // Check to see if we are logging out the user that is currently logged in to craft a proper IdP response\n              // It is up to the caller to return the same `User` as we have currently recorded as logged in for a successful logout\n\n              assert.deepStrictEqual(req.user, logoutUser);\n            } catch (err) {\n              userMatch = false;\n            }\n\n            const RelayState = req.query?.RelayState || req.body?.RelayState;\n            if (this._saml == null) {\n              return this.error(\n                new Error(\"Can't get logout response URL without a SAML provider defined.\"),\n              );\n            } else {\n              this._saml.getLogoutResponseUrl(\n                profile,\n                RelayState,\n                options,\n                userMatch,\n                redirectIfSuccess,\n              );\n            }\n\n            // Log out the current user no matter if we can verify the logged in user === logout requested user\n            await new Promise((resolve, reject) => {\n              req.logout((err) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(undefined);\n              });\n            });\n          };\n\n          let logoutUser: User | undefined;\n          try {\n            logoutUser = await new Promise((resolve, reject) => {\n              const verifedCallback: VerifiedCallback = (err: Error | null, logoutUser?: User) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(logoutUser);\n              };\n\n              if (this._passReqToCallback) {\n                (this._logoutVerify as VerifyWithRequest)(req, profile, verifedCallback);\n              } else {\n                (this._logoutVerify as VerifyWithoutRequest)(profile, verifedCallback);\n              }\n            });\n          } catch (err) {\n            return this.error(err as Error);\n          }\n          await verified(logoutUser);\n        } else {\n          // If the `profile` object was null, this is just a logout acknowledgment, so we take no action\n          return this.pass();\n        }\n      } else {\n        const verified = (err: Error | null, user?: User, info?: unknown) => {\n          if (err) {\n            return this.error(err);\n          }\n\n          if (!user) {\n            return this.fail(info, 401);\n          }\n\n          this.success(user, info);\n        };\n\n        if (this._passReqToCallback) {\n          (this._signonVerify as VerifyWithRequest)(req, profile, verified);\n        } else {\n          (this._signonVerify as VerifyWithoutRequest)(profile, verified);\n        }\n      }\n    };\n\n    const redirectIfSuccess = (err: Error | null, url?: string) => {\n      if (err) {\n        this.error(err);\n      } else if (url == null) {\n        this.error(new Error(\"Invalid logout redirect URL.\"));\n      } else {\n        this.redirect(url);\n      }\n    };\n\n    if (req.query?.SAMLResponse || req.query?.SAMLRequest) {\n      const originalQuery = url.parse(req.url).query ?? \"\";\n      this._saml\n        .validateRedirectAsync(req.query, originalQuery)\n        .then(validateCallback)\n        .catch((err) => this.error(err));\n    } else if (req.body?.SAMLResponse) {\n      this._saml\n        .validatePostResponseAsync(req.body)\n        .then(validateCallback)\n        .catch((err) => this.error(err));\n    } else if (req.body?.SAMLRequest) {\n      this._saml\n        .validatePostRequestAsync(req.body)\n        .then(validateCallback)\n        .catch((err) => this.error(err));\n    } else {\n      const requestHandler = {\n        \"login-request\": async () => {\n          try {\n            if (this._saml == null) {\n              throw new Error(\"Can't process login request without a SAML provider defined.\");\n            }\n\n            const RelayState =\n              (req.query && req.query.RelayState) || (req.body && req.body.RelayState);\n            const host = req.headers && req.headers.host;\n            if (this._saml.options.authnRequestBinding === \"HTTP-POST\") {\n              const data = await this._saml.getAuthorizeFormAsync(RelayState, host);\n              const res = req.res;\n              res?.send(data);\n            } else {\n              // Defaults to HTTP-Redirect\n              this.redirect(await this._saml.getAuthorizeUrlAsync(RelayState, host, options));\n            }\n          } catch (err) {\n            this.error(err as Error);\n          }\n        },\n        \"logout-request\": async () => {\n          if (this._saml == null) {\n            throw new Error(\"Can't process logout request without a SAML provider defined.\");\n          }\n\n          try {\n            const RelayState =\n              (req.query && req.query.RelayState) || (req.body && req.body.RelayState);\n            // Defaults to HTTP-Redirect\n            this.redirect(\n              await this._saml.getLogoutUrlAsync(req.user as Profile, RelayState, options),\n            );\n          } catch (err) {\n            this.error(err as Error);\n          }\n        },\n      }[options.samlFallback];\n\n      requestHandler();\n    }\n  }\n\n  logout(req: RequestWithUser, callback: (err: Error | null, url?: string | null) => void): void {\n    if (this._saml == null) {\n      throw new Error(\"Can't logout without a SAML provider defined.\");\n    }\n    const RelayState = (req.query && req.query.RelayState) || (req.body && req.body.RelayState);\n    this._saml\n      .getLogoutUrlAsync(req.user as Profile, RelayState, {})\n      .then((url) => callback(null, url))\n      .catch((err) => callback(err));\n  }\n\n  protected _generateServiceProviderMetadata(\n    decryptionCert: string | null,\n    signingCert?: string | string[] | null,\n  ): string {\n    if (this._saml == null) {\n      throw new Error(\"Can't generate service provider metadata without a SAML provider defined.\");\n    }\n\n    return this._saml.generateServiceProviderMetadata(decryptionCert, signingCert);\n  }\n\n  // This is redundant, but helps with testing\n  error(err: Error): void {\n    super.error(err);\n  }\n  redirect(url: string, status?: number): void {\n    super.redirect(url, status);\n  }\n  success(user: unknown, info?: unknown): void {\n    super.success(user, info);\n  }\n}\n\nexport class Strategy extends AbstractStrategy {\n  static readonly newSamlProviderOnConstruct = true;\n\n  generateServiceProviderMetadata(\n    decryptionCert: string | null,\n    signingCert?: string | string[] | null,\n  ): string {\n    return this._generateServiceProviderMetadata(decryptionCert, signingCert);\n  }\n}\n"]}