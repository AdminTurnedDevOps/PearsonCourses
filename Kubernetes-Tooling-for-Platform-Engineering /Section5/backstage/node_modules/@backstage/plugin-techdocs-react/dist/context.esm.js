import React, { memo, useState, useEffect, useContext } from 'react';
import useAsync from 'react-use/esm/useAsync';
import useAsyncRetry from 'react-use/esm/useAsyncRetry';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { createVersionedContext, createVersionedValueMap } from '@backstage/version-bridge';
import { useApi, configApiRef, AnalyticsContext } from '@backstage/core-plugin-api';
import { techdocsApiRef } from './api.esm.js';
import { toLowercaseEntityRefMaybe } from './helpers.esm.js';

const areEntityRefsEqual = (prevEntityRef, nextEntityRef) => {
  return stringifyEntityRef(prevEntityRef) === stringifyEntityRef(nextEntityRef);
};
const defaultTechDocsReaderPageValue = {
  title: "",
  subtitle: "",
  setTitle: () => {
  },
  setSubtitle: () => {
  },
  setShadowRoot: () => {
  },
  metadata: { loading: true },
  entityMetadata: { loading: true },
  entityRef: { kind: "", name: "", namespace: "" }
};
const TechDocsReaderPageContext = createVersionedContext("techdocs-reader-page-context");
const TechDocsReaderPageProvider = memo(
  (props) => {
    const { entityRef, children } = props;
    const techdocsApi = useApi(techdocsApiRef);
    const config = useApi(configApiRef);
    const entityMetadata = useAsync(async () => {
      return techdocsApi.getEntityMetadata(entityRef);
    }, [entityRef]);
    const metadata = useAsyncRetry(async () => {
      return techdocsApi.getTechDocsMetadata(entityRef);
    }, [entityRef]);
    const [title, setTitle] = useState(defaultTechDocsReaderPageValue.title);
    const [subtitle, setSubtitle] = useState(
      defaultTechDocsReaderPageValue.subtitle
    );
    const [shadowRoot, setShadowRoot] = useState(
      defaultTechDocsReaderPageValue.shadowRoot
    );
    useEffect(() => {
      if (shadowRoot && !metadata.value && !metadata.loading) {
        metadata.retry();
      }
    }, [
      metadata.value,
      metadata.loading,
      shadowRoot,
      metadata.retry,
      metadata
    ]);
    const value = {
      metadata,
      entityRef: toLowercaseEntityRefMaybe(entityRef, config),
      entityMetadata,
      shadowRoot,
      setShadowRoot,
      title,
      setTitle,
      subtitle,
      setSubtitle
    };
    const versionedValue = createVersionedValueMap({ 1: value });
    return /* @__PURE__ */ React.createElement(
      AnalyticsContext,
      {
        attributes: { entityRef: stringifyEntityRef(entityRef) }
      },
      /* @__PURE__ */ React.createElement(TechDocsReaderPageContext.Provider, { value: versionedValue }, children instanceof Function ? children(value) : children)
    );
  },
  (prevProps, nextProps) => {
    return areEntityRefsEqual(prevProps.entityRef, nextProps.entityRef);
  }
);
const useTechDocsReaderPage = () => {
  const versionedContext = useContext(TechDocsReaderPageContext);
  if (versionedContext === void 0) {
    return defaultTechDocsReaderPageValue;
  }
  const context = versionedContext.atVersion(1);
  if (context === void 0) {
    throw new Error("No context found for version 1.");
  }
  return context;
};

export { TechDocsReaderPageProvider, useTechDocsReaderPage };
//# sourceMappingURL=context.esm.js.map
