{"version":3,"file":"testUtils.cjs.js","sources":["../src/testUtils.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { packagePathMocks } from './paths';\nimport { posix as posixPath, resolve as resolvePath } from 'path';\n\n/** @public */\nexport interface PackagePathResolutionOverride {\n  /** Restores the normal behavior of resolvePackagePath */\n  restore(): void;\n}\n\n/** @public */\nexport interface OverridePackagePathResolutionOptions {\n  /** The name of the package to mock the resolved path of */\n  packageName: string;\n\n  /** A replacement for the root package path */\n  path?: string;\n\n  /**\n   * Replacements for package sub-paths, each key must be an exact match of the posix-style path\n   * that is being resolved within the package.\n   *\n   * For example, code calling `resolvePackagePath('x', 'foo', 'bar')` would match only the following\n   * configuration: `overridePackagePathResolution({ packageName: 'x', paths: { 'foo/bar': baz } })`\n   */\n  paths?: { [path in string]: string | (() => string) };\n}\n\n/**\n * This utility helps you override the paths returned by `resolvePackagePath` for a given package.\n *\n * @public\n */\nexport function overridePackagePathResolution(\n  options: OverridePackagePathResolutionOptions,\n): PackagePathResolutionOverride {\n  const name = options.packageName;\n\n  if (packagePathMocks.has(name)) {\n    throw new Error(\n      `Tried to override resolution for '${name}' more than once for package '${name}'`,\n    );\n  }\n\n  packagePathMocks.set(name, paths => {\n    const joinedPath = posixPath.join(...paths);\n    const localResolver = options.paths?.[joinedPath];\n    if (localResolver) {\n      return typeof localResolver === 'function'\n        ? localResolver()\n        : localResolver;\n    }\n    if (options.path) {\n      return resolvePath(options.path, ...paths);\n    }\n    return undefined;\n  });\n\n  return {\n    restore() {\n      packagePathMocks.delete(name);\n    },\n  };\n}\n"],"names":["packagePathMocks","posixPath","resolvePath"],"mappings":";;;;;AAgDO,SAAS,8BACd,OAC+B,EAAA;AAC/B,EAAA,MAAM,OAAO,OAAQ,CAAA,WAAA;AAErB,EAAI,IAAAA,sBAAA,CAAiB,GAAI,CAAA,IAAI,CAAG,EAAA;AAC9B,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,kCAAA,EAAqC,IAAI,CAAA,8BAAA,EAAiC,IAAI,CAAA,CAAA;AAAA,KAChF;AAAA;AAGF,EAAiBA,sBAAA,CAAA,GAAA,CAAI,MAAM,CAAS,KAAA,KAAA;AAClC,IAAA,MAAM,UAAa,GAAAC,UAAA,CAAU,IAAK,CAAA,GAAG,KAAK,CAAA;AAC1C,IAAM,MAAA,aAAA,GAAgB,OAAQ,CAAA,KAAA,GAAQ,UAAU,CAAA;AAChD,IAAA,IAAI,aAAe,EAAA;AACjB,MAAA,OAAO,OAAO,aAAA,KAAkB,UAC5B,GAAA,aAAA,EACA,GAAA,aAAA;AAAA;AAEN,IAAA,IAAI,QAAQ,IAAM,EAAA;AAChB,MAAA,OAAOC,YAAY,CAAA,OAAA,CAAQ,IAAM,EAAA,GAAG,KAAK,CAAA;AAAA;AAE3C,IAAO,OAAA,KAAA,CAAA;AAAA,GACR,CAAA;AAED,EAAO,OAAA;AAAA,IACL,OAAU,GAAA;AACR,MAAAF,sBAAA,CAAiB,OAAO,IAAI,CAAA;AAAA;AAC9B,GACF;AACF;;;;"}