'use strict';

var cliCommon = require('@backstage/cli-common');
var errors = require('@backstage/errors');
var path = require('path');
var fs = require('fs');

const packagePathMocks = /* @__PURE__ */ new Map();
function resolvePackagePath(name, ...paths) {
  const mockedResolve = packagePathMocks.get(name);
  if (mockedResolve) {
    const resolved = mockedResolve(paths);
    if (resolved) {
      return resolved;
    }
  }
  const req = typeof __non_webpack_require__ === "undefined" ? require : __non_webpack_require__;
  return path.resolve(req.resolve(`${name}/package.json`), "..", ...paths);
}
function resolveSafeChildPath(base, path$1) {
  const resolvedBasePath = resolveRealPath(base);
  const targetPath = path.resolve(resolvedBasePath, path$1);
  if (!cliCommon.isChildPath(resolvedBasePath, resolveRealPath(targetPath))) {
    throw new errors.NotAllowedError(
      "Relative path is not allowed to refer to a directory outside its parent"
    );
  }
  return path.resolve(base, path$1);
}
function resolveRealPath(path) {
  try {
    return fs.realpathSync(path);
  } catch (ex) {
    if (ex.code !== "ENOENT") {
      throw ex;
    }
  }
  return path;
}

Object.defineProperty(exports, "isChildPath", {
  enumerable: true,
  get: function () { return cliCommon.isChildPath; }
});
exports.packagePathMocks = packagePathMocks;
exports.resolvePackagePath = resolvePackagePath;
exports.resolveSafeChildPath = resolveSafeChildPath;
//# sourceMappingURL=paths.cjs.js.map
