/// <reference types="node" />
import { Readable } from 'stream';
import { Config } from '@backstage/config';
import { JsonObject, HumanDuration, JsonValue } from '@backstage/types';
import { Duration } from 'luxon';
import { Handler, Request, Response } from 'express';
import { PermissionAttributes, EvaluatorRequestOptions, PermissionEvaluator, AuthorizePermissionRequest, AuthorizePermissionResponse, QueryPermissionRequest, QueryPermissionResponse } from '@backstage/plugin-permission-common';
import { Knex } from 'knex';
export { isChildPath } from '@backstage/cli-common';

/**
 * A generic interface for fetching plain data from URLs.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/url-reader | service documentation} for more details.
 *
 * @public
 */
interface UrlReaderService {
    /**
     * Reads a single file and return its content.
     */
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    /**
     * Reads a full or partial file tree.
     */
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    /**
     * Searches for a file in a tree using a glob pattern.
     */
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
}
/**
 * An options object for readUrl operations.
 *
 * @public
 */
type UrlReaderServiceReadUrlOptions = {
    /**
     * An ETag which can be provided to check whether a
     * {@link UrlReaderService.readUrl} response has changed from a previous execution.
     *
     * @remarks
     *
     * In the {@link UrlReaderService.readUrl} response, an ETag is returned along with
     * the data. The ETag is a unique identifier of the data, usually the commit
     * SHA or ETag from the target.
     *
     * When an ETag is given in ReadUrlOptions, {@link UrlReaderService.readUrl} will
     * first compare the ETag against the ETag of the target. If they match,
     * {@link UrlReaderService.readUrl} will throw a
     * {@link @backstage/errors#NotModifiedError} indicating that the response
     * will not differ from the previous response which included this particular
     * ETag. If they do not match, {@link UrlReaderService.readUrl} will return the rest
     * of the response along with a new ETag.
     */
    etag?: string;
    /**
     * A date which can be provided to check whether a
     * {@link UrlReaderService.readUrl} response has changed since the lastModifiedAt.
     *
     * @remarks
     *
     * In the {@link UrlReaderService.readUrl} response, an lastModifiedAt is returned
     * along with data. The lastModifiedAt date represents the last time the data
     * was modified.
     *
     * When an lastModifiedAfter is given in ReadUrlOptions, {@link UrlReaderService.readUrl}
     * will compare the lastModifiedAfter against the lastModifiedAt of the target. If
     * the data has not been modified since this date, the {@link UrlReaderService.readUrl}
     * will throw a {@link @backstage/errors#NotModifiedError} indicating that the
     * response does not contain any new data. If they do not match,
     * {@link UrlReaderService.readUrl} will return the rest of the response along with new
     * lastModifiedAt date.
     */
    lastModifiedAfter?: Date;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
    /**
     * An optional token to use for authentication when reading the resources.
     *
     * @remarks
     *
     * By default all URL Readers will use the integrations config which is supplied
     * when creating the Readers. Sometimes it might be desireable to use the already
     * created URLReaders but with a different token, maybe that's supplied by the user
     * at runtime.
     */
    token?: string;
};
/**
 * A response object for {@link UrlReaderService.readUrl} operations.
 *
 * @public
 */
type UrlReaderServiceReadUrlResponse = {
    /**
     * Returns the data that was read from the remote URL.
     */
    buffer(): Promise<Buffer>;
    /**
     * Returns the data that was read from the remote URL as a Readable stream.
     *
     * @remarks
     *
     * This method will be required in a future release.
     */
    stream?(): Readable;
    /**
     * Etag returned by content provider.
     *
     * @remarks
     *
     * Can be used to compare and cache responses when doing subsequent calls.
     */
    etag?: string;
    /**
     * Last modified date of the file contents.
     */
    lastModifiedAt?: Date;
};
/**
 * An options object for {@link UrlReaderService.readTree} operations.
 *
 * @public
 */
type UrlReaderServiceReadTreeOptions = {
    /**
     * A filter that can be used to select which files should be included.
     *
     * @remarks
     *
     * The path passed to the filter function is the relative path from the URL
     * that the file tree is fetched from, without any leading '/'.
     *
     * For example, given the URL https://github.com/my/repo/tree/master/my-dir, a file
     * at https://github.com/my/repo/blob/master/my-dir/my-subdir/my-file.txt will
     * be represented as my-subdir/my-file.txt
     *
     * If no filter is provided, all files are extracted.
     */
    filter?(path: string, info?: {
        size: number;
    }): boolean;
    /**
     * An ETag which can be provided to check whether a
     * {@link UrlReaderService.readTree} response has changed from a previous execution.
     *
     * @remarks
     *
     * In the {@link UrlReaderService.readTree} response, an ETag is returned along with
     * the tree blob. The ETag is a unique identifier of the tree blob, usually
     * the commit SHA or ETag from the target.
     *
     * When an ETag is given as a request option, {@link UrlReaderService.readTree} will
     * first compare the ETag against the ETag on the target branch. If they
     * match, {@link UrlReaderService.readTree} will throw a
     * {@link @backstage/errors#NotModifiedError} indicating that the response
     * will not differ from the previous response which included this particular
     * ETag. If they do not match, {@link UrlReaderService.readTree} will return the
     * rest of the response along with a new ETag.
     */
    etag?: string;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
    /**
     * An optional token to use for authentication when reading the resources.
     *
     * @remarks
     *
     * By default all URL Readers will use the integrations config which is supplied
     * when creating the Readers. Sometimes it might be desireable to use the already
     * created URLReaders but with a different token, maybe that's supplied by the user
     * at runtime.
     */
    token?: string;
};
/**
 * Options that control {@link UrlReaderServiceReadTreeResponse.dir} execution.
 *
 * @public
 */
type UrlReaderServiceReadTreeResponseDirOptions = {
    /**
     * The directory to write files to.
     *
     * @remarks
     *
     * Defaults to the OS tmpdir, or `backend.workingDirectory` if set in config.
     */
    targetDir?: string;
};
/**
 * A response object for {@link UrlReaderService.readTree} operations.
 *
 * @public
 */
type UrlReaderServiceReadTreeResponse = {
    /**
     * Returns an array of all the files inside the tree, and corresponding
     * functions to read their content.
     */
    files(): Promise<UrlReaderServiceReadTreeResponseFile[]>;
    /**
     * Returns the tree contents as a binary archive, using a stream.
     */
    archive(): Promise<NodeJS.ReadableStream>;
    /**
     * Extracts the tree response into a directory and returns the path of the
     * directory.
     *
     * **NOTE**: It is the responsibility of the caller to remove the directory after use.
     */
    dir(options?: UrlReaderServiceReadTreeResponseDirOptions): Promise<string>;
    /**
     * Etag returned by content provider.
     *
     * @remarks
     *
     * Can be used to compare and cache responses when doing subsequent calls.
     */
    etag: string;
};
/**
 * Represents a single file in a {@link UrlReaderService.readTree} response.
 *
 * @public
 */
type UrlReaderServiceReadTreeResponseFile = {
    /**
     * The filepath of the data.
     */
    path: string;
    /**
     * The binary contents of the file.
     */
    content(): Promise<Buffer>;
    /**
     * The last modified timestamp of the data.
     */
    lastModifiedAt?: Date;
};
/**
 * An options object for search operations.
 *
 * @public
 */
type UrlReaderServiceSearchOptions = {
    /**
     * An etag can be provided to check whether the search response has changed from a previous execution.
     *
     * In the search() response, an etag is returned along with the files. The etag is a unique identifier
     * of the current tree, usually the commit SHA or etag from the target.
     *
     * When an etag is given in SearchOptions, search will first compare the etag against the etag
     * on the target branch. If they match, search will throw a NotModifiedError indicating that the search
     * response will not differ from the previous response which included this particular etag. If they mismatch,
     * search will return the rest of SearchResponse along with a new etag.
     */
    etag?: string;
    /**
     * An abort signal to pass down to the underlying request.
     *
     * @remarks
     *
     * Not all reader implementations may take this field into account.
     */
    signal?: AbortSignal;
    /**
     * An optional token to use for authentication when reading the resources.
     *
     * @remarks
     *
     * By default all URL Readers will use the integrations config which is supplied
     * when creating the Readers. Sometimes it might be desireable to use the already
     * created URLReaders but with a different token, maybe that's supplied by the user
     * at runtime.
     */
    token?: string;
};
/**
 * The output of a search operation.
 *
 * @public
 */
type UrlReaderServiceSearchResponse = {
    /**
     * The files that matched the search query.
     */
    files: UrlReaderServiceSearchResponseFile[];
    /**
     * A unique identifier of the current remote tree, usually the commit SHA or etag from the target.
     */
    etag: string;
};
/**
 * Represents a single file in a search response.
 *
 * @public
 */
type UrlReaderServiceSearchResponseFile = {
    /**
     * The full URL to the file.
     */
    url: string;
    /**
     * The binary contents of the file.
     */
    content(): Promise<Buffer>;
    /**
     * The last modified timestamp of the data.
     */
    lastModifiedAt?: Date;
};

/**
 * A function that can be called as a scheduled task.
 *
 * It may optionally accept an abort signal argument. When the signal triggers,
 * processing should abort and return as quickly as possible.
 *
 * @public
 */
type SchedulerServiceTaskFunction = ((abortSignal: AbortSignal) => void | Promise<void>) | (() => void | Promise<void>);
/**
 * A semi-opaque type to describe an actively scheduled task.
 *
 * @public
 */
type SchedulerServiceTaskDescriptor = {
    /**
     * The unique identifier of the task.
     */
    id: string;
    /**
     * The scope of the task.
     */
    scope: 'global' | 'local';
    /**
     * The settings that control the task flow. This is a semi-opaque structure
     * that is mainly there for debugging purposes. Do not make any assumptions
     * about the contents of this field.
     */
    settings: {
        version: number;
    } & JsonObject;
};
/**
 * Options that control the scheduling of a task.
 *
 * @public
 */
interface SchedulerServiceTaskScheduleDefinition {
    /**
     * How often you want the task to run. The system does its best to avoid
     * overlapping invocations.
     *
     * @remarks
     *
     * This is the best effort value; under some circumstances there can be
     * deviations. For example, if the task runtime is longer than the frequency
     * and the timeout has not been given or not been exceeded yet, the next
     * invocation of this task will be delayed until after the previous one
     * finishes.
     *
     * This is a required field.
     */
    frequency: {
        /**
         * A crontab style string.
         *
         * @remarks
         *
         * Overview:
         *
         * ```
         *   ┌────────────── second (optional)
         *   │ ┌──────────── minute
         *   │ │ ┌────────── hour
         *   │ │ │ ┌──────── day of month
         *   │ │ │ │ ┌────── month
         *   │ │ │ │ │ ┌──── day of week
         *   │ │ │ │ │ │
         *   │ │ │ │ │ │
         *   * * * * * *
         * ```
         */
        cron: string;
    } | Duration | HumanDuration | {
        trigger: 'manual';
    };
    /**
     * The maximum amount of time that a single task invocation can take, before
     * it's considered timed out and gets "released" such that a new invocation
     * is permitted to take place (possibly, then, on a different worker).
     */
    timeout: Duration | HumanDuration;
    /**
     * The amount of time that should pass before the first invocation happens.
     *
     * @remarks
     *
     * This can be useful in cold start scenarios to stagger or delay some heavy
     * compute jobs. If no value is given for this field then the first invocation
     * will happen as soon as possible according to the cadence.
     *
     * NOTE: This is a per-worker delay. If you have a cluster of workers all
     * collaborating on a task that has its `scope` field set to `'global'`, then
     * you may still see the task being processed by other long-lived workers,
     * while any given single worker is in its initial sleep delay time e.g. after
     * a deployment. Therefore, this parameter is not useful for "globally" pausing
     * work; its main intended use is for individual machines to get a chance to
     * reach some equilibrium at startup before triggering heavy batch workloads.
     */
    initialDelay?: Duration | HumanDuration;
    /**
     * Sets the scope of concurrency control / locking to apply for invocations of
     * this task.
     *
     * @remarks
     *
     * When the scope is set to the default value `'global'`, the scheduler will
     * attempt to ensure that only one worker machine runs the task at a time,
     * according to the given cadence. This means that as the number of worker
     * hosts increases, the invocation frequency of this task will not go up.
     * Instead, the load is spread randomly across hosts. This setting is useful
     * for tasks that access shared resources, for example catalog ingestion tasks
     * where you do not want many machines to repeatedly import the same data and
     * trample over each other.
     *
     * When the scope is set to `'local'`, there is no concurrency control across
     * hosts. Each host runs the task according to the given cadence similarly to
     * `setInterval`, but the runtime ensures that there are no overlapping runs.
     *
     * @defaultValue 'global'
     */
    scope?: 'global' | 'local';
}
/**
 * Config options for {@link SchedulerServiceTaskScheduleDefinition}
 * that control the scheduling of a task.
 *
 * @public
 */
interface SchedulerServiceTaskScheduleDefinitionConfig {
    /**
     * How often you want the task to run. The system does its best to avoid
     * overlapping invocations.
     *
     * @remarks
     *
     * This is the best effort value; under some circumstances there can be
     * deviations. For example, if the task runtime is longer than the frequency
     * and the timeout has not been given or not been exceeded yet, the next
     * invocation of this task will be delayed until after the previous one
     * finishes.
     *
     * This is a required field.
     */
    frequency: {
        /**
         * A crontab style string.
         *
         * @remarks
         *
         * Overview:
         *
         * ```
         *   ┌────────────── second (optional)
         *   │ ┌──────────── minute
         *   │ │ ┌────────── hour
         *   │ │ │ ┌──────── day of month
         *   │ │ │ │ ┌────── month
         *   │ │ │ │ │ ┌──── day of week
         *   │ │ │ │ │ │
         *   │ │ │ │ │ │
         *   * * * * * *
         * ```
         */
        cron: string;
    } | string | HumanDuration
    /**
     * This task will only run when manually triggered with the `triggerTask` method; no automatic
     * scheduling. This is useful for locking of global tasks that should not be run concurrently.
     */
     | {
        trigger: 'manual';
    };
    /**
     * The maximum amount of time that a single task invocation can take, before
     * it's considered timed out and gets "released" such that a new invocation
     * is permitted to take place (possibly, then, on a different worker).
     */
    timeout: string | HumanDuration;
    /**
     * The amount of time that should pass before the first invocation happens.
     *
     * @remarks
     *
     * This can be useful in cold start scenarios to stagger or delay some heavy
     * compute jobs. If no value is given for this field then the first invocation
     * will happen as soon as possible according to the cadence.
     *
     * NOTE: This is a per-worker delay. If you have a cluster of workers all
     * collaborating on a task that has its `scope` field set to `'global'`, then
     * you may still see the task being processed by other long-lived workers,
     * while any given single worker is in its initial sleep delay time e.g. after
     * a deployment. Therefore, this parameter is not useful for "globally" pausing
     * work; its main intended use is for individual machines to get a chance to
     * reach some equilibrium at startup before triggering heavy batch workloads.
     */
    initialDelay?: string | HumanDuration;
    /**
     * Sets the scope of concurrency control / locking to apply for invocations of
     * this task.
     *
     * @remarks
     *
     * When the scope is set to the default value `'global'`, the scheduler will
     * attempt to ensure that only one worker machine runs the task at a time,
     * according to the given cadence. This means that as the number of worker
     * hosts increases, the invocation frequency of this task will not go up.
     * Instead, the load is spread randomly across hosts. This setting is useful
     * for tasks that access shared resources, for example catalog ingestion tasks
     * where you do not want many machines to repeatedly import the same data and
     * trample over each other.
     *
     * When the scope is set to `'local'`, there is no concurrency control across
     * hosts. Each host runs the task according to the given cadence similarly to
     * `setInterval`, but the runtime ensures that there are no overlapping runs.
     *
     * @defaultValue 'global'
     */
    scope?: 'global' | 'local';
}
/**
 * Options that apply to the invocation of a given task.
 *
 * @public
 */
interface SchedulerServiceTaskInvocationDefinition {
    /**
     * A unique ID (within the scope of the plugin) for the task.
     */
    id: string;
    /**
     * The actual task function to be invoked regularly.
     */
    fn: SchedulerServiceTaskFunction;
    /**
     * An abort signal that, when triggered, will stop the recurring execution of
     * the task.
     */
    signal?: AbortSignal;
}
/**
 * A previously prepared task schedule, ready to be invoked.
 *
 * @public
 */
interface SchedulerServiceTaskRunner {
    /**
     * Takes the schedule and executes an actual task using it.
     *
     * @param task - The actual runtime properties of the task
     */
    run(task: SchedulerServiceTaskInvocationDefinition): Promise<void>;
}
/**
 * Deals with the scheduling of distributed tasks, for a given plugin.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/scheduler | service documentation} for more details.
 *
 * @public
 */
interface SchedulerService {
    /**
     * Manually triggers a task by ID.
     *
     * If the task doesn't exist, a NotFoundError is thrown. If the task is
     * currently running, a ConflictError is thrown.
     *
     * @param id - The task ID
     */
    triggerTask(id: string): Promise<void>;
    /**
     * Schedules a task function for recurring runs.
     *
     * @remarks
     *
     * The `scope` task field controls whether to use coordinated exclusive
     * invocation across workers, or to just coordinate within the current worker.
     *
     * This convenience method performs both the scheduling and invocation in one
     * go.
     *
     * @param task - The task definition
     */
    scheduleTask(task: SchedulerServiceTaskScheduleDefinition & SchedulerServiceTaskInvocationDefinition): Promise<void>;
    /**
     * Creates a scheduled but dormant recurring task, ready to be launched at a
     * later time.
     *
     * @remarks
     *
     * This method is useful for pre-creating a schedule in outer code to be
     * passed into an inner implementation, such that the outer code controls
     * scheduling while inner code controls implementation.
     *
     * @param schedule - The task schedule
     */
    createScheduledTaskRunner(schedule: SchedulerServiceTaskScheduleDefinition): SchedulerServiceTaskRunner;
    /**
     * Returns all scheduled tasks registered to this scheduler.
     *
     * @remarks
     *
     * This method is useful for triggering tasks manually using the triggerTask
     * functionality. Note that the returned tasks contain only tasks that have
     * been initialized in this instance of the scheduler.
     *
     * @returns Scheduled tasks
     */
    getScheduledTasks(): Promise<SchedulerServiceTaskDescriptor[]>;
}
/**
 * Reads a {@link SchedulerServiceTaskScheduleDefinition} from config. Expects
 * the config not to be the root config, but the config for the definition.
 *
 * @param config - config for a TaskScheduleDefinition.
 * @public
 */
declare function readSchedulerServiceTaskScheduleDefinitionFromConfig(config: Config): SchedulerServiceTaskScheduleDefinition;

/**
 * A service that provides a logging facility.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/logger | service documentation} for more details.
 *
 * @public
 */
interface LoggerService {
    error(message: string, meta?: Error | JsonObject): void;
    warn(message: string, meta?: Error | JsonObject): void;
    info(message: string, meta?: Error | JsonObject): void;
    debug(message: string, meta?: Error | JsonObject): void;
    child(meta: JsonObject): LoggerService;
}

/**
 * Root-level logging.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/root-logger | service documentation} for more details.
 *
 * @public
 */
interface RootLoggerService extends LoggerService {
}

/**
 * @public
 */
type LifecycleServiceStartupHook = () => void | Promise<void>;
/**
 * @public
 */
interface LifecycleServiceStartupOptions {
    /**
     * Optional {@link LoggerService} that will be used for logging instead of the default logger.
     */
    logger?: LoggerService;
}
/**
 * @public
 */
type LifecycleServiceShutdownHook = () => void | Promise<void>;
/**
 * @public
 */
interface LifecycleServiceShutdownOptions {
    /**
     * Optional {@link LoggerService} that will be used for logging instead of the default logger.
     */
    logger?: LoggerService;
}
/**
 * Provides registration of plugin startup and shutdown lifecycle hooks.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/lifecycle | service documentation} for more details.
 *
 * @public
 */
interface LifecycleService {
    /**
     * Register a function to be called when the backend has been initialized.
     *
     * @remarks
     *
     * When used with plugin scope it will wait for the plugin itself to have been initialized.
     *
     * When used with root scope it will wait for all plugins to have been initialized.
     */
    addStartupHook(hook: LifecycleServiceStartupHook, options?: LifecycleServiceStartupOptions): void;
    /**
     * Register a function to be called when the backend is shutting down.
     */
    addShutdownHook(hook: LifecycleServiceShutdownHook, options?: LifecycleServiceShutdownOptions): void;
}

/**
 * Registration of backend startup and shutdown lifecycle hooks.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/root-lifecycle | service documentation} for more details.
 *
 * @public
 */
interface RootLifecycleService extends LifecycleService {
    addBeforeShutdownHook(hook: () => void | Promise<void>): void;
}

/**
 * HTTP route registration for root services.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/root-http-router | service documentation} for more details.
 *
 * @public
 */
interface RootHttpRouterService {
    /**
     * Registers a handler at the root of the backend router.
     * The path is required and may not be empty.
     */
    use(path: string, handler: Handler): void;
}

/**
 * Access metadata about the current plugin.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/plugin-metadata | service documentation} for more details.
 *
 * @public
 */
interface PluginMetadataService {
    /**
     * The ID of the current plugin.
     */
    getId(): string;
}

/**
 * Represents a user principal (for example when a user Backstage token issued
 * by the auth backend was given to a request).
 *
 * @remarks
 *
 * Additional information about the user can be fetched using the
 * {@link UserInfoService}.
 *
 * @public
 */
type BackstageUserPrincipal = {
    type: 'user';
    /**
     * The entity ref of the user entity that this principal represents.
     */
    userEntityRef: string;
};
/**
 * Represents a principal that is not authenticated (for example when no token
 * at all was given to a request).
 *
 * @public
 */
type BackstageNonePrincipal = {
    type: 'none';
};
/**
 * Represents a service principal (for example when an external access method
 * token was given to a request, or the caller was a Backstage backend plugin).
 * @public
 */
type BackstageServicePrincipal = {
    type: 'service';
    /**
     * A string that represents the service.
     *
     * @remarks
     *
     * This string is only informational, has no well defined semantics, and
     * should never be used to drive actual logic in code.
     */
    subject: string;
    /**
     * The access restrictions that apply to this principal.
     *
     * @remarks
     *
     * If no access restrictions are provided the principal is assumed to have
     * unlimited access, at a framework level. The permissions system and
     * individual plugins may or may not still apply additional access controls on
     * top of this.
     */
    accessRestrictions?: BackstagePrincipalAccessRestrictions;
};
/**
 * The access restrictions that apply to a given principal.
 *
 * @public
 */
type BackstagePrincipalAccessRestrictions = {
    /**
     * If given, the principal is limited to only performing actions with these
     * named permissions.
     *
     * Note that this only applies where permissions checks are enabled in the
     * first place. Endpoints that are not protected by the permissions system at
     * all, are not affected by this setting.
     *
     * This array always has at least one element, or is missing entirely.
     */
    permissionNames?: string[];
    /**
     * If given, the principal is limited to only performing actions whose
     * permissions have these attributes.
     *
     * Note that this only applies where permissions checks are enabled in the
     * first place. Endpoints that are not protected by the permissions system at
     * all, are not affected by this setting.
     *
     * This object always has at least one key, or is missing entirely.
     */
    permissionAttributes?: {
        /**
         * Match any of these action values. This array always has at least one
         * element, or is missing entirely.
         */
        action?: Array<Required<PermissionAttributes>['action']>;
    };
};
/**
 * An opaque representation of credentials, for example as passed in a
 * request-response flow.
 *
 * @public
 */
type BackstageCredentials<TPrincipal = unknown> = {
    $$type: '@backstage/BackstageCredentials';
    /**
     * If the credentials have a limited lifetime, this is the time at which they
     * expire and may no longer be accepted by a receiver.
     */
    expiresAt?: Date;
    /**
     * The principal (originator) of the request.
     *
     * @remarks
     *
     * This is semantically the originator of a request chain, and may or may not
     * represent the immediate caller of your service. For example, in
     * on-behalf-of scenarios, the immediate caller may be an intermediary backend
     * service, but the principal may still be a user that was the original
     * caller.
     */
    principal: TPrincipal;
};
/**
 * The types of principal that can be represented in a
 * {@link BackstageCredentials} object.
 *
 * @public
 */
type BackstagePrincipalTypes = {
    user: BackstageUserPrincipal;
    service: BackstageServicePrincipal;
    none: BackstageNonePrincipal;
    unknown: unknown;
};
/**
 * Provides token authentication and credentials management.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/auth | service documentation} for more details.
 *
 * @public
 */
interface AuthService {
    /**
     * Verifies a token and returns the associated credentials.
     */
    authenticate(token: string, options?: {
        /**
         * If set to true, allow limited access tokens (such as cookies).
         *
         * If this flag is not set, or is set to false, calls with limited access
         * tokens will lead to a {@link @backstage/errors#NotAllowedError} being
         * thrown.
         */
        allowLimitedAccess?: boolean;
    }): Promise<BackstageCredentials>;
    /**
     * Checks if the given credentials are of the given type, and narrows the
     * TypeScript type accordingly if there's a match.
     */
    isPrincipal<TType extends keyof BackstagePrincipalTypes>(credentials: BackstageCredentials, type: TType): credentials is BackstageCredentials<BackstagePrincipalTypes[TType]>;
    /**
     * Create a credentials object that represents an unauthenticated caller.
     */
    getNoneCredentials(): Promise<BackstageCredentials<BackstageNonePrincipal>>;
    /**
     * Create a credentials object that represents the current service itself.
     */
    getOwnServiceCredentials(): Promise<BackstageCredentials<BackstageServicePrincipal>>;
    /**
     * Issue a token that can be used for authenticating calls towards other
     * backend plugins.
     *
     * @remarks
     *
     * This method should be called before each request. Do not hold on to the
     * issued token and reuse it for future calls.
     */
    getPluginRequestToken(options: {
        /**
         * The credentials of the originator of the request.
         *
         * @remarks
         *
         * This is most commonly the result of
         * {@link AuthService.getOwnServiceCredentials} when the current service is
         * the originator, or the output of {@link HttpAuthService.credentials} when
         * performing requests on behalf of an incoming request identity.
         */
        onBehalfOf: BackstageCredentials;
        /**
         * The ID of the plugin that the request is being made to.
         */
        targetPluginId: string;
    }): Promise<{
        token: string;
    }>;
    /**
     * Issue a limited user token that can be used e.g. in cookie flows.
     */
    getLimitedUserToken(
    /**
     * The credentials that this token should represent. Must be a user
     * principal. Commonly the output of {@link HttpAuthService.credentials} is
     * used as the input.
     */
    credentials: BackstageCredentials<BackstageUserPrincipal>): Promise<{
        token: string;
        expiresAt: Date;
    }>;
    /**
     * Retrieve the public keys that have been used to sign tokens that were
     * issued by this service. This list is periodically pruned from keys that are
     * significantly past their expiry.
     */
    listPublicServiceKeys(): Promise<{
        keys: JsonObject[];
    }>;
}

/**
 * Options for {@link PermissionsService} requests.
 *
 * @public
 */
interface PermissionsServiceRequestOptions extends EvaluatorRequestOptions {
    credentials: BackstageCredentials;
}
/**
 * Permission system integration for authorization of user/service actions.
 *
 * See the {@link https://backstage.io/docs/permissions/overview | permissions documentation}
 * and the {@link https://backstage.io/docs/backend-system/core-services/permissions | service documentation}
 * for more details.
 *
 * @public
 */
interface PermissionsService extends PermissionEvaluator {
    /**
     * Evaluates
     * {@link @backstage/plugin-permission-common#Permission | Permissions} and
     * returns definitive decisions.
     *
     * @remarks
     *
     * The returned array has the same number of items, in the same order, as the
     * given requests.
     */
    authorize(requests: AuthorizePermissionRequest[], options: PermissionsServiceRequestOptions): Promise<AuthorizePermissionResponse[]>;
    /**
     * Evaluates {@link @backstage/plugin-permission-common#ResourcePermission | ResourcePermissions} and returns both definitive and
     * conditional decisions, depending on the configured
     * {@link @backstage/plugin-permission-node#PermissionPolicy}.
     *
     * @remarks
     *
     * This method is useful when the
     * caller needs more control over the processing of conditional decisions. For example, a plugin
     * backend may want to use {@link @backstage/plugin-permission-common#PermissionCriteria | conditions} in a database query instead of
     * evaluating each resource in memory.
     *
     * The returned array has the same number of items, in the same order, as the
     * given requests.
     */
    authorizeConditional(requests: QueryPermissionRequest[], options: PermissionsServiceRequestOptions): Promise<QueryPermissionResponse[]>;
}

/**
 * Options for {@link HttpRouterService.addAuthPolicy}.
 *
 * @public
 */
interface HttpRouterServiceAuthPolicy {
    path: string;
    allow: 'unauthenticated' | 'user-cookie';
}
/**
 * Allows plugins to register HTTP routes.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/http-router | service documentation} for more details.
 *
 * @public
 */
interface HttpRouterService {
    /**
     * Registers an Express request handler under the plugin's base router. This
     * typically makes its base path `/api/<plugin-id>`.
     */
    use(handler: Handler): void;
    /**
     * Adds an auth policy to the router. This is used to allow unauthenticated or
     * cookie based access to parts of a plugin's API.
     *
     * @remarks
     *
     * The paths given follow the same pattern as the routers given to the `use`
     * method, that is, they are relative to the plugin's base URL, and can
     * contain placeholders.
     *
     * @example
     *
     * ```ts
     * http.addAuthPolicy({
     *   path: '/static/:id',
     *   allow: 'user-cookie',
     * });
     * ```
     *
     * This allows limited access tokens via cookies on the
     * `/api/<plugin-id>/static/*` paths, but not unauthenticated access.
     */
    addAuthPolicy(policy: HttpRouterServiceAuthPolicy): void;
}

/**
 * Provides handling of credentials in an ongoing request.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/http-auth | service documentation} for more details.
 *
 * @public
 */
interface HttpAuthService {
    /**
     * Extracts the caller's credentials from a request.
     *
     * @remarks
     *
     * The credentials have been validated before returning, and are guaranteed to
     * adhere to whatever policies have been added to this route using
     * {@link HttpRouterService.addAuthPolicy}, if any.
     *
     * Further restrictions can be imposed by passing in options that control the
     * allowed types of credential.
     *
     * You can narrow the returned credentials object to specific principal types
     * using {@link AuthService.isPrincipal}.
     */
    credentials<TAllowed extends keyof BackstagePrincipalTypes = 'unknown'>(
    /**
     * An Express request object.
     */
    req: Request<any, any, any, any, any>, 
    /**
     * Optional further restrictions.
     */
    options?: {
        /**
         * If specified, allow only principals of the given type(s).
         *
         * If the incoming credentials were not of a type that matched this
         * restriction, a {@link @backstage/errors#NotAllowedError} is thrown.
         *
         * The default is to allow user and service principals.
         */
        allow?: Array<TAllowed>;
        /**
         * If set to true, allow limited access tokens (such as cookies).
         *
         * If this flag is not set, or is set to false, calls with limited access
         * tokens will lead to a {@link @backstage/errors#NotAllowedError} being
         * thrown.
         */
        allowLimitedAccess?: boolean;
    }): Promise<BackstageCredentials<BackstagePrincipalTypes[TAllowed]>>;
    /**
     * Issues a limited access token as a cookie on the given response object.
     * This is only possible for requests that were originally made with user
     * credentials (such as a Backstage token).
     *
     * This must be called before sending any payload data.
     */
    issueUserCookie(
    /**
     * An Express response object.
     */
    res: Response, 
    /**
     * Optional further settings.
     */
    options?: {
        /**
         * Issue the cookie for this specific credential. Must be a "user" type
         * principal, or a "none" type (which leads to deleting the cookie).
         *
         * @remarks
         *
         * Normally you do not have to specify this option, because the default
         * behavior is to extract the credentials from the request that
         * corresponded to the given respnse.
         */
        credentials?: BackstageCredentials;
    }): Promise<{
        expiresAt: Date;
    }>;
}

/**
 * @public
 */
interface RootHealthService {
    /**
     * Get the liveness status of the backend.
     */
    getLiveness(): Promise<{
        status: number;
        payload?: JsonValue;
    }>;
    /**
     * Get the readiness status of the backend.
     */
    getReadiness(): Promise<{
        status: number;
        payload?: JsonValue;
    }>;
}

/**
 * The DiscoveryService is used to provide a mechanism for backend
 * plugins to discover the endpoints for itself or other backend plugins.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/discovery | service documentation} for more details.
 *
 * @remarks
 *
 * The purpose of the discovery API is to allow for many different deployment
 * setups and routing methods through a central configuration, instead
 * of letting each individual plugin manage that configuration.
 *
 * Implementations of the discovery API can be as simple as a URL pattern
 * using the pluginId, but could also have overrides for individual plugins,
 * or query a separate discovery service.
 *
 * @public
 */
interface DiscoveryService {
    /**
     * Returns the internal HTTP base URL for a given plugin, without a trailing slash.
     *
     * @remarks
     *
     * The returned URL should point to an internal endpoint for the plugin, with
     * the shortest route possible. The URL should be used for service-to-service
     * communication within a Backstage backend deployment.
     *
     * This method must always be called just before making each request, as opposed to
     * fetching the URL once when constructing an API client. That is to ensure that more
     * flexible routing patterns can be supported where a different result might be returned each time.
     *
     * For example, asking for the URL for `catalog` may return something
     * like `http://10.1.2.3/api/catalog`
     */
    getBaseUrl(pluginId: string): Promise<string>;
    /**
     * Returns the external HTTP base backend URL for a given plugin, without a trailing slash.
     *
     * @remarks
     *
     * The returned URL should point to an external endpoint for the plugin, such that
     * it is reachable from the Backstage frontend and other external services. The returned
     * URL should be usable for example as a callback / webhook URL.
     *
     * The returned URL should be stable and in general not change unless other static
     * or external configuration is changed. Changes should not come as a surprise
     * to an operator of the Backstage backend.
     *
     * For example, asking for the URL for `catalog` may return something
     * like `https://backstage.example.com/api/catalog`
     */
    getExternalBaseUrl(pluginId: string): Promise<string>;
}

/**
 * Manages access to databases that plugins get.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/database | service documentation} for more details.
 *
 * @public
 */
interface DatabaseService {
    /**
     * getClient provides backend plugins database connections for itself.
     *
     * The purpose of this method is to allow plugins to get isolated data
     * stores so that plugins are discouraged from database integration.
     */
    getClient(): Promise<Knex>;
    /**
     * This property is used to control the behavior of database migrations.
     */
    migrations?: {
        /**
         * skip database migrations. Useful if connecting to a read-only database.
         *
         * @defaultValue false
         */
        skip?: boolean;
    };
}

/**
 * Provides access to static configuration.
 *
 * See the {@link https://backstage.io/docs/conf/ | configuration documentation}
 * and the {@link https://backstage.io/docs/backend-system/core-services/root-config | service documentation}
 * for more details.
 *
 * @public
 */
interface RootConfigService extends Config {
}

/**
 * Options passed to {@link CacheService.set}.
 *
 * @public
 */
type CacheServiceSetOptions = {
    /**
     * Optional TTL (in milliseconds if given as a number). Defaults to the TTL provided when the client
     * was set up (or no TTL if none are provided).
     */
    ttl?: number | HumanDuration;
};
/**
 * Options passed to {@link CacheService.withOptions}.
 *
 * @public
 */
type CacheServiceOptions = {
    /**
     * An optional default TTL (in milliseconds if given as a number) to be set when getting a client
     * instance. If not provided, data will persist indefinitely by default (or
     * can be configured per entry at set-time).
     */
    defaultTtl?: number | HumanDuration;
};
/**
 * A pre-configured, storage agnostic cache service suitable for use by
 * Backstage plugins.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/cache | service documentation} for more details.
 *
 * @public
 */
interface CacheService {
    /**
     * Reads data from a cache store for the given key. If no data was found,
     * returns undefined.
     */
    get<TValue extends JsonValue>(key: string): Promise<TValue | undefined>;
    /**
     * Writes the given data to a cache store, associated with the given key. An
     * optional TTL may also be provided, otherwise it defaults to the TTL that
     * was provided when the client was instantiated.
     */
    set(key: string, value: JsonValue, options?: CacheServiceSetOptions): Promise<void>;
    /**
     * Removes the given key from the cache store.
     */
    delete(key: string): Promise<void>;
    /**
     * Creates a new {@link CacheService} instance with the given options.
     */
    withOptions(options: CacheServiceOptions): CacheService;
}

/**
 * Represents user information that is available to the backend, based on some
 * user credentials.
 *
 * @public
 */
interface BackstageUserInfo {
    userEntityRef: string;
    ownershipEntityRefs: string[];
}
/**
 * Authenticated user information retrieval.
 *
 * See the {@link https://backstage.io/docs/backend-system/core-services/user-info | service documentation} for more details.
 *
 * @public
 */
interface UserInfoService {
    /**
     * Retrieve user information based on the provided credentials.
     */
    getUserInfo(credentials: BackstageCredentials): Promise<BackstageUserInfo>;
}

/** @public */
interface BackendFeature {
    $$type: '@backstage/BackendFeature';
}

/**
 * A reference to a backend service. You can use these references to mark
 * dependencies on services and having their implementations injected
 * automatically.
 *
 * @public
 */
type ServiceRef<TService, TScope extends 'root' | 'plugin' = 'root' | 'plugin', TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton'> = {
    id: string;
    /**
     * This determines the scope at which this service is available.
     *
     * Root scoped services are available to all other services but
     * may only depend on other root scoped services.
     *
     * Plugin scoped services are only available to other plugin scoped
     * services but may depend on all other services.
     */
    scope: TScope;
    /**
     * Marks whether the service is a multiton or not. Multiton services the
     * opposite of singletons - they can be provided many times, and when depended
     * on, you receive an array of all provided instances.
     */
    multiton?: TInstances extends 'multiton' ? true : false;
    /**
     * Utility for getting the type of the service, using `typeof serviceRef.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: TService;
    $$type: '@backstage/ServiceRef';
};
/** @public */
interface ServiceFactory<TService = unknown, TScope extends 'plugin' | 'root' = 'plugin' | 'root', TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton'> extends BackendFeature {
    service: ServiceRef<TService, TScope, TInstances>;
}
/** @public */
interface ServiceRefOptions<TService, TScope extends 'root' | 'plugin', TInstances extends 'singleton' | 'multiton'> {
    id: string;
    scope?: TScope;
    multiton?: TInstances extends 'multiton' ? true : false;
    defaultFactory?(service: ServiceRef<TService, TScope>): Promise<ServiceFactory>;
}
/**
 * Creates a new service definition. This overload is used to create plugin scoped services.
 *
 * @public
 */
declare function createServiceRef<TService>(options: ServiceRefOptions<TService, 'plugin', 'singleton'>): ServiceRef<TService, 'plugin', 'singleton'>;
/**
 * Creates a new service definition. This overload is used to create root scoped services.
 *
 * @public
 */
declare function createServiceRef<TService>(options: ServiceRefOptions<TService, 'root', 'singleton'>): ServiceRef<TService, 'root', 'singleton'>;
/**
 * Creates a new service definition. This overload is used to create plugin scoped services.
 *
 * @public
 */
declare function createServiceRef<TService>(options: ServiceRefOptions<TService, 'plugin', 'multiton'>): ServiceRef<TService, 'plugin', 'multiton'>;
/**
 * Creates a new service definition. This overload is used to create root scoped services.
 *
 * @public
 */
declare function createServiceRef<TService>(options: ServiceRefOptions<TService, 'root', 'multiton'>): ServiceRef<TService, 'root', 'multiton'>;
/** @ignore */
type ServiceRefsToInstances<T extends {
    [key in string]: ServiceRef<unknown>;
}, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    [key in keyof T as T[key]['scope'] extends TScope ? key : never]: T[key]['multiton'] extends true | undefined ? Array<T[key]['T']> : T[key]['T'];
};
/** @public */
interface RootServiceFactoryOptions<TService, TInstances extends 'singleton' | 'multiton', TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}> {
    /**
     * The initialization strategy for the service factory. This service is root scoped and will use `always` by default.
     *
     * @remarks
     *
     * - `always` - The service will always be initialized regardless if it is used or not.
     * - `lazy` - The service will only be initialized if it is depended on by a different service or feature.
     *
     * Service factories for root scoped services use `always` as the default, while plugin scoped services use `lazy`.
     */
    initialization?: 'always' | 'lazy';
    service: ServiceRef<TService, 'root', TInstances>;
    deps: TDeps;
    factory(deps: ServiceRefsToInstances<TDeps, 'root'>): TImpl | Promise<TImpl>;
}
/** @public */
interface PluginServiceFactoryOptions<TService, TInstances extends 'singleton' | 'multiton', TContext, TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}> {
    /**
     * The initialization strategy for the service factory. This service is plugin scoped and will use `lazy` by default.
     *
     * @remarks
     *
     * - `always` - The service will always be initialized regardless if it is used or not.
     * - `lazy` - The service will only be initialized if it is depended on by a different service or feature.
     *
     * Service factories for root scoped services use `always` as the default, while plugin scoped services use `lazy`.
     */
    initialization?: 'always' | 'lazy';
    service: ServiceRef<TService, 'plugin', TInstances>;
    deps: TDeps;
    createRootContext?(deps: ServiceRefsToInstances<TDeps, 'root'>): TContext | Promise<TContext>;
    factory(deps: ServiceRefsToInstances<TDeps>, context: TContext): TImpl | Promise<TImpl>;
}
/**
 * Creates a root scoped service factory without options.
 *
 * @public
 * @param options - The service factory configuration.
 */
declare function createServiceFactory<TService, TInstances extends 'singleton' | 'multiton', TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown, 'root'>;
}>(options: RootServiceFactoryOptions<TService, TInstances, TImpl, TDeps>): ServiceFactory<TService, 'root', TInstances>;
/**
 * Creates a plugin scoped service factory without options.
 *
 * @public
 * @param options - The service factory configuration.
 */
declare function createServiceFactory<TService, TInstances extends 'singleton' | 'multiton', TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TContext = undefined>(options: PluginServiceFactoryOptions<TService, TInstances, TContext, TImpl, TDeps>): ServiceFactory<TService, 'plugin', TInstances>;

/**
 * All core services references
 *
 * @public
 */
declare namespace coreServices {
    /**
     * Handles token authentication and credentials management.
     *
     * See {@link AuthService}
     * and {@link https://backstage.io/docs/backend-system/core-services/auth | the service docs}
     * for more information.
     *
     * @public
     */
    const auth: ServiceRef<AuthService, "plugin", "singleton">;
    /**
     * Authenticated user information retrieval.
     *
     * See {@link UserInfoService}
     * and {@link https://backstage.io/docs/backend-system/core-services/user-info | the service docs}
     * for more information.
     *
     * @public
     */
    const userInfo: ServiceRef<UserInfoService, "plugin", "singleton">;
    /**
     * Key-value store for caching data.
     *
     * See {@link CacheService}
     * and {@link https://backstage.io/docs/backend-system/core-services/cache | the service docs}
     * for more information.
     *
     * @public
     */
    const cache: ServiceRef<CacheService, "plugin", "singleton">;
    /**
     * Access to static configuration.
     *
     * See {@link RootConfigService}
     * and {@link https://backstage.io/docs/backend-system/core-services/root-config | the service docs}
     * for more information.
     *
     * @public
     */
    const rootConfig: ServiceRef<RootConfigService, "root", "singleton">;
    /**
     * Database access and management via `knex`.
     *
     * See {@link DatabaseService}
     * and {@link https://backstage.io/docs/backend-system/core-services/database | the service docs}
     * for more information.
     *
     * @public
     */
    const database: ServiceRef<DatabaseService, "plugin", "singleton">;
    /**
     * Service discovery for inter-plugin communication.
     *
     * See {@link DiscoveryService}
     * and {@link https://backstage.io/docs/backend-system/core-services/discovery | the service docs}
     * for more information.
     *
     * @public
     */
    const discovery: ServiceRef<DiscoveryService, "plugin", "singleton">;
    /**
     * The service reference for the plugin scoped {@link RootHealthService}.
     */
    const rootHealth: ServiceRef<RootHealthService, "root", "singleton">;
    /**
     * Authentication of HTTP requests.
     *
     * See {@link HttpAuthService}
     * and {@link https://backstage.io/docs/backend-system/core-services/http-auth | the service docs}
     * for more information.
     *
     * @public
     */
    const httpAuth: ServiceRef<HttpAuthService, "plugin", "singleton">;
    /**
     * HTTP route registration for plugins.
     *
     * See {@link HttpRouterService}
     * and {@link https://backstage.io/docs/backend-system/core-services/http-router | the service docs}
     * for more information.
     *
     * @public
     */
    const httpRouter: ServiceRef<HttpRouterService, "plugin", "singleton">;
    /**
     * Registration of plugin startup and shutdown lifecycle hooks.
     *
     * See {@link LifecycleService}
     * and {@link https://backstage.io/docs/backend-system/core-services/lifecycle | the service docs}
     * for more information.
     *
     * @public
     */
    const lifecycle: ServiceRef<LifecycleService, "plugin", "singleton">;
    /**
     * Plugin-level logging.
     *
     * See {@link LoggerService}
     * and {@link https://backstage.io/docs/backend-system/core-services/logger | the service docs}
     * for more information.
     *
     * @public
     */
    const logger: ServiceRef<LoggerService, "plugin", "singleton">;
    /**
     * Permission system integration for authorization of user actions.
     *
     * See {@link PermissionsService}
     * and {@link https://backstage.io/docs/backend-system/core-services/permissions | the service docs}
     * for more information.
     *
     * @public
     */
    const permissions: ServiceRef<PermissionsService, "plugin", "singleton">;
    /**
     * Built-in service for accessing metadata about the current plugin.
     *
     * See {@link PluginMetadataService}
     * and {@link https://backstage.io/docs/backend-system/core-services/plugin-metadata | the service docs}
     * for more information.
     *
     * @public
     */
    const pluginMetadata: ServiceRef<PluginMetadataService, "plugin", "singleton">;
    /**
     * HTTP route registration for root services.
     *
     * See {@link RootHttpRouterService}
     * and {@link https://backstage.io/docs/backend-system/core-services/root-http-router | the service docs}
     * for more information.
     *
     * @public
     */
    const rootHttpRouter: ServiceRef<RootHttpRouterService, "root", "singleton">;
    /**
     * Registration of backend startup and shutdown lifecycle hooks.
     *
     * See {@link RootLifecycleService}
     * and {@link https://backstage.io/docs/backend-system/core-services/root-lifecycle | the service docs}
     * for more information.
     *
     * @public
     */
    const rootLifecycle: ServiceRef<RootLifecycleService, "root", "singleton">;
    /**
     * Root-level logging.
     *
     * See {@link RootLoggerService}
     * and {@link https://backstage.io/docs/backend-system/core-services/root-logger | the service docs}
     * for more information.
     *
     * @public
     */
    const rootLogger: ServiceRef<RootLoggerService, "root", "singleton">;
    /**
     * Scheduling of distributed background tasks.
     *
     * See {@link SchedulerService}
     * and {@link https://backstage.io/docs/backend-system/core-services/scheduler | the service docs}
     * for more information.
     *
     * @public
     */
    const scheduler: ServiceRef<SchedulerService, "plugin", "singleton">;
    /**
     * Reading content from external systems.
     *
     * See {@link UrlReaderService}
     * and {@link https://backstage.io/docs/backend-system/core-services/url-reader | the service docs}
     * for more information.
     *
     * @public
     */
    const urlReader: ServiceRef<UrlReaderService, "plugin", "singleton">;
}

/**
 * Tries to deduce whether a thrown error is a database conflict.
 *
 * @public
 * @param e - A thrown error
 * @returns True if the error looks like it was a conflict error thrown by a
 *          known database engine
 */
declare function isDatabaseConflictError(e: unknown): boolean;

/**
 * Resolve a path relative to the root of a package directory.
 * Additional path arguments are resolved relative to the package dir.
 *
 * This is particularly useful when you want to access assets shipped with
 * your backend plugin package. When doing so, do not forget to include the assets
 * in your published package by adding them to `files` in your `package.json`.
 *
 * @public
 */
declare function resolvePackagePath(name: string, ...paths: string[]): string;
/**
 * Resolves a target path from a base path while guaranteeing that the result is
 * a path that point to or within the base path. This is useful for resolving
 * paths from user input, as it otherwise opens up for vulnerabilities.
 *
 * @public
 * @param base - The base directory to resolve the path from.
 * @param path - The target path, relative or absolute
 * @returns A path that is guaranteed to point to or within the base path.
 */
declare function resolveSafeChildPath(base: string, path: string): string;

/**
 * TODO
 *
 * @public
 */
type ExtensionPoint<T> = {
    id: string;
    /**
     * Utility for getting the type of the extension point, using `typeof extensionPoint.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: T;
    toString(): string;
    $$type: '@backstage/ExtensionPoint';
};
/** @ignore */
type DepsToInstances<TDeps extends {
    [key in string]: ServiceRef<unknown> | ExtensionPoint<unknown>;
}> = {
    [key in keyof TDeps]: TDeps[key] extends ServiceRef<unknown, any, 'multiton'> ? Array<TDeps[key]['T']> : TDeps[key]['T'];
};
/**
 * The callbacks passed to the `register` method of a backend plugin.
 *
 * @public
 */
interface BackendPluginRegistrationPoints {
    registerExtensionPoint<TExtensionPoint>(ref: ExtensionPoint<TExtensionPoint>, impl: TExtensionPoint): void;
    registerInit<TDeps extends {
        [name in string]: ServiceRef<unknown>;
    }>(options: {
        deps: TDeps;
        init(deps: DepsToInstances<TDeps>): Promise<void>;
    }): void;
}
/**
 * The callbacks passed to the `register` method of a backend module.
 *
 * @public
 */
interface BackendModuleRegistrationPoints {
    registerExtensionPoint<TExtensionPoint>(ref: ExtensionPoint<TExtensionPoint>, impl: TExtensionPoint): void;
    registerInit<TDeps extends {
        [name in string]: ServiceRef<unknown> | ExtensionPoint<unknown>;
    }>(options: {
        deps: TDeps;
        init(deps: DepsToInstances<TDeps>): Promise<void>;
    }): void;
}

/**
 * The configuration options passed to {@link createBackendModule}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
interface CreateBackendModuleOptions {
    /**
     * Should exactly match the `id` of the plugin that the module extends.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    pluginId: string;
    /**
     * The ID of this module, used to identify the module and ensure that it is not installed twice.
     */
    moduleId: string;
    register(reg: BackendModuleRegistrationPoints): void;
}
/**
 * Creates a new backend module for a given plugin.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
declare function createBackendModule(options: CreateBackendModuleOptions): BackendFeature;

/**
 * The configuration options passed to {@link createBackendPlugin}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
interface CreateBackendPluginOptions {
    /**
     * The ID of this plugin.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    pluginId: string;
    register(reg: BackendPluginRegistrationPoints): void;
}
/**
 * Creates a new backend plugin.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
declare function createBackendPlugin(options: CreateBackendPluginOptions): BackendFeature;

/**
 * The configuration options passed to {@link createExtensionPoint}.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}
 * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
 */
interface CreateExtensionPointOptions {
    /**
     * The ID of this extension point.
     *
     * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}
     */
    id: string;
}
/**
 * Creates a new backend extension point.
 *
 * @public
 * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}
 */
declare function createExtensionPoint<T>(options: CreateExtensionPointOptions): ExtensionPoint<T>;

/**
 * @public
 * Options for creating a new backend feature loader.
 */
interface CreateBackendFeatureLoaderOptions<TDeps extends {
    [name in string]: unknown;
}> {
    deps?: {
        [name in keyof TDeps]: ServiceRef<TDeps[name], 'root'>;
    };
    loader(deps: TDeps): Iterable<BackendFeature | Promise<{
        default: BackendFeature;
    }>> | Promise<Iterable<BackendFeature | Promise<{
        default: BackendFeature;
    }>>> | AsyncIterable<BackendFeature | {
        default: BackendFeature;
    }>;
}
/**
 * @public
 * Creates a new backend feature loader.
 */
declare function createBackendFeatureLoader<TDeps extends {
    [name in string]: unknown;
}>(options: CreateBackendFeatureLoaderOptions<TDeps>): BackendFeature;

export { type AuthService, type BackendFeature, type BackendModuleRegistrationPoints, type BackendPluginRegistrationPoints, type BackstageCredentials, type BackstageNonePrincipal, type BackstagePrincipalAccessRestrictions, type BackstagePrincipalTypes, type BackstageServicePrincipal, type BackstageUserInfo, type BackstageUserPrincipal, type CacheService, type CacheServiceOptions, type CacheServiceSetOptions, type CreateBackendFeatureLoaderOptions, type CreateBackendModuleOptions, type CreateBackendPluginOptions, type CreateExtensionPointOptions, type DatabaseService, type DiscoveryService, type ExtensionPoint, type HttpAuthService, type HttpRouterService, type HttpRouterServiceAuthPolicy, type LifecycleService, type LifecycleServiceShutdownHook, type LifecycleServiceShutdownOptions, type LifecycleServiceStartupHook, type LifecycleServiceStartupOptions, type LoggerService, type PermissionsService, type PermissionsServiceRequestOptions, type PluginMetadataService, type PluginServiceFactoryOptions, type RootConfigService, type RootHealthService, type RootHttpRouterService, type RootLifecycleService, type RootLoggerService, type RootServiceFactoryOptions, type SchedulerService, type SchedulerServiceTaskDescriptor, type SchedulerServiceTaskFunction, type SchedulerServiceTaskInvocationDefinition, type SchedulerServiceTaskRunner, type SchedulerServiceTaskScheduleDefinition, type SchedulerServiceTaskScheduleDefinitionConfig, type ServiceFactory, type ServiceRef, type ServiceRefOptions, type UrlReaderService, type UrlReaderServiceReadTreeOptions, type UrlReaderServiceReadTreeResponse, type UrlReaderServiceReadTreeResponseDirOptions, type UrlReaderServiceReadTreeResponseFile, type UrlReaderServiceReadUrlOptions, type UrlReaderServiceReadUrlResponse, type UrlReaderServiceSearchOptions, type UrlReaderServiceSearchResponse, type UrlReaderServiceSearchResponseFile, type UserInfoService, coreServices, createBackendFeatureLoader, createBackendModule, createBackendPlugin, createExtensionPoint, createServiceFactory, createServiceRef, isDatabaseConflictError, readSchedulerServiceTaskScheduleDefinitionFromConfig, resolvePackagePath, resolveSafeChildPath };
