import { getComponentData } from '@backstage/core-plugin-api';
import { PageBlueprint, createExtensionInput, coreExtensionData, createFrontendPlugin, ApiBlueprint, createExtension } from '@backstage/frontend-plugin-api';
import React, { Children, isValidElement } from 'react';
import { Route, Routes } from 'react-router-dom';
import { convertLegacyRouteRef, convertLegacyRouteRefs } from './convertLegacyRouteRef.esm.js';
import { compatWrapper } from './compatWrapper/compatWrapper.esm.js';

function makeRoutingShimExtension(options) {
  const { name, parentExtensionId, routePath, routeRef } = options;
  return createExtension({
    kind: "routing-shim",
    name,
    attachTo: { id: parentExtensionId, input: "childRoutingShims" },
    inputs: {
      childRoutingShims: createExtensionInput([
        coreExtensionData.routePath.optional(),
        coreExtensionData.routeRef.optional()
      ])
    },
    output: [
      coreExtensionData.routePath.optional(),
      coreExtensionData.routeRef.optional()
    ],
    *factory() {
      if (routePath !== void 0) {
        yield coreExtensionData.routePath(routePath);
      }
      if (routeRef) {
        yield coreExtensionData.routeRef(convertLegacyRouteRef(routeRef));
      }
    }
  });
}
function visitRouteChildren(options) {
  const { children, parentExtensionId, context } = options;
  const { pluginId, extensions, getUniqueName, discoverPlugin } = context;
  Children.forEach(children, (node) => {
    if (!isValidElement(node)) {
      return;
    }
    const plugin = getComponentData(node, "core.plugin");
    const routeRef = getComponentData(
      node,
      "core.mountPoint"
    );
    const routePath = node.props?.path;
    if (plugin) {
      discoverPlugin(plugin);
    }
    let nextParentExtensionId = parentExtensionId;
    if (routeRef || routePath) {
      const nextParentExtensionName = getUniqueName();
      nextParentExtensionId = `routing-shim:${pluginId}/${nextParentExtensionName}`;
      extensions.push(
        makeRoutingShimExtension({
          name: nextParentExtensionName,
          parentExtensionId,
          routePath,
          routeRef
        })
      );
    }
    visitRouteChildren({
      children: node.props.children,
      parentExtensionId: nextParentExtensionId,
      context
    });
  });
}
function collectLegacyRoutes(flatRoutesElement) {
  const pluginExtensions = /* @__PURE__ */ new Map();
  const getUniqueName = /* @__PURE__ */ (() => {
    let currentIndex = 1;
    return () => String(currentIndex++);
  })();
  const getPluginExtensions = (plugin) => {
    let extensions = pluginExtensions.get(plugin);
    if (!extensions) {
      extensions = [];
      pluginExtensions.set(plugin, extensions);
    }
    return extensions;
  };
  React.Children.forEach(
    flatRoutesElement.props.children,
    (route) => {
      if (!React.isValidElement(route)) {
        throw new Error(
          `Invalid element inside FlatRoutes, expected Route but found element of type ${typeof route}.`
        );
      }
      if (route.type !== Route) {
        throw new Error(
          `Invalid element inside FlatRoutes, expected Route but found ${route.type}.`
        );
      }
      const routeElement = route.props.element;
      const path = route.props.path;
      const plugin = getComponentData(
        routeElement,
        "core.plugin"
      );
      const routeRef = getComponentData(
        routeElement,
        "core.mountPoint"
      );
      if (!plugin) {
        throw new Error(
          // TODO(vinzscam): add See <link-to-app-migration-docs> for more info
          `Route with path ${path} has en element that can not be converted as it does not belong to a plugin. Make sure that the top-level React element of the element prop is an extension from a Backstage plugin, or remove the Route completely.`
        );
      }
      if (path === void 0) {
        throw new Error(
          `Route element inside FlatRoutes had no path prop value given`
        );
      }
      const extensions = getPluginExtensions(plugin);
      const pageExtensionName = extensions.length ? getUniqueName() : void 0;
      const pageExtensionId = `page:${plugin.getId()}${pageExtensionName ? `/${pageExtensionName}` : pageExtensionName}`;
      extensions.push(
        PageBlueprint.makeWithOverrides({
          name: pageExtensionName,
          inputs: {
            childRoutingShims: createExtensionInput([
              coreExtensionData.routePath.optional(),
              coreExtensionData.routeRef.optional()
            ])
          },
          factory(originalFactory, { inputs: _inputs }) {
            return originalFactory({
              defaultPath: path[0] === "/" ? path.slice(1) : path,
              routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0,
              loader: async () => compatWrapper(
                route.props.children ? /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, { path: "*", element: routeElement }, /* @__PURE__ */ React.createElement(Route, { path: "*", element: route.props.children }))) : routeElement
              )
            });
          }
        })
      );
      visitRouteChildren({
        children: route.props.children,
        parentExtensionId: pageExtensionId,
        context: {
          pluginId: plugin.getId(),
          extensions,
          getUniqueName,
          discoverPlugin: getPluginExtensions
        }
      });
    }
  );
  return Array.from(pluginExtensions).map(
    ([plugin, extensions]) => createFrontendPlugin({
      id: plugin.getId(),
      extensions: [
        ...extensions,
        ...Array.from(plugin.getApis()).map(
          (factory) => ApiBlueprint.make({
            name: factory.api.id,
            params: { factory }
          })
        )
      ],
      routes: convertLegacyRouteRefs(plugin.routes ?? {}),
      externalRoutes: convertLegacyRouteRefs(plugin.externalRoutes ?? {})
    })
  );
}

export { collectLegacyRoutes };
//# sourceMappingURL=collectLegacyRoutes.esm.js.map
