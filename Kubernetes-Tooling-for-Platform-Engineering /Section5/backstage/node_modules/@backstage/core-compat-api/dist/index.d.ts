import React, { ReactNode, ComponentType } from 'react';
import { AnalyticsApi, AnalyticsEvent, BackstagePlugin, RouteRef, SubRouteRef, ExternalRouteRef, AnyRouteRefParams } from '@backstage/core-plugin-api';
import { AnalyticsApi as AnalyticsApi$1, AnalyticsEvent as AnalyticsEvent$1, FrontendPlugin, FrontendModule, ExtensionOverrides, ExtensionDefinition, RouteRef as RouteRef$1, SubRouteRef as SubRouteRef$1, ExternalRouteRef as ExternalRouteRef$1 } from '@backstage/frontend-plugin-api';

/**
 * Wraps a React element in a bidirectional compatibility provider, allow APIs
 * from `@backstage/core-plugin-api` to be used in an app from `@backstage/frontend-app-api`,
 * and APIs from `@backstage/frontend-plugin-api` to be used in an app from `@backstage/core-app-api`.
 *
 * @public
 */
declare function compatWrapper(element: ReactNode): React.JSX.Element;

/**
 * An implementation of the AnalyticsApi that can be used to forward analytics
 * events to multiple concrete implementations.
 *
 * @public
 *
 * @example
 *
 * ```jsx
 * createApiFactory({
 *   api: analyticsApiRef,
 *   deps: { configApi: configApiRef, identityApi: identityApiRef, storageApi: storageApiRef },
 *   factory: ({ configApi, identityApi, storageApi }) =>
 *     MultipleAnalyticsApi.fromApis([
 *       VendorAnalyticsApi.fromConfig(configApi, { identityApi }),
 *       CustomAnalyticsApi.fromConfig(configApi, { identityApi, storageApi }),
 *     ]),
 * });
 * ```
 */
declare class MultipleAnalyticsApi implements AnalyticsApi, AnalyticsApi$1 {
    private readonly actualApis;
    private constructor();
    /**
     * Create an AnalyticsApi implementation from an array of concrete
     * implementations.
     *
     * @example
     *
     * ```jsx
     * MultipleAnalyticsApi.fromApis([
     *   SomeAnalyticsApi.fromConfig(configApi),
     *   new CustomAnalyticsApi(),
     * ]);
     * ```
     */
    static fromApis(actualApis: (AnalyticsApi | AnalyticsApi$1)[]): MultipleAnalyticsApi;
    /**
     * Forward the event to all configured analytics API implementations.
     */
    captureEvent(event: AnalyticsEvent | AnalyticsEvent$1): void;
}

/**
 * Base implementation for the AnalyticsApi that does nothing.
 *
 * @public
 */
declare class NoOpAnalyticsApi implements AnalyticsApi, AnalyticsApi$1 {
    captureEvent(_event: AnalyticsEvent | AnalyticsEvent$1): void;
}

/** @public */
declare function convertLegacyApp(rootElement: React.JSX.Element): (FrontendPlugin | FrontendModule | ExtensionOverrides)[];

/** @public */
declare function convertLegacyPlugin(legacyPlugin: BackstagePlugin, options: {
    extensions: ExtensionDefinition[];
}): FrontendPlugin;

/** @public */
declare function convertLegacyPageExtension(LegacyExtension: ComponentType<{}>, overrides?: {
    name?: string;
    defaultPath?: string;
}): ExtensionDefinition;

/**
 * Converts a legacy route ref type to the new system.
 *
 * @public
 */
type ToNewRouteRef<T extends RouteRef | SubRouteRef | ExternalRouteRef> = T extends RouteRef<infer IParams> ? RouteRef$1<IParams> : T extends SubRouteRef<infer IParams> ? SubRouteRef$1<IParams> : T extends ExternalRouteRef<infer IParams> ? ExternalRouteRef$1<IParams> : never;
/**
 * Converts a collection of legacy route refs to the new system.
 * This is particularly useful when defining plugin `routes` and `externalRoutes`.
 *
 * @public
 */
declare function convertLegacyRouteRefs<TRefs extends {
    [name in string]: RouteRef | SubRouteRef | ExternalRouteRef;
}>(refs: TRefs): {
    [KName in keyof TRefs]: ToNewRouteRef<TRefs[KName]>;
};
/**
 * A temporary helper to convert a legacy route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: RouteRef<TParams>): RouteRef$1<TParams>;
/**
 * A temporary helper to convert a legacy sub route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createSubRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: SubRouteRef<TParams>): SubRouteRef$1<TParams>;
/**
 * A temporary helper to convert a legacy external route ref to the new system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createExternalRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: ExternalRouteRef<TParams>): ExternalRouteRef$1<TParams>;
/**
 * A temporary helper to convert a new route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: RouteRef$1<TParams>): RouteRef<TParams>;
/**
 * A temporary helper to convert a new sub route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createSubRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: SubRouteRef$1<TParams>): SubRouteRef<TParams>;
/**
 * A temporary helper to convert a new external route ref to the legacy system.
 *
 * @public
 * @remarks
 *
 * In the future the legacy createExternalRouteRef will instead create refs compatible with both systems.
 */
declare function convertLegacyRouteRef<TParams extends AnyRouteRefParams>(ref: ExternalRouteRef$1<TParams>): ExternalRouteRef<TParams, true>;

export { MultipleAnalyticsApi, NoOpAnalyticsApi, type ToNewRouteRef, compatWrapper, convertLegacyApp, convertLegacyPageExtension, convertLegacyPlugin, convertLegacyRouteRef, convertLegacyRouteRefs };
