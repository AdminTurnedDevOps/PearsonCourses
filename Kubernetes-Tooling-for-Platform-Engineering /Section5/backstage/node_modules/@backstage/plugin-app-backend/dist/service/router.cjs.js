'use strict';

var backendCommon = require('@backstage/backend-common');
var backendPluginApi = require('@backstage/backend-plugin-api');
var helmet = require('helmet');
var express = require('express');
var Router = require('express-promise-router');
var fs = require('fs-extra');
var path = require('path');
var StaticAssetsStore = require('../lib/assets/StaticAssetsStore.cjs.js');
var findStaticAssets = require('../lib/assets/findStaticAssets.cjs.js');
var createStaticAssetMiddleware = require('../lib/assets/createStaticAssetMiddleware.cjs.js');
var headers = require('../lib/headers.cjs.js');
var errors = require('@backstage/errors');
var injectConfig = require('../lib/config/injectConfig.cjs.js');
var readFrontendConfig = require('../lib/config/readFrontendConfig.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var helmet__default = /*#__PURE__*/_interopDefaultCompat(helmet);
var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

async function createRouter(options) {
  const {
    config,
    logger,
    appPackageName,
    staticFallbackHandler,
    auth,
    httpAuth,
    schema
  } = options;
  const disableConfigInjection = options.disableConfigInjection ?? config.getOptionalBoolean("app.disableConfigInjection");
  const disableStaticFallbackCache = config.getOptionalBoolean(
    "app.disableStaticFallbackCache"
  );
  const appDistDir = backendPluginApi.resolvePackagePath(appPackageName, "dist");
  const staticDir = path.resolve(appDistDir, "static");
  if (!await fs__default.default.pathExists(staticDir)) {
    if (process.env.NODE_ENV === "production") {
      logger.error(
        `Can't serve static app content from ${staticDir}, directory doesn't exist`
      );
    }
    return Router__default.default();
  }
  logger.info(`Serving static app content from ${appDistDir}`);
  const appConfigs = disableConfigInjection ? void 0 : await readFrontendConfig.readFrontendConfig({
    config,
    appDistDir,
    env: process.env,
    schema
  });
  const assetStore = options.database && !disableStaticFallbackCache ? await StaticAssetsStore.StaticAssetsStore.create({
    logger,
    database: options.database
  }) : void 0;
  const router = Router__default.default();
  router.use(helmet__default.default.frameguard({ action: "deny" }));
  const publicDistDir = path.resolve(appDistDir, "public");
  const enablePublicEntryPoint = await fs__default.default.pathExists(publicDistDir) && auth && httpAuth;
  if (enablePublicEntryPoint && auth && httpAuth) {
    logger.info(
      `App is running in protected mode, serving public content from ${publicDistDir}`
    );
    const publicRouter = Router__default.default();
    publicRouter.use(async (req, res, next) => {
      try {
        const credentials = await httpAuth.credentials(req, {
          allow: ["user", "service", "none"],
          allowLimitedAccess: true
        });
        if (credentials.principal.type === "none") {
          next();
        } else {
          next("router");
        }
      } catch {
        await httpAuth.issueUserCookie(res, {
          credentials: await auth.getNoneCredentials()
        });
        next();
      }
    });
    publicRouter.post(
      "*",
      express__default.default.urlencoded({ extended: true }),
      async (req, res, next) => {
        if (req.body.type === "sign-in") {
          const credentials = await auth.authenticate(req.body.token);
          if (!auth.isPrincipal(credentials, "user")) {
            throw new errors.AuthenticationError("Invalid token, not a user");
          }
          await httpAuth.issueUserCookie(res, {
            credentials
          });
          req.method = "GET";
          next("router");
        } else {
          throw new errors.InputError(
            "Invalid POST request to app-backend wildcard endpoint"
          );
        }
      }
    );
    publicRouter.use(
      await createEntryPointRouter({
        logger: logger.child({ entry: "public" }),
        rootDir: publicDistDir,
        assetStore: assetStore?.withNamespace("public"),
        appConfigs
        // TODO(Rugvip): We should not be including the full config here
      })
    );
    router.use(publicRouter);
  }
  router.use(
    await createEntryPointRouter({
      logger: logger.child({ entry: "main" }),
      rootDir: appDistDir,
      assetStore,
      staticFallbackHandler,
      appConfigs
    })
  );
  return router;
}
async function createEntryPointRouter({
  logger,
  rootDir,
  assetStore,
  staticFallbackHandler,
  appConfigs
}) {
  const staticDir = path.resolve(rootDir, "static");
  const injectResult = appConfigs && await injectConfig.injectConfig({ appConfigs, logger, rootDir, staticDir });
  const router = Router__default.default();
  const staticRouter = Router__default.default();
  staticRouter.use(
    express__default.default.static(staticDir, {
      setHeaders: (res, path) => {
        if (injectResult?.injectedPath === path) {
          res.setHeader("Cache-Control", headers.CACHE_CONTROL_REVALIDATE_CACHE);
        } else {
          res.setHeader("Cache-Control", headers.CACHE_CONTROL_MAX_CACHE);
        }
      }
    })
  );
  if (assetStore) {
    const assets = await findStaticAssets.findStaticAssets(staticDir);
    await assetStore.storeAssets(assets);
    await assetStore.trimAssets({ maxAgeSeconds: 60 * 60 * 24 * 7 });
    staticRouter.use(createStaticAssetMiddleware.createStaticAssetMiddleware(assetStore));
  }
  if (staticFallbackHandler) {
    staticRouter.use(staticFallbackHandler);
  }
  staticRouter.use(backendCommon.notFoundHandler());
  router.use("/static", staticRouter);
  const rootRouter = Router__default.default();
  rootRouter.use((req, _res, next) => {
    if (req.path === "/" || req.path === "/index.html") {
      next("router");
    } else {
      next();
    }
  });
  rootRouter.use(
    express__default.default.static(rootDir, {
      setHeaders: (res, path) => {
        if (express__default.default.static.mime.lookup(path) === "text/html") {
          res.setHeader("Cache-Control", headers.CACHE_CONTROL_NO_CACHE);
        }
      }
    })
  );
  router.use(rootRouter);
  router.get("/*", (_req, res) => {
    if (injectResult?.indexHtmlContent) {
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Cache-Control", headers.CACHE_CONTROL_NO_CACHE);
      res.send(injectResult.indexHtmlContent);
    } else {
      res.sendFile(path.resolve(rootDir, "index.html"), {
        headers: {
          // The Cache-Control header instructs the browser to not cache the index.html since it might
          // link to static assets from recently deployed versions.
          "cache-control": headers.CACHE_CONTROL_NO_CACHE
        }
      });
    }
  });
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.cjs.js.map
