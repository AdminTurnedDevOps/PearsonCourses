'use strict';

var luxon = require('luxon');
var partition = require('lodash/partition');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var partition__default = /*#__PURE__*/_interopDefaultCompat(partition);

const migrationsDir = backendPluginApi.resolvePackagePath(
  "@backstage/plugin-app-backend",
  "migrations"
);
class StaticAssetsStore {
  #db;
  #logger;
  #namespace;
  static async create(options) {
    const { database } = options;
    const client = await database.getClient();
    if (!database.migrations?.skip) {
      await client.migrate.latest({
        directory: migrationsDir
      });
    }
    return new StaticAssetsStore(client, options.logger);
  }
  constructor(client, logger, namespace) {
    this.#db = client;
    this.#logger = logger;
    this.#namespace = namespace ?? "default";
  }
  /**
   * Creates a new store with the provided namespace, using the same underlying storage.
   */
  withNamespace(namespace) {
    return new StaticAssetsStore(this.#db, this.#logger, namespace);
  }
  /**
   * Store the provided assets.
   *
   * If an asset for a given path already exists the modification time will be
   * updated, but the contents will not.
   */
  async storeAssets(assets) {
    const existingRows = await this.#db("static_assets_cache").where("namespace", this.#namespace).whereIn(
      "path",
      assets.map((a) => a.path)
    );
    const existingAssetPaths = new Set(existingRows.map((r) => r.path));
    const [modified, added] = partition__default.default(
      assets,
      (asset) => existingAssetPaths.has(asset.path)
    );
    this.#logger.info(
      `Storing ${modified.length} updated assets and ${added.length} new assets`
    );
    await this.#db("static_assets_cache").update({
      last_modified_at: this.#db.fn.now()
    }).where("namespace", this.#namespace).whereIn(
      "path",
      modified.map((a) => a.path)
    );
    for (const asset of added) {
      await this.#db("static_assets_cache").insert({
        path: asset.path,
        content: await asset.content(),
        namespace: this.#namespace
      }).onConflict(["namespace", "path"]).ignore();
    }
  }
  /**
   * Retrieve an asset from the store with the given path.
   */
  async getAsset(path) {
    const [row] = await this.#db("static_assets_cache").where({
      path,
      namespace: this.#namespace
    });
    if (!row) {
      return void 0;
    }
    return {
      path: row.path,
      content: row.content,
      lastModifiedAt: typeof row.last_modified_at === "string" ? luxon.DateTime.fromSQL(row.last_modified_at, { zone: "UTC" }).toJSDate() : row.last_modified_at
    };
  }
  /**
   * Delete any assets from the store whose modification time is older than the max age.
   */
  async trimAssets(options) {
    const { maxAgeSeconds } = options;
    let lastModifiedInterval = this.#db.raw(
      `now() + interval '${-maxAgeSeconds} seconds'`
    );
    if (this.#db.client.config.client.includes("mysql")) {
      lastModifiedInterval = this.#db.raw(
        `date_sub(now(), interval ${maxAgeSeconds} second)`
      );
    } else if (this.#db.client.config.client.includes("sqlite3")) {
      lastModifiedInterval = this.#db.raw(`datetime('now', ?)`, [
        `-${maxAgeSeconds} seconds`
      ]);
    }
    await this.#db("static_assets_cache").where("namespace", this.#namespace).where("last_modified_at", "<=", lastModifiedInterval).delete();
  }
}

exports.StaticAssetsStore = StaticAssetsStore;
//# sourceMappingURL=StaticAssetsStore.cjs.js.map
