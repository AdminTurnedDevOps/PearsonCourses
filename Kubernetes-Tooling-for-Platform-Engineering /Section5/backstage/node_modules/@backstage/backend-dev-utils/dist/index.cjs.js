'use strict';

const requestType = "@backstage/cli/channel/request";
const responseType = "@backstage/cli/channel/response";
const IPC_TIMEOUT_MS = 5e3;
class BackstageIpcClient {
  #messageId = 0;
  #sendMessage;
  #handlers = /* @__PURE__ */ new Map();
  /**
   * Creates a new client if we're in a child process with IPC and BACKSTAGE_CLI_CHANNEL is set.
   */
  static create() {
    const sendMessage = process.send?.bind(process);
    const client = sendMessage && process.env.BACKSTAGE_CLI_CHANNEL ? new BackstageIpcClient(sendMessage) : void 0;
    if (client) {
      process.on(
        "message",
        (message, _sendHandle) => client.handleMessage(message, _sendHandle)
      );
    }
    return client;
  }
  constructor(sendMessage) {
    this.#sendMessage = sendMessage;
  }
  handleMessage(message, _sendHandle) {
    const isResponse = (msg) => msg?.type === responseType;
    if (isResponse(message)) {
      this.#handlers.get(message.id)?.(message);
    }
  }
  /**
   * Send a request to the parent process and wait for a response.
   */
  async request(method, body) {
    return new Promise((resolve, reject) => {
      const id = this.#messageId++;
      const request = {
        type: requestType,
        id,
        method,
        body
      };
      let timeout = void 0;
      const responseHandler = (response) => {
        clearTimeout(timeout);
        timeout = void 0;
        this.#handlers.delete(id);
        if ("error" in response) {
          const error = new Error(response.error.message);
          if (response.error.name) {
            error.name = response.error.name;
          }
          reject(error);
        } else {
          resolve(response.body);
        }
      };
      timeout = setTimeout(() => {
        reject(new Error(`IPC request '${method}' with ID ${id} timed out`));
        this.#handlers.delete(id);
      }, IPC_TIMEOUT_MS);
      timeout.unref();
      this.#handlers.set(id, responseHandler);
      this.#sendMessage(request, (e) => {
        if (e) {
          reject(e);
        }
      });
    });
  }
}
const ipcClient = BackstageIpcClient.create();

class DevDataStore {
  static #instance;
  /**
   * Tries to acquire a DevDataStore instance. This will only succeed when the backend
   * process is being run through the `@backstage/cli` in development mode.
   *
   * @returns A DevDataStore instance, or undefined if not available.
   */
  static get() {
    if (ipcClient) {
      if (!this.#instance) {
        this.#instance = new DevDataStore(ipcClient);
      }
      return this.#instance;
    }
    return void 0;
  }
  /** @internal */
  static forTest(client) {
    return new DevDataStore(client);
  }
  #client;
  constructor(client) {
    this.#client = client;
  }
  /**
   * Save data to the data store.
   *
   * @param key - The key used to identify the data.
   * @param data - The data to save. The data will be serialized using advanced IPC serialization.
   * @returns A promise that resolves to a result object that indicates whether the data was saved.
   */
  async save(key, data) {
    return this.#client.request(
      "DevDataStore.save",
      { key, data }
    );
  }
  /**
   * Loads data from the data store.
   *
   * @param key - The key used to identify the data.
   * @returns A promise that resolves to a result object that indicates whether the data was loaded, as well as the data.
   */
  async load(key) {
    const result = await this.#client.request(
      "DevDataStore.load",
      { key }
    );
    return result;
  }
}

exports.DevDataStore = DevDataStore;
//# sourceMappingURL=index.cjs.js.map
