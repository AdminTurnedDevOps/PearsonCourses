{"version":3,"file":"DependencyGraph.cjs.js","sources":["../../src/lib/DependencyGraph.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ninterface NodeInput<T> {\n  value: T;\n  consumes?: Iterable<string>;\n  provides?: Iterable<string>;\n}\n\n/** @internal */\nclass Node<T> {\n  static from<T>(input: NodeInput<T>) {\n    return new Node<T>(\n      input.value,\n      input.consumes ? new Set(input.consumes) : new Set(),\n      input.provides ? new Set(input.provides) : new Set(),\n    );\n  }\n\n  private constructor(\n    readonly value: T,\n    readonly consumes: Set<string>,\n    readonly provides: Set<string>,\n  ) {}\n}\n\n/** @internal */\nclass CycleKeySet<T> {\n  static from<T>(nodes: Array<Node<T>>) {\n    return new CycleKeySet<T>(nodes);\n  }\n\n  #nodeIds: Map<T, number>;\n  #cycleKeys: Set<string>;\n\n  private constructor(nodes: Array<Node<T>>) {\n    this.#nodeIds = new Map(nodes.map((n, i) => [n.value, i]));\n    this.#cycleKeys = new Set<string>();\n  }\n\n  tryAdd(path: T[]): boolean {\n    const cycleKey = this.#getCycleKey(path);\n    if (this.#cycleKeys.has(cycleKey)) {\n      return false;\n    }\n    this.#cycleKeys.add(cycleKey);\n    return true;\n  }\n\n  #getCycleKey(path: T[]): string {\n    return path\n      .map(n => this.#nodeIds.get(n)!)\n      .sort()\n      .join(',');\n  }\n}\n\n/**\n * Internal helper to help validate and traverse a dependency graph.\n * @internal\n */\nexport class DependencyGraph<T> {\n  static fromMap(\n    nodes: Record<string, Omit<NodeInput<unknown>, 'value'>>,\n  ): DependencyGraph<string> {\n    return this.fromIterable(\n      Object.entries(nodes).map(([key, node]) => ({\n        value: String(key),\n        ...node,\n      })),\n    );\n  }\n\n  static fromIterable<T>(\n    nodeInputs: Iterable<NodeInput<T>>,\n  ): DependencyGraph<T> {\n    const nodes = new Array<Node<T>>();\n    for (const nodeInput of nodeInputs) {\n      nodes.push(Node.from(nodeInput));\n    }\n\n    return new DependencyGraph(nodes);\n  }\n\n  #nodes: Array<Node<T>>;\n  #allProvided: Set<string>;\n\n  private constructor(nodes: Array<Node<T>>) {\n    this.#nodes = nodes;\n    this.#allProvided = new Set();\n\n    for (const node of this.#nodes.values()) {\n      for (const produced of node.provides) {\n        this.#allProvided.add(produced);\n      }\n    }\n  }\n\n  /**\n   * Find all nodes that consume dependencies that are not provided by any other node.\n   */\n  findUnsatisfiedDeps(): Array<{ value: T; unsatisfied: string[] }> {\n    const unsatisfiedDependencies = [];\n    for (const node of this.#nodes.values()) {\n      const unsatisfied = Array.from(node.consumes).filter(\n        id => !this.#allProvided.has(id),\n      );\n      if (unsatisfied.length > 0) {\n        unsatisfiedDependencies.push({ value: node.value, unsatisfied });\n      }\n    }\n    return unsatisfiedDependencies;\n  }\n\n  /**\n   * Detect the first circular dependency within the graph, returning the path of nodes that\n   * form a cycle, with the same node as the first and last element of the array.\n   */\n  detectCircularDependency(): T[] | undefined {\n    return this.detectCircularDependencies().next().value;\n  }\n\n  /**\n   * Detect circular dependencies within the graph, returning the path of nodes that\n   * form a cycle, with the same node as the first and last element of the array.\n   */\n  *detectCircularDependencies(): Generator<T[], undefined> {\n    const cycleKeys = CycleKeySet.from(this.#nodes);\n\n    for (const startNode of this.#nodes) {\n      const visited = new Set<Node<T>>();\n      const stack = new Array<[node: Node<T>, path: T[]]>([\n        startNode,\n        [startNode.value],\n      ]);\n\n      while (stack.length > 0) {\n        const [node, path] = stack.pop()!;\n        if (visited.has(node)) {\n          continue;\n        }\n        visited.add(node);\n        for (const consumed of node.consumes) {\n          const providerNodes = this.#nodes.filter(other =>\n            other.provides.has(consumed),\n          );\n          for (const provider of providerNodes) {\n            if (provider === startNode) {\n              if (cycleKeys.tryAdd(path)) {\n                yield [...path, startNode.value];\n              }\n\n              break;\n            }\n            if (!visited.has(provider)) {\n              stack.push([provider, [...path, provider.value]]);\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Traverses the dependency graph in topological order, calling the provided\n   * function for each node and waiting for it to resolve.\n   *\n   * The nodes are traversed in parallel, but in such a way that no node is\n   * visited before all of its dependencies.\n   *\n   * Dependencies of nodes that are not produced by any other nodes will be ignored.\n   */\n  async parallelTopologicalTraversal<TResult>(\n    fn: (value: T) => Promise<TResult>,\n  ): Promise<TResult[]> {\n    const allProvided = this.#allProvided;\n    const producedSoFar = new Set<string>();\n    const waiting = new Set(this.#nodes.values());\n    const visited = new Set<Node<T>>();\n    const results = new Array<TResult>();\n    let inFlight = 0; // Keep track of how many callbacks are in flight, so that we know if we got stuck\n\n    // Find all nodes that have no dependencies that have not already been produced by visited nodes\n    async function processMoreNodes() {\n      if (waiting.size === 0) {\n        return;\n      }\n      const nodesToProcess = [];\n      for (const node of waiting) {\n        let ready = true;\n        for (const consumed of node.consumes) {\n          if (allProvided.has(consumed) && !producedSoFar.has(consumed)) {\n            ready = false;\n            continue;\n          }\n        }\n        if (ready) {\n          nodesToProcess.push(node);\n        }\n      }\n\n      for (const node of nodesToProcess) {\n        waiting.delete(node);\n      }\n\n      if (nodesToProcess.length === 0 && inFlight === 0) {\n        // We expect the caller to check for circular dependencies before\n        // traversal, so this error should never happen\n        throw new Error('Circular dependency detected');\n      }\n\n      await Promise.all(nodesToProcess.map(processNode));\n    }\n\n    // Process an individual node, and then add its produced dependencies to the set of available products\n    async function processNode(node: Node<T>) {\n      visited.add(node);\n      inFlight += 1;\n\n      const result = await fn(node.value);\n      results.push(result);\n\n      node.provides.forEach(produced => producedSoFar.add(produced));\n      inFlight -= 1;\n      await processMoreNodes();\n    }\n\n    await processMoreNodes();\n\n    return results;\n  }\n}\n"],"names":[],"mappings":"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"}