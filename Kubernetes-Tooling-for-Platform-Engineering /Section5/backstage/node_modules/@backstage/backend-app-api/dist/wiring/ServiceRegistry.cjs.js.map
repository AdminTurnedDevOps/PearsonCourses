{"version":3,"file":"ServiceRegistry.cjs.js","sources":["../../src/wiring/ServiceRegistry.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ServiceFactory,\n  ServiceRef,\n  coreServices,\n  createServiceFactory,\n} from '@backstage/backend-plugin-api';\nimport { ConflictError, stringifyError } from '@backstage/errors';\n// Direct internal import to avoid duplication\n// eslint-disable-next-line @backstage/no-forbidden-package-imports\nimport { InternalServiceFactory } from '@backstage/backend-plugin-api/src/services/system/types';\nimport { DependencyGraph } from '../lib/DependencyGraph';\n/**\n * Keep in sync with `@backstage/backend-plugin-api/src/services/system/types.ts`\n * @internal\n */\nexport type InternalServiceRef = ServiceRef<unknown> & {\n  __defaultFactory?: (\n    service: ServiceRef<unknown>,\n  ) => Promise<ServiceFactory | (() => ServiceFactory)>;\n};\n\nfunction toInternalServiceFactory<TService, TScope extends 'plugin' | 'root'>(\n  factory: ServiceFactory<TService, TScope>,\n): InternalServiceFactory<TService, TScope> {\n  const f = factory as InternalServiceFactory<TService, TScope>;\n  if (f.$$type !== '@backstage/BackendFeature') {\n    throw new Error(`Invalid service factory, bad type '${f.$$type}'`);\n  }\n  if (f.version !== 'v1') {\n    throw new Error(`Invalid service factory, bad version '${f.version}'`);\n  }\n  return f;\n}\n\nfunction createPluginMetadataServiceFactory(pluginId: string) {\n  return createServiceFactory({\n    service: coreServices.pluginMetadata,\n    deps: {},\n    factory: async () => ({ getId: () => pluginId }),\n  });\n}\n\nexport class ServiceRegistry {\n  static create(factories: Array<ServiceFactory>): ServiceRegistry {\n    const factoryMap = new Map<string, InternalServiceFactory[]>();\n    for (const factory of factories) {\n      if (factory.service.multiton) {\n        const existing = factoryMap.get(factory.service.id) ?? [];\n        factoryMap.set(\n          factory.service.id,\n          existing.concat(toInternalServiceFactory(factory)),\n        );\n      } else {\n        factoryMap.set(factory.service.id, [toInternalServiceFactory(factory)]);\n      }\n    }\n    const registry = new ServiceRegistry(factoryMap);\n    registry.checkForCircularDeps();\n    return registry;\n  }\n\n  readonly #providedFactories: Map<string, InternalServiceFactory[]>;\n  readonly #loadedDefaultFactories: Map<\n    Function,\n    Promise<InternalServiceFactory>\n  >;\n  readonly #implementations: Map<\n    InternalServiceFactory,\n    {\n      context: Promise<unknown>;\n      byPlugin: Map<string, Promise<unknown>>;\n    }\n  >;\n  readonly #rootServiceImplementations = new Map<\n    InternalServiceFactory,\n    Promise<unknown>\n  >();\n  readonly #addedFactoryIds = new Set<string>();\n  readonly #instantiatedFactories = new Set<string>();\n\n  private constructor(factories: Map<string, InternalServiceFactory[]>) {\n    this.#providedFactories = factories;\n    this.#loadedDefaultFactories = new Map();\n    this.#implementations = new Map();\n  }\n\n  #resolveFactory(\n    ref: ServiceRef<unknown>,\n    pluginId: string,\n  ): Promise<InternalServiceFactory[]> | undefined {\n    // Special case handling of the plugin metadata service, generating a custom factory for it each time\n    if (ref.id === coreServices.pluginMetadata.id) {\n      return Promise.resolve([\n        toInternalServiceFactory(createPluginMetadataServiceFactory(pluginId)),\n      ]);\n    }\n\n    let resolvedFactory:\n      | Promise<InternalServiceFactory[]>\n      | InternalServiceFactory[]\n      | undefined = this.#providedFactories.get(ref.id);\n    const { __defaultFactory: defaultFactory } = ref as InternalServiceRef;\n    if (!resolvedFactory && !defaultFactory) {\n      return undefined;\n    }\n\n    if (!resolvedFactory) {\n      let loadedFactory = this.#loadedDefaultFactories.get(defaultFactory!);\n      if (!loadedFactory) {\n        loadedFactory = Promise.resolve()\n          .then(() => defaultFactory!(ref))\n          .then(f =>\n            toInternalServiceFactory(typeof f === 'function' ? f() : f),\n          );\n        this.#loadedDefaultFactories.set(defaultFactory!, loadedFactory);\n      }\n      resolvedFactory = loadedFactory.then(\n        factory => [factory],\n        error => {\n          throw new Error(\n            `Failed to instantiate service '${\n              ref.id\n            }' because the default factory loader threw an error, ${stringifyError(\n              error,\n            )}`,\n          );\n        },\n      );\n    }\n\n    return Promise.resolve(resolvedFactory);\n  }\n\n  #checkForMissingDeps(factory: InternalServiceFactory, pluginId: string) {\n    const missingDeps = Object.values(factory.deps).filter(ref => {\n      if (ref.id === coreServices.pluginMetadata.id) {\n        return false;\n      }\n      if (this.#providedFactories.get(ref.id)) {\n        return false;\n      }\n      if (ref.multiton) {\n        return false;\n      }\n\n      return !(ref as InternalServiceRef).__defaultFactory;\n    });\n\n    if (missingDeps.length) {\n      const missing = missingDeps.map(r => `'${r.id}'`).join(', ');\n      throw new Error(\n        `Failed to instantiate service '${factory.service.id}' for '${pluginId}' because the following dependent services are missing: ${missing}`,\n      );\n    }\n  }\n\n  checkForCircularDeps(): void {\n    const graph = DependencyGraph.fromIterable(\n      Array.from(this.#providedFactories).map(([serviceId, factories]) => ({\n        value: serviceId,\n        provides: [serviceId],\n        consumes: factories.flatMap(factory =>\n          Object.values(factory.deps).map(d => d.id),\n        ),\n      })),\n    );\n    const circularDependencies = Array.from(graph.detectCircularDependencies());\n\n    if (circularDependencies.length) {\n      const cycles = circularDependencies\n        .map(c => c.map(id => `'${id}'`).join(' -> '))\n        .join('\\n  ');\n\n      throw new ConflictError(`Circular dependencies detected:\\n  ${cycles}`);\n    }\n  }\n\n  hasBeenAdded(ref: ServiceRef<any>) {\n    if (ref.id === coreServices.pluginMetadata.id) {\n      return true;\n    }\n    return this.#addedFactoryIds.has(ref.id);\n  }\n\n  add(factory: ServiceFactory) {\n    const factoryId = factory.service.id;\n    if (factoryId === coreServices.pluginMetadata.id) {\n      throw new Error(\n        `The ${coreServices.pluginMetadata.id} service cannot be overridden`,\n      );\n    }\n\n    if (this.#instantiatedFactories.has(factoryId)) {\n      throw new Error(\n        `Unable to set service factory with id ${factoryId}, service has already been instantiated`,\n      );\n    }\n\n    if (factory.service.multiton) {\n      const newFactories = (\n        this.#providedFactories.get(factoryId) ?? []\n      ).concat(toInternalServiceFactory(factory));\n      this.#providedFactories.set(factoryId, newFactories);\n    } else {\n      if (this.#addedFactoryIds.has(factoryId)) {\n        throw new Error(\n          `Duplicate service implementations provided for ${factoryId}`,\n        );\n      }\n\n      this.#addedFactoryIds.add(factoryId);\n      this.#providedFactories.set(factoryId, [\n        toInternalServiceFactory(factory),\n      ]);\n    }\n  }\n\n  async initializeEagerServicesWithScope(\n    scope: 'root' | 'plugin',\n    pluginId: string = 'root',\n  ) {\n    for (const [factory] of this.#providedFactories.values()) {\n      if (factory.service.scope === scope) {\n        // Root-scoped services are eager by default, plugin-scoped are lazy by default\n        if (scope === 'root' && factory.initialization !== 'lazy') {\n          await this.get(factory.service, pluginId);\n        } else if (scope === 'plugin' && factory.initialization === 'always') {\n          await this.get(factory.service, pluginId);\n        }\n      }\n    }\n  }\n\n  get<T, TInstances extends 'singleton' | 'multiton'>(\n    ref: ServiceRef<T, 'plugin' | 'root', TInstances>,\n    pluginId: string,\n  ): Promise<TInstances extends 'multiton' ? T[] : T> | undefined {\n    this.#instantiatedFactories.add(ref.id);\n\n    const resolvedFactory = this.#resolveFactory(ref, pluginId);\n\n    if (!resolvedFactory) {\n      return ref.multiton\n        ? (Promise.resolve([]) as\n            | Promise<TInstances extends 'multiton' ? T[] : T>\n            | undefined)\n        : undefined;\n    }\n\n    return resolvedFactory\n      .then(factories => {\n        return Promise.all(\n          factories.map(factory => {\n            if (factory.service.scope === 'root') {\n              let existing = this.#rootServiceImplementations.get(factory);\n              if (!existing) {\n                this.#checkForMissingDeps(factory, pluginId);\n                const rootDeps = new Array<\n                  Promise<[name: string, impl: unknown]>\n                >();\n\n                for (const [name, serviceRef] of Object.entries(factory.deps)) {\n                  if (serviceRef.scope !== 'root') {\n                    throw new Error(\n                      `Failed to instantiate 'root' scoped service '${ref.id}' because it depends on '${serviceRef.scope}' scoped service '${serviceRef.id}'.`,\n                    );\n                  }\n                  const target = this.get(serviceRef, pluginId)!;\n                  rootDeps.push(target.then(impl => [name, impl]));\n                }\n\n                existing = Promise.all(rootDeps).then(entries =>\n                  factory.factory(Object.fromEntries(entries), undefined),\n                );\n                this.#rootServiceImplementations.set(factory, existing);\n              }\n              return existing as Promise<T>;\n            }\n\n            let implementation = this.#implementations.get(factory);\n            if (!implementation) {\n              this.#checkForMissingDeps(factory, pluginId);\n              const rootDeps = new Array<\n                Promise<[name: string, impl: unknown]>\n              >();\n\n              for (const [name, serviceRef] of Object.entries(factory.deps)) {\n                if (serviceRef.scope === 'root') {\n                  const target = this.get(serviceRef, pluginId)!;\n                  rootDeps.push(target.then(impl => [name, impl]));\n                }\n              }\n\n              implementation = {\n                context: Promise.all(rootDeps)\n                  .then(entries =>\n                    factory.createRootContext?.(Object.fromEntries(entries)),\n                  )\n                  .catch(error => {\n                    const cause = stringifyError(error);\n                    throw new Error(\n                      `Failed to instantiate service '${ref.id}' because createRootContext threw an error, ${cause}`,\n                    );\n                  }),\n                byPlugin: new Map(),\n              };\n\n              this.#implementations.set(factory, implementation);\n            }\n\n            let result = implementation.byPlugin.get(pluginId) as Promise<any>;\n            if (!result) {\n              const allDeps = new Array<\n                Promise<[name: string, impl: unknown]>\n              >();\n\n              for (const [name, serviceRef] of Object.entries(factory.deps)) {\n                const target = this.get(serviceRef, pluginId)!;\n                allDeps.push(target.then(impl => [name, impl]));\n              }\n\n              result = implementation.context\n                .then(context =>\n                  Promise.all(allDeps).then(entries =>\n                    factory.factory(Object.fromEntries(entries), context),\n                  ),\n                )\n                .catch(error => {\n                  const cause = stringifyError(error);\n                  throw new Error(\n                    `Failed to instantiate service '${ref.id}' for '${pluginId}' because the factory function threw an error, ${cause}`,\n                  );\n                });\n              implementation.byPlugin.set(pluginId, result);\n            }\n            return result;\n          }),\n        );\n      })\n      .then(results => (ref.multiton ? results : results[0]));\n  }\n}\n"],"names":["createServiceFactory","coreServices","stringifyError","DependencyGraph","ConflictError"],"mappings":"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"}