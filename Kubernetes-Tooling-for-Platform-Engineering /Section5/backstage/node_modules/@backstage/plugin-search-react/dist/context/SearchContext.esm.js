import { isEqual } from 'lodash';
import React, { useContext, useState, useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
import usePrevious from 'react-use/esm/usePrevious';
import { createVersionedContext, createVersionedValueMap } from '@backstage/version-bridge';
import { useApi, configApiRef, AnalyticsContext, useAnalytics } from '@backstage/core-plugin-api';
import { searchApiRef } from '../api.esm.js';

const SearchContext = createVersionedContext("search-context");
const useSearch = () => {
  const context = useContext(SearchContext);
  if (!context) {
    throw new Error("useSearch must be used within a SearchContextProvider");
  }
  const value = context.atVersion(1);
  if (!value) {
    throw new Error("No SearchContext v1 found");
  }
  return value;
};
const useSearchContextCheck = () => {
  const context = useContext(SearchContext);
  return context !== void 0;
};
const defaultInitialSearchState = {
  term: "",
  types: [],
  filters: {},
  pageLimit: void 0,
  pageCursor: void 0
};
const useSearchContextValue = (initialValue = defaultInitialSearchState) => {
  const searchApi = useApi(searchApiRef);
  const analytics = useAnalytics();
  const [term, setTerm] = useState(initialValue.term);
  const [types, setTypes] = useState(initialValue.types);
  const [filters, setFilters] = useState(initialValue.filters);
  const [pageLimit, setPageLimit] = useState(
    initialValue.pageLimit
  );
  const [pageCursor, setPageCursor] = useState(
    initialValue.pageCursor
  );
  const prevTerm = usePrevious(term);
  const prevFilters = usePrevious(filters);
  const result = useAsync(async () => {
    const resultSet = await searchApi.query({
      term,
      types,
      filters,
      pageLimit,
      pageCursor
    });
    if (term) {
      analytics.captureEvent("search", term, {
        value: result.value?.numberOfResults ?? void 0
      });
    }
    return resultSet;
  }, [term, types, filters, pageLimit, pageCursor]);
  const hasNextPage = !result.loading && !result.error && result.value?.nextPageCursor;
  const hasPreviousPage = !result.loading && !result.error && result.value?.previousPageCursor;
  const fetchNextPage = useCallback(() => {
    setPageCursor(result.value?.nextPageCursor);
  }, [result.value?.nextPageCursor]);
  const fetchPreviousPage = useCallback(() => {
    setPageCursor(result.value?.previousPageCursor);
  }, [result.value?.previousPageCursor]);
  useEffect(() => {
    if (prevTerm !== void 0 && term !== prevTerm) {
      setPageCursor(void 0);
    }
  }, [term, prevTerm, setPageCursor]);
  useEffect(() => {
    if (prevFilters !== void 0 && !isEqual(filters, prevFilters)) {
      setPageCursor(void 0);
    }
  }, [filters, prevFilters, setPageCursor]);
  const value = {
    result,
    term,
    setTerm,
    types,
    setTypes,
    filters,
    setFilters,
    pageLimit,
    setPageLimit,
    pageCursor,
    setPageCursor,
    fetchNextPage: hasNextPage ? fetchNextPage : void 0,
    fetchPreviousPage: hasPreviousPage ? fetchPreviousPage : void 0
  };
  return value;
};
const LocalSearchContext = (props) => {
  const { initialState, children } = props;
  const value = useSearchContextValue(initialState);
  return /* @__PURE__ */ React.createElement(
    AnalyticsContext,
    {
      attributes: { searchTypes: value.types.sort().join(",") }
    },
    /* @__PURE__ */ React.createElement(SearchContext.Provider, { value: createVersionedValueMap({ 1: value }) }, children)
  );
};
const SearchContextProvider = (props) => {
  const { initialState, inheritParentContextIfAvailable, children } = props;
  const hasParentContext = useSearchContextCheck();
  const configApi = useApi(configApiRef);
  const propsInitialSearchState = initialState ?? {};
  const configInitialSearchState = configApi.has("search.query.pageLimit") ? { pageLimit: configApi.getNumber("search.query.pageLimit") } : {};
  const searchContextInitialState = {
    ...defaultInitialSearchState,
    ...propsInitialSearchState,
    ...configInitialSearchState
  };
  return hasParentContext && inheritParentContextIfAvailable ? /* @__PURE__ */ React.createElement(React.Fragment, null, children) : /* @__PURE__ */ React.createElement(LocalSearchContext, { initialState: searchContextInitialState }, children);
};

export { SearchContextProvider, useSearch, useSearchContextCheck };
//# sourceMappingURL=SearchContext.esm.js.map
