{"version":3,"file":"DatabaseDocumentStore.cjs.js","sources":["../../src/database/DatabaseDocumentStore.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  DatabaseService,\n  resolvePackagePath,\n} from '@backstage/backend-plugin-api';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Knex } from 'knex';\nimport {\n  DatabaseStore,\n  DocumentResultRow,\n  PgSearchQuery,\n  RawDocumentRow,\n} from './types';\nimport { queryPostgresMajorVersion } from './util';\n\nconst migrationsDir = resolvePackagePath(\n  '@backstage/plugin-search-backend-module-pg',\n  'migrations',\n);\n\n/** @public */\nexport class DatabaseDocumentStore implements DatabaseStore {\n  static async create(\n    database: DatabaseService,\n  ): Promise<DatabaseDocumentStore> {\n    const knex = await database.getClient();\n    try {\n      const majorVersion = await queryPostgresMajorVersion(knex);\n\n      if (majorVersion < 12) {\n        // We are using some features (like generated columns) that aren't\n        // available in older postgres versions.\n        throw new Error(\n          `The PgSearchEngine requires at least postgres version 12 (but is running on ${majorVersion})`,\n        );\n      }\n    } catch {\n      // Actually both mysql and sqlite have a full text search, too. We could\n      // implement them separately or add them here.\n      throw new Error(\n        'The PgSearchEngine is only supported when using a postgres database (>=12.x)',\n      );\n    }\n\n    if (!database.migrations?.skip) {\n      await knex.migrate.latest({\n        directory: migrationsDir,\n      });\n    }\n\n    return new DatabaseDocumentStore(knex);\n  }\n\n  static async supported(knex: Knex): Promise<boolean> {\n    try {\n      const majorVersion = await queryPostgresMajorVersion(knex);\n\n      return majorVersion >= 12;\n    } catch {\n      return false;\n    }\n  }\n\n  constructor(private readonly db: Knex) {}\n\n  async transaction<T>(fn: (tx: Knex.Transaction) => Promise<T>): Promise<T> {\n    return await this.db.transaction(fn);\n  }\n\n  async getTransaction(): Promise<Knex.Transaction> {\n    return this.db.transaction();\n  }\n\n  async prepareInsert(tx: Knex.Transaction): Promise<void> {\n    // We create a temporary table to collect the hashes of the documents that\n    // we expect to be in the documents table at the end. The table is deleted\n    // at the end of the transaction.\n    // The hash makes sure that we generate a new row for every change.\n    await tx.raw(\n      'CREATE TEMP TABLE documents_to_insert (' +\n        'type text NOT NULL, ' +\n        'document jsonb NOT NULL, ' +\n        // Generating the hash requires a trick, as the text to bytea\n        // conversation runs into errors in case the text contains a backslash.\n        // Therefore we have to escape them.\n        \"hash bytea NOT NULL GENERATED ALWAYS AS (sha256(replace(document::text || type, '\\\\', '\\\\\\\\')::bytea)) STORED\" +\n        ') ON COMMIT DROP',\n    );\n  }\n\n  async completeInsert(tx: Knex.Transaction, type: string): Promise<void> {\n    // Copy all new rows into the documents table\n    await tx\n      .insert(\n        tx<RawDocumentRow>('documents_to_insert').select(\n          'type',\n          'document',\n          'hash',\n        ),\n      )\n      .into(tx.raw('documents (type, document, hash)'))\n      .onConflict('hash')\n      .ignore();\n\n    // Delete all documents that we don't expect (deleted and changed)\n    const rowsToDelete = tx<RawDocumentRow>('documents')\n      .select('documents.hash')\n      .leftJoin<RawDocumentRow>('documents_to_insert', {\n        'documents.hash': 'documents_to_insert.hash',\n      })\n      .whereNull('documents_to_insert.hash');\n\n    await tx<RawDocumentRow>('documents')\n      .where({ type })\n      .whereIn('hash', rowsToDelete)\n      .delete();\n  }\n\n  async insertDocuments(\n    tx: Knex.Transaction,\n    type: string,\n    documents: IndexableDocument[],\n  ): Promise<void> {\n    // Insert all documents into the temporary table to process them later\n    await tx<DocumentResultRow>('documents_to_insert').insert(\n      documents.map(document => ({\n        type,\n        document,\n      })),\n    );\n  }\n\n  async query(\n    tx: Knex.Transaction,\n    searchQuery: PgSearchQuery,\n  ): Promise<DocumentResultRow[]> {\n    const { types, pgTerm, fields, offset, limit, options } = searchQuery;\n    // TODO(awanlin): We should make the language a parameter so that we can support more then just english\n    // Builds a query like:\n    // SELECT ts_rank_cd(body, query) AS rank, type, document,\n    // ts_headline('english', document, query) AS highlight\n    // FROM documents, to_tsquery('english', 'consent') query\n    // WHERE query @@ body AND (document @> '{\"kind\": \"API\"}')\n    // ORDER BY rank DESC\n    // LIMIT 10;\n    const query = tx<DocumentResultRow>('documents');\n\n    if (pgTerm) {\n      query\n        .from(tx.raw(\"documents, to_tsquery('english', ?) query\", pgTerm))\n        .whereRaw('query @@ body');\n    } else {\n      query.from('documents');\n    }\n\n    if (types) {\n      query.whereIn('type', types);\n    }\n\n    if (fields) {\n      Object.keys(fields).forEach(key => {\n        const value = fields[key];\n        const valueArray = Array.isArray(value) ? value : [value];\n        const fieldValueCompare = valueArray\n          .map(v => ({ [key]: v }))\n          .map(v => JSON.stringify(v));\n        const arrayValueCompare = valueArray\n          .map(v => ({ [key]: [v] }))\n          .map(v => JSON.stringify(v));\n        const valueCompare = [...fieldValueCompare, ...arrayValueCompare];\n        query.whereRaw(\n          `(${valueCompare.map(() => 'document @> ?').join(' OR ')})`,\n          valueCompare,\n        );\n      });\n    }\n\n    query.select('type', 'document');\n\n    if (pgTerm && options.useHighlight) {\n      const headlineOptions = `MaxWords=${options.maxWords}, MinWords=${options.minWords}, ShortWord=${options.shortWord}, HighlightAll=${options.highlightAll}, MaxFragments=${options.maxFragments}, FragmentDelimiter=${options.fragmentDelimiter}, StartSel=${options.preTag}, StopSel=${options.postTag}`;\n      query\n        .select(tx.raw('ts_rank_cd(body, query) AS \"rank\"'))\n        .select(\n          tx.raw(\n            `ts_headline(\\'english\\', document, query, '${headlineOptions}') as \"highlight\"`,\n          ),\n        )\n        .orderBy('rank', 'desc');\n    } else if (pgTerm && !options.useHighlight) {\n      query\n        .select(tx.raw('ts_rank_cd(body, query) AS \"rank\"'))\n        .orderBy('rank', 'desc');\n    } else {\n      query.select(tx.raw('1 as rank'));\n    }\n\n    return await query.offset(offset).limit(limit);\n  }\n}\n"],"names":["resolvePackagePath","queryPostgresMajorVersion"],"mappings":"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"}