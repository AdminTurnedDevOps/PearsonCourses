'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var util = require('./util.cjs.js');

const migrationsDir = backendPluginApi.resolvePackagePath(
  "@backstage/plugin-search-backend-module-pg",
  "migrations"
);
class DatabaseDocumentStore {
  constructor(db) {
    this.db = db;
  }
  static async create(database) {
    const knex = await database.getClient();
    try {
      const majorVersion = await util.queryPostgresMajorVersion(knex);
      if (majorVersion < 12) {
        throw new Error(
          `The PgSearchEngine requires at least postgres version 12 (but is running on ${majorVersion})`
        );
      }
    } catch {
      throw new Error(
        "The PgSearchEngine is only supported when using a postgres database (>=12.x)"
      );
    }
    if (!database.migrations?.skip) {
      await knex.migrate.latest({
        directory: migrationsDir
      });
    }
    return new DatabaseDocumentStore(knex);
  }
  static async supported(knex) {
    try {
      const majorVersion = await util.queryPostgresMajorVersion(knex);
      return majorVersion >= 12;
    } catch {
      return false;
    }
  }
  async transaction(fn) {
    return await this.db.transaction(fn);
  }
  async getTransaction() {
    return this.db.transaction();
  }
  async prepareInsert(tx) {
    await tx.raw(
      "CREATE TEMP TABLE documents_to_insert (type text NOT NULL, document jsonb NOT NULL, hash bytea NOT NULL GENERATED ALWAYS AS (sha256(replace(document::text || type, '\\', '\\\\')::bytea)) STORED) ON COMMIT DROP"
    );
  }
  async completeInsert(tx, type) {
    await tx.insert(
      tx("documents_to_insert").select(
        "type",
        "document",
        "hash"
      )
    ).into(tx.raw("documents (type, document, hash)")).onConflict("hash").ignore();
    const rowsToDelete = tx("documents").select("documents.hash").leftJoin("documents_to_insert", {
      "documents.hash": "documents_to_insert.hash"
    }).whereNull("documents_to_insert.hash");
    await tx("documents").where({ type }).whereIn("hash", rowsToDelete).delete();
  }
  async insertDocuments(tx, type, documents) {
    await tx("documents_to_insert").insert(
      documents.map((document) => ({
        type,
        document
      }))
    );
  }
  async query(tx, searchQuery) {
    const { types, pgTerm, fields, offset, limit, options } = searchQuery;
    const query = tx("documents");
    if (pgTerm) {
      query.from(tx.raw("documents, to_tsquery('english', ?) query", pgTerm)).whereRaw("query @@ body");
    } else {
      query.from("documents");
    }
    if (types) {
      query.whereIn("type", types);
    }
    if (fields) {
      Object.keys(fields).forEach((key) => {
        const value = fields[key];
        const valueArray = Array.isArray(value) ? value : [value];
        const fieldValueCompare = valueArray.map((v) => ({ [key]: v })).map((v) => JSON.stringify(v));
        const arrayValueCompare = valueArray.map((v) => ({ [key]: [v] })).map((v) => JSON.stringify(v));
        const valueCompare = [...fieldValueCompare, ...arrayValueCompare];
        query.whereRaw(
          `(${valueCompare.map(() => "document @> ?").join(" OR ")})`,
          valueCompare
        );
      });
    }
    query.select("type", "document");
    if (pgTerm && options.useHighlight) {
      const headlineOptions = `MaxWords=${options.maxWords}, MinWords=${options.minWords}, ShortWord=${options.shortWord}, HighlightAll=${options.highlightAll}, MaxFragments=${options.maxFragments}, FragmentDelimiter=${options.fragmentDelimiter}, StartSel=${options.preTag}, StopSel=${options.postTag}`;
      query.select(tx.raw('ts_rank_cd(body, query) AS "rank"')).select(
        tx.raw(
          `ts_headline('english', document, query, '${headlineOptions}') as "highlight"`
        )
      ).orderBy("rank", "desc");
    } else if (pgTerm && !options.useHighlight) {
      query.select(tx.raw('ts_rank_cd(body, query) AS "rank"')).orderBy("rank", "desc");
    } else {
      query.select(tx.raw("1 as rank"));
    }
    return await query.offset(offset).limit(limit);
  }
}

exports.DatabaseDocumentStore = DatabaseDocumentStore;
//# sourceMappingURL=DatabaseDocumentStore.cjs.js.map
