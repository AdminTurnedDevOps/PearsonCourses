'use strict';

var pluginSearchBackendNode = require('@backstage/plugin-search-backend-node');

class PgSearchEngineIndexer extends pluginSearchBackendNode.BatchSearchEngineIndexer {
  logger;
  store;
  type;
  tx;
  numRecords = 0;
  constructor(options) {
    super({ batchSize: options.batchSize });
    this.store = options.databaseStore;
    this.type = options.type;
    this.logger = options.logger;
  }
  async initialize() {
    this.tx = await this.store.getTransaction();
    try {
      await this.store.prepareInsert(this.tx);
    } catch (e) {
      this.tx.rollback(e);
      throw e;
    }
  }
  async index(documents) {
    this.numRecords += documents.length;
    const refs = [...new Set(documents.map((d) => d.authorization?.resourceRef))];
    this.logger?.debug(
      `Attempting to index the following entities: ${refs.toString()}`
    );
    try {
      await this.store.insertDocuments(this.tx, this.type, documents);
    } catch (e) {
      this.tx.rollback(e);
      throw e;
    }
  }
  async finalize() {
    if (this.numRecords === 0) {
      this.logger?.warn(
        `Index for ${this.type} was not replaced: indexer received 0 documents`
      );
      this.tx.rollback();
      return;
    }
    try {
      await this.store.completeInsert(this.tx, this.type);
      this.tx.commit();
    } catch (e) {
      this.tx.rollback(e);
      throw e;
    }
  }
  /**
   * Custom handler covering the case where an error occurred somewhere else in
   * the indexing pipeline (e.g. a collator or decorator). In such cases, the
   * finalize method is not called, which leaves a dangling transaction and
   * therefore an open connection to PG. This handler ensures we close the
   * transaction and associated connection.
   *
   * todo(@backstage/search-maintainers): Consider introducing a more
   * formal mechanism for handling such errors in BatchSearchEngineIndexer and
   * replacing this method with it. See: #17291
   *
   * @internal
   */
  async _destroy(error, done) {
    if (!error) {
      done();
      return;
    }
    if (!this.tx.isCompleted()) {
      await this.tx.rollback(error);
    }
    done(error);
  }
}

exports.PgSearchEngineIndexer = PgSearchEngineIndexer;
//# sourceMappingURL=PgSearchEngineIndexer.cjs.js.map
