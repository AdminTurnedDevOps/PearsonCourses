'use strict';

var PgSearchEngineIndexer = require('./PgSearchEngineIndexer.cjs.js');
var DatabaseDocumentStore = require('../database/DatabaseDocumentStore.cjs.js');
var uuid = require('uuid');

class PgSearchEngine {
  /**
   * @deprecated This will be marked as private in a future release, please us fromConfig instead
   */
  constructor(databaseStore, config, logger) {
    this.databaseStore = databaseStore;
    const uuidTag = uuid.v4();
    const highlightConfig = config.getOptionalConfig(
      "search.pg.highlightOptions"
    );
    const highlightOptions = {
      preTag: `<${uuidTag}>`,
      postTag: `</${uuidTag}>`,
      useHighlight: highlightConfig?.getOptionalBoolean("useHighlight") ?? true,
      maxWords: highlightConfig?.getOptionalNumber("maxWords") ?? 35,
      minWords: highlightConfig?.getOptionalNumber("minWords") ?? 15,
      shortWord: highlightConfig?.getOptionalNumber("shortWord") ?? 3,
      highlightAll: highlightConfig?.getOptionalBoolean("highlightAll") ?? false,
      maxFragments: highlightConfig?.getOptionalNumber("maxFragments") ?? 0,
      fragmentDelimiter: highlightConfig?.getOptionalString("fragmentDelimiter") ?? " ... "
    };
    this.highlightOptions = highlightOptions;
    this.indexerBatchSize = config.getOptionalNumber("search.pg.indexerBatchSize") ?? 1e3;
    this.logger = logger;
  }
  logger;
  highlightOptions;
  indexerBatchSize;
  /**
   * @deprecated This will be removed in a future release, please use fromConfig instead
   */
  static async from(options) {
    return new PgSearchEngine(
      await DatabaseDocumentStore.DatabaseDocumentStore.create(options.database),
      options.config,
      options.logger
    );
  }
  static async fromConfig(config, options) {
    return new PgSearchEngine(
      await DatabaseDocumentStore.DatabaseDocumentStore.create(options.database),
      config,
      options.logger
    );
  }
  static async supported(database) {
    return await DatabaseDocumentStore.DatabaseDocumentStore.supported(await database.getClient());
  }
  translator(query, options) {
    const pageSize = query.pageLimit || 25;
    const { page } = decodePageCursor(query.pageCursor);
    const offset = page * pageSize;
    const limit = pageSize + 1;
    return {
      pgQuery: {
        pgTerm: query.term.split(/\s/).map((p) => p.replace(/[\0()|&:*!]/g, "").trim()).filter((p) => p !== "").map((p) => `(${JSON.stringify(p)} | ${JSON.stringify(p)}:*)`).join("&"),
        fields: query.filters,
        types: query.types,
        offset,
        limit,
        options: options.highlightOptions
      },
      pageSize
    };
  }
  setTranslator(translator) {
    this.translator = translator;
  }
  async getIndexer(type) {
    return new PgSearchEngineIndexer.PgSearchEngineIndexer({
      batchSize: this.indexerBatchSize,
      type,
      databaseStore: this.databaseStore,
      logger: this.logger?.child({ documentType: type })
    });
  }
  async query(query) {
    const { pgQuery, pageSize } = this.translator(query, {
      highlightOptions: this.highlightOptions
    });
    const rows = await this.databaseStore.transaction(
      async (tx) => this.databaseStore.query(tx, pgQuery)
    );
    const { page } = decodePageCursor(query.pageCursor);
    const hasNextPage = rows.length > pageSize;
    const hasPreviousPage = page > 0;
    const pageRows = rows.slice(0, pageSize);
    const nextPageCursor = hasNextPage ? encodePageCursor({ page: page + 1 }) : void 0;
    const previousPageCursor = hasPreviousPage ? encodePageCursor({ page: page - 1 }) : void 0;
    const results = pageRows.map(
      ({ type, document, highlight }, index) => ({
        type,
        document,
        rank: page * pageSize + index + 1,
        highlight: {
          preTag: pgQuery.options.preTag,
          postTag: pgQuery.options.postTag,
          fields: highlight ? {
            text: highlight.text,
            title: highlight.title,
            location: highlight.location,
            path: ""
          } : {}
        }
      })
    );
    return { results, nextPageCursor, previousPageCursor };
  }
}
function decodePageCursor(pageCursor) {
  if (!pageCursor) {
    return { page: 0 };
  }
  return {
    page: Number(Buffer.from(pageCursor, "base64").toString("utf-8"))
  };
}
function encodePageCursor({ page }) {
  return Buffer.from(`${page}`, "utf-8").toString("base64");
}

exports.PgSearchEngine = PgSearchEngine;
exports.decodePageCursor = decodePageCursor;
exports.encodePageCursor = encodePageCursor;
//# sourceMappingURL=PgSearchEngine.cjs.js.map
