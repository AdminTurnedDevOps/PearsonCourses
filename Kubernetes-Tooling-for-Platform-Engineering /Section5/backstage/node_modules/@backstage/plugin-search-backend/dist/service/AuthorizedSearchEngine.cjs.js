'use strict';

var lodash = require('lodash');
var qs = require('qs');
var DataLoader = require('dataloader');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var errors = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var qs__default = /*#__PURE__*/_interopDefaultCompat(qs);
var DataLoader__default = /*#__PURE__*/_interopDefaultCompat(DataLoader);

function decodePageCursor(pageCursor) {
  if (!pageCursor) {
    return { page: 0 };
  }
  const page = Number(Buffer.from(pageCursor, "base64").toString("utf-8"));
  if (isNaN(page)) {
    throw new errors.InputError("Invalid page cursor");
  }
  if (page < 0) {
    throw new errors.InputError("Invalid page cursor");
  }
  return {
    page
  };
}
function encodePageCursor({ page }) {
  return Buffer.from(`${page}`, "utf-8").toString("base64");
}
class AuthorizedSearchEngine {
  constructor(searchEngine, types, permissions, auth, config) {
    this.searchEngine = searchEngine;
    this.types = types;
    this.permissions = permissions;
    this.auth = auth;
    this.queryLatencyBudgetMs = config.getOptionalNumber("search.permissions.queryLatencyBudgetMs") ?? 1e3;
  }
  queryLatencyBudgetMs;
  setTranslator(translator) {
    this.searchEngine.setTranslator(translator);
  }
  async getIndexer(type) {
    return this.searchEngine.getIndexer(type);
  }
  async query(query, options) {
    const queryStartTime = Date.now();
    const compatOptions = "credentials" in options ? options : { credentials: await this.auth.getNoneCredentials() };
    const conditionFetcher = new DataLoader__default.default(
      (requests) => this.permissions.authorizeConditional(requests.slice(), compatOptions),
      {
        cacheKeyFn: ({ permission: { name } }) => name
      }
    );
    const authorizer = new DataLoader__default.default(
      (requests) => this.permissions.authorize(requests.slice(), compatOptions),
      {
        // Serialize the permission name and resourceRef as
        // a query string to avoid collisions from overlapping
        // permission names and resourceRefs.
        cacheKeyFn: ({ permission: { name }, resourceRef }) => qs__default.default.stringify({ name, resourceRef })
      }
    );
    const requestedTypes = query.types || Object.keys(this.types);
    const typeDecisions = lodash.zipObject(
      requestedTypes,
      await Promise.all(
        requestedTypes.map((type) => {
          const permission = this.types[type]?.visibilityPermission;
          if (!permission) {
            return { result: pluginPermissionCommon.AuthorizeResult.ALLOW };
          }
          if (pluginPermissionCommon.isResourcePermission(permission)) {
            return conditionFetcher.load({ permission });
          }
          return authorizer.load({ permission });
        })
      )
    );
    const authorizedTypes = requestedTypes.filter(
      (type) => typeDecisions[type]?.result !== pluginPermissionCommon.AuthorizeResult.DENY
    );
    const resultByResultFilteringRequired = authorizedTypes.some(
      (type) => typeDecisions[type]?.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL
    );
    if (!resultByResultFilteringRequired) {
      return this.searchEngine.query(
        { ...query, types: authorizedTypes },
        compatOptions
      );
    }
    const pageSize = query.pageLimit || 25;
    const { page } = decodePageCursor(query.pageCursor);
    const targetResults = (page + 1) * pageSize;
    let filteredResults = [];
    let nextPageCursor;
    let latencyBudgetExhausted = false;
    do {
      const nextPage = await this.searchEngine.query(
        { ...query, types: authorizedTypes, pageCursor: nextPageCursor },
        compatOptions
      );
      filteredResults = filteredResults.concat(
        await this.filterResults(nextPage.results, typeDecisions, authorizer)
      );
      nextPageCursor = nextPage.nextPageCursor;
      latencyBudgetExhausted = Date.now() - queryStartTime > this.queryLatencyBudgetMs;
    } while (nextPageCursor && filteredResults.length < targetResults && !latencyBudgetExhausted);
    return {
      results: filteredResults.slice(page * pageSize, (page + 1) * pageSize).map((result, index) => {
        return {
          ...result,
          rank: page * pageSize + index + 1
        };
      }),
      previousPageCursor: page === 0 ? void 0 : encodePageCursor({ page: page - 1 }),
      nextPageCursor: !latencyBudgetExhausted && (nextPageCursor || filteredResults.length > targetResults) ? encodePageCursor({ page: page + 1 }) : void 0,
      numberOfResults: void 0
    };
  }
  async filterResults(results, typeDecisions, authorizer) {
    return lodash.compact(
      await Promise.all(
        results.map((result) => {
          if (typeDecisions[result.type]?.result === pluginPermissionCommon.AuthorizeResult.ALLOW) {
            return result;
          }
          const permission = this.types[result.type]?.visibilityPermission;
          const resourceRef = result.document.authorization?.resourceRef;
          if (!permission || !resourceRef) {
            return result;
          }
          if (!pluginPermissionCommon.isResourcePermission(permission)) {
            throw new Error(
              `Unexpected conditional decision returned for non-resource permission "${permission.name}"`
            );
          }
          return authorizer.load({ permission, resourceRef }).then(
            (decision) => decision.result === pluginPermissionCommon.AuthorizeResult.ALLOW ? result : void 0
          );
        })
      )
    );
  }
}

exports.AuthorizedSearchEngine = AuthorizedSearchEngine;
exports.decodePageCursor = decodePageCursor;
exports.encodePageCursor = encodePageCursor;
//# sourceMappingURL=AuthorizedSearchEngine.cjs.js.map
