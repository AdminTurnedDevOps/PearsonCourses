{"version":3,"file":"AuthorizedSearchEngine.cjs.js","sources":["../../src/service/AuthorizedSearchEngine.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { compact, zipObject } from 'lodash';\nimport qs from 'qs';\nimport DataLoader from 'dataloader';\nimport {\n  AuthorizePermissionRequest,\n  AuthorizeResult,\n  EvaluatePermissionRequest,\n  EvaluatePermissionResponse,\n  isResourcePermission,\n  QueryPermissionRequest,\n} from '@backstage/plugin-permission-common';\nimport {\n  DocumentTypeInfo,\n  IndexableResult,\n  IndexableResultSet,\n  SearchQuery,\n} from '@backstage/plugin-search-common';\nimport {\n  QueryRequestOptions,\n  QueryTranslator,\n  SearchEngine,\n} from '@backstage/plugin-search-backend-node';\nimport { Config } from '@backstage/config';\nimport { InputError } from '@backstage/errors';\nimport { Writable } from 'stream';\nimport { AuthService, PermissionsService } from '@backstage/backend-plugin-api';\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  const page = Number(Buffer.from(pageCursor, 'base64').toString('utf-8'));\n  if (isNaN(page)) {\n    throw new InputError('Invalid page cursor');\n  }\n\n  if (page < 0) {\n    throw new InputError('Invalid page cursor');\n  }\n\n  return {\n    page,\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n\nexport class AuthorizedSearchEngine implements SearchEngine {\n  private readonly queryLatencyBudgetMs: number;\n\n  constructor(\n    private readonly searchEngine: SearchEngine,\n    private readonly types: Record<string, DocumentTypeInfo>,\n    private readonly permissions: PermissionsService,\n    private readonly auth: AuthService,\n    config: Config,\n  ) {\n    this.queryLatencyBudgetMs =\n      config.getOptionalNumber('search.permissions.queryLatencyBudgetMs') ??\n      1000;\n  }\n\n  setTranslator(translator: QueryTranslator): void {\n    this.searchEngine.setTranslator(translator);\n  }\n\n  async getIndexer(type: string): Promise<Writable> {\n    return this.searchEngine.getIndexer(type);\n  }\n\n  async query(\n    query: SearchQuery,\n    options: QueryRequestOptions,\n  ): Promise<IndexableResultSet> {\n    const queryStartTime = Date.now();\n\n    const compatOptions =\n      'credentials' in options\n        ? options\n        : { credentials: await this.auth.getNoneCredentials() };\n\n    const conditionFetcher = new DataLoader(\n      (requests: readonly QueryPermissionRequest[]) =>\n        this.permissions.authorizeConditional(requests.slice(), compatOptions),\n      {\n        cacheKeyFn: ({ permission: { name } }) => name,\n      },\n    );\n\n    const authorizer = new DataLoader(\n      (requests: readonly AuthorizePermissionRequest[]) =>\n        this.permissions.authorize(requests.slice(), compatOptions),\n      {\n        // Serialize the permission name and resourceRef as\n        // a query string to avoid collisions from overlapping\n        // permission names and resourceRefs.\n        cacheKeyFn: ({ permission: { name }, resourceRef }) =>\n          qs.stringify({ name, resourceRef }),\n      },\n    );\n\n    const requestedTypes = query.types || Object.keys(this.types);\n\n    const typeDecisions = zipObject(\n      requestedTypes,\n      await Promise.all(\n        requestedTypes.map(type => {\n          const permission = this.types[type]?.visibilityPermission;\n\n          // No permission configured for this document type - always allow.\n          if (!permission) {\n            return { result: AuthorizeResult.ALLOW as const };\n          }\n\n          // Resource permission supplied, so we need to check for conditional decisions.\n          if (isResourcePermission(permission)) {\n            return conditionFetcher.load({ permission });\n          }\n\n          // Non-resource permission supplied - we can perform a standard authorization.\n          return authorizer.load({ permission });\n        }),\n      ),\n    );\n\n    const authorizedTypes = requestedTypes.filter(\n      type => typeDecisions[type]?.result !== AuthorizeResult.DENY,\n    );\n\n    const resultByResultFilteringRequired = authorizedTypes.some(\n      type => typeDecisions[type]?.result === AuthorizeResult.CONDITIONAL,\n    );\n\n    // When there are no CONDITIONAL decisions for any of the requested\n    // result types, we can skip filtering result by result by simply\n    // skipping the types the user is not permitted to see, which will\n    // be much more efficient.\n    //\n    // Since it's not currently possible to configure the page size used\n    // by search engines, this detail means that a single user might see\n    // a different page size depending on whether their search required\n    // result-by-result filtering or not. We can fix this minor\n    // inconsistency by introducing a configurable page size.\n    //\n    // cf. https://github.com/backstage/backstage/issues/9162\n    if (!resultByResultFilteringRequired) {\n      return this.searchEngine.query(\n        { ...query, types: authorizedTypes },\n        compatOptions,\n      );\n    }\n\n    const pageSize = query.pageLimit || 25;\n    const { page } = decodePageCursor(query.pageCursor);\n    const targetResults = (page + 1) * pageSize;\n\n    let filteredResults: IndexableResult[] = [];\n    let nextPageCursor: string | undefined;\n    let latencyBudgetExhausted = false;\n\n    do {\n      const nextPage = await this.searchEngine.query(\n        { ...query, types: authorizedTypes, pageCursor: nextPageCursor },\n        compatOptions,\n      );\n\n      filteredResults = filteredResults.concat(\n        await this.filterResults(nextPage.results, typeDecisions, authorizer),\n      );\n\n      nextPageCursor = nextPage.nextPageCursor;\n      latencyBudgetExhausted =\n        Date.now() - queryStartTime > this.queryLatencyBudgetMs;\n    } while (\n      nextPageCursor &&\n      filteredResults.length < targetResults &&\n      !latencyBudgetExhausted\n    );\n\n    return {\n      results: filteredResults\n        .slice(page * pageSize, (page + 1) * pageSize)\n        .map((result, index) => {\n          // Overwrite any/all rank entries to avoid leaking knowledge of filtered results.\n          return {\n            ...result,\n            rank: page * pageSize + index + 1,\n          };\n        }),\n      previousPageCursor:\n        page === 0 ? undefined : encodePageCursor({ page: page - 1 }),\n      nextPageCursor:\n        !latencyBudgetExhausted &&\n        (nextPageCursor || filteredResults.length > targetResults)\n          ? encodePageCursor({ page: page + 1 })\n          : undefined,\n      numberOfResults: undefined,\n    };\n  }\n\n  private async filterResults(\n    results: IndexableResult[],\n    typeDecisions: Record<string, EvaluatePermissionResponse>,\n    authorizer: DataLoader<\n      EvaluatePermissionRequest,\n      EvaluatePermissionResponse\n    >,\n  ) {\n    return compact(\n      await Promise.all(\n        results.map(result => {\n          if (typeDecisions[result.type]?.result === AuthorizeResult.ALLOW) {\n            return result;\n          }\n\n          const permission = this.types[result.type]?.visibilityPermission;\n          const resourceRef = result.document.authorization?.resourceRef;\n\n          if (!permission || !resourceRef) {\n            return result;\n          }\n\n          // We only reach this point in the code for types where the initial\n          // authorization returned CONDITIONAL -- ALLOWs return early\n          // immediately above, and types where the decision was DENY get\n          // filtered out entirely when querying.\n          //\n          // This means the call to isResourcePermission here is mostly about\n          // narrowing the type of permission - the only way to get here with a\n          // non-resource permission is if the PermissionPolicy returns a\n          // CONDITIONAL decision for a non-resource permission, which can't\n          // happen - it would throw an error during validation in the\n          // permission-backend.\n          if (!isResourcePermission(permission)) {\n            throw new Error(\n              `Unexpected conditional decision returned for non-resource permission \"${permission.name}\"`,\n            );\n          }\n\n          return authorizer\n            .load({ permission, resourceRef })\n            .then(decision =>\n              decision.result === AuthorizeResult.ALLOW ? result : undefined,\n            );\n        }),\n      ),\n    );\n  }\n}\n"],"names":["InputError","DataLoader","qs","zipObject","AuthorizeResult","isResourcePermission","compact"],"mappings":"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"}