'use strict';

var zod = require('zod');
var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var AuthorizedSearchEngine = require('./AuthorizedSearchEngine.cjs.js');
var router = require('../schema/openapi/generated/router.cjs.js');
var discovery = require('@backstage/backend-defaults/discovery');

const jsonObjectSchema = zod.z.lazy(() => {
  const jsonValueSchema = zod.z.lazy(
    () => zod.z.union([
      zod.z.string(),
      zod.z.number(),
      zod.z.boolean(),
      zod.z.null(),
      zod.z.array(jsonValueSchema),
      jsonObjectSchema
    ])
  );
  return zod.z.record(jsonValueSchema);
});
const defaultMaxPageLimit = 100;
const defaultMaxTermLength = 100;
const allowedLocationProtocols = ["http:", "https:"];
async function createRouter(options) {
  const router$1 = await router.createOpenApiRouter();
  const {
    engine: inputEngine,
    types,
    permissions,
    config,
    logger,
    discovery: discovery$1 = discovery.HostDiscovery.fromConfig(config)
  } = options;
  const { auth, httpAuth } = backendCommon.createLegacyAuthAdapters({
    ...options,
    discovery: discovery$1
  });
  const maxPageLimit = config.getOptionalNumber("search.maxPageLimit") ?? defaultMaxPageLimit;
  const maxTermLength = config.getOptionalNumber("search.maxTermLength") ?? defaultMaxTermLength;
  const requestSchema = zod.z.object({
    term: zod.z.string().refine(
      (term) => term.length <= maxTermLength,
      (term) => ({
        message: `The term length "${term.length}" is greater than "${maxTermLength}"`
      })
    ).default(""),
    filters: jsonObjectSchema.optional(),
    types: zod.z.array(zod.z.string().refine((type) => Object.keys(types).includes(type))).optional(),
    pageCursor: zod.z.string().optional(),
    pageLimit: zod.z.number().refine(
      (pageLimit) => pageLimit <= maxPageLimit,
      (pageLimit) => ({
        message: `The page limit "${pageLimit}" is greater than "${maxPageLimit}"`
      })
    ).optional()
  });
  let permissionEvaluator;
  if ("authorizeConditional" in permissions) {
    permissionEvaluator = permissions;
  } else {
    logger.warn(
      "PermissionAuthorizer is deprecated. Please use an instance of PermissionEvaluator instead of PermissionAuthorizer in PluginEnvironment#permissions"
    );
    permissionEvaluator = pluginPermissionCommon.toPermissionEvaluator(permissions);
  }
  const engine = config.getOptionalBoolean("permission.enabled") ? new AuthorizedSearchEngine.AuthorizedSearchEngine(
    inputEngine,
    types,
    permissionEvaluator,
    auth,
    config
  ) : inputEngine;
  const filterResultSet = ({ results, ...resultSet }) => ({
    ...resultSet,
    results: results.filter((result) => {
      const protocol = new URL(result.document.location, "https://example.com").protocol;
      const isAllowed = allowedLocationProtocols.includes(protocol);
      if (!isAllowed) {
        logger.info(
          `Rejected search result for "${result.document.title}" as location protocol "${protocol}" is unsafe`
        );
      }
      return isAllowed;
    })
  });
  const toSearchResults = (resultSet) => ({
    ...resultSet,
    results: resultSet.results.map((result) => ({
      ...result,
      document: {
        ...result.document,
        authorization: void 0
      }
    }))
  });
  router$1.get("/query", async (req, res) => {
    const parseResult = requestSchema.passthrough().safeParse(req.query);
    if (!parseResult.success) {
      throw new errors.InputError(`Invalid query string: ${parseResult.error}`);
    }
    const query = parseResult.data;
    logger.info(
      `Search request received: term="${query.term}", filters=${JSON.stringify(
        query.filters
      )}, types=${query.types ? query.types.join(",") : ""}, pageCursor=${query.pageCursor ?? ""}`
    );
    try {
      const credentials = await httpAuth.credentials(req);
      const { token } = await auth.getPluginRequestToken({
        onBehalfOf: credentials,
        targetPluginId: "search"
      });
      const resultSet = await engine?.query(query, {
        token,
        credentials
      });
      res.json(filterResultSet(toSearchResults(resultSet)));
    } catch (error) {
      if (error.name === "MissingIndexError") {
        throw error;
      }
      throw new Error(
        `There was a problem performing the search query: ${error.message}`
      );
    }
  });
  return router$1;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.cjs.js.map
