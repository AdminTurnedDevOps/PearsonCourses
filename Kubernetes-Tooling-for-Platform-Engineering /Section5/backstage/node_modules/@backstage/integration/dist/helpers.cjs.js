'use strict';

var parseGitUrl = require('git-url-parse');
var lodash = require('lodash');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);

function isValidHost(host) {
  const check = new URL("http://example.com");
  check.host = host;
  return check.host === host;
}
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}
function basicIntegrations(integrations, getHost) {
  return {
    list() {
      return integrations;
    },
    byUrl(url) {
      try {
        const parsed = typeof url === "string" ? new URL(url) : url;
        return integrations.find((i) => getHost(i) === parsed.host);
      } catch {
        return void 0;
      }
    },
    byHost(host) {
      return integrations.find((i) => getHost(i) === host);
    }
  };
}
function defaultScmResolveUrl(options) {
  const { url, base, lineNumber } = options;
  try {
    new URL(url);
    return url;
  } catch {
  }
  let updated;
  if (url.startsWith("/")) {
    const { href, filepath } = parseGitUrl__default.default(base);
    updated = new URL(href);
    const repoRootPath = lodash.trimEnd(
      updated.pathname.substring(0, updated.pathname.length - filepath.length),
      "/"
    );
    updated.pathname = `${repoRootPath}${url}`;
  } else {
    updated = new URL(url, base);
  }
  updated.search = new URL(base).search;
  if (lineNumber) {
    updated.hash = `L${lineNumber}`;
  }
  return updated.toString();
}

exports.basicIntegrations = basicIntegrations;
exports.defaultScmResolveUrl = defaultScmResolveUrl;
exports.isValidHost = isValidHost;
exports.isValidUrl = isValidUrl;
//# sourceMappingURL=helpers.cjs.js.map
