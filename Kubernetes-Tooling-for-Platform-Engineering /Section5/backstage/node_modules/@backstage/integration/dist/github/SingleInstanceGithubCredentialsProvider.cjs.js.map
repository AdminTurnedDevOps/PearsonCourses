{"version":3,"file":"SingleInstanceGithubCredentialsProvider.cjs.js","sources":["../../src/github/SingleInstanceGithubCredentialsProvider.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport parseGitUrl from 'git-url-parse';\nimport { GithubAppConfig, GithubIntegrationConfig } from './config';\nimport { createAppAuth } from '@octokit/auth-app';\nimport { Octokit, RestEndpointMethodTypes } from '@octokit/rest';\nimport { DateTime } from 'luxon';\nimport {\n  GithubCredentials,\n  GithubCredentialsProvider,\n  GithubCredentialType,\n} from './types';\n\ntype InstallationData = {\n  installationId: number;\n  suspended: boolean;\n};\n\ntype InstallationTokenData = {\n  token: string;\n  expiresAt: DateTime;\n  repositories?: String[];\n};\n\nclass Cache {\n  private readonly tokenCache = new Map<string, InstallationTokenData>();\n\n  async getOrCreateToken(\n    owner: string,\n    repo: string | undefined,\n    supplier: () => Promise<InstallationTokenData>,\n  ): Promise<{ accessToken: string }> {\n    let existingInstallationData = this.tokenCache.get(owner);\n\n    if (\n      !existingInstallationData ||\n      this.isExpired(existingInstallationData.expiresAt)\n    ) {\n      existingInstallationData = await supplier();\n      // Allow 10 minutes grace to account for clock skew\n      existingInstallationData.expiresAt =\n        existingInstallationData.expiresAt.minus({ minutes: 10 });\n      this.tokenCache.set(owner, existingInstallationData);\n    }\n\n    if (!this.appliesToRepo(existingInstallationData, repo)) {\n      throw new Error(\n        `The Backstage GitHub application used in the ${owner} organization does not have access to a repository with the name ${repo}`,\n      );\n    }\n\n    return { accessToken: existingInstallationData.token };\n  }\n\n  private isExpired = (date: DateTime) => DateTime.local() > date;\n\n  private appliesToRepo(tokenData: InstallationTokenData, repo?: string) {\n    // If no specific repo has been requested the token is applicable\n    if (repo === undefined) {\n      return true;\n    }\n    // If the token is restricted to repositories, the token only applies if the repo is in the allow list\n    if (tokenData.repositories !== undefined) {\n      return tokenData.repositories.includes(repo);\n    }\n    // Otherwise the token is applicable\n    return true;\n  }\n}\n\n/**\n * This accept header is required when calling App APIs in GitHub Enterprise.\n * It has no effect on calls to github.com and can probably be removed entirely\n * once GitHub Apps is out of preview.\n */\nconst HEADERS = {\n  Accept: 'application/vnd.github.machine-man-preview+json',\n};\n\n/**\n * GithubAppManager issues and caches tokens for a specific GitHub App.\n */\nclass GithubAppManager {\n  private readonly appClient: Octokit;\n  private readonly baseUrl?: string;\n  private readonly baseAuthConfig: { appId: number; privateKey: string };\n  private readonly cache = new Cache();\n  private readonly allowedInstallationOwners: string[] | undefined; // undefined allows all installations\n\n  constructor(config: GithubAppConfig, baseUrl?: string) {\n    this.allowedInstallationOwners = config.allowedInstallationOwners;\n    this.baseUrl = baseUrl;\n    this.baseAuthConfig = {\n      appId: config.appId,\n      privateKey: config.privateKey.replace(/\\\\n/gm, '\\n'),\n    };\n    this.appClient = new Octokit({\n      baseUrl,\n      headers: HEADERS,\n      authStrategy: createAppAuth,\n      auth: this.baseAuthConfig,\n    });\n  }\n\n  async getInstallationCredentials(\n    owner: string,\n    repo?: string,\n  ): Promise<{ accessToken: string | undefined }> {\n    if (this.allowedInstallationOwners) {\n      if (!this.allowedInstallationOwners?.includes(owner)) {\n        return { accessToken: undefined }; // An empty token allows anonymous access to public repos\n      }\n    }\n\n    // Go and grab an access token for the app scoped to a repository if provided, if not use the organisation installation.\n    return this.cache.getOrCreateToken(owner, repo, async () => {\n      const { installationId, suspended } = await this.getInstallationData(\n        owner,\n      );\n      if (suspended) {\n        throw new Error(`The GitHub application for ${owner} is suspended`);\n      }\n\n      const result = await this.appClient.apps.createInstallationAccessToken({\n        installation_id: installationId,\n        headers: HEADERS,\n      });\n\n      let repositoryNames;\n\n      if (result.data.repository_selection === 'selected') {\n        const installationClient = new Octokit({\n          baseUrl: this.baseUrl,\n          auth: result.data.token,\n        });\n        const repos = await installationClient.paginate(\n          installationClient.apps.listReposAccessibleToInstallation,\n        );\n        // The return type of the paginate method is incorrect.\n        const repositories: RestEndpointMethodTypes['apps']['listReposAccessibleToInstallation']['response']['data']['repositories'] =\n          repos.repositories ?? repos;\n\n        repositoryNames = repositories.map(repository => repository.name);\n      }\n      return {\n        token: result.data.token,\n        expiresAt: DateTime.fromISO(result.data.expires_at),\n        repositories: repositoryNames,\n      };\n    });\n  }\n\n  getInstallations(): Promise<\n    RestEndpointMethodTypes['apps']['listInstallations']['response']['data']\n  > {\n    return this.appClient.paginate(this.appClient.apps.listInstallations);\n  }\n\n  private async getInstallationData(owner: string): Promise<InstallationData> {\n    const allInstallations = await this.getInstallations();\n    const installation = allInstallations.find(\n      inst =>\n        inst.account &&\n        'login' in inst.account &&\n        inst.account.login?.toLocaleLowerCase('en-US') ===\n          owner.toLocaleLowerCase('en-US'),\n    );\n    if (installation) {\n      return {\n        installationId: installation.id,\n        suspended: Boolean(installation.suspended_by),\n      };\n    }\n    const notFoundError = new Error(\n      `No app installation found for ${owner} in ${this.baseAuthConfig.appId}`,\n    );\n    notFoundError.name = 'NotFoundError';\n    throw notFoundError;\n  }\n}\n\n/**\n * Corresponds to a Github installation which internally could hold several GitHub Apps.\n *\n * @public\n */\nexport class GithubAppCredentialsMux {\n  private readonly apps: GithubAppManager[];\n\n  constructor(config: GithubIntegrationConfig) {\n    this.apps =\n      config.apps?.map(ac => new GithubAppManager(ac, config.apiBaseUrl)) ?? [];\n  }\n\n  async getAllInstallations(): Promise<\n    RestEndpointMethodTypes['apps']['listInstallations']['response']['data']\n  > {\n    if (!this.apps.length) {\n      return [];\n    }\n\n    const installs = await Promise.all(\n      this.apps.map(app => app.getInstallations()),\n    );\n\n    return installs.flat();\n  }\n\n  async getAppToken(owner: string, repo?: string): Promise<string | undefined> {\n    if (this.apps.length === 0) {\n      return undefined;\n    }\n\n    const results = await Promise.all(\n      this.apps.map(app =>\n        app.getInstallationCredentials(owner, repo).then(\n          credentials => ({ credentials, error: undefined }),\n          error => ({ credentials: undefined, error }),\n        ),\n      ),\n    );\n\n    const result = results.find(\n      resultItem => resultItem.credentials?.accessToken,\n    );\n    if (result) {\n      return result.credentials!.accessToken;\n    }\n\n    const errors = results.map(r => r.error);\n    const notNotFoundError = errors.find(err => err?.name !== 'NotFoundError');\n    if (notNotFoundError) {\n      throw notNotFoundError;\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Handles the creation and caching of credentials for GitHub integrations.\n *\n * @public\n * @remarks\n *\n * TODO: Possibly move this to a backend only package so that it's not used in the frontend by mistake\n */\nexport class SingleInstanceGithubCredentialsProvider\n  implements GithubCredentialsProvider\n{\n  static create: (\n    config: GithubIntegrationConfig,\n  ) => GithubCredentialsProvider = config => {\n    return new SingleInstanceGithubCredentialsProvider(\n      new GithubAppCredentialsMux(config),\n      config.token,\n    );\n  };\n\n  private constructor(\n    private readonly githubAppCredentialsMux: GithubAppCredentialsMux,\n    private readonly token?: string,\n  ) {}\n\n  /**\n   * Returns {@link GithubCredentials} for a given URL.\n   *\n   * @remarks\n   *\n   * Consecutive calls to this method with the same URL will return cached\n   * credentials.\n   *\n   * The shortest lifetime for a token returned is 10 minutes.\n   *\n   * @example\n   * ```ts\n   * const { token, headers } = await getCredentials({\n   *   url: 'github.com/backstage/foobar'\n   * })\n   * ```\n   *\n   * @param opts - The organization or repository URL\n   * @returns A promise of {@link GithubCredentials}.\n   */\n  async getCredentials(opts: { url: string }): Promise<GithubCredentials> {\n    const parsed = parseGitUrl(opts.url);\n\n    const owner = parsed.owner || parsed.name;\n    const repo = parsed.owner ? parsed.name : undefined;\n\n    let type: GithubCredentialType = 'app';\n    let token = await this.githubAppCredentialsMux.getAppToken(owner, repo);\n    if (!token) {\n      type = 'token';\n      token = this.token;\n    }\n\n    return {\n      headers: token ? { Authorization: `Bearer ${token}` } : undefined,\n      token,\n      type,\n    };\n  }\n}\n"],"names":["DateTime","Octokit","createAppAuth","parseGitUrl"],"mappings":"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"}