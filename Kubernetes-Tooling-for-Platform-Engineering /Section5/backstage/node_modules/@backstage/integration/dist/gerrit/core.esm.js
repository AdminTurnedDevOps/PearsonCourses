import { trimStart, takeWhile, join, trimEnd } from 'lodash';

const GERRIT_BODY_PREFIX = ")]}'";
function parseGerritGitilesUrl(config, url) {
  const baseUrlParse = new URL(config.gitilesBaseUrl);
  const urlParse = new URL(url);
  const urlPath = urlParse.pathname.substring(urlParse.pathname.startsWith("/a/") ? 2 : 0).replace(baseUrlParse.pathname, "");
  const parts = urlPath.split("/").filter((p) => !!p);
  const projectEndIndex = parts.indexOf("+");
  if (projectEndIndex <= 0) {
    throw new Error(`Unable to parse project from url: ${url}`);
  }
  const project = trimStart(parts.slice(0, projectEndIndex).join("/"), "/");
  const branchIndex = parts.indexOf("heads");
  if (branchIndex <= 0) {
    throw new Error(`Unable to parse branch from url: ${url}`);
  }
  const branch = parts[branchIndex + 1];
  const filePath = parts.slice(branchIndex + 2).join("/");
  return {
    branch,
    filePath: filePath === "" ? "/" : filePath,
    project
  };
}
function parseGitilesUrlRef(config, url) {
  const baseUrlParse = new URL(config.gitilesBaseUrl);
  const urlParse = new URL(url);
  const urlPath = trimStart(
    urlParse.pathname.substring(urlParse.pathname.startsWith("/a/") ? 2 : 0).replace(baseUrlParse.pathname, ""),
    "/"
  );
  const parts = urlPath.split("/").filter((p) => !!p);
  const projectParts = takeWhile(parts, (p) => p !== "+");
  if (projectParts.length === 0) {
    throw new Error(`Unable to parse gitiles url: ${url}`);
  }
  const rest = parts.slice(projectParts.length + 1);
  const project = join(projectParts, "/");
  if (rest.length > 0 && rest[0] === "HEAD") {
    const ref = rest.shift();
    const path = join(rest, "/");
    return {
      project,
      ref,
      refType: "head",
      path: path || "/",
      basePath: trimEnd(url.replace(path, ""), "/")
    };
  }
  if (rest.length > 0 && rest[0].length === 40) {
    const ref = rest.shift();
    const path = join(rest, "/");
    return {
      project,
      ref,
      refType: "sha",
      path: path || "/",
      basePath: trimEnd(url.replace(path, ""), "/")
    };
  }
  const remainingPath = join(rest, "/");
  const refsRegexp = /^refs\/(?<refsReference>heads|tags)\/(?<ref>.*?)(\/|$)/;
  const result = refsRegexp.exec(remainingPath);
  if (result) {
    const matchString = result[0];
    let refType;
    const { refsReference, ref } = result.groups || {};
    const path = remainingPath.replace(matchString, "");
    switch (refsReference) {
      case "heads":
        refType = "branch";
        break;
      case "tags":
        refType = "tag";
        break;
      default:
        throw new Error(`Unable to parse gitiles url: ${url}`);
    }
    return {
      project,
      ref,
      refType,
      path: path || "/",
      basePath: trimEnd(url.replace(path, ""), "/")
    };
  }
  throw new Error(`Unable to parse gitiles : ${url}`);
}
function buildGerritGitilesArchiveUrl(config, project, branch, filePath) {
  const archiveName = filePath === "/" || filePath === "" ? ".tar.gz" : `/${filePath}.tar.gz`;
  return `${getGitilesAuthenticationUrl(
    config
  )}/${project}/+archive/refs/heads/${branch}${archiveName}`;
}
function getAuthenticationPrefix(config) {
  return config.password ? "/a/" : "/";
}
function getGitilesAuthenticationUrl(config) {
  if (!config.baseUrl || !config.gitilesBaseUrl) {
    throw new Error(
      "Unexpected Gerrit config values. baseUrl or gitilesBaseUrl not set."
    );
  }
  if (config.gitilesBaseUrl.startsWith(config.baseUrl)) {
    return config.gitilesBaseUrl.replace(
      config.baseUrl.concat("/"),
      config.baseUrl.concat(getAuthenticationPrefix(config))
    );
  }
  if (config.password) {
    throw new Error(
      "Since the baseUrl (Gerrit) is not part of the gitilesBaseUrl, an authentication URL could not be constructed."
    );
  }
  return config.gitilesBaseUrl;
}
function getGerritBranchApiUrl(config, url) {
  const { branch, project } = parseGerritGitilesUrl(config, url);
  return `${config.baseUrl}${getAuthenticationPrefix(
    config
  )}projects/${encodeURIComponent(project)}/branches/${branch}`;
}
function getGerritCloneRepoUrl(config, url) {
  const { project } = parseGerritGitilesUrl(config, url);
  return `${config.cloneUrl}${getAuthenticationPrefix(config)}${project}`;
}
function getGerritFileContentsApiUrl(config, url) {
  const { branch, filePath, project } = parseGerritGitilesUrl(config, url);
  return `${config.baseUrl}${getAuthenticationPrefix(
    config
  )}projects/${encodeURIComponent(
    project
  )}/branches/${branch}/files/${encodeURIComponent(filePath)}/content`;
}
function getGerritProjectsApiUrl(config) {
  return `${config.baseUrl}${getAuthenticationPrefix(config)}projects/`;
}
function getGerritRequestOptions(config) {
  const headers = {};
  if (!config.password) {
    return headers;
  }
  const buffer = Buffer.from(`${config.username}:${config.password}`, "utf8");
  headers.Authorization = `Basic ${buffer.toString("base64")}`;
  return {
    headers
  };
}
async function parseGerritJsonResponse(response) {
  const responseBody = await response.text();
  if (responseBody.startsWith(GERRIT_BODY_PREFIX)) {
    try {
      return JSON.parse(responseBody.slice(GERRIT_BODY_PREFIX.length));
    } catch (ex) {
      throw new Error(
        `Invalid response from Gerrit: ${responseBody.slice(0, 10)} - ${ex}`
      );
    }
  }
  throw new Error(
    `Gerrit JSON body prefix missing. Found: ${responseBody.slice(0, 10)}`
  );
}

export { buildGerritGitilesArchiveUrl, getAuthenticationPrefix, getGerritBranchApiUrl, getGerritCloneRepoUrl, getGerritFileContentsApiUrl, getGerritProjectsApiUrl, getGerritRequestOptions, getGitilesAuthenticationUrl, parseGerritGitilesUrl, parseGerritJsonResponse, parseGitilesUrlRef };
//# sourceMappingURL=core.esm.js.map
