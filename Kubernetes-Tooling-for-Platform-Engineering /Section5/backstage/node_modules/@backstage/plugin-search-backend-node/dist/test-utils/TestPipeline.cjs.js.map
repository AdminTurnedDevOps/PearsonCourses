{"version":3,"file":"TestPipeline.cjs.js","sources":["../../src/test-utils/TestPipeline.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { pipeline, Readable, Transform, Writable } from 'stream';\n\n/**\n * Object resolved after a test pipeline is executed.\n * @public\n */\nexport type TestPipelineResult = {\n  /**\n   * If an error was emitted by the pipeline, it will be set here.\n   */\n  error: unknown;\n\n  /**\n   * A list of documents collected at the end of the pipeline. If the subject\n   * under test is an indexer, this will be an empty array (because your\n   * indexer should have received the documents instead).\n   */\n  documents: IndexableDocument[];\n};\n\n/**\n * Test utility for Backstage Search collators, decorators, and indexers.\n *\n * @example\n * An example test checking that a collator provides expected documents.\n * ```\n * it('provides expected documents', async () => {\n *   const testSubject = await yourCollatorFactory.getCollator();\n *   const pipeline = TestPipeline.fromCollator(testSubject);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(2);\n * })\n * ```\n *\n * @example\n * An example test checking that a decorator behaves as expected.\n * ```\n * it('filters private documents', async () => {\n *   const testSubject = await yourDecoratorFactory.getDecorator();\n *   const pipeline = TestPipeline\n *     .fromDecorator(testSubject)\n *     .withDocuments([{ title: 'Private', location: '/private', text: '' }]);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(0);\n * })\n * ```\n *\n * @public\n */\nexport class TestPipeline {\n  private collator?: Readable;\n  private decorator?: Transform;\n  private indexer?: Writable;\n\n  private constructor({\n    collator,\n    decorator,\n    indexer,\n  }: {\n    collator?: Readable;\n    decorator?: Transform;\n    indexer?: Writable;\n  }) {\n    this.collator = collator;\n    this.decorator = decorator;\n    this.indexer = indexer;\n  }\n\n  /**\n   * Provide the collator, decorator, or indexer to be tested.\n   *\n   * @deprecated Use `fromCollator`, `fromDecorator` or `fromIndexer` static\n   *   methods to create a test pipeline instead.\n   */\n  static withSubject(subject: Readable | Transform | Writable) {\n    if (subject instanceof Transform) {\n      return new TestPipeline({ decorator: subject });\n    }\n\n    if (subject instanceof Writable) {\n      return new TestPipeline({ indexer: subject });\n    }\n\n    if (subject.readable || subject instanceof Readable) {\n      return new TestPipeline({ collator: subject });\n    }\n\n    throw new Error(\n      'Unknown test subject: are you passing a readable, writable, or transform stream?',\n    );\n  }\n\n  /**\n   * Create a test pipeline given a collator you want to test.\n   */\n  static fromCollator(collator: Readable) {\n    return new TestPipeline({ collator });\n  }\n\n  /**\n   * Add a collator to the test pipeline.\n   */\n  withCollator(collator: Readable): this {\n    this.collator = collator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given a decorator you want to test.\n   */\n  static fromDecorator(decorator: Transform) {\n    return new TestPipeline({ decorator });\n  }\n\n  /**\n   * Add a decorator to the test pipeline.\n   */\n  withDecorator(decorator: Transform): this {\n    this.decorator = decorator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given an indexer you want to test.\n   */\n  static fromIndexer(indexer: Writable) {\n    return new TestPipeline({ indexer });\n  }\n\n  /**\n   * Add an indexer to the test pipeline.\n   */\n  withIndexer(indexer: Writable): this {\n    this.indexer = indexer;\n    return this;\n  }\n\n  /**\n   * Provide documents for testing decorators and indexers.\n   */\n  withDocuments(documents: IndexableDocument[]): TestPipeline {\n    if (this.collator) {\n      throw new Error('Cannot provide documents when testing a collator.');\n    }\n\n    // Set a naive readable stream that just pushes all given documents.\n    this.collator = new Readable({ objectMode: true });\n    this.collator._read = () => {};\n    process.nextTick(() => {\n      documents.forEach(document => {\n        this.collator!.push(document);\n      });\n      this.collator!.push(null);\n    });\n\n    return this;\n  }\n\n  /**\n   * Execute the test pipeline so that you can make assertions about the result\n   * or behavior of the given test subject.\n   */\n  async execute(): Promise<TestPipelineResult> {\n    const documents: IndexableDocument[] = [];\n    if (!this.collator) {\n      throw new Error(\n        'Cannot execute pipeline without a collator or documents',\n      );\n    }\n\n    // If we are here and there is no indexer, we are testing a collator or a\n    // decorator. Set up a naive writable that captures documents in memory.\n    if (!this.indexer) {\n      this.indexer = new Writable({ objectMode: true });\n      this.indexer._write = (document: IndexableDocument, _, done) => {\n        documents.push(document);\n        done();\n      };\n    }\n\n    return new Promise<TestPipelineResult>(done => {\n      const pipes: (Readable | Transform | Writable)[] = [this.collator!];\n      if (this.decorator) {\n        pipes.push(this.decorator);\n      }\n      pipes.push(this.indexer!);\n\n      pipeline(pipes, (error: NodeJS.ErrnoException | null) => {\n        done({\n          error,\n          documents,\n        });\n      });\n    });\n  }\n}\n"],"names":["Transform","Writable","Readable","pipeline"],"mappings":"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"}