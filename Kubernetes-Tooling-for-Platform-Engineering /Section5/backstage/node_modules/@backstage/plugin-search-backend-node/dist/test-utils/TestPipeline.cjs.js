'use strict';

var stream = require('stream');

class TestPipeline {
  collator;
  decorator;
  indexer;
  constructor({
    collator,
    decorator,
    indexer
  }) {
    this.collator = collator;
    this.decorator = decorator;
    this.indexer = indexer;
  }
  /**
   * Provide the collator, decorator, or indexer to be tested.
   *
   * @deprecated Use `fromCollator`, `fromDecorator` or `fromIndexer` static
   *   methods to create a test pipeline instead.
   */
  static withSubject(subject) {
    if (subject instanceof stream.Transform) {
      return new TestPipeline({ decorator: subject });
    }
    if (subject instanceof stream.Writable) {
      return new TestPipeline({ indexer: subject });
    }
    if (subject.readable || subject instanceof stream.Readable) {
      return new TestPipeline({ collator: subject });
    }
    throw new Error(
      "Unknown test subject: are you passing a readable, writable, or transform stream?"
    );
  }
  /**
   * Create a test pipeline given a collator you want to test.
   */
  static fromCollator(collator) {
    return new TestPipeline({ collator });
  }
  /**
   * Add a collator to the test pipeline.
   */
  withCollator(collator) {
    this.collator = collator;
    return this;
  }
  /**
   * Create a test pipeline given a decorator you want to test.
   */
  static fromDecorator(decorator) {
    return new TestPipeline({ decorator });
  }
  /**
   * Add a decorator to the test pipeline.
   */
  withDecorator(decorator) {
    this.decorator = decorator;
    return this;
  }
  /**
   * Create a test pipeline given an indexer you want to test.
   */
  static fromIndexer(indexer) {
    return new TestPipeline({ indexer });
  }
  /**
   * Add an indexer to the test pipeline.
   */
  withIndexer(indexer) {
    this.indexer = indexer;
    return this;
  }
  /**
   * Provide documents for testing decorators and indexers.
   */
  withDocuments(documents) {
    if (this.collator) {
      throw new Error("Cannot provide documents when testing a collator.");
    }
    this.collator = new stream.Readable({ objectMode: true });
    this.collator._read = () => {
    };
    process.nextTick(() => {
      documents.forEach((document) => {
        this.collator.push(document);
      });
      this.collator.push(null);
    });
    return this;
  }
  /**
   * Execute the test pipeline so that you can make assertions about the result
   * or behavior of the given test subject.
   */
  async execute() {
    const documents = [];
    if (!this.collator) {
      throw new Error(
        "Cannot execute pipeline without a collator or documents"
      );
    }
    if (!this.indexer) {
      this.indexer = new stream.Writable({ objectMode: true });
      this.indexer._write = (document, _, done) => {
        documents.push(document);
        done();
      };
    }
    return new Promise((done) => {
      const pipes = [this.collator];
      if (this.decorator) {
        pipes.push(this.decorator);
      }
      pipes.push(this.indexer);
      stream.pipeline(pipes, (error) => {
        done({
          error,
          documents
        });
      });
    });
  }
}

exports.TestPipeline = TestPipeline;
//# sourceMappingURL=TestPipeline.cjs.js.map
