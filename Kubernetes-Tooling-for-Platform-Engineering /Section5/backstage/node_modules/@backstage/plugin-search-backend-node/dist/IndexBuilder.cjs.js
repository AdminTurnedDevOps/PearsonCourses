'use strict';

var stream = require('stream');
var Scheduler = require('./Scheduler.cjs.js');

class IndexBuilder {
  collators;
  decorators;
  documentTypes;
  searchEngine;
  logger;
  constructor(options) {
    this.collators = {};
    this.decorators = {};
    this.documentTypes = {};
    this.logger = options.logger;
    this.searchEngine = options.searchEngine;
  }
  /**
   * Responsible for returning the registered search engine.
   */
  getSearchEngine() {
    return this.searchEngine;
  }
  /**
   * Responsible for returning the registered document types.
   */
  getDocumentTypes() {
    return this.documentTypes;
  }
  /**
   * Makes the index builder aware of a collator that should be executed at the
   * given refresh interval.
   */
  addCollator(options) {
    const { factory, schedule } = options;
    this.logger.info(
      `Added ${factory.constructor.name} collator factory for type ${factory.type}`
    );
    this.collators[factory.type] = {
      factory,
      schedule
    };
    this.documentTypes[factory.type] = {
      visibilityPermission: factory.visibilityPermission
    };
  }
  /**
   * Makes the index builder aware of a decorator. If no types are provided on
   * the decorator, it will be applied to documents from all known collators,
   * otherwise it will only be applied to documents of the given types.
   */
  addDecorator(options) {
    const { factory } = options;
    const types = factory.types || ["*"];
    this.logger.info(
      `Added decorator ${factory.constructor.name} to types ${types.join(
        ", "
      )}`
    );
    types.forEach((type) => {
      if (this.decorators.hasOwnProperty(type)) {
        this.decorators[type].push(factory);
      } else {
        this.decorators[type] = [factory];
      }
    });
  }
  /**
   * Compiles collators and decorators into tasks, which are added to a
   * scheduler returned to the caller.
   */
  async build() {
    const scheduler = new Scheduler.Scheduler({
      logger: this.logger
    });
    Object.keys(this.collators).forEach((type) => {
      const taskLogger = this.logger.child({ documentType: type });
      scheduler.addToSchedule({
        id: `search_index_${type.replace("-", "_").toLocaleLowerCase("en-US")}`,
        scheduledRunner: this.collators[type].schedule,
        task: async () => {
          const collator = await this.collators[type].factory.getCollator();
          taskLogger.info(
            `Collating documents for ${type} via ${this.collators[type].factory.constructor.name}`
          );
          const decorators = await Promise.all(
            (this.decorators["*"] || []).concat(this.decorators[type] || []).map(async (factory) => {
              const decorator = await factory.getDecorator();
              taskLogger.info(
                `Attached decorator via ${factory.constructor.name} to ${type} index pipeline.`
              );
              return decorator;
            })
          );
          const indexer = await this.searchEngine.getIndexer(type);
          return new Promise((resolve, reject) => {
            stream.pipeline(
              [collator, ...decorators, indexer],
              (error) => {
                if (error) {
                  taskLogger.error(
                    `Collating documents for ${type} failed: ${error}`
                  );
                  reject(error);
                } else {
                  taskLogger.info(`Collating documents for ${type} succeeded`);
                  resolve();
                }
              }
            );
          });
        }
      });
    });
    return {
      scheduler
    };
  }
}

exports.IndexBuilder = IndexBuilder;
//# sourceMappingURL=IndexBuilder.cjs.js.map
