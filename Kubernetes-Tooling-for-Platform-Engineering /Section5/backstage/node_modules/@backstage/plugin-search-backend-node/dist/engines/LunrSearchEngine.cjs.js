'use strict';

var errors = require('../errors.cjs.js');
var lunr = require('lunr');
var uuid = require('uuid');
var LunrSearchEngineIndexer = require('./LunrSearchEngineIndexer.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lunr__default = /*#__PURE__*/_interopDefaultCompat(lunr);

class LunrSearchEngine {
  lunrIndices = {};
  docStore;
  logger;
  highlightPreTag;
  highlightPostTag;
  constructor(options) {
    this.logger = options.logger;
    this.docStore = {};
    const uuidTag = uuid.v4();
    this.highlightPreTag = `<${uuidTag}>`;
    this.highlightPostTag = `</${uuidTag}>`;
  }
  translator = ({
    term,
    filters,
    types,
    pageLimit
  }) => {
    const pageSize = pageLimit || 25;
    return {
      lunrQueryBuilder: (q) => {
        const termToken = lunr__default.default.tokenizer(term);
        q.term(termToken, {
          usePipeline: true,
          boost: 100
        });
        q.term(termToken, {
          usePipeline: false,
          boost: 10,
          wildcard: lunr__default.default.Query.wildcard.TRAILING
        });
        q.term(termToken, {
          usePipeline: false,
          editDistance: 2,
          boost: 1
        });
        if (filters) {
          Object.entries(filters).forEach(([field, fieldValue]) => {
            if (!q.allFields.includes(field)) {
              throw new Error(`unrecognised field ${field}`);
            }
            const value = Array.isArray(fieldValue) && fieldValue.length === 1 ? fieldValue[0] : fieldValue;
            if (["string", "number", "boolean"].includes(typeof value)) {
              q.term(
                lunr__default.default.tokenizer(value?.toString()).map(lunr__default.default.stopWordFilter).filter((element) => element !== void 0),
                {
                  presence: lunr__default.default.Query.presence.REQUIRED,
                  fields: [field]
                }
              );
            } else if (Array.isArray(value)) {
              this.logger.warn(
                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`
              );
              q.term(lunr__default.default.tokenizer(value), {
                presence: lunr__default.default.Query.presence.OPTIONAL,
                fields: [field]
              });
            } else {
              this.logger.warn(`Unknown filter type used on field ${field}`);
            }
          });
        }
      },
      documentTypes: types,
      pageSize
    };
  };
  setTranslator(translator) {
    this.translator = translator;
  }
  async getIndexer(type) {
    const indexer = new LunrSearchEngineIndexer.LunrSearchEngineIndexer();
    const indexerLogger = this.logger.child({ documentType: type });
    let errorThrown;
    indexer.on("error", (err) => {
      errorThrown = err;
    });
    indexer.on("close", () => {
      const newDocuments = indexer.getDocumentStore();
      const docStoreExists = this.lunrIndices[type] !== void 0;
      const documentsIndexed = Object.keys(newDocuments).length;
      if (!errorThrown && documentsIndexed > 0) {
        this.lunrIndices[type] = indexer.buildIndex();
        this.docStore = { ...this.docStore, ...newDocuments };
      } else {
        indexerLogger.warn(
          `Index for ${type} was not ${docStoreExists ? "replaced" : "created"}: ${errorThrown ? "an error was encountered" : "indexer received 0 documents"}`
        );
      }
    });
    return indexer;
  }
  async query(query) {
    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(
      query
    );
    const results = [];
    const indexKeys = Object.keys(this.lunrIndices).filter(
      (type) => !documentTypes || documentTypes.includes(type)
    );
    if (documentTypes?.length && !indexKeys.length) {
      throw new errors.MissingIndexError(
        `Missing index for ${documentTypes?.toString()}. This could be because the index hasn't been created yet or there was a problem during index creation.`
      );
    }
    indexKeys.forEach((type) => {
      try {
        results.push(
          ...this.lunrIndices[type].query(lunrQueryBuilder).map((result) => {
            return {
              result,
              type
            };
          })
        );
      } catch (err) {
        if (err instanceof Error && err.message.startsWith("unrecognised field")) {
          return;
        }
        throw err;
      }
    });
    results.sort((doc1, doc2) => {
      return doc2.result.score - doc1.result.score;
    });
    const { page } = decodePageCursor(query.pageCursor);
    const offset = page * pageSize;
    const hasPreviousPage = page > 0;
    const hasNextPage = results.length > offset + pageSize;
    const nextPageCursor = hasNextPage ? encodePageCursor({ page: page + 1 }) : void 0;
    const previousPageCursor = hasPreviousPage ? encodePageCursor({ page: page - 1 }) : void 0;
    const realResultSet = {
      results: results.slice(offset, offset + pageSize).map((d, index) => ({
        type: d.type,
        document: this.docStore[d.result.ref],
        rank: page * pageSize + index + 1,
        highlight: {
          preTag: this.highlightPreTag,
          postTag: this.highlightPostTag,
          fields: parseHighlightFields({
            preTag: this.highlightPreTag,
            postTag: this.highlightPostTag,
            doc: this.docStore[d.result.ref],
            positionMetadata: d.result.matchData.metadata
          })
        }
      })),
      numberOfResults: results.length,
      nextPageCursor,
      previousPageCursor
    };
    return realResultSet;
  }
}
function decodePageCursor(pageCursor) {
  if (!pageCursor) {
    return { page: 0 };
  }
  return {
    page: Number(Buffer.from(pageCursor, "base64").toString("utf-8"))
  };
}
function encodePageCursor({ page }) {
  return Buffer.from(`${page}`, "utf-8").toString("base64");
}
function parseHighlightFields({
  preTag,
  postTag,
  doc,
  positionMetadata
}) {
  const highlightFieldPositions = Object.values(positionMetadata).reduce(
    (fieldPositions, metadata) => {
      Object.keys(metadata).map((fieldKey) => {
        const validFieldMetadataPositions = metadata[fieldKey]?.position?.filter((position) => Array.isArray(position));
        if (validFieldMetadataPositions.length) {
          fieldPositions[fieldKey] = fieldPositions[fieldKey] ?? [];
          fieldPositions[fieldKey].push(...validFieldMetadataPositions);
        }
      });
      return fieldPositions;
    },
    {}
  );
  return Object.fromEntries(
    Object.entries(highlightFieldPositions).map(([field, positions]) => {
      positions.sort((a, b) => b[0] - a[0]);
      const highlightedField = positions.reduce((content, pos) => {
        return `${String(content).substring(0, pos[0])}${preTag}${String(content).substring(pos[0], pos[0] + pos[1])}${postTag}${String(content).substring(pos[0] + pos[1])}`;
      }, doc[field] ?? "");
      return [field, highlightedField];
    })
  );
}

exports.LunrSearchEngine = LunrSearchEngine;
exports.decodePageCursor = decodePageCursor;
exports.encodePageCursor = encodePageCursor;
exports.parseHighlightFields = parseHighlightFields;
//# sourceMappingURL=LunrSearchEngine.cjs.js.map
