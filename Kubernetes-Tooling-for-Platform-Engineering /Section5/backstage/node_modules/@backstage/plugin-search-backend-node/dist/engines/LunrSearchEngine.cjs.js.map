{"version":3,"file":"LunrSearchEngine.cjs.js","sources":["../../src/engines/LunrSearchEngine.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexableDocument,\n  IndexableResultSet,\n  SearchQuery,\n} from '@backstage/plugin-search-common';\nimport { QueryTranslator, SearchEngine } from '../types';\nimport { MissingIndexError } from '../errors';\nimport lunr from 'lunr';\nimport { v4 as uuid } from 'uuid';\nimport { LunrSearchEngineIndexer } from './LunrSearchEngineIndexer';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\n/**\n * Type of translated query for the Lunr Search Engine.\n * @public\n */\nexport type ConcreteLunrQuery = {\n  lunrQueryBuilder: lunr.Index.QueryBuilder;\n  documentTypes?: string[];\n  pageSize: number;\n};\n\ntype LunrResultEnvelope = {\n  result: lunr.Index.Result;\n  type: string;\n};\n\n/**\n * Translator responsible for translating search term and filters to a query that the Lunr Search Engine understands.\n * @public\n */\nexport type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;\n\n/**\n * Lunr specific search engine implementation.\n * @public\n */\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: LoggerService;\n  protected highlightPreTag: string;\n  protected highlightPostTag: string;\n\n  constructor(options: { logger: LoggerService }) {\n    this.logger = options.logger;\n    this.docStore = {};\n    const uuidTag = uuid();\n    this.highlightPreTag = `<${uuidTag}>`;\n    this.highlightPostTag = `</${uuidTag}>`;\n  }\n\n  protected translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n    pageLimit,\n  }: SearchQuery): ConcreteLunrQuery => {\n    const pageSize = pageLimit || 25;\n\n    return {\n      lunrQueryBuilder: q => {\n        const termToken = lunr.tokenizer(term);\n\n        // Support for typeahead search is based on https://github.com/olivernn/lunr.js/issues/256#issuecomment-295407852\n        // look for an exact match and apply a large positive boost\n        q.term(termToken, {\n          usePipeline: true,\n          boost: 100,\n        });\n        // look for terms that match the beginning of this term and apply a\n        // medium boost\n        q.term(termToken, {\n          usePipeline: false,\n          boost: 10,\n          wildcard: lunr.Query.wildcard.TRAILING,\n        });\n        // look for terms that match with an edit distance of 2 and apply a\n        // small boost\n        q.term(termToken, {\n          usePipeline: false,\n          editDistance: 2,\n          boost: 1,\n        });\n\n        if (filters) {\n          Object.entries(filters).forEach(([field, fieldValue]) => {\n            if (!q.allFields.includes(field)) {\n              // Throw for unknown field, as this will be a non match\n              throw new Error(`unrecognised field ${field}`);\n            }\n            // Arrays are poorly supported, but we can make it better for single-item arrays,\n            // which should be a common case\n            const value =\n              Array.isArray(fieldValue) && fieldValue.length === 1\n                ? fieldValue[0]\n                : fieldValue;\n\n            // Require that the given field has the given value\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n              q.term(\n                lunr\n                  .tokenizer(value?.toString())\n                  .map(lunr.stopWordFilter)\n                  .filter(element => element !== undefined),\n                {\n                  presence: lunr.Query.presence.REQUIRED,\n                  fields: [field],\n                },\n              );\n            } else if (Array.isArray(value)) {\n              // Illustrate how multi-value filters could work.\n              // But warn that Lurn supports this poorly.\n              this.logger.warn(\n                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`,\n              );\n              q.term(lunr.tokenizer(value), {\n                presence: lunr.Query.presence.OPTIONAL,\n                fields: [field],\n              });\n            } else {\n              // Log a warning or something about unknown filter value\n              this.logger.warn(`Unknown filter type used on field ${field}`);\n            }\n          });\n        }\n      },\n      documentTypes: types,\n      pageSize,\n    };\n  };\n\n  setTranslator(translator: LunrQueryTranslator) {\n    this.translator = translator;\n  }\n\n  async getIndexer(type: string) {\n    const indexer = new LunrSearchEngineIndexer();\n    const indexerLogger = this.logger.child({ documentType: type });\n    let errorThrown: Error | undefined;\n\n    indexer.on('error', err => {\n      errorThrown = err;\n    });\n\n    indexer.on('close', () => {\n      // Once the stream is closed, build the index and store the documents in\n      // memory for later retrieval.\n      const newDocuments = indexer.getDocumentStore();\n      const docStoreExists = this.lunrIndices[type] !== undefined;\n      const documentsIndexed = Object.keys(newDocuments).length;\n\n      // Do not set the index if there was an error or if no documents were\n      // indexed. This ensures search continues to work for an index, even in\n      // case of transient issues in underlying collators.\n      if (!errorThrown && documentsIndexed > 0) {\n        this.lunrIndices[type] = indexer.buildIndex();\n        this.docStore = { ...this.docStore, ...newDocuments };\n      } else {\n        indexerLogger.warn(\n          `Index for ${type} was not ${\n            docStoreExists ? 'replaced' : 'created'\n          }: ${\n            errorThrown\n              ? 'an error was encountered'\n              : 'indexer received 0 documents'\n          }`,\n        );\n      }\n    });\n\n    return indexer;\n  }\n\n  async query(query: SearchQuery): Promise<IndexableResultSet> {\n    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: LunrResultEnvelope[] = [];\n\n    const indexKeys = Object.keys(this.lunrIndices).filter(\n      type => !documentTypes || documentTypes.includes(type),\n    );\n\n    if (documentTypes?.length && !indexKeys.length) {\n      throw new MissingIndexError(\n        `Missing index for ${documentTypes?.toString()}. This could be because the index hasn't been created yet or there was a problem during index creation.`,\n      );\n    }\n\n    // Iterate over the filtered list of this.lunrIndex keys.\n    indexKeys.forEach(type => {\n      try {\n        results.push(\n          ...this.lunrIndices[type].query(lunrQueryBuilder).map(result => {\n            return {\n              result: result,\n              type: type,\n            };\n          }),\n        );\n      } catch (err) {\n        // if a field does not exist on a index, we can see that as a no-match\n        if (\n          err instanceof Error &&\n          err.message.startsWith('unrecognised field')\n        ) {\n          return;\n        }\n        throw err;\n      }\n    });\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.result.score - doc1.result.score;\n    });\n\n    // Perform paging\n    const { page } = decodePageCursor(query.pageCursor);\n    const offset = page * pageSize;\n    const hasPreviousPage = page > 0;\n    const hasNextPage = results.length > offset + pageSize;\n    const nextPageCursor = hasNextPage\n      ? encodePageCursor({ page: page + 1 })\n      : undefined;\n    const previousPageCursor = hasPreviousPage\n      ? encodePageCursor({ page: page - 1 })\n      : undefined;\n\n    // Translate results into IndexableResultSet\n    const realResultSet: IndexableResultSet = {\n      results: results.slice(offset, offset + pageSize).map((d, index) => ({\n        type: d.type,\n        document: this.docStore[d.result.ref],\n        rank: page * pageSize + index + 1,\n        highlight: {\n          preTag: this.highlightPreTag,\n          postTag: this.highlightPostTag,\n          fields: parseHighlightFields({\n            preTag: this.highlightPreTag,\n            postTag: this.highlightPostTag,\n            doc: this.docStore[d.result.ref],\n            positionMetadata: d.result.matchData.metadata as any,\n          }),\n        },\n      })),\n      numberOfResults: results.length,\n      nextPageCursor,\n      previousPageCursor,\n    };\n\n    return realResultSet;\n  }\n}\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  return {\n    page: Number(Buffer.from(pageCursor, 'base64').toString('utf-8')),\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n\ntype ParseHighlightFieldsProps = {\n  preTag: string;\n  postTag: string;\n  doc: any;\n  positionMetadata: {\n    [term: string]: {\n      [field: string]: {\n        position: number[][];\n      };\n    };\n  };\n};\n\nexport function parseHighlightFields({\n  preTag,\n  postTag,\n  doc,\n  positionMetadata,\n}: ParseHighlightFieldsProps): { [field: string]: string } {\n  // Merge the field positions across all query terms\n  const highlightFieldPositions = Object.values(positionMetadata).reduce(\n    (fieldPositions, metadata) => {\n      Object.keys(metadata).map(fieldKey => {\n        const validFieldMetadataPositions = metadata[\n          fieldKey\n        ]?.position?.filter(position => Array.isArray(position));\n        if (validFieldMetadataPositions.length) {\n          fieldPositions[fieldKey] = fieldPositions[fieldKey] ?? [];\n          fieldPositions[fieldKey].push(...validFieldMetadataPositions);\n        }\n      });\n\n      return fieldPositions;\n    },\n    {} as { [field: string]: number[][] },\n  );\n\n  return Object.fromEntries(\n    Object.entries(highlightFieldPositions).map(([field, positions]) => {\n      positions.sort((a, b) => b[0] - a[0]);\n\n      const highlightedField = positions.reduce((content, pos) => {\n        return (\n          `${String(content).substring(0, pos[0])}${preTag}` +\n          `${String(content).substring(pos[0], pos[0] + pos[1])}` +\n          `${postTag}${String(content).substring(pos[0] + pos[1])}`\n        );\n      }, doc[field] ?? '');\n\n      return [field, highlightedField];\n    }),\n  );\n}\n"],"names":["uuid","lunr","LunrSearchEngineIndexer","MissingIndexError"],"mappings":"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"}