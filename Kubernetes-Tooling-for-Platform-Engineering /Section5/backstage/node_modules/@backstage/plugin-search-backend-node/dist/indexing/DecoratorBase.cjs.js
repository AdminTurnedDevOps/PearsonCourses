'use strict';

var errors = require('@backstage/errors');
var stream = require('stream');

class DecoratorBase extends stream.Transform {
  constructor() {
    super({ objectMode: true });
  }
  /**
   * Encapsulates initialization logic.
   * @internal
   */
  async _construct(done) {
    try {
      await this.initialize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates simple transform stream logic.
   * @internal
   */
  async _transform(document, _, done) {
    try {
      const decorated = await this.decorate(document);
      if (decorated === void 0) {
        done();
        return;
      }
      if (Array.isArray(decorated)) {
        decorated.forEach((doc) => {
          this.push(doc);
        });
        done();
        return;
      }
      this.push(decorated);
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates finalization and final error handling logic.
   * @internal
   */
  async _final(done) {
    try {
      await this.finalize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
}

exports.DecoratorBase = DecoratorBase;
//# sourceMappingURL=DecoratorBase.cjs.js.map
