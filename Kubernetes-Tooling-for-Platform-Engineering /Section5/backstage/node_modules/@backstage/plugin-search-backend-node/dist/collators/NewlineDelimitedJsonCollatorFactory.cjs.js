'use strict';

var ndjson = require('ndjson');

class NewlineDelimitedJsonCollatorFactory {
  constructor(type, searchPattern, reader, logger, visibilityPermission) {
    this.searchPattern = searchPattern;
    this.reader = reader;
    this.logger = logger;
    this.type = type;
    this.visibilityPermission = visibilityPermission;
  }
  type;
  visibilityPermission;
  /**
   * Returns a NewlineDelimitedJsonCollatorFactory instance from configuration
   * and a set of options.
   */
  static fromConfig(_config, options) {
    return new NewlineDelimitedJsonCollatorFactory(
      options.type,
      options.searchPattern,
      options.reader,
      options.logger.child({ documentType: options.type }),
      options.visibilityPermission
    );
  }
  /**
   * Returns the "latest" URL for the given search pattern (e.g. the one at the
   * end of the list, sorted alphabetically).
   */
  async lastUrl() {
    try {
      this.logger.info(
        `Attempting to find latest .ndjson matching ${this.searchPattern}`
      );
      const { files } = await this.reader.search(this.searchPattern);
      const candidates = files.filter((file) => file.url.endsWith(".ndjson")).sort((a, b) => a.url.localeCompare(b.url)).reverse();
      return candidates[0]?.url;
    } catch (e) {
      this.logger.error(`Could not search for ${this.searchPattern}`, e);
      throw e;
    }
  }
  async getCollator() {
    const lastUrl = await this.lastUrl();
    if (!lastUrl) {
      const noMatchingFile = `Could not find an .ndjson file matching ${this.searchPattern}`;
      this.logger.error(noMatchingFile);
      throw new Error(noMatchingFile);
    } else {
      this.logger.info(`Using latest .ndjson file ${lastUrl}`);
    }
    const readerResponse = await this.reader.readUrl(lastUrl);
    const stream = readerResponse.stream();
    return stream.pipe(ndjson.parse());
  }
}

exports.NewlineDelimitedJsonCollatorFactory = NewlineDelimitedJsonCollatorFactory;
//# sourceMappingURL=NewlineDelimitedJsonCollatorFactory.cjs.js.map
