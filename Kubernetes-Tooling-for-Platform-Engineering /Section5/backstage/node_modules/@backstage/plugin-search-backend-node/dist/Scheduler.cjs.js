'use strict';

class Scheduler {
  logger;
  schedule;
  abortControllers;
  isRunning;
  constructor(options) {
    this.logger = options.logger;
    this.schedule = {};
    this.abortControllers = [];
    this.isRunning = false;
  }
  /**
   * Adds each task and interval to the schedule.
   * When running the tasks, the scheduler waits at least for the time specified
   * in the interval once the task was completed, before running it again.
   */
  addToSchedule(options) {
    const { id, task, scheduledRunner } = options;
    if (this.isRunning) {
      throw new Error(
        "Cannot add task to schedule that has already been started."
      );
    }
    if (this.schedule[id]) {
      throw new Error(`Task with id ${id} already exists.`);
    }
    this.schedule[id] = { task, scheduledRunner };
  }
  /**
   * Starts the scheduling process for each task
   */
  start() {
    this.logger.info("Starting all scheduled search tasks.");
    this.isRunning = true;
    Object.keys(this.schedule).forEach((id) => {
      const abortController = new AbortController();
      this.abortControllers.push(abortController);
      const { task, scheduledRunner } = this.schedule[id];
      scheduledRunner.run({
        id,
        fn: task,
        signal: abortController.signal
      });
    });
  }
  /**
   * Stop all scheduled tasks.
   */
  stop() {
    this.logger.info("Stopping all scheduled search tasks.");
    for (const abortController of this.abortControllers) {
      abortController.abort();
    }
    this.abortControllers = [];
    this.isRunning = false;
  }
}

exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.cjs.js.map
