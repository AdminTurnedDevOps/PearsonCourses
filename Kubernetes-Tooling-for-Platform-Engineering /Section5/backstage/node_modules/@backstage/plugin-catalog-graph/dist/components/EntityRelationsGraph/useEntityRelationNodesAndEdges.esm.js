import { useState } from 'react';
import useDebounce from 'react-use/esm/useDebounce';
import { ALL_RELATION_PAIRS } from './relations.esm.js';
import { useEntityRelationGraph } from './useEntityRelationGraph.esm.js';
import { DEFAULT_NAMESPACE } from '@backstage/catalog-model';

function useEntityRelationNodesAndEdges({
  rootEntityRefs,
  maxDepth = Number.POSITIVE_INFINITY,
  unidirectional = true,
  mergeRelations = true,
  kinds,
  relations,
  entityFilter,
  onNodeClick,
  relationPairs = ALL_RELATION_PAIRS
}) {
  const [nodesAndEdges, setNodesAndEdges] = useState({});
  const { entities, loading, error } = useEntityRelationGraph({
    rootEntityRefs,
    filter: {
      maxDepth,
      kinds,
      relations,
      entityFilter
    }
  });
  useDebounce(
    () => {
      if (!entities || Object.keys(entities).length === 0) {
        setNodesAndEdges({});
        return;
      }
      const nodes = Object.entries(entities).map(([entityRef, entity]) => {
        const focused = rootEntityRefs.includes(entityRef);
        const node = {
          id: entityRef,
          entity,
          focused,
          color: focused ? "secondary" : "primary",
          // @deprecated
          kind: entity.kind,
          name: entity.metadata.name,
          namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
          title: entity.metadata.title,
          spec: entity.spec
        };
        if (onNodeClick) {
          node.onClick = (event) => onNodeClick(node, event);
        }
        return node;
      });
      const edges = [];
      const visitedNodes = /* @__PURE__ */ new Set();
      const nodeQueue = [...rootEntityRefs];
      while (nodeQueue.length > 0) {
        const entityRef = nodeQueue.pop();
        const entity = entities[entityRef];
        visitedNodes.add(entityRef);
        if (entity) {
          entity?.relations?.forEach((rel) => {
            if (!entities[rel.targetRef]) {
              return;
            }
            if (relations && !relations.includes(rel.type)) {
              return;
            }
            if (kinds && !kinds.some(
              (kind) => rel.targetRef.startsWith(`${kind.toLocaleLowerCase("en-US")}:`)
            )) {
              return;
            }
            if (!unidirectional || !visitedNodes.has(rel.targetRef)) {
              if (mergeRelations) {
                const pair = relationPairs.find(
                  ([l, r]) => l === rel.type || r === rel.type
                ) ?? [rel.type];
                const [left] = pair;
                edges.push({
                  from: left === rel.type ? entityRef : rel.targetRef,
                  to: left === rel.type ? rel.targetRef : entityRef,
                  relations: pair,
                  label: "visible"
                });
              } else {
                edges.push({
                  from: entityRef,
                  to: rel.targetRef,
                  relations: [rel.type],
                  label: "visible"
                });
              }
            }
            if (!visitedNodes.has(rel.targetRef)) {
              nodeQueue.push(rel.targetRef);
              visitedNodes.add(rel.targetRef);
            }
            if (unidirectional) {
              const findIndex = edges.findIndex(
                (edge) => entityRef === edge.from && rel.targetRef === edge.to && !edge.relations.includes(rel.type)
              );
              if (findIndex >= 0) {
                if (mergeRelations) {
                  const pair = relationPairs.find(
                    ([l, r]) => l === rel.type || r === rel.type
                  ) ?? [rel.type];
                  edges[findIndex].relations = [
                    ...edges[findIndex].relations,
                    ...pair
                  ];
                } else {
                  edges[findIndex].relations = [
                    ...edges[findIndex].relations,
                    rel.type
                  ];
                }
              }
            }
          });
        }
      }
      const finalEdges = edges.reduce((previousEdges, currentEdge) => {
        const indexFound = previousEdges.findIndex(
          (previousEdge) => previousEdge.from === currentEdge.from && previousEdge.to === currentEdge.to
        );
        if (indexFound >= 0) {
          previousEdges[indexFound] = {
            ...previousEdges[indexFound],
            relations: Array.from(
              /* @__PURE__ */ new Set([
                ...previousEdges[indexFound].relations,
                ...currentEdge.relations
              ])
            )
          };
          return previousEdges;
        }
        return [...previousEdges, currentEdge];
      }, []);
      setNodesAndEdges({ nodes, edges: finalEdges });
    },
    100,
    [
      entities,
      rootEntityRefs,
      kinds,
      relations,
      unidirectional,
      mergeRelations,
      onNodeClick,
      relationPairs
    ]
  );
  return {
    loading,
    error,
    ...nodesAndEdges
  };
}

export { useEntityRelationNodesAndEdges };
//# sourceMappingURL=useEntityRelationNodesAndEdges.esm.js.map
