import { parseEntityRef, stringifyEntityRef } from '@backstage/catalog-model';
import qs from 'qs';
import { useMemo, useCallback, useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import '../EntityRelationsGraph/EntityRelationsGraph.esm.js';
import { Direction } from '../EntityRelationsGraph/types.esm.js';

function useCatalogGraphPage({
  initialState = {}
}) {
  const location = useLocation();
  const navigate = useNavigate();
  const query = useMemo(
    () => qs.parse(location.search, { arrayLimit: 0, ignoreQueryPrefix: true }) || {},
    [location.search]
  );
  const rootEntityNames = useMemo(
    () => (Array.isArray(query.rootEntityRefs) ? query.rootEntityRefs : initialState?.rootEntityRefs ?? []).map((r) => parseEntityRef(r)),
    [initialState?.rootEntityRefs, query.rootEntityRefs]
  );
  const setRootEntityNames = useCallback(
    (value) => {
      const areSame = rootEntityNames.length === value.length && rootEntityNames.every(
        (r, i) => stringifyEntityRef(r) === stringifyEntityRef(value[i])
      );
      if (areSame) {
        return;
      }
      const newSearch = qs.stringify(
        {
          ...query,
          rootEntityRefs: value.map((r) => stringifyEntityRef(r))
        },
        { arrayFormat: "brackets", addQueryPrefix: true }
      );
      navigate(newSearch);
    },
    [rootEntityNames, navigate, query]
  );
  const [maxDepth, setMaxDepth] = useState(
    () => typeof query.maxDepth === "string" ? parseMaxDepth(query.maxDepth) : initialState?.maxDepth ?? Number.POSITIVE_INFINITY
  );
  const [selectedRelations, setSelectedRelations] = useState(
    () => Array.isArray(query.selectedRelations) ? query.selectedRelations : initialState?.selectedRelations
  );
  const [selectedKinds, setSelectedKinds] = useState(
    () => (Array.isArray(query.selectedKinds) ? query.selectedKinds : initialState?.selectedKinds)?.map((k) => k.toLocaleLowerCase("en-US"))
  );
  const [unidirectional, setUnidirectional] = useState(
    () => typeof query.unidirectional === "string" ? query.unidirectional === "true" : initialState?.unidirectional ?? true
  );
  const [mergeRelations, setMergeRelations] = useState(
    () => typeof query.mergeRelations === "string" ? query.mergeRelations === "true" : initialState?.mergeRelations ?? true
  );
  const [direction, setDirection] = useState(
    () => typeof query.direction === "string" ? query.direction : initialState?.direction ?? Direction.LEFT_RIGHT
  );
  const [curve, setCurve] = useState(
    () => typeof query.curve === "string" ? query.curve : initialState?.curve ?? "curveMonotoneX"
  );
  const [showFilters, setShowFilters] = useState(
    () => typeof query.showFilters === "string" ? query.showFilters === "true" : initialState?.showFilters ?? true
  );
  const toggleShowFilters = useCallback(
    () => setShowFilters((s) => !s),
    [setShowFilters]
  );
  useEffect(() => {
    const newParams = qs.stringify(
      {
        rootEntityRefs: rootEntityNames.map(stringifyEntityRef),
        maxDepth: isFinite(maxDepth) ? maxDepth : "\u221E",
        selectedKinds,
        selectedRelations,
        unidirectional,
        mergeRelations,
        direction,
        showFilters,
        curve
      },
      { arrayFormat: "brackets", addQueryPrefix: true }
    );
    navigate(newParams, { replace: true });
  }, [
    maxDepth,
    curve,
    selectedKinds,
    selectedRelations,
    unidirectional,
    mergeRelations,
    direction,
    showFilters,
    rootEntityNames,
    navigate
  ]);
  return {
    rootEntityNames,
    setRootEntityNames,
    maxDepth,
    setMaxDepth,
    selectedRelations,
    setSelectedRelations,
    selectedKinds,
    setSelectedKinds,
    unidirectional,
    setUnidirectional,
    mergeRelations,
    setMergeRelations,
    direction,
    setDirection,
    curve,
    setCurve,
    showFilters,
    toggleShowFilters
  };
}
function parseMaxDepth(value) {
  return value === "\u221E" ? Number.POSITIVE_INFINITY : Number(value);
}

export { useCatalogGraphPage };
//# sourceMappingURL=useCatalogGraphPage.esm.js.map
