{"version":3,"file":"createExtensionBlueprint.esm.js","sources":["../../src/wiring/createExtensionBlueprint.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport { Expand } from '../types';\nimport {\n  ExtensionDefinition,\n  ResolvedExtensionInputs,\n  VerifyExtensionFactoryOutput,\n  createExtension,\n  ctxParamsSymbol,\n} from './createExtension';\nimport { z } from 'zod';\nimport { ExtensionInput } from './createExtensionInput';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport {\n  ExtensionDataContainer,\n  createExtensionDataContainer,\n} from './createExtensionDataContainer';\nimport {\n  ResolveInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\n\n/**\n * @public\n */\nexport type CreateExtensionBlueprintOptions<\n  TKind extends string,\n  TName extends string | undefined,\n  TParams,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TDataRefs extends { [name in string]: AnyExtensionDataRef },\n> = {\n  kind: TKind;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  name?: TName;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(\n    params: TParams,\n    context: {\n      node: AppNode;\n      apis: ApiHolder;\n      config: {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n      inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n    },\n  ): Iterable<UFactoryOutput>;\n\n  dataRefs?: TDataRefs;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport type ExtensionBlueprintParameters = {\n  kind: string;\n  name?: string;\n  params?: object;\n  configInput?: { [K in string]: any };\n  config?: { [K in string]: any };\n  output?: AnyExtensionDataRef;\n  inputs?: {\n    [KName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  };\n  dataRefs?: { [name in string]: AnyExtensionDataRef };\n};\n\n/**\n * @public\n */\nexport interface ExtensionBlueprint<\n  T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters,\n> {\n  dataRefs: T['dataRefs'];\n\n  make<TNewName extends string | undefined>(args: {\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    params: T['params'];\n  }): ExtensionDefinition<{\n    kind: T['kind'];\n    name: string | undefined extends TNewName ? T['name'] : TNewName;\n    config: T['config'];\n    configInput: T['configInput'];\n    output: T['output'];\n    inputs: T['inputs'];\n    params: T['params'];\n  }>;\n\n  /**\n   * Creates a new extension from the blueprint.\n   *\n   * You must either pass `params` directly, or define a `factory` that can\n   * optionally call the original factory with the same params.\n   */\n  makeWithOverrides<\n    TNewName extends string | undefined,\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends AnyExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        AnyExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n  >(args: {\n    name?: TNewName;\n    attachTo?: { id: string; input: string };\n    disabled?: boolean;\n    inputs?: TExtraInputs & {\n      [KName in keyof T['inputs']]?: `Error: Input '${KName &\n        string}' is already defined in parent definition`;\n    };\n    output?: Array<UNewOutput>;\n    config?: {\n      schema: TExtensionConfigSchema & {\n        [KName in keyof T['config']]?: `Error: Config key '${KName &\n          string}' is already defined in parent schema`;\n      };\n    };\n    factory(\n      originalFactory: (\n        params: T['params'],\n        context?: {\n          config?: T['config'];\n          inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;\n        },\n      ) => ExtensionDataContainer<NonNullable<T['output']>>,\n      context: {\n        node: AppNode;\n        apis: ApiHolder;\n        config: T['config'] & {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        };\n        inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;\n      },\n    ): Iterable<UFactoryOutput> &\n      VerifyExtensionFactoryOutput<\n        AnyExtensionDataRef extends UNewOutput\n          ? NonNullable<T['output']>\n          : UNewOutput,\n        UFactoryOutput\n      >;\n  }): ExtensionDefinition<{\n    config: (string extends keyof TExtensionConfigSchema\n      ? {}\n      : {\n          [key in keyof TExtensionConfigSchema]: z.infer<\n            ReturnType<TExtensionConfigSchema[key]>\n          >;\n        }) &\n      T['config'];\n    configInput: (string extends keyof TExtensionConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TExtensionConfigSchema]: ReturnType<\n              TExtensionConfigSchema[key]\n            >;\n          }>\n        >) &\n      T['configInput'];\n    output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;\n    inputs: T['inputs'] & TExtraInputs;\n    kind: T['kind'];\n    name: string | undefined extends TNewName ? T['name'] : TNewName;\n    params: T['params'];\n  }>;\n}\n\n/**\n * A simpler replacement for wrapping up `createExtension` inside a kind or type. This allows for a cleaner API for creating\n * types and instances of those types.\n *\n * @public\n */\nexport function createExtensionBlueprint<\n  TParams extends object,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key in string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  TKind extends string,\n  TName extends string | undefined = undefined,\n  TDataRefs extends { [name in string]: AnyExtensionDataRef } = never,\n>(\n  options: CreateExtensionBlueprintOptions<\n    TKind,\n    TName,\n    TParams,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput,\n    TDataRefs\n  >,\n): ExtensionBlueprint<{\n  kind: TKind;\n  name: TName;\n  params: TParams;\n  output: UOutput;\n  inputs: string extends keyof TInputs ? {} : TInputs;\n  config: string extends keyof TConfigSchema\n    ? {}\n    : { [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>> };\n  configInput: string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >;\n  dataRefs: TDataRefs;\n}> {\n  return {\n    dataRefs: options.dataRefs,\n    make(args) {\n      return createExtension({\n        kind: options.kind,\n        name: args.name ?? options.name,\n        attachTo: args.attachTo ?? options.attachTo,\n        disabled: args.disabled ?? options.disabled,\n        inputs: options.inputs,\n        output: options.output as AnyExtensionDataRef[],\n        config: options.config,\n        factory: ctx =>\n          options.factory(\n            { ...args.params, ...(ctx as any)[ctxParamsSymbol] },\n            ctx,\n          ) as Iterable<ExtensionDataValue<any, any>>,\n      }) as ExtensionDefinition;\n    },\n    makeWithOverrides(args) {\n      return createExtension({\n        kind: options.kind,\n        name: args.name ?? options.name,\n        attachTo: args.attachTo ?? options.attachTo,\n        disabled: args.disabled ?? options.disabled,\n        inputs: { ...args.inputs, ...options.inputs },\n        output: (args.output ?? options.output) as AnyExtensionDataRef[],\n        config:\n          options.config || args.config\n            ? {\n                schema: {\n                  ...options.config?.schema,\n                  ...args.config?.schema,\n                },\n              }\n            : undefined,\n        factory: ctx => {\n          const { node, config, inputs, apis } = ctx;\n          return args.factory(\n            (innerParams, innerContext) => {\n              return createExtensionDataContainer<UOutput>(\n                options.factory(\n                  { ...innerParams, ...(ctx as any)[ctxParamsSymbol] },\n                  {\n                    apis,\n                    node,\n                    config: (innerContext?.config ?? config) as any,\n                    inputs: resolveInputOverrides(\n                      options.inputs,\n                      inputs,\n                      innerContext?.inputs,\n                    ) as any,\n                  },\n                ) as Iterable<any>,\n                options.output,\n              );\n            },\n            {\n              apis,\n              node,\n              config: config as any,\n              inputs: inputs as any,\n            },\n          ) as Iterable<ExtensionDataValue<any, any>>;\n        },\n      }) as ExtensionDefinition;\n    },\n  } as ExtensionBlueprint<{\n    kind: TKind;\n    name: TName;\n    params: TParams;\n    output: UOutput;\n    inputs: string extends keyof TInputs ? {} : TInputs;\n    config: string extends keyof TConfigSchema\n      ? {}\n      : {\n          [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n        };\n    configInput: string extends keyof TConfigSchema\n      ? {}\n      : z.input<\n          z.ZodObject<{\n            [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n          }>\n        >;\n    dataRefs: TDataRefs;\n  }>;\n}\n"],"names":[],"mappings":";;;;AAsNO,SAAS,yBAed,OA2BC,EAAA;AACD,EAAO,OAAA;AAAA,IACL,UAAU,OAAQ,CAAA,QAAA;AAAA,IAClB,KAAK,IAAM,EAAA;AACT,MAAA,OAAO,eAAgB,CAAA;AAAA,QACrB,MAAM,OAAQ,CAAA,IAAA;AAAA,QACd,IAAA,EAAM,IAAK,CAAA,IAAA,IAAQ,OAAQ,CAAA,IAAA;AAAA,QAC3B,QAAA,EAAU,IAAK,CAAA,QAAA,IAAY,OAAQ,CAAA,QAAA;AAAA,QACnC,QAAA,EAAU,IAAK,CAAA,QAAA,IAAY,OAAQ,CAAA,QAAA;AAAA,QACnC,QAAQ,OAAQ,CAAA,MAAA;AAAA,QAChB,QAAQ,OAAQ,CAAA,MAAA;AAAA,QAChB,QAAQ,OAAQ,CAAA,MAAA;AAAA,QAChB,OAAA,EAAS,SACP,OAAQ,CAAA,OAAA;AAAA,UACN,EAAE,GAAG,IAAA,CAAK,QAAQ,GAAI,GAAA,CAAY,eAAe,CAAE,EAAA;AAAA,UACnD;AAAA;AACF,OACH,CAAA;AAAA,KACH;AAAA,IACA,kBAAkB,IAAM,EAAA;AACtB,MAAA,OAAO,eAAgB,CAAA;AAAA,QACrB,MAAM,OAAQ,CAAA,IAAA;AAAA,QACd,IAAA,EAAM,IAAK,CAAA,IAAA,IAAQ,OAAQ,CAAA,IAAA;AAAA,QAC3B,QAAA,EAAU,IAAK,CAAA,QAAA,IAAY,OAAQ,CAAA,QAAA;AAAA,QACnC,QAAA,EAAU,IAAK,CAAA,QAAA,IAAY,OAAQ,CAAA,QAAA;AAAA,QACnC,QAAQ,EAAE,GAAG,KAAK,MAAQ,EAAA,GAAG,QAAQ,MAAO,EAAA;AAAA,QAC5C,MAAA,EAAS,IAAK,CAAA,MAAA,IAAU,OAAQ,CAAA,MAAA;AAAA,QAChC,MACE,EAAA,OAAA,CAAQ,MAAU,IAAA,IAAA,CAAK,MACnB,GAAA;AAAA,UACE,MAAQ,EAAA;AAAA,YACN,GAAG,QAAQ,MAAQ,EAAA,MAAA;AAAA,YACnB,GAAG,KAAK,MAAQ,EAAA;AAAA;AAClB,SAEF,GAAA,KAAA,CAAA;AAAA,QACN,SAAS,CAAO,GAAA,KAAA;AACd,UAAA,MAAM,EAAE,IAAA,EAAM,MAAQ,EAAA,MAAA,EAAQ,MAAS,GAAA,GAAA;AACvC,UAAA,OAAO,IAAK,CAAA,OAAA;AAAA,YACV,CAAC,aAAa,YAAiB,KAAA;AAC7B,cAAO,OAAA,4BAAA;AAAA,gBACL,OAAQ,CAAA,OAAA;AAAA,kBACN,EAAE,GAAG,WAAA,EAAa,GAAI,GAAA,CAAY,eAAe,CAAE,EAAA;AAAA,kBACnD;AAAA,oBACE,IAAA;AAAA,oBACA,IAAA;AAAA,oBACA,MAAA,EAAS,cAAc,MAAU,IAAA,MAAA;AAAA,oBACjC,MAAQ,EAAA,qBAAA;AAAA,sBACN,OAAQ,CAAA,MAAA;AAAA,sBACR,MAAA;AAAA,sBACA,YAAc,EAAA;AAAA;AAChB;AACF,iBACF;AAAA,gBACA,OAAQ,CAAA;AAAA,eACV;AAAA,aACF;AAAA,YACA;AAAA,cACE,IAAA;AAAA,cACA,IAAA;AAAA,cACA,MAAA;AAAA,cACA;AAAA;AACF,WACF;AAAA;AACF,OACD,CAAA;AAAA;AACH,GACF;AAoBF;;;;"}