{"version":3,"file":"resolveInputOverrides.esm.js","sources":["../../src/wiring/resolveInputOverrides.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport { Expand } from '../types';\nimport { ResolvedExtensionInput } from './createExtension';\nimport {\n  ExtensionDataContainer,\n  createExtensionDataContainer,\n} from './createExtensionDataContainer';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataRefToValue,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\n\n/** @public */\nexport type ResolveInputValueOverrides<\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  } = {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n> = Expand<\n  {\n    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<\n      any,\n      {\n        optional: infer IOptional extends boolean;\n        singleton: boolean;\n      }\n    >\n      ? IOptional extends true\n        ? never\n        : KName\n      : never]: TInputs[KName] extends ExtensionInput<\n      infer IDataRefs,\n      { optional: boolean; singleton: infer ISingleton extends boolean }\n    >\n      ? ISingleton extends true\n        ? Iterable<ExtensionDataRefToValue<IDataRefs>>\n        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>\n      : never;\n  } & {\n    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<\n      any,\n      {\n        optional: infer IOptional extends boolean;\n        singleton: boolean;\n      }\n    >\n      ? IOptional extends true\n        ? KName\n        : never\n      : never]?: TInputs[KName] extends ExtensionInput<\n      infer IDataRefs,\n      { optional: boolean; singleton: infer ISingleton extends boolean }\n    >\n      ? ISingleton extends true\n        ? Iterable<ExtensionDataRefToValue<IDataRefs>>\n        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>\n      : never;\n  }\n>;\n\nfunction expectArray<T>(value: T | T[]): T[] {\n  return value as T[];\n}\nfunction expectItem<T>(value: T | T[]): T {\n  return value as T;\n}\n\n/** @internal */\nexport function resolveInputOverrides(\n  declaredInputs?: {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  inputs?: {\n    [KName in string]?:\n      | ({ node: AppNode } & ExtensionDataContainer<any>)\n      | Array<{ node: AppNode } & ExtensionDataContainer<any>>;\n  },\n  inputOverrides?: ResolveInputValueOverrides,\n) {\n  if (!declaredInputs || !inputs || !inputOverrides) {\n    return inputs;\n  }\n\n  const newInputs: typeof inputs = {};\n  for (const name in declaredInputs) {\n    if (!Object.hasOwn(declaredInputs, name)) {\n      continue;\n    }\n    const declaredInput = declaredInputs[name];\n    const providedData = inputOverrides[name];\n    if (declaredInput.config.singleton) {\n      const originalInput = expectItem(inputs[name]);\n      if (providedData) {\n        const providedContainer = createExtensionDataContainer(\n          providedData as Iterable<ExtensionDataValue<any, any>>,\n          declaredInput.extensionData,\n        );\n        if (!originalInput) {\n          throw new Error(\n            `attempted to override data of input '${name}' but it is not present in the original inputs`,\n          );\n        }\n        newInputs[name] = Object.assign(providedContainer, {\n          node: (originalInput as ResolvedExtensionInput<any>).node,\n        }) as any;\n      }\n    } else {\n      const originalInput = expectArray(inputs[name]);\n      if (!Array.isArray(providedData)) {\n        throw new Error(\n          `override data provided for input '${name}' must be an array`,\n        );\n      }\n\n      // Regular inputs can be overridden in two different ways:\n      // 1) Forward a subset of the original inputs in a new order\n      // 2) Provide new data for each original input\n\n      // First check if all inputs are being removed\n      if (providedData.length === 0) {\n        newInputs[name] = [];\n      } else {\n        // Check how many of the provided data items have a node property, i.e. is a forwarded input\n        const withNodesCount = providedData.filter(d => 'node' in d).length;\n        if (withNodesCount === 0) {\n          if (originalInput.length !== providedData.length) {\n            throw new Error(\n              `override data provided for input '${name}' must match the length of the original inputs`,\n            );\n          }\n          newInputs[name] = providedData.map((data, i) => {\n            const providedContainer = createExtensionDataContainer(\n              data as Iterable<ExtensionDataValue<any, any>>,\n              declaredInput.extensionData,\n            );\n            return Object.assign(providedContainer, {\n              node: (originalInput[i] as ResolvedExtensionInput<any>).node,\n            }) as any;\n          });\n        } else if (withNodesCount === providedData.length) {\n          newInputs[name] = providedData as any;\n        } else {\n          throw new Error(\n            `override data for input '${name}' may not mix forwarded inputs with data overrides`,\n          );\n        }\n      }\n    }\n  }\n  return newInputs;\n}\n"],"names":[],"mappings":";;AAqFA,SAAS,YAAe,KAAqB,EAAA;AAC3C,EAAO,OAAA,KAAA;AACT;AACA,SAAS,WAAc,KAAmB,EAAA;AACxC,EAAO,OAAA,KAAA;AACT;AAGgB,SAAA,qBAAA,CACd,cAMA,EAAA,MAAA,EAKA,cACA,EAAA;AACA,EAAA,IAAI,CAAC,cAAA,IAAkB,CAAC,MAAA,IAAU,CAAC,cAAgB,EAAA;AACjD,IAAO,OAAA,MAAA;AAAA;AAGT,EAAA,MAAM,YAA2B,EAAC;AAClC,EAAA,KAAA,MAAW,QAAQ,cAAgB,EAAA;AACjC,IAAA,IAAI,CAAC,MAAA,CAAO,MAAO,CAAA,cAAA,EAAgB,IAAI,CAAG,EAAA;AACxC,MAAA;AAAA;AAEF,IAAM,MAAA,aAAA,GAAgB,eAAe,IAAI,CAAA;AACzC,IAAM,MAAA,YAAA,GAAe,eAAe,IAAI,CAAA;AACxC,IAAI,IAAA,aAAA,CAAc,OAAO,SAAW,EAAA;AAClC,MAAA,MAAM,aAAgB,GAAA,UAAA,CAAW,MAAO,CAAA,IAAI,CAAC,CAAA;AAC7C,MAAA,IAAI,YAAc,EAAA;AAChB,QAAA,MAAM,iBAAoB,GAAA,4BAAA;AAAA,UACxB,YAAA;AAAA,UACA,aAAc,CAAA;AAAA,SAChB;AACA,QAAA,IAAI,CAAC,aAAe,EAAA;AAClB,UAAA,MAAM,IAAI,KAAA;AAAA,YACR,wCAAwC,IAAI,CAAA,8CAAA;AAAA,WAC9C;AAAA;AAEF,QAAA,SAAA,CAAU,IAAI,CAAA,GAAI,MAAO,CAAA,MAAA,CAAO,iBAAmB,EAAA;AAAA,UACjD,MAAO,aAA8C,CAAA;AAAA,SACtD,CAAA;AAAA;AACH,KACK,MAAA;AACL,MAAA,MAAM,aAAgB,GAAA,WAAA,CAAY,MAAO,CAAA,IAAI,CAAC,CAAA;AAC9C,MAAA,IAAI,CAAC,KAAA,CAAM,OAAQ,CAAA,YAAY,CAAG,EAAA;AAChC,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,qCAAqC,IAAI,CAAA,kBAAA;AAAA,SAC3C;AAAA;AAQF,MAAI,IAAA,YAAA,CAAa,WAAW,CAAG,EAAA;AAC7B,QAAU,SAAA,CAAA,IAAI,IAAI,EAAC;AAAA,OACd,MAAA;AAEL,QAAA,MAAM,iBAAiB,YAAa,CAAA,MAAA,CAAO,CAAK,CAAA,KAAA,MAAA,IAAU,CAAC,CAAE,CAAA,MAAA;AAC7D,QAAA,IAAI,mBAAmB,CAAG,EAAA;AACxB,UAAI,IAAA,aAAA,CAAc,MAAW,KAAA,YAAA,CAAa,MAAQ,EAAA;AAChD,YAAA,MAAM,IAAI,KAAA;AAAA,cACR,qCAAqC,IAAI,CAAA,8CAAA;AAAA,aAC3C;AAAA;AAEF,UAAA,SAAA,CAAU,IAAI,CAAI,GAAA,YAAA,CAAa,GAAI,CAAA,CAAC,MAAM,CAAM,KAAA;AAC9C,YAAA,MAAM,iBAAoB,GAAA,4BAAA;AAAA,cACxB,IAAA;AAAA,cACA,aAAc,CAAA;AAAA,aAChB;AACA,YAAO,OAAA,MAAA,CAAO,OAAO,iBAAmB,EAAA;AAAA,cACtC,IAAA,EAAO,aAAc,CAAA,CAAC,CAAkC,CAAA;AAAA,aACzD,CAAA;AAAA,WACF,CAAA;AAAA,SACH,MAAA,IAAW,cAAmB,KAAA,YAAA,CAAa,MAAQ,EAAA;AACjD,UAAA,SAAA,CAAU,IAAI,CAAI,GAAA,YAAA;AAAA,SACb,MAAA;AACL,UAAA,MAAM,IAAI,KAAA;AAAA,YACR,4BAA4B,IAAI,CAAA,kDAAA;AAAA,WAClC;AAAA;AACF;AACF;AACF;AAEF,EAAO,OAAA,SAAA;AACT;;;;"}