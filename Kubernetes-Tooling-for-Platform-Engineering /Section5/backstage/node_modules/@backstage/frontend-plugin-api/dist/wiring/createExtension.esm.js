import { resolveInputOverrides } from './resolveInputOverrides.esm.js';
import { createExtensionDataContainer } from './createExtensionDataContainer.esm.js';
import { createSchemaFromZod } from '../schema/createSchemaFromZod.esm.js';
import { OpaqueExtensionDefinition } from '../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';
import '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';

const ctxParamsSymbol = Symbol("params");
function createExtension(options) {
  const schemaDeclaration = options.config?.schema;
  const configSchema = schemaDeclaration && createSchemaFromZod(
    (innerZ) => innerZ.object(
      Object.fromEntries(
        Object.entries(schemaDeclaration).map(([k, v]) => [k, v(innerZ)])
      )
    )
  );
  return OpaqueExtensionDefinition.createInstance("v2", {
    T: void 0,
    kind: options.kind,
    name: options.name,
    attachTo: options.attachTo,
    disabled: options.disabled ?? false,
    inputs: options.inputs ?? {},
    output: options.output,
    configSchema,
    factory: options.factory,
    toString() {
      const parts = [];
      if (options.kind) {
        parts.push(`kind=${options.kind}`);
      }
      if (options.name) {
        parts.push(`name=${options.name}`);
      }
      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);
      return `ExtensionDefinition{${parts.join(",")}}`;
    },
    override(overrideOptions) {
      if (!Array.isArray(options.output)) {
        throw new Error(
          "Cannot override an extension that is not declared using the new format with outputs as an array"
        );
      }
      if (overrideOptions.output && !overrideOptions.factory) {
        throw new Error(
          "Refused to override output without also overriding factory"
        );
      }
      if (overrideOptions.params && overrideOptions.factory) {
        throw new Error(
          "Refused to override params and factory at the same time"
        );
      }
      return createExtension({
        kind: options.kind,
        name: options.name,
        attachTo: overrideOptions.attachTo ?? options.attachTo,
        disabled: overrideOptions.disabled ?? options.disabled,
        inputs: { ...overrideOptions.inputs, ...options.inputs },
        output: overrideOptions.output ?? options.output,
        config: options.config || overrideOptions.config ? {
          schema: {
            ...options.config?.schema,
            ...overrideOptions.config?.schema
          }
        } : void 0,
        factory: ({ node, apis, config, inputs }) => {
          if (!overrideOptions.factory) {
            return options.factory({
              node,
              apis,
              config,
              inputs,
              [ctxParamsSymbol]: overrideOptions.params
            });
          }
          const parentResult = overrideOptions.factory(
            (innerContext) => {
              return createExtensionDataContainer(
                options.factory({
                  node,
                  apis,
                  config: innerContext?.config ?? config,
                  inputs: resolveInputOverrides(
                    options.inputs,
                    inputs,
                    innerContext?.inputs
                  ),
                  [ctxParamsSymbol]: innerContext?.params
                }),
                options.output
              );
            },
            {
              node,
              apis,
              config,
              inputs
            }
          );
          const deduplicatedResult = /* @__PURE__ */ new Map();
          for (const item of parentResult) {
            deduplicatedResult.set(item.id, item);
          }
          return deduplicatedResult.values();
        }
      });
    }
  });
}

export { createExtension, ctxParamsSymbol };
//# sourceMappingURL=createExtension.esm.js.map
