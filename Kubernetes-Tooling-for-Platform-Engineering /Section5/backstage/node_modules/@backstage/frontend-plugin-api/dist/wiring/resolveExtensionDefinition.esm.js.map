{"version":3,"file":"resolveExtensionDefinition.esm.js","sources":["../../src/wiring/resolveExtensionDefinition.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport {\n  ExtensionDefinition,\n  ExtensionDefinitionParameters,\n  ResolvedExtensionInputs,\n} from './createExtension';\nimport { PortableSchema } from '../schema';\nimport { ExtensionInput } from './createExtensionInput';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport { OpaqueExtensionDefinition } from '@internal/frontend';\n\n/** @public */\nexport interface Extension<TConfig, TConfigInput = TConfig> {\n  $$type: '@backstage/Extension';\n  readonly id: string;\n  readonly attachTo: { id: string; input: string };\n  readonly disabled: boolean;\n  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;\n}\n\n/** @internal */\nexport type InternalExtension<TConfig, TConfigInput> = Extension<\n  TConfig,\n  TConfigInput\n> &\n  (\n    | {\n        readonly version: 'v1';\n        readonly inputs: {\n          [inputName in string]: {\n            $$type: '@backstage/ExtensionInput';\n            extensionData: {\n              [name in string]: AnyExtensionDataRef;\n            };\n            config: { optional: boolean; singleton: boolean };\n          };\n        };\n        readonly output: {\n          [name in string]: AnyExtensionDataRef;\n        };\n        factory(context: {\n          apis: ApiHolder;\n          node: AppNode;\n          config: TConfig;\n          inputs: {\n            [inputName in string]: unknown;\n          };\n        }): {\n          [inputName in string]: unknown;\n        };\n      }\n    | {\n        readonly version: 'v2';\n        readonly inputs: {\n          [inputName in string]: ExtensionInput<\n            AnyExtensionDataRef,\n            { optional: boolean; singleton: boolean }\n          >;\n        };\n        readonly output: Array<AnyExtensionDataRef>;\n        factory(options: {\n          apis: ApiHolder;\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<{\n            [inputName in string]: ExtensionInput<\n              AnyExtensionDataRef,\n              { optional: boolean; singleton: boolean }\n            >;\n          }>;\n        }): Iterable<ExtensionDataValue<any, any>>;\n      }\n  );\n\n/** @internal */\nexport function toInternalExtension<TConfig, TConfigInput>(\n  overrides: Extension<TConfig, TConfigInput>,\n): InternalExtension<TConfig, TConfigInput> {\n  const internal = overrides as InternalExtension<TConfig, TConfigInput>;\n  if (internal.$$type !== '@backstage/Extension') {\n    throw new Error(\n      `Invalid extension instance, bad type '${internal.$$type}'`,\n    );\n  }\n  const version = internal.version;\n  if (version !== 'v1' && version !== 'v2') {\n    throw new Error(`Invalid extension instance, bad version '${version}'`);\n  }\n  return internal;\n}\n\n/** @ignore */\nexport type ResolveExtensionId<\n  TExtension extends ExtensionDefinition,\n  TNamespace extends string,\n> = TExtension extends ExtensionDefinition<{\n  kind: infer IKind extends string | undefined;\n  name: infer IName extends string | undefined;\n}>\n  ? [string] extends [IKind | IName]\n    ? never\n    : (\n        undefined extends IName ? TNamespace : `${TNamespace}/${IName}`\n      ) extends infer INamePart extends string\n    ? IKind extends string\n      ? `${IKind}:${INamePart}`\n      : INamePart\n    : never\n  : never;\n\n/** @internal */\nexport function resolveExtensionDefinition<\n  T extends ExtensionDefinitionParameters,\n>(\n  definition: ExtensionDefinition<T>,\n  context?: { namespace?: string },\n): Extension<T['config'], T['configInput']> {\n  const internalDefinition = OpaqueExtensionDefinition.toInternal(definition);\n  const {\n    name,\n    kind,\n    namespace: _skip1,\n    override: _skip2,\n    ...rest\n  } = internalDefinition;\n\n  const namespace = internalDefinition.namespace ?? context?.namespace;\n\n  const namePart =\n    name && namespace ? `${namespace}/${name}` : namespace || name;\n  if (!namePart) {\n    throw new Error(\n      `Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${kind} namespace=${namespace} name=${name}`,\n    );\n  }\n\n  const id = kind ? `${kind}:${namePart}` : namePart;\n\n  return {\n    ...rest,\n    $$type: '@backstage/Extension',\n    version: internalDefinition.version,\n    id,\n    toString() {\n      return `Extension{id=${id}}`;\n    },\n  } as InternalExtension<T['config'], T['configInput']> & Object;\n}\n"],"names":[],"mappings":";;AAkIgB,SAAA,0BAAA,CAGd,YACA,OAC0C,EAAA;AAC1C,EAAM,MAAA,kBAAA,GAAqB,yBAA0B,CAAA,UAAA,CAAW,UAAU,CAAA;AAC1E,EAAM,MAAA;AAAA,IACJ,IAAA;AAAA,IACA,IAAA;AAAA,IACA,SAAW,EAAA,MAAA;AAAA,IACX,QAAU,EAAA,MAAA;AAAA,IACV,GAAG;AAAA,GACD,GAAA,kBAAA;AAEJ,EAAM,MAAA,SAAA,GAAY,kBAAmB,CAAA,SAAA,IAAa,OAAS,EAAA,SAAA;AAE3D,EAAM,MAAA,QAAA,GACJ,QAAQ,SAAY,GAAA,CAAA,EAAG,SAAS,CAAI,CAAA,EAAA,IAAI,KAAK,SAAa,IAAA,IAAA;AAC5D,EAAA,IAAI,CAAC,QAAU,EAAA;AACb,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAuG,oGAAA,EAAA,IAAI,CAAc,WAAA,EAAA,SAAS,SAAS,IAAI,CAAA;AAAA,KACjJ;AAAA;AAGF,EAAA,MAAM,KAAK,IAAO,GAAA,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAK,CAAA,GAAA,QAAA;AAE1C,EAAO,OAAA;AAAA,IACL,GAAG,IAAA;AAAA,IACH,MAAQ,EAAA,sBAAA;AAAA,IACR,SAAS,kBAAmB,CAAA,OAAA;AAAA,IAC5B,EAAA;AAAA,IACA,QAAW,GAAA;AACT,MAAA,OAAO,gBAAgB,EAAE,CAAA,CAAA,CAAA;AAAA;AAC3B,GACF;AACF;;;;"}