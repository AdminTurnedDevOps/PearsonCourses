import { createExtensionDataContainer } from './createExtensionDataContainer.esm.js';

function expectArray(value) {
  return value;
}
function expectItem(value) {
  return value;
}
function resolveInputOverrides(declaredInputs, inputs, inputOverrides) {
  if (!declaredInputs || !inputs || !inputOverrides) {
    return inputs;
  }
  const newInputs = {};
  for (const name in declaredInputs) {
    if (!Object.hasOwn(declaredInputs, name)) {
      continue;
    }
    const declaredInput = declaredInputs[name];
    const providedData = inputOverrides[name];
    if (declaredInput.config.singleton) {
      const originalInput = expectItem(inputs[name]);
      if (providedData) {
        const providedContainer = createExtensionDataContainer(
          providedData,
          declaredInput.extensionData
        );
        if (!originalInput) {
          throw new Error(
            `attempted to override data of input '${name}' but it is not present in the original inputs`
          );
        }
        newInputs[name] = Object.assign(providedContainer, {
          node: originalInput.node
        });
      }
    } else {
      const originalInput = expectArray(inputs[name]);
      if (!Array.isArray(providedData)) {
        throw new Error(
          `override data provided for input '${name}' must be an array`
        );
      }
      if (providedData.length === 0) {
        newInputs[name] = [];
      } else {
        const withNodesCount = providedData.filter((d) => "node" in d).length;
        if (withNodesCount === 0) {
          if (originalInput.length !== providedData.length) {
            throw new Error(
              `override data provided for input '${name}' must match the length of the original inputs`
            );
          }
          newInputs[name] = providedData.map((data, i) => {
            const providedContainer = createExtensionDataContainer(
              data,
              declaredInput.extensionData
            );
            return Object.assign(providedContainer, {
              node: originalInput[i].node
            });
          });
        } else if (withNodesCount === providedData.length) {
          newInputs[name] = providedData;
        } else {
          throw new Error(
            `override data for input '${name}' may not mix forwarded inputs with data overrides`
          );
        }
      }
    }
  }
  return newInputs;
}

export { resolveInputOverrides };
//# sourceMappingURL=resolveInputOverrides.esm.js.map
