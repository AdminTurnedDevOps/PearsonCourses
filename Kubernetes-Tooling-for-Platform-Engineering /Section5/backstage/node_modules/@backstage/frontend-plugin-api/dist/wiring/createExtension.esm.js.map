{"version":3,"file":"createExtension.esm.js","sources":["../../src/wiring/createExtension.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport { Expand } from '../types';\nimport {\n  ResolveInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\nimport {\n  ExtensionDataContainer,\n  createExtensionDataContainer,\n} from './createExtensionDataContainer';\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\nimport { z } from 'zod';\nimport { createSchemaFromZod } from '../schema/createSchemaFromZod';\nimport { OpaqueExtensionDefinition } from '@internal/frontend';\n\n/**\n * This symbol is used to pass parameter overrides from the extension override to the blueprint factory\n * @internal\n */\nexport const ctxParamsSymbol = Symbol('params');\n\n/**\n * Convert a single extension input into a matching resolved input.\n * @public\n */\nexport type ResolvedExtensionInput<\n  TExtensionInput extends ExtensionInput<any, any>,\n> = TExtensionInput['extensionData'] extends Array<AnyExtensionDataRef>\n  ? {\n      node: AppNode;\n    } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>\n  : never;\n\n/**\n * Converts an extension input map into a matching collection of resolved inputs.\n * @public\n */\nexport type ResolvedExtensionInputs<\n  TInputs extends {\n    [name in string]: ExtensionInput<any, any>;\n  },\n> = {\n  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']\n    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>\n    : false extends TInputs[InputName]['config']['optional']\n    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>\n    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;\n};\n\ntype ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\ntype PopUnion<U> = ToIntersection<\n  U extends any ? () => U : never\n> extends () => infer R\n  ? [rest: Exclude<U, R>, next: R]\n  : undefined;\n\n/** @ignore */\ntype JoinStringUnion<\n  U,\n  TDiv extends string = ', ',\n  TResult extends string = '',\n> = PopUnion<U> extends [infer IRest extends string, infer INext extends string]\n  ? TResult extends ''\n    ? JoinStringUnion<IRest, TDiv, INext>\n    : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`>\n  : TResult;\n\n/** @ignore */\nexport type VerifyExtensionFactoryOutput<\n  UDeclaredOutput extends AnyExtensionDataRef,\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = (\n  UDeclaredOutput extends any\n    ? UDeclaredOutput['config']['optional'] extends true\n      ? never\n      : UDeclaredOutput['id']\n    : never\n) extends infer IRequiredOutputIds\n  ? [IRequiredOutputIds] extends [UFactoryOutput['id']]\n    ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']]\n      ? {}\n      : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<\n          Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>\n        >}`\n    : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<\n        Exclude<IRequiredOutputIds, UFactoryOutput['id']>\n      >}`\n  : never;\n\n/** @public */\nexport type CreateExtensionOptions<\n  TKind extends string | undefined,\n  TName extends string | undefined,\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = {\n  kind?: TKind;\n  name?: TName;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(context: {\n    node: AppNode;\n    apis: ApiHolder;\n    config: {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    };\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Iterable<UFactoryOutput>;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport type ExtensionDefinitionParameters = {\n  kind?: string;\n  name?: string;\n  configInput?: { [K in string]: any };\n  config?: { [K in string]: any };\n  output?: AnyExtensionDataRef;\n  inputs?: {\n    [KName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  };\n  params?: object;\n};\n\n/** @public */\nexport type ExtensionDefinition<\n  T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,\n> = {\n  $$type: '@backstage/ExtensionDefinition';\n  readonly T: T;\n\n  override<\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends AnyExtensionDataRef,\n    TExtraInputs extends {\n      [inputName in string]: ExtensionInput<\n        AnyExtensionDataRef,\n        { optional: boolean; singleton: boolean }\n      >;\n    },\n  >(\n    args: Expand<\n      {\n        attachTo?: { id: string; input: string };\n        disabled?: boolean;\n        inputs?: TExtraInputs & {\n          [KName in keyof T['inputs']]?: `Error: Input '${KName &\n            string}' is already defined in parent definition`;\n        };\n        output?: Array<UNewOutput>;\n        config?: {\n          schema: TExtensionConfigSchema & {\n            [KName in keyof T['config']]?: `Error: Config key '${KName &\n              string}' is already defined in parent schema`;\n          };\n        };\n        factory?(\n          originalFactory: (\n            context?: Expand<\n              {\n                config?: T['config'];\n                inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;\n              } & ([T['params']] extends [never]\n                ? {}\n                : { params?: Partial<T['params']> })\n            >,\n          ) => ExtensionDataContainer<NonNullable<T['output']>>,\n          context: {\n            node: AppNode;\n            apis: ApiHolder;\n            config: T['config'] & {\n              [key in keyof TExtensionConfigSchema]: z.infer<\n                ReturnType<TExtensionConfigSchema[key]>\n              >;\n            };\n            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;\n          },\n        ): Iterable<UFactoryOutput>;\n      } & ([T['params']] extends [never]\n        ? {}\n        : { params?: Partial<T['params']> })\n    > &\n      VerifyExtensionFactoryOutput<\n        AnyExtensionDataRef extends UNewOutput\n          ? NonNullable<T['output']>\n          : UNewOutput,\n        UFactoryOutput\n      >,\n  ): ExtensionDefinition<{\n    kind: T['kind'];\n    name: T['name'];\n    output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;\n    inputs: T['inputs'] & TExtraInputs;\n    config: T['config'] & {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    };\n    configInput: T['configInput'] &\n      z.input<\n        z.ZodObject<{\n          [key in keyof TExtensionConfigSchema]: ReturnType<\n            TExtensionConfigSchema[key]\n          >;\n        }>\n      >;\n  }>;\n};\n\n/** @public */\nexport function createExtension<\n  UOutput extends AnyExtensionDataRef,\n  TInputs extends {\n    [inputName in string]: ExtensionInput<\n      AnyExtensionDataRef,\n      { optional: boolean; singleton: boolean }\n    >;\n  },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  const TKind extends string | undefined = undefined,\n  const TName extends string | undefined = undefined,\n>(\n  options: CreateExtensionOptions<\n    TKind,\n    TName,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput\n  >,\n): ExtensionDefinition<{\n  config: string extends keyof TConfigSchema\n    ? {}\n    : {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n  configInput: string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >;\n  output: UOutput;\n  inputs: TInputs;\n  params: never;\n  kind: string | undefined extends TKind ? undefined : TKind;\n  name: string | undefined extends TName ? undefined : TName;\n}> {\n  const schemaDeclaration = options.config?.schema;\n  const configSchema =\n    schemaDeclaration &&\n    createSchemaFromZod(innerZ =>\n      innerZ.object(\n        Object.fromEntries(\n          Object.entries(schemaDeclaration).map(([k, v]) => [k, v(innerZ)]),\n        ),\n      ),\n    );\n\n  return OpaqueExtensionDefinition.createInstance('v2', {\n    T: undefined as unknown as {\n      config: string extends keyof TConfigSchema\n        ? {}\n        : {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n      configInput: string extends keyof TConfigSchema\n        ? {}\n        : z.input<\n            z.ZodObject<{\n              [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n            }>\n          >;\n      output: UOutput;\n      inputs: TInputs;\n      kind: string | undefined extends TKind ? undefined : TKind;\n      name: string | undefined extends TName ? undefined : TName;\n    },\n    kind: options.kind,\n    name: options.name,\n    attachTo: options.attachTo,\n    disabled: options.disabled ?? false,\n    inputs: options.inputs ?? {},\n    output: options.output,\n    configSchema,\n    factory: options.factory,\n    toString() {\n      const parts: string[] = [];\n      if (options.kind) {\n        parts.push(`kind=${options.kind}`);\n      }\n      if (options.name) {\n        parts.push(`name=${options.name}`);\n      }\n      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);\n      return `ExtensionDefinition{${parts.join(',')}}`;\n    },\n    override(overrideOptions) {\n      if (!Array.isArray(options.output)) {\n        throw new Error(\n          'Cannot override an extension that is not declared using the new format with outputs as an array',\n        );\n      }\n\n      // TODO(Rugvip): Making this a type check would be optimal, but it seems\n      //               like it's tricky to add that and still have the type\n      //               inference work correctly for the factory output.\n      if (overrideOptions.output && !overrideOptions.factory) {\n        throw new Error(\n          'Refused to override output without also overriding factory',\n        );\n      }\n      // TODO(Rugvip): Similar to above, would be nice to error during type checking, but don't want to complicate the types too much\n      if (overrideOptions.params && overrideOptions.factory) {\n        throw new Error(\n          'Refused to override params and factory at the same time',\n        );\n      }\n\n      return createExtension({\n        kind: options.kind,\n        name: options.name,\n        attachTo: overrideOptions.attachTo ?? options.attachTo,\n        disabled: overrideOptions.disabled ?? options.disabled,\n        inputs: { ...overrideOptions.inputs, ...options.inputs },\n        output: (overrideOptions.output ??\n          options.output) as AnyExtensionDataRef[],\n        config:\n          options.config || overrideOptions.config\n            ? {\n                schema: {\n                  ...options.config?.schema,\n                  ...overrideOptions.config?.schema,\n                },\n              }\n            : undefined,\n        factory: ({ node, apis, config, inputs }) => {\n          if (!overrideOptions.factory) {\n            return options.factory({\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n              [ctxParamsSymbol as any]: overrideOptions.params,\n            });\n          }\n          const parentResult = overrideOptions.factory(\n            (innerContext): ExtensionDataContainer<UOutput> => {\n              return createExtensionDataContainer<UOutput>(\n                options.factory({\n                  node,\n                  apis,\n                  config: (innerContext?.config ?? config) as any,\n                  inputs: resolveInputOverrides(\n                    options.inputs,\n                    inputs,\n                    innerContext?.inputs,\n                  ) as any,\n                  [ctxParamsSymbol as any]: innerContext?.params,\n                }) as Iterable<any>,\n                options.output,\n              );\n            },\n            {\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n            },\n          );\n\n          const deduplicatedResult = new Map<\n            string,\n            ExtensionDataValue<any, any>\n          >();\n          for (const item of parentResult) {\n            deduplicatedResult.set(item.id, item);\n          }\n\n          return deduplicatedResult.values();\n        },\n      }) as ExtensionDefinition<any>;\n    },\n  });\n}\n"],"names":[],"mappings":"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"}