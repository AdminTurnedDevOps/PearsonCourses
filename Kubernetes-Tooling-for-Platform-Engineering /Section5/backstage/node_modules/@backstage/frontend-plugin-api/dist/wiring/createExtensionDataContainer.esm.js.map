{"version":3,"file":"createExtensionDataContainer.esm.js","sources":["../../src/wiring/createExtensionDataContainer.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnyExtensionDataRef,\n  ExtensionDataRef,\n  ExtensionDataValue,\n} from './createExtensionDataRef';\n\n/** @public */\nexport type ExtensionDataContainer<UExtensionData extends AnyExtensionDataRef> =\n  Iterable<\n    UExtensionData extends ExtensionDataRef<\n      infer IData,\n      infer IId,\n      infer IConfig\n    >\n      ? IConfig['optional'] extends true\n        ? never\n        : ExtensionDataValue<IData, IId>\n      : never\n  > & {\n    get<TId extends UExtensionData['id']>(\n      ref: ExtensionDataRef<any, TId, any>,\n    ): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig>\n      ? IConfig['optional'] extends true\n        ? IData | undefined\n        : IData\n      : never;\n  };\n\n/** @internal */\nexport function createExtensionDataContainer<UData extends AnyExtensionDataRef>(\n  values: Iterable<\n    UData extends ExtensionDataRef<infer IData, infer IId>\n      ? ExtensionDataValue<IData, IId>\n      : never\n  >,\n  declaredRefs?: ExtensionDataRef<any, any, any>[],\n): ExtensionDataContainer<UData> {\n  const container = new Map<string, ExtensionDataValue<any, any>>();\n  const verifyRefs =\n    declaredRefs && new Map(declaredRefs.map(ref => [ref.id, ref]));\n\n  for (const output of values) {\n    if (verifyRefs) {\n      if (!verifyRefs.delete(output.id)) {\n        throw new Error(\n          `extension data '${output.id}' was provided but not declared`,\n        );\n      }\n    }\n    container.set(output.id, output);\n  }\n\n  const remainingRefs =\n    verifyRefs &&\n    Array.from(verifyRefs.values()).filter(ref => !ref.config.optional);\n  if (remainingRefs && remainingRefs.length > 0) {\n    throw new Error(\n      `missing required extension data value(s) '${remainingRefs\n        .map(ref => ref.id)\n        .join(', ')}'`,\n    );\n  }\n\n  return {\n    get(ref) {\n      return container.get(ref.id)?.value;\n    },\n    [Symbol.iterator]() {\n      return container.values();\n    },\n  } as ExtensionDataContainer<UData>;\n}\n"],"names":[],"mappings":"AA6CgB,SAAA,4BAAA,CACd,QAKA,YAC+B,EAAA;AAC/B,EAAM,MAAA,SAAA,uBAAgB,GAA0C,EAAA;AAChE,EAAA,MAAM,UACJ,GAAA,YAAA,IAAgB,IAAI,GAAA,CAAI,YAAa,CAAA,GAAA,CAAI,CAAO,GAAA,KAAA,CAAC,GAAI,CAAA,EAAA,EAAI,GAAG,CAAC,CAAC,CAAA;AAEhE,EAAA,KAAA,MAAW,UAAU,MAAQ,EAAA;AAC3B,IAAA,IAAI,UAAY,EAAA;AACd,MAAA,IAAI,CAAC,UAAA,CAAW,MAAO,CAAA,MAAA,CAAO,EAAE,CAAG,EAAA;AACjC,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,CAAA,gBAAA,EAAmB,OAAO,EAAE,CAAA,+BAAA;AAAA,SAC9B;AAAA;AACF;AAEF,IAAU,SAAA,CAAA,GAAA,CAAI,MAAO,CAAA,EAAA,EAAI,MAAM,CAAA;AAAA;AAGjC,EAAA,MAAM,aACJ,GAAA,UAAA,IACA,KAAM,CAAA,IAAA,CAAK,UAAW,CAAA,MAAA,EAAQ,CAAA,CAAE,MAAO,CAAA,CAAA,GAAA,KAAO,CAAC,GAAA,CAAI,OAAO,QAAQ,CAAA;AACpE,EAAI,IAAA,aAAA,IAAiB,aAAc,CAAA,MAAA,GAAS,CAAG,EAAA;AAC7C,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,0CAAA,EAA6C,cAC1C,GAAI,CAAA,CAAA,GAAA,KAAO,IAAI,EAAE,CAAA,CACjB,IAAK,CAAA,IAAI,CAAC,CAAA,CAAA;AAAA,KACf;AAAA;AAGF,EAAO,OAAA;AAAA,IACL,IAAI,GAAK,EAAA;AACP,MAAA,OAAO,SAAU,CAAA,GAAA,CAAI,GAAI,CAAA,EAAE,CAAG,EAAA,KAAA;AAAA,KAChC;AAAA,IACA,CAAC,MAAO,CAAA,QAAQ,CAAI,GAAA;AAClB,MAAA,OAAO,UAAU,MAAO,EAAA;AAAA;AAC1B,GACF;AACF;;;;"}