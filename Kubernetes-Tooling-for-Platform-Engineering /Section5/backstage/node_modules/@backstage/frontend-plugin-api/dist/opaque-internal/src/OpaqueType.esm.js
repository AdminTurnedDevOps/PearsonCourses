class OpaqueType {
  /**
   * Creates a new opaque type.
   *
   * @param options.type The type identifier of the opaque type
   * @param options.versions The available versions of the opaque type
   * @returns A new opaque type helper
   */
  static create(options) {
    return new OpaqueType(options.type, new Set(options.versions));
  }
  #type;
  #versions;
  constructor(type, versions) {
    this.#type = type;
    this.#versions = versions;
  }
  /**
   * The internal version of the opaque type, used like this: `typeof MyOpaqueType.TPublic`
   *
   * @remarks
   *
   * This property is only useful for type checking, its runtime value is `undefined`.
   */
  TPublic = void 0;
  /**
   * The internal version of the opaque type, used like this: `typeof MyOpaqueType.TInternal`
   *
   * @remarks
   *
   * This property is only useful for type checking, its runtime value is `undefined`.
   */
  TInternal = void 0;
  /**
   * @param value Input value expected to be an instance of this opaque type
   * @returns True if the value matches this opaque type
   */
  isType = (value) => {
    return this.#isThisInternalType(value);
  };
  /**
   * @param value Input value expected to be an instance of this opaque type
   * @throws If the value is not an instance of this opaque type or is of an unsupported version
   * @returns The internal version of the opaque type
   */
  toInternal = (value) => {
    if (!this.#isThisInternalType(value)) {
      throw new TypeError(
        `Invalid opaque type, expected '${this.#type}', but got '${this.#stringifyUnknown(value)}'`
      );
    }
    if (!this.#versions.has(value.version)) {
      const versions = Array.from(this.#versions).map(this.#stringifyVersion);
      if (versions.length > 1) {
        versions[versions.length - 1] = `or ${versions[versions.length - 1]}`;
      }
      const expected = versions.length > 2 ? versions.join(", ") : versions.join(" ");
      throw new TypeError(
        `Invalid opaque type instance, got version ${this.#stringifyVersion(
          value.version
        )}, expected ${expected}`
      );
    }
    return value;
  };
  /**
   * Creates an instance of the opaque type, returning the public type.
   *
   * @param version The version of the instance to create
   * @param value The remaining public and internal properties of the instance
   * @returns An instance of the opaque type
   */
  createInstance(version, props) {
    return Object.assign(props, {
      $$type: this.#type,
      ...version && { version }
    });
  }
  #isThisInternalType(value) {
    if (value === null || typeof value !== "object") {
      return false;
    }
    return value.$$type === this.#type;
  }
  #stringifyUnknown(value) {
    if (typeof value !== "object") {
      return `<${typeof value}>`;
    }
    if (value === null) {
      return "<null>";
    }
    if ("$$type" in value) {
      return String(value.$$type);
    }
    return String(value);
  }
  #stringifyVersion = (version) => {
    return version ? `'${version}'` : "undefined";
  };
}

export { OpaqueType };
//# sourceMappingURL=OpaqueType.esm.js.map
