{"version":3,"file":"SubRouteRef.esm.js","sources":["../../src/routing/SubRouteRef.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RouteRef, toInternalRouteRef } from './RouteRef';\nimport { AnyRouteRefParams } from './types';\n\n// Should match the pattern in react-router\nconst PARAM_PATTERN = /^\\w+$/;\n\n/**\n * Descriptor of a route relative to an absolute {@link RouteRef}.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}.\n *\n * @public\n */\nexport interface SubRouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n> {\n  readonly $$type: '@backstage/SubRouteRef';\n\n  readonly T: TParams;\n\n  readonly path: string;\n}\n\n/** @internal */\nexport interface InternalSubRouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n> extends SubRouteRef<TParams> {\n  readonly version: 'v1';\n\n  getParams(): string[];\n  getParent(): RouteRef;\n  getDescription(): string;\n}\n\n/** @internal */\nexport function toInternalSubRouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n>(resource: SubRouteRef<TParams>): InternalSubRouteRef<TParams> {\n  const r = resource as InternalSubRouteRef<TParams>;\n  if (r.$$type !== '@backstage/SubRouteRef') {\n    throw new Error(`Invalid SubRouteRef, bad type '${r.$$type}'`);\n  }\n\n  return r;\n}\n\n/** @internal */\nexport function isSubRouteRef(opaque: {\n  $$type: string;\n}): opaque is SubRouteRef {\n  return opaque.$$type === '@backstage/SubRouteRef';\n}\n\n/** @internal */\nexport class SubRouteRefImpl<TParams extends AnyRouteRefParams>\n  implements SubRouteRef<TParams>\n{\n  readonly $$type = '@backstage/SubRouteRef';\n  readonly version = 'v1';\n  declare readonly T: never;\n\n  #params: string[];\n  #parent: RouteRef;\n\n  constructor(readonly path: string, params: string[], parent: RouteRef) {\n    this.#params = params;\n    this.#parent = parent;\n  }\n\n  getParams(): string[] {\n    return this.#params;\n  }\n\n  getParent(): RouteRef {\n    return this.#parent;\n  }\n\n  getDescription(): string {\n    const parent = toInternalRouteRef(this.#parent);\n    return `at ${this.path} with parent ${parent.getDescription()}`;\n  }\n\n  toString(): string {\n    return `SubRouteRef{${this.getDescription()}}`;\n  }\n}\n\n/**\n * Used in {@link PathParams} type declaration.\n * @ignore\n */\ntype ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;\n\n/**\n * Used in {@link PathParams} type declaration.\n * @ignore\n */\ntype ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}`\n  ? ParamPart<Part> | ParamNames<Rest>\n  : ParamPart<S>;\n/**\n * This utility type helps us infer a Param object type from a string path\n * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`\n * @ignore\n */\ntype PathParams<S extends string> = { [name in ParamNames<S>]: string };\n\n/**\n * Merges a param object type with an optional params type into a params object.\n * @ignore\n */\ntype MergeParams<\n  P1 extends { [param in string]: string },\n  P2 extends AnyRouteRefParams,\n> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);\n\n/**\n * Convert empty params to undefined.\n * @ignore\n */\ntype TrimEmptyParams<Params extends { [param in string]: string }> =\n  keyof Params extends never ? undefined : Params;\n\n/**\n * Creates a SubRouteRef type given the desired parameters and parent route parameters.\n * The parameters types are merged together while ensuring that there is no overlap between the two.\n *\n * @ignore\n */\ntype MakeSubRouteRef<\n  Params extends { [param in string]: string },\n  ParentParams extends AnyRouteRefParams,\n> = keyof Params & keyof ParentParams extends never\n  ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>>\n  : never;\n\n/**\n * Create a {@link SubRouteRef} from a route descriptor.\n *\n * @param config - Description of the route reference to be created.\n * @public\n */\nexport function createSubRouteRef<\n  Path extends string,\n  ParentParams extends AnyRouteRefParams = never,\n>(config: {\n  path: Path;\n  parent: RouteRef<ParentParams>;\n}): MakeSubRouteRef<PathParams<Path>, ParentParams> {\n  const { path, parent } = config;\n  type Params = PathParams<Path>;\n\n  const internalParent = toInternalRouteRef(parent);\n  const parentParams = internalParent.getParams();\n\n  // Collect runtime parameters from the path, e.g. ['bar', 'baz'] from '/foo/:bar/:baz'\n  const pathParams = path\n    .split('/')\n    .filter(p => p.startsWith(':'))\n    .map(p => p.substring(1));\n  const params = [...parentParams, ...pathParams];\n\n  if (parentParams.some(p => pathParams.includes(p as string))) {\n    throw new Error(\n      'SubRouteRef may not have params that overlap with its parent',\n    );\n  }\n  if (!path.startsWith('/')) {\n    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);\n  }\n  if (path.endsWith('/')) {\n    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);\n  }\n  for (const param of pathParams) {\n    if (!PARAM_PATTERN.test(param)) {\n      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);\n    }\n  }\n\n  // We ensure that the type of the return type is sane here\n  const subRouteRef = new SubRouteRefImpl(\n    path,\n    params as string[],\n    parent,\n  ) as SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>>;\n\n  // But skip type checking of the return value itself, because the conditional\n  // type checking of the parent parameter overlap is tricky to express.\n  return subRouteRef as any;\n}\n"],"names":[],"mappings":";;AAoBA,MAAM,aAAgB,GAAA,OAAA;AAoDf,MAAM,eAEb,CAAA;AAAA,EAQE,WAAA,CAAqB,IAAc,EAAA,MAAA,EAAkB,MAAkB,EAAA;AAAlD,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACnB,IAAA,IAAA,CAAK,OAAU,GAAA,MAAA;AACf,IAAA,IAAA,CAAK,OAAU,GAAA,MAAA;AAAA;AACjB,EAVS,MAAS,GAAA,wBAAA;AAAA,EACT,OAAU,GAAA,IAAA;AAAA,EAGnB,OAAA;AAAA,EACA,OAAA;AAAA,EAOA,SAAsB,GAAA;AACpB,IAAA,OAAO,IAAK,CAAA,OAAA;AAAA;AACd,EAEA,SAAsB,GAAA;AACpB,IAAA,OAAO,IAAK,CAAA,OAAA;AAAA;AACd,EAEA,cAAyB,GAAA;AACvB,IAAM,MAAA,MAAA,GAAS,kBAAmB,CAAA,IAAA,CAAK,OAAO,CAAA;AAC9C,IAAA,OAAO,MAAM,IAAK,CAAA,IAAI,CAAgB,aAAA,EAAA,MAAA,CAAO,gBAAgB,CAAA,CAAA;AAAA;AAC/D,EAEA,QAAmB,GAAA;AACjB,IAAO,OAAA,CAAA,YAAA,EAAe,IAAK,CAAA,cAAA,EAAgB,CAAA,CAAA,CAAA;AAAA;AAE/C;AAyDO,SAAS,kBAGd,MAGkD,EAAA;AAClD,EAAM,MAAA,EAAE,IAAM,EAAA,MAAA,EAAW,GAAA,MAAA;AAGzB,EAAM,MAAA,cAAA,GAAiB,mBAAmB,MAAM,CAAA;AAChD,EAAM,MAAA,YAAA,GAAe,eAAe,SAAU,EAAA;AAG9C,EAAA,MAAM,aAAa,IAChB,CAAA,KAAA,CAAM,GAAG,CAAA,CACT,OAAO,CAAK,CAAA,KAAA,CAAA,CAAE,UAAW,CAAA,GAAG,CAAC,CAC7B,CAAA,GAAA,CAAI,OAAK,CAAE,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA;AAC1B,EAAA,MAAM,MAAS,GAAA,CAAC,GAAG,YAAA,EAAc,GAAG,UAAU,CAAA;AAE9C,EAAA,IAAI,aAAa,IAAK,CAAA,CAAA,CAAA,KAAK,WAAW,QAAS,CAAA,CAAW,CAAC,CAAG,EAAA;AAC5D,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA;AAEF,EAAA,IAAI,CAAC,IAAA,CAAK,UAAW,CAAA,GAAG,CAAG,EAAA;AACzB,IAAA,MAAM,IAAI,KAAA,CAAM,CAA8C,2CAAA,EAAA,IAAI,CAAG,CAAA,CAAA,CAAA;AAAA;AAEvE,EAAI,IAAA,IAAA,CAAK,QAAS,CAAA,GAAG,CAAG,EAAA;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAgD,6CAAA,EAAA,IAAI,CAAG,CAAA,CAAA,CAAA;AAAA;AAEzE,EAAA,KAAA,MAAW,SAAS,UAAY,EAAA;AAC9B,IAAA,IAAI,CAAC,aAAA,CAAc,IAAK,CAAA,KAAK,CAAG,EAAA;AAC9B,MAAA,MAAM,IAAI,KAAA,CAAM,CAA4C,yCAAA,EAAA,KAAK,CAAG,CAAA,CAAA,CAAA;AAAA;AACtE;AAIF,EAAA,MAAM,cAAc,IAAI,eAAA;AAAA,IACtB,IAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACF;AAIA,EAAO,OAAA,WAAA;AACT;;;;"}