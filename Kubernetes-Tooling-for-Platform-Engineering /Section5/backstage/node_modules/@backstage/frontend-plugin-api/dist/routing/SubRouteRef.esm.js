import { toInternalRouteRef } from './RouteRef.esm.js';

const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(path, params, parent) {
    this.path = path;
    this.#params = params;
    this.#parent = parent;
  }
  $$type = "@backstage/SubRouteRef";
  version = "v1";
  #params;
  #parent;
  getParams() {
    return this.#params;
  }
  getParent() {
    return this.#parent;
  }
  getDescription() {
    const parent = toInternalRouteRef(this.#parent);
    return `at ${this.path} with parent ${parent.getDescription()}`;
  }
  toString() {
    return `SubRouteRef{${this.getDescription()}}`;
  }
}
function createSubRouteRef(config) {
  const { path, parent } = config;
  const internalParent = toInternalRouteRef(parent);
  const parentParams = internalParent.getParams();
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parentParams, ...pathParams];
  if (parentParams.some((p) => pathParams.includes(p))) {
    throw new Error(
      "SubRouteRef may not have params that overlap with its parent"
    );
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(
    path,
    params,
    parent
  );
  return subRouteRef;
}

export { SubRouteRefImpl, createSubRouteRef };
//# sourceMappingURL=SubRouteRef.esm.js.map
