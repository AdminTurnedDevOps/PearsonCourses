{"version":3,"file":"Tracker.esm.js","sources":["../../../../../core-plugin-api/src/analytics/Tracker.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getOrCreateGlobalSingleton } from '@backstage/version-bridge';\nimport {\n  AnalyticsApi,\n  AnalyticsEventAttributes,\n  AnalyticsTracker,\n} from '../apis';\nimport { AnalyticsContextValue } from './';\n\ntype TempGlobalEvents = {\n  /**\n   * Stores the most recent \"gathered\" mountpoint navigation.\n   */\n  mostRecentGatheredNavigation?: {\n    action: string;\n    subject: string;\n    value?: number;\n    attributes?: AnalyticsEventAttributes;\n    context: AnalyticsContextValue;\n  };\n  /**\n   * Stores the most recent routable extension render.\n   */\n  mostRecentRoutableExtensionRender?: {\n    context: AnalyticsContextValue;\n  };\n  /**\n   * Tracks whether or not a beforeunload event listener has already been\n   * registered.\n   */\n  beforeUnloadRegistered: boolean;\n};\n\n/**\n * Temporary global store for select event data. Used to make `navigate` events\n * more accurate when gathered mountpoints are used.\n */\nconst globalEvents = getOrCreateGlobalSingleton<TempGlobalEvents>(\n  'core-plugin-api:analytics-tracker-events',\n  () => ({\n    mostRecentGatheredNavigation: undefined,\n    mostRecentRoutableExtensionRender: undefined,\n    beforeUnloadRegistered: false,\n  }),\n);\n\n/**\n * Internal-only event representing when a routable extension is rendered.\n */\nexport const routableExtensionRenderedEvent = '_ROUTABLE-EXTENSION-RENDERED';\n\nexport class Tracker implements AnalyticsTracker {\n  constructor(\n    private readonly analyticsApi: AnalyticsApi,\n    private context: AnalyticsContextValue = {\n      routeRef: 'unknown',\n      pluginId: 'root',\n      extension: 'App',\n    },\n  ) {\n    // Only register a single beforeunload event across all trackers.\n    if (!globalEvents.beforeUnloadRegistered) {\n      // Before the page unloads, attempt to capture any deferred navigation\n      // events that haven't yet been captured.\n      addEventListener(\n        'beforeunload',\n        () => {\n          if (globalEvents.mostRecentGatheredNavigation) {\n            this.analyticsApi.captureEvent({\n              ...globalEvents.mostRecentGatheredNavigation,\n              ...globalEvents.mostRecentRoutableExtensionRender,\n            });\n            globalEvents.mostRecentGatheredNavigation = undefined;\n            globalEvents.mostRecentRoutableExtensionRender = undefined;\n          }\n        },\n        { once: true, passive: true },\n      );\n\n      // Prevent duplicate handlers from being registered.\n      globalEvents.beforeUnloadRegistered = true;\n    }\n  }\n\n  setContext(context: AnalyticsContextValue) {\n    this.context = context;\n  }\n\n  captureEvent(\n    action: string,\n    subject: string,\n    {\n      value,\n      attributes,\n    }: { value?: number; attributes?: AnalyticsEventAttributes } = {},\n  ) {\n    // Never pass internal \"_routeNodeType\" context value.\n    const { _routeNodeType, ...context } = this.context;\n\n    // Never fire the special \"_routable-extension-rendered\" internal event.\n    if (action === routableExtensionRenderedEvent) {\n      // But keep track of it if we're delaying a `navigate` event for a\n      // a gathered route node type.\n      if (globalEvents.mostRecentGatheredNavigation) {\n        globalEvents.mostRecentRoutableExtensionRender = {\n          context: {\n            ...context,\n            extension: 'App',\n          },\n        };\n      }\n      return;\n    }\n\n    // If we are about to fire a real event, and we have an un-fired gathered\n    // mountpoint navigation on the global store, we need to fire the navigate\n    // event first, so this real event happens accurately after the navigation.\n    if (globalEvents.mostRecentGatheredNavigation) {\n      try {\n        this.analyticsApi.captureEvent({\n          ...globalEvents.mostRecentGatheredNavigation,\n          ...globalEvents.mostRecentRoutableExtensionRender,\n        });\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.warn('Error during analytics event capture. %o', e);\n      }\n\n      // Clear the global stores.\n      globalEvents.mostRecentGatheredNavigation = undefined;\n      globalEvents.mostRecentRoutableExtensionRender = undefined;\n    }\n\n    // Never directly fire a navigation event on a gathered route with default\n    // contextual details.\n    if (\n      action === 'navigate' &&\n      _routeNodeType === 'gathered' &&\n      context.pluginId === 'root'\n    ) {\n      // Instead, set it on the global store.\n      globalEvents.mostRecentGatheredNavigation = {\n        action,\n        subject,\n        value,\n        attributes,\n        context,\n      };\n      return;\n    }\n\n    try {\n      this.analyticsApi.captureEvent({\n        action,\n        subject,\n        value,\n        attributes,\n        context,\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.warn('Error during analytics event capture. %o', e);\n    }\n  }\n}\n"],"names":[],"mappings":";;AAoDqB,0BAAA;AAAA,EACnB,0CAAA;AAAA,EACA,OAAO;AAAA,IACL,4BAA8B,EAAA,KAAA,CAAA;AAAA,IAC9B,iCAAmC,EAAA,KAAA,CAAA;AAAA,IACnC,sBAAwB,EAAA;AAAA,GAC1B;AACF;AAKO,MAAM,8BAAiC,GAAA;;;;"}