/**
 * A deferred promise that can be resolved or rejected later.
 *
 * @public
 */
type DeferredPromise<TResolved = void, TRejected = Error> = Promise<TResolved> & {
    resolve(value: TResolved | PromiseLike<TResolved>): void;
    reject(reason?: TRejected): void;
};
/**
 * Creates a deferred promise that can be resolved or rejected later.
 *
 * @public
 */
declare function createDeferred<TResolved = void, TRejected = Error>(): DeferredPromise<TResolved, TRejected>;

/**
 * A type representing all allowed JSON primitive values.
 *
 * @public
 */
type JsonPrimitive = number | string | boolean | null;
/**
 * A type representing all allowed JSON object values.
 *
 * @public
 */
type JsonObject = {
    [key in string]?: JsonValue;
};
/**
 * A type representing all allowed JSON array values.
 *
 * @public
 */
interface JsonArray extends Array<JsonValue> {
}
/**
 * A type representing all allowed JSON values.
 *
 * @public
 */
type JsonValue = JsonObject | JsonArray | JsonPrimitive;

/**
 * Observer interface for consuming an Observer, see TC39.
 *
 * @public
 */
type Observer<T> = {
    next?(value: T): void;
    error?(error: Error): void;
    complete?(): void;
};
/**
 * Subscription returned when subscribing to an Observable, see TC39.
 *
 * @public
 */
type Subscription = {
    /**
     * Cancels the subscription
     */
    unsubscribe(): void;
    /**
     * Value indicating whether the subscription is closed.
     */
    readonly closed: boolean;
};
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
/**
 * Observable sequence of values and errors, see TC39.
 *
 * https://github.com/tc39/proposal-observable
 *
 * This is used as a common return type for observable values and can be created
 * using many different observable implementations, such as zen-observable or RxJS 5.
 *
 * @public
 */
type Observable<T> = {
    [Symbol.observable](): Observable<T>;
    /**
     * Subscribes to this observable to start receiving new values.
     */
    subscribe(observer: Observer<T>): Subscription;
    subscribe(onNext?: (value: T) => void, onError?: (error: Error) => void, onComplete?: () => void): Subscription;
};

/**
 * Human friendly durations object.
 *
 * @public
 */
type HumanDuration = {
    years?: number;
    months?: number;
    weeks?: number;
    days?: number;
    hours?: number;
    minutes?: number;
    seconds?: number;
    milliseconds?: number;
};
/**
 * Converts a {@link HumanDuration} to milliseconds.
 *
 * @public
 * @remarks
 *
 * Note that this conversion by definition is an approximation in the absence of
 * an anchor to a point in time and time zone, as the number of milliseconds is
 * not constant for many units. So the conversion assumes 365-day years, 30-day
 * months, and fixed 24-hour days.
 *
 * @param duration - A human friendly duration object.
 * @returns The number of approximate milliseconds that the duration represents.
 */
declare function durationToMilliseconds(duration: HumanDuration): number;

export { type DeferredPromise, type HumanDuration, type JsonArray, type JsonObject, type JsonPrimitive, type JsonValue, type Observable, type Observer, type Subscription, createDeferred, durationToMilliseconds };
