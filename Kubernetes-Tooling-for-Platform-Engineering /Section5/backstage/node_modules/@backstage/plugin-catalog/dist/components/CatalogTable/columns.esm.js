import React from 'react';
import { EntityRefLink, EntityRefLinks, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import Chip from '@material-ui/core/Chip';
import { OverflowTooltip } from '@backstage/core-components';

const columnFactories = Object.freeze({
  createNameColumn(options) {
    function formatContent(entity) {
      return entity.metadata?.title || humanizeEntityRef(entity, {
        defaultKind: options?.defaultKind
      });
    }
    return {
      title: "Name",
      field: "resolved.entityRef",
      highlight: true,
      customSort({ entity: entity1 }, { entity: entity2 }) {
        return formatContent(entity1).localeCompare(formatContent(entity2));
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(
        EntityRefLink,
        {
          entityRef: entity,
          defaultKind: options?.defaultKind || "Component"
        }
      )
    };
  },
  createSystemColumn() {
    return {
      title: "System",
      field: "resolved.partOfSystemRelationTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.partOfSystemRelations,
          defaultKind: "system"
        }
      )
    };
  },
  createOwnerColumn() {
    return {
      title: "Owner",
      field: "resolved.ownedByRelationsTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.ownedByRelations,
          defaultKind: "group"
        }
      )
    };
  },
  createSpecTargetsColumn() {
    return {
      title: "Targets",
      field: "entity.spec.targets",
      customFilterAndSearch: (query, row) => {
        let targets = [];
        if (row.entity?.spec?.targets && Array.isArray(row.entity?.spec?.targets)) {
          targets = row.entity?.spec?.targets;
        } else if (row.entity?.spec?.target) {
          targets = [row.entity?.spec?.target];
        }
        return targets.join(", ").toLocaleUpperCase("en-US").includes(query.toLocaleUpperCase("en-US"));
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(React.Fragment, null, (entity?.spec?.targets || entity?.spec?.target) && /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: (entity.spec.targets || [entity.spec.target]).join(", "),
          placement: "bottom-start"
        }
      ))
    };
  },
  createSpecTypeColumn(options = { hidden: false }) {
    return {
      title: "Type",
      field: "entity.spec.type",
      hidden: options.hidden,
      width: "auto"
    };
  },
  createSpecLifecycleColumn() {
    return {
      title: "Lifecycle",
      field: "entity.spec.lifecycle"
    };
  },
  createMetadataDescriptionColumn() {
    return {
      title: "Description",
      field: "entity.metadata.description",
      render: ({ entity }) => /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: entity.metadata.description,
          placement: "bottom-start"
        }
      ),
      width: "auto"
    };
  },
  createTagsColumn() {
    return {
      title: "Tags",
      field: "entity.metadata.tags",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(React.Fragment, null, entity.metadata.tags && entity.metadata.tags.map((t) => /* @__PURE__ */ React.createElement(
        Chip,
        {
          key: t,
          label: t,
          size: "small",
          variant: "outlined",
          style: { marginBottom: "0px" }
        }
      ))),
      width: "auto"
    };
  },
  createTitleColumn(options) {
    return {
      title: "Title",
      field: "entity.metadata.title",
      hidden: options?.hidden,
      searchable: true
    };
  },
  createLabelColumn(key, options) {
    function formatContent(keyLabel, entity) {
      const labels = entity.metadata?.labels;
      return labels && labels[keyLabel] || "";
    }
    return {
      title: options?.title || "Label",
      field: "entity.metadata.labels",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      customSort({ entity: entity1 }, { entity: entity2 }) {
        return formatContent(key, entity1).localeCompare(
          formatContent(key, entity2)
        );
      },
      render: ({ entity }) => {
        const labels = entity.metadata?.labels;
        const specifiedLabelValue = labels && labels[key] || options?.defaultValue;
        return /* @__PURE__ */ React.createElement(React.Fragment, null, specifiedLabelValue && /* @__PURE__ */ React.createElement(
          Chip,
          {
            key: specifiedLabelValue,
            label: specifiedLabelValue,
            size: "small",
            variant: "outlined"
          }
        ));
      },
      width: "auto"
    };
  },
  createNamespaceColumn() {
    return {
      title: "Namespace",
      field: "entity.metadata.namespace",
      width: "auto"
    };
  }
});

export { columnFactories };
//# sourceMappingURL=columns.esm.js.map
