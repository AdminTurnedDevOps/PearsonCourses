import { ANNOTATION_EDIT_URL, parseEntityRef, DEFAULT_NAMESPACE, ANNOTATION_LOCATION, stringifyEntityRef } from '@backstage/catalog-model';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardHeader from '@material-ui/core/CardHeader';
import Divider from '@material-ui/core/Divider';
import IconButton from '@material-ui/core/IconButton';
import { makeStyles } from '@material-ui/core/styles';
import { Link, AppIcon, HeaderIconLinkRow } from '@backstage/core-components';
import React, { useCallback } from 'react';
import { scmIntegrationsApiRef, ScmIntegrationIcon } from '@backstage/integration-react';
import { useApp, useApi, alertApiRef, errorApiRef, useRouteRef } from '@backstage/core-plugin-api';
import { useEntity, catalogApiRef, getEntitySourceLocation } from '@backstage/plugin-catalog-react';
import { viewTechDocRouteRef, createFromTemplateRouteRef } from '../../routes.esm.js';
import { AboutContent } from './AboutContent.esm.js';
import CachedIcon from '@material-ui/icons/Cached';
import CreateComponentIcon from '@material-ui/icons/AddCircleOutline';
import DocsIcon from '@material-ui/icons/Description';
import EditIcon from '@material-ui/icons/Edit';
import { isTemplateEntityV1beta3 } from '@backstage/plugin-scaffolder-common';
import { useEntityPermission } from '@backstage/plugin-catalog-react/alpha';
import { catalogEntityRefreshPermission } from '@backstage/plugin-catalog-common/alpha';
import { useSourceTemplateCompoundEntityRef } from './hooks.esm.js';
import { taskCreatePermission } from '@backstage/plugin-scaffolder-common/alpha';
import { usePermission } from '@backstage/plugin-permission-react';
import { catalogTranslationRef } from '../../alpha/translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';

const TECHDOCS_ANNOTATION = "backstage.io/techdocs-ref";
const TECHDOCS_EXTERNAL_ANNOTATION = "backstage.io/techdocs-entity";
const useStyles = makeStyles({
  gridItemCard: {
    display: "flex",
    flexDirection: "column",
    height: "calc(100% - 10px)",
    // for pages without content header
    marginBottom: "10px"
  },
  fullHeightCard: {
    display: "flex",
    flexDirection: "column",
    height: "100%"
  },
  gridItemCardContent: {
    flex: 1
  },
  fullHeightCardContent: {
    flex: 1
  }
});
function AboutCard(props) {
  const { variant } = props;
  const app = useApp();
  const classes = useStyles();
  const { entity } = useEntity();
  const scmIntegrationsApi = useApi(scmIntegrationsApiRef);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const errorApi = useApi(errorApiRef);
  const viewTechdocLink = useRouteRef(viewTechDocRouteRef);
  const templateRoute = useRouteRef(createFromTemplateRouteRef);
  const sourceTemplateRef = useSourceTemplateCompoundEntityRef(entity);
  const { allowed: canRefresh } = useEntityPermission(
    catalogEntityRefreshPermission
  );
  const { t } = useTranslationRef(catalogTranslationRef);
  const { allowed: canCreateTemplateTask } = usePermission({
    permission: taskCreatePermission
  });
  const entitySourceLocation = getEntitySourceLocation(
    entity,
    scmIntegrationsApi
  );
  const entityMetadataEditUrl = entity.metadata.annotations?.[ANNOTATION_EDIT_URL];
  let techdocsRef;
  if (entity.metadata.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]) {
    try {
      techdocsRef = parseEntityRef(
        entity.metadata.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]
      );
    } catch {
      techdocsRef = void 0;
    }
  }
  const viewInSource = {
    label: t("aboutCard.viewSource"),
    disabled: !entitySourceLocation,
    icon: /* @__PURE__ */ React.createElement(ScmIntegrationIcon, { type: entitySourceLocation?.integrationType }),
    href: entitySourceLocation?.locationTargetUrl
  };
  const viewInTechDocs = {
    label: t("aboutCard.viewTechdocs"),
    disabled: !(entity.metadata.annotations?.[TECHDOCS_ANNOTATION] || entity.metadata.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]) || !viewTechdocLink,
    icon: /* @__PURE__ */ React.createElement(DocsIcon, null),
    href: viewTechdocLink && (techdocsRef ? viewTechdocLink({
      namespace: techdocsRef.namespace || DEFAULT_NAMESPACE,
      kind: techdocsRef.kind,
      name: techdocsRef.name
    }) : viewTechdocLink({
      namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
      kind: entity.kind,
      name: entity.metadata.name
    }))
  };
  const subHeaderLinks = [viewInSource, viewInTechDocs];
  if (isTemplateEntityV1beta3(entity)) {
    const Icon = app.getSystemIcon("scaffolder") ?? CreateComponentIcon;
    const launchTemplate = {
      label: t("aboutCard.launchTemplate"),
      icon: /* @__PURE__ */ React.createElement(Icon, null),
      disabled: !templateRoute || !canCreateTemplateTask,
      href: templateRoute && templateRoute({
        templateName: entity.metadata.name,
        namespace: entity.metadata.namespace || DEFAULT_NAMESPACE
      })
    };
    subHeaderLinks.push(launchTemplate);
  }
  let cardClass = "";
  if (variant === "gridItem") {
    cardClass = classes.gridItemCard;
  } else if (variant === "fullHeight") {
    cardClass = classes.fullHeightCard;
  }
  let cardContentClass = "";
  if (variant === "gridItem") {
    cardContentClass = classes.gridItemCardContent;
  } else if (variant === "fullHeight") {
    cardContentClass = classes.fullHeightCardContent;
  }
  const entityLocation = entity.metadata.annotations?.[ANNOTATION_LOCATION];
  const allowRefresh = entityLocation?.startsWith("url:") || entityLocation?.startsWith("file:");
  const refreshEntity = useCallback(async () => {
    try {
      await catalogApi.refreshEntity(stringifyEntityRef(entity));
      alertApi.post({
        message: t("aboutCard.refreshScheduledMessage"),
        severity: "info",
        display: "transient"
      });
    } catch (e) {
      errorApi.post(e);
    }
  }, [catalogApi, entity, alertApi, t, errorApi]);
  return /* @__PURE__ */ React.createElement(Card, { className: cardClass }, /* @__PURE__ */ React.createElement(
    CardHeader,
    {
      title: t("aboutCard.title"),
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, allowRefresh && canRefresh && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "Refresh",
          title: t("aboutCard.refreshButtonTitle"),
          onClick: refreshEntity
        },
        /* @__PURE__ */ React.createElement(CachedIcon, null)
      ), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          component: Link,
          "aria-label": "Edit",
          disabled: !entityMetadataEditUrl,
          title: t("aboutCard.editButtonTitle"),
          to: entityMetadataEditUrl ?? "#"
        },
        /* @__PURE__ */ React.createElement(EditIcon, null)
      ), sourceTemplateRef && templateRoute && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          component: Link,
          title: t("aboutCard.createSimilarButtonTitle"),
          to: templateRoute({
            namespace: sourceTemplateRef.namespace,
            templateName: sourceTemplateRef.name
          })
        },
        /* @__PURE__ */ React.createElement(AppIcon, { id: "scaffolder" })
      )),
      subheader: /* @__PURE__ */ React.createElement(HeaderIconLinkRow, { links: subHeaderLinks })
    }
  ), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(CardContent, { className: cardContentClass }, /* @__PURE__ */ React.createElement(AboutContent, { entity })));
}

export { AboutCard };
//# sourceMappingURL=AboutCard.esm.js.map
