import { RELATION_PART_OF, RELATION_OWNED_BY, stringifyEntityRef, ANNOTATION_VIEW_URL, ANNOTATION_EDIT_URL } from '@backstage/catalog-model';
import { WarningPanel, CodeSnippet, Table, FavoriteToggleIcon } from '@backstage/core-components';
import { useStarredEntities, useEntityList, getEntityRelations, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import Typography from '@material-ui/core/Typography';
import { visuallyHidden } from '@mui/utils';
import EditIcon from '@material-ui/icons/Edit';
import OpenInNew from '@material-ui/icons/OpenInNew';
import { capitalize } from 'lodash';
import pluralize from 'pluralize';
import React, { useMemo } from 'react';
import { columnFactories } from './columns.esm.js';
import { OffsetPaginatedCatalogTable } from './OffsetPaginatedCatalogTable.esm.js';
import { CursorPaginatedCatalogTable } from './CursorPaginatedCatalogTable.esm.js';
import { defaultCatalogTableColumnsFunc } from './defaultCatalogTableColumnsFunc.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { catalogTranslationRef } from '../../alpha/translation.esm.js';
import { CatalogTableToolbar } from './CatalogTableToolbar.esm.js';

const refCompare = (a, b) => {
  const toRef = (entity) => entity.metadata.title || humanizeEntityRef(entity, {
    defaultKind: "Component"
  });
  return toRef(a).localeCompare(toRef(b));
};
const CatalogTable = (props) => {
  const {
    columns = defaultCatalogTableColumnsFunc,
    tableOptions,
    subtitle,
    emptyContent
  } = props;
  const { isStarredEntity, toggleStarredEntity } = useStarredEntities();
  const entityListContext = useEntityList();
  const {
    loading,
    error,
    entities,
    filters,
    pageInfo,
    totalItems,
    paginationMode
  } = entityListContext;
  const tableColumns = useMemo(
    () => typeof columns === "function" ? columns(entityListContext) : columns,
    [columns, entityListContext]
  );
  const { t } = useTranslationRef(catalogTranslationRef);
  if (error) {
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(
      WarningPanel,
      {
        severity: "error",
        title: t("catalogTable.warningPanelTitle")
      },
      /* @__PURE__ */ React.createElement(CodeSnippet, { language: "text", text: error.toString() })
    ));
  }
  const defaultActions = [
    ({ entity }) => {
      const url = entity.metadata.annotations?.[ANNOTATION_VIEW_URL];
      const title2 = t("catalogTable.viewActionTitle");
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { style: visuallyHidden }, title2), /* @__PURE__ */ React.createElement(OpenInNew, { fontSize: "small" })),
        tooltip: title2,
        disabled: !url,
        onClick: () => {
          if (!url) return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      const url = entity.metadata.annotations?.[ANNOTATION_EDIT_URL];
      const title2 = t("catalogTable.editActionTitle");
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { style: visuallyHidden }, title2), /* @__PURE__ */ React.createElement(EditIcon, { fontSize: "small" })),
        tooltip: title2,
        disabled: !url,
        onClick: () => {
          if (!url) return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      const isStarred = isStarredEntity(entity);
      const title2 = isStarred ? t("catalogTable.unStarActionTitle") : t("catalogTable.starActionTitle");
      return {
        cellStyle: { paddingLeft: "1em" },
        icon: () => /* @__PURE__ */ React.createElement(FavoriteToggleIcon, { isFavorite: isStarred }),
        tooltip: title2,
        onClick: () => toggleStarredEntity(entity)
      };
    }
  ];
  const currentKind = filters.kind?.label || "";
  const currentType = filters.type?.value || "";
  const currentCount = typeof totalItems === "number" ? `(${totalItems})` : "";
  const titlePreamble = capitalize(filters.user?.value ?? "all");
  const title = props.title || [titlePreamble, currentType, pluralize(currentKind), currentCount].filter((s) => s).join(" ");
  const actions = props.actions || defaultActions;
  const options = {
    actionsColumnIndex: -1,
    loadingType: "linear",
    showEmptyDataSourceMessage: !loading,
    padding: "dense",
    ...tableOptions
  };
  if (paginationMode === "cursor") {
    return /* @__PURE__ */ React.createElement(
      CursorPaginatedCatalogTable,
      {
        columns: tableColumns,
        emptyContent,
        isLoading: loading,
        title,
        actions,
        subtitle,
        options,
        data: entities.map(toEntityRow),
        next: pageInfo?.next,
        prev: pageInfo?.prev
      }
    );
  } else if (paginationMode === "offset") {
    return /* @__PURE__ */ React.createElement(
      OffsetPaginatedCatalogTable,
      {
        columns: tableColumns,
        emptyContent,
        isLoading: loading,
        title,
        actions,
        subtitle,
        options,
        data: entities.map(toEntityRow)
      }
    );
  }
  const rows = entities.sort(refCompare).map(toEntityRow);
  const pageSize = 20;
  const showPagination = rows.length > pageSize;
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      isLoading: loading,
      columns: tableColumns,
      options: {
        paging: showPagination,
        pageSize,
        pageSizeOptions: [20, 50, 100],
        ...options
      },
      components: {
        Toolbar: CatalogTableToolbar
      },
      title,
      data: rows,
      actions,
      subtitle,
      emptyContent
    }
  );
};
CatalogTable.columns = columnFactories;
CatalogTable.defaultColumnsFunc = defaultCatalogTableColumnsFunc;
function toEntityRow(entity) {
  const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "system"
  });
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return {
    entity,
    resolved: {
      // This name is here for backwards compatibility mostly; the
      // presentation of refs in the table should in general be handled with
      // EntityRefLink / EntityName components
      name: humanizeEntityRef(entity, {
        defaultKind: "Component"
      }),
      entityRef: stringifyEntityRef(entity),
      ownedByRelationsTitle: ownedByRelations.map((r) => humanizeEntityRef(r, { defaultKind: "group" })).join(", "),
      ownedByRelations,
      partOfSystemRelationTitle: partOfSystemRelations.map(
        (r) => humanizeEntityRef(r, {
          defaultKind: "system"
        })
      ).join(", "),
      partOfSystemRelations
    }
  };
}

export { CatalogTable };
//# sourceMappingURL=CatalogTable.esm.js.map
