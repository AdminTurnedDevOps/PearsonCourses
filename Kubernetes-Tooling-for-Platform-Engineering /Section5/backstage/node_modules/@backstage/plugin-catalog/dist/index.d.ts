/// <reference types="react" />
import { Entity, CompoundEntityRef, ComponentEntity, ResourceEntity, DomainEntity, SystemEntity } from '@backstage/catalog-model';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { IconComponent, StorageApi, ApiHolder } from '@backstage/core-plugin-api';
import { EntityRefPresentationSnapshot, CatalogApi, EntityPresentationApi, EntityRefPresentation, StarredEntitiesApi, EntityListContextProps, UserListFilterKind, EntityOwnerPickerProps, EntityListPagination } from '@backstage/plugin-catalog-react';
import { HumanDuration, Observable } from '@backstage/types';
import { InfoCardVariants, TableColumn, TableProps, TableOptions } from '@backstage/core-components';
import * as React$1 from 'react';
import React__default, { ReactNode } from 'react';
import { TabProps } from '@material-ui/core/Tab';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';
import { IndexableDocument, ResultHighlight } from '@backstage/plugin-search-common';
import { SearchResultListItemExtensionProps } from '@backstage/plugin-search-react';

/**
 * A custom renderer for the {@link DefaultEntityPresentationApi}.
 *
 * @public
 */
interface DefaultEntityPresentationApiRenderer {
    /**
     * Whether to request the entity from the catalog API asynchronously.
     *
     * @remarks
     *
     * If this is set to true, entity data will be streamed in from the catalog
     * whenever needed, and the render function may be called more than once:
     * first when no entity data existed (or with old cached data), and then again
     * at a later point when data is loaded from the catalog that proved to be
     * different from the old one.
     *
     * @defaultValue true
     */
    async?: boolean;
    /**
     * The actual render function.
     *
     * @remarks
     *
     * This function may be called multiple times.
     *
     * The loading flag signals that the framework MAY be trying to load more
     * entity data from the catalog and call the render function again, if it
     * succeeds. In some cases you may want to render a loading state in that
     * case.
     *
     * The entity may or may not be given. If the caller of the presentation API
     * did present an entity upfront, then that's what will be passed in here.
     * Otherwise, it may be a server-side entity that either comes from a local
     * cache or directly from the server.
     *
     * In either case, the renderer should return a presentation that is the most
     * useful possible for the end user, given the data that is available.
     */
    render: (options: {
        entityRef: string;
        loading: boolean;
        entity: Entity | undefined;
        context: {
            defaultKind?: string;
            defaultNamespace?: string;
        };
    }) => {
        snapshot: Omit<EntityRefPresentationSnapshot, 'entityRef'>;
    };
}
/**
 * Options for the {@link DefaultEntityPresentationApi}.
 *
 * @public
 */
interface DefaultEntityPresentationApiOptions {
    /**
     * The catalog API to use. If you want to use any asynchronous features, you
     * must supply one.
     */
    catalogApi?: CatalogApi;
    /**
     * When to expire entities that have been loaded from the catalog API and
     * cached for a while.
     *
     * @defaultValue 10 seconds
     * @remarks
     *
     * The higher this value, the lower the load on the catalog API, but also the
     * higher the risk of users seeing stale data.
     */
    cacheTtl?: HumanDuration;
    /**
     * For how long to wait before sending a batch of entity references to the
     * catalog API.
     *
     * @defaultValue 50 milliseconds
     * @remarks
     *
     * The higher this value, the greater the chance of batching up requests from
     * across a page, but also the longer the lag time before displaying accurate
     * information.
     */
    batchDelay?: HumanDuration;
    /**
     * A mapping from kinds to icons.
     *
     * @remarks
     *
     * The keys are kinds (case insensitive) that map to icon values to represent
     * kinds by. These are merged with the default set of icons.
     */
    kindIcons?: Record<string, IconComponent>;
    /**
     * A custom renderer, if any.
     */
    renderer?: DefaultEntityPresentationApiRenderer;
}
/**
 * Default implementation of the {@link @backstage/plugin-catalog-react#EntityPresentationApi}.
 *
 * @public
 */
declare class DefaultEntityPresentationApi implements EntityPresentationApi {
    #private;
    /**
     * Creates a new presentation API that does not reach out to the catalog.
     */
    static createLocal(): EntityPresentationApi;
    /**
     * Creates a new presentation API that calls out to the catalog as needed to
     * get additional information about entities.
     */
    static create(options: DefaultEntityPresentationApiOptions): EntityPresentationApi;
    private constructor();
    /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */
    forEntity(entityOrRef: Entity | string, context?: {
        defaultKind?: string;
        defaultNamespace?: string;
    }): EntityRefPresentation;
}

/**
 * Default implementation of the StarredEntitiesApi that is backed by the StorageApi.
 *
 * @public
 */
declare class DefaultStarredEntitiesApi implements StarredEntitiesApi {
    private readonly settingsStore;
    private starredEntities;
    constructor(opts: {
        storageApi: StorageApi;
    });
    toggleStarred(entityRef: string): Promise<void>;
    starredEntitie$(): Observable<Set<string>>;
    private readonly subscribers;
    private readonly observable;
    private notifyChanges;
}

/**
 * Props for {@link EntityAboutCard}.
 *
 * @public
 */
interface AboutCardProps {
    variant?: InfoCardVariants;
}

/**
 * Props for {@link AboutContent}.
 *
 * @public
 */
interface AboutContentProps {
    entity: Entity;
}
/** @public */
declare function AboutContent(props: AboutContentProps): React__default.JSX.Element;

/**
 * Props for {@link AboutField}.
 *
 * @public
 */
interface AboutFieldProps {
    label: string;
    value?: string;
    gridSizes?: Record<string, number>;
    children?: React__default.ReactNode;
    className?: string;
}
/** @public */
declare function AboutField(props: AboutFieldProps): React__default.JSX.Element;

/**
 * Props for {@link CatalogKindHeader}.
 *
 * @public
 */
interface CatalogKindHeaderProps {
    /**
     * Entity kinds to show in the dropdown; by default all kinds are fetched from the catalog and
     * displayed.
     */
    allowedKinds?: string[];
    /**
     * The initial kind to select; defaults to 'component'. A kind filter entered directly in the
     * query parameter will override this value.
     */
    initialFilter?: string;
}
/**
 * @public
 * @deprecated This component has been deprecated in favour of the EntityKindPicker in the list of filters. If you wish to keep this component long term make sure to raise an issue at github.com/backstage/backstage
 */
declare function CatalogKindHeader(props: CatalogKindHeaderProps): React__default.JSX.Element;

/** @public */
interface CatalogTableRow {
    entity: Entity;
    resolved: {
        name: string;
        entityRef: string;
        partOfSystemRelationTitle?: string;
        partOfSystemRelations: CompoundEntityRef[];
        ownedByRelationsTitle?: string;
        ownedByRelations: CompoundEntityRef[];
    };
}
/**
 * Typed columns function to dynamically render columns based on entity list context.
 *
 * @public
 */
type CatalogTableColumnsFunc = (entityListContext: EntityListContextProps) => TableColumn<CatalogTableRow>[];

/**
 * Props for {@link CatalogTable}.
 *
 * @public
 */
interface CatalogTableProps {
    columns?: TableColumn<CatalogTableRow>[] | CatalogTableColumnsFunc;
    actions?: TableProps<CatalogTableRow>['actions'];
    tableOptions?: TableProps<CatalogTableRow>['options'];
    emptyContent?: ReactNode;
    /**
     * A static title to use for the table. If not provided, a title will be
     * generated based on the current Kind and Type filters and total number of items.
     */
    title?: string;
    subtitle?: string;
}
/**
 * CatalogTable is a wrapper around the Table component that is pre-configured
 * to display catalog entities.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/catalog-customization}
 *
 * @public
 */
declare const CatalogTable: {
    (props: CatalogTableProps): React__default.JSX.Element;
    columns: Readonly<{
        createNameColumn(options?: {
            defaultKind?: string | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createSystemColumn(): TableColumn<CatalogTableRow>;
        createOwnerColumn(): TableColumn<CatalogTableRow>;
        createSpecTargetsColumn(): TableColumn<CatalogTableRow>;
        createSpecTypeColumn(options?: {
            hidden: boolean;
        }): TableColumn<CatalogTableRow>;
        createSpecLifecycleColumn(): TableColumn<CatalogTableRow>;
        createMetadataDescriptionColumn(): TableColumn<CatalogTableRow>;
        createTagsColumn(): TableColumn<CatalogTableRow>;
        createTitleColumn(options?: {
            hidden?: boolean | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createLabelColumn(key: string, options?: {
            title?: string | undefined;
            defaultValue?: string | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createNamespaceColumn(): TableColumn<CatalogTableRow>;
    }>;
    defaultColumnsFunc: CatalogTableColumnsFunc;
};

/** @public */
type CatalogTableToolbarClassKey = 'root' | 'text';

/** @public */
type EntityLayoutRouteProps = {
    path: string;
    title: string;
    children: JSX.Element;
    if?: (entity: Entity) => boolean;
    tabProps?: TabProps<React__default.ElementType, {
        component?: React__default.ElementType;
    }>;
};
interface ExtraContextMenuItem {
    title: string;
    Icon: IconComponent;
    onClick: () => void;
}
type VisibleType = 'visible' | 'hidden' | 'disable';
interface EntityContextMenuOptions {
    disableUnregister: boolean | VisibleType;
}
/** @public */
interface EntityLayoutProps {
    UNSTABLE_extraContextMenuItems?: ExtraContextMenuItem[];
    UNSTABLE_contextMenuOptions?: EntityContextMenuOptions;
    children?: React__default.ReactNode;
    NotFoundComponent?: React__default.ReactNode;
    /**
     * An array of relation types used to determine the parent entities in the hierarchy.
     * These relations are prioritized in the order provided, allowing for flexible
     * navigation through entity relationships.
     *
     * For example, use relation types like `["partOf", "memberOf", "ownedBy"]` to define how the entity is related to
     * its parents in the Entity Catalog.
     *
     * It adds breadcrumbs in the Entity page to enhance user navigation and context awareness.
     */
    parentEntityRelations?: string[];
}
/**
 * EntityLayout is a compound component, which allows you to define a layout for
 * entities using a sub-navigation mechanism.
 *
 * Consists of two parts: EntityLayout and EntityLayout.Route
 *
 * @example
 * ```jsx
 * <EntityLayout>
 *   <EntityLayout.Route path="/example" title="Example tab">
 *     <div>This is rendered under /example/anything-here route</div>
 *   </EntityLayout.Route>
 * </EntityLayout>
 * ```
 *
 * @public
 */
declare const EntityLayout: {
    (props: EntityLayoutProps): React__default.JSX.Element;
    Route: (props: EntityLayoutRouteProps) => null;
};

/**
 * Returns true if the given entity has the orphan annotation given by the
 * catalog.
 *
 * @public
 */
declare function isOrphan(entity: Entity): boolean;
/**
 * Displays a warning alert if the entity is marked as orphan with the ability
 * to delete said entity.
 *
 * @public
 */
declare function EntityOrphanWarning(): React__default.JSX.Element;

/**
 * Returns true if the given entity has relations to other entities, which
 * don't exist in the catalog
 *
 * @public
 */
declare function hasRelationWarnings(entity: Entity, context: {
    apis: ApiHolder;
}): Promise<boolean>;
/**
 * Displays a warning alert if the entity has relations to other entities, which
 * don't exist in the catalog
 *
 * @public
 */
declare function EntityRelationWarning(): React__default.JSX.Element | null;

/**
 * Returns true if the given entity has any processing errors on it.
 *
 * @public
 */
declare function hasCatalogProcessingErrors(entity: Entity, context: {
    apis: ApiHolder;
}): Promise<boolean>;
/**
 * Displays a list of errors from the ancestors of the current entity.
 *
 * @public
 */
declare function EntityProcessingErrorsPanel(): React__default.JSX.Element | null;

/** @public */
interface EntitySwitchCaseProps {
    if?: (entity: Entity, context: {
        apis: ApiHolder;
    }) => boolean | Promise<boolean>;
    children: ReactNode;
}
/**
 * Props for the {@link EntitySwitch} component.
 * @public
 */
interface EntitySwitchProps {
    children: ReactNode;
    renderMultipleMatches?: 'first' | 'all';
}
/** @public */
declare const EntitySwitch: {
    (props: EntitySwitchProps): React__default.JSX.Element;
    Case: (_props: EntitySwitchCaseProps) => null;
};

/** @public */
interface EntityPredicates {
    kind?: string | string[];
    type?: string | string[];
}
/**
 * For use in EntitySwitch.Case. Matches if the entity is of a given kind.
 * @public
 */
declare function isKind(kinds: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is a Component of a given spec.type.
 * @public
 */
declare function isComponentType(types: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is a Resource of a given spec.type.
 * @public
 */
declare function isResourceType(types: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is an API of a given spec.type.
 * @public
 */
declare function isApiType(types: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is the specified kind and type (if present).
 * @public
 */
declare function isEntityWith(predicate: EntityPredicates): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is in a given namespace.
 * @public
 */
declare function isNamespace(namespaces: string | string[]): (entity: Entity) => boolean;

/**
 * @public
 * @deprecated Use `CatalogFilterLayout` from `@backstage/plugin-catalog-react` instead.
 */
declare const FilteredEntityLayout: (props: {
    children: React.ReactNode;
}) => JSX.Element;
/**
 * @public
 * @deprecated Use `CatalogFilterLayout.Filters` from `@backstage/plugin-catalog-react` instead.
 */
declare const FilterContainer: (props: {
    children: React$1.ReactNode;
    options?: {
        drawerBreakpoint?: number | "xs" | "sm" | "md" | "lg" | "xl" | undefined;
        drawerAnchor?: "left" | "top" | "bottom" | "right" | undefined;
    } | undefined;
}) => React$1.JSX.Element;
/**
 * @public
 * @deprecated Use `CatalogFilterLayout.Content` from `@backstage/plugin-catalog-react` instead.
 */
declare const EntityListContainer: (props: {
    children: React$1.ReactNode;
}) => React$1.JSX.Element;

/** @public */
type Breakpoint = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/** @public */
type ColumnBreakpoints = Record<Breakpoint, number>;

/** @public */
interface EntityLinksCardProps {
    cols?: ColumnBreakpoints | number;
    variant?: InfoCardVariants;
}

/** @public */
type EntityLinksEmptyStateClassKey = 'code';

/** @public */
type SystemDiagramCardClassKey = 'domainNode' | 'systemNode' | 'componentNode' | 'apiNode' | 'resourceNode';

/** @public */
type EntityContextMenuClassKey = 'button';

/** @public */
type CatalogSearchResultListItemClassKey = 'item' | 'flexContainer' | 'itemText';
/**
 * Props for {@link CatalogSearchResultListItem}.
 *
 * @public
 */
interface CatalogSearchResultListItemProps {
    icon?: ReactNode | ((result: IndexableDocument) => ReactNode);
    result?: IndexableDocument;
    highlight?: ResultHighlight;
    rank?: number;
    lineClamp?: number;
}

/** @public */
interface EntityLabelsCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/**
 * Returns true if the given entity has labels annotation given by the
 * catalog. For use by EntitySwitch
 *
 * @public
 */
declare function hasLabels(entity: Entity): boolean;

/** @public */
type EntityLabelsEmptyStateClassKey = 'code';

/** @public */
type PluginCatalogComponentsNameToClassKey = {
    PluginCatalogEntityLinksEmptyState: EntityLinksEmptyStateClassKey;
    PluginCatalogSystemDiagramCard: SystemDiagramCardClassKey;
    PluginCatalogEntityContextMenu: EntityContextMenuClassKey;
    PluginCatalogSearchResultListItem: CatalogSearchResultListItemClassKey;
    PluginCatalogTableToolbar: CatalogTableToolbarClassKey;
    PluginCatalogEntityLabelsEmptyState: EntityLabelsEmptyStateClassKey;
};
/** @public */
type BackstageOverrides = Overrides & {
    [Name in keyof PluginCatalogComponentsNameToClassKey]?: Partial<StyleRules<PluginCatalogComponentsNameToClassKey[Name]>>;
};
declare module '@backstage/theme' {
    interface OverrideComponentNameToClassKeys extends PluginCatalogComponentsNameToClassKey {
    }
}

/**
 * Props for root catalog pages.
 *
 * @public
 */
interface DefaultCatalogPageProps {
    initiallySelectedFilter?: UserListFilterKind;
    columns?: TableColumn<CatalogTableRow>[] | CatalogTableColumnsFunc;
    actions?: TableProps<CatalogTableRow>['actions'];
    initialKind?: string;
    tableOptions?: TableProps<CatalogTableRow>['options'];
    emptyContent?: ReactNode;
    ownerPickerMode?: EntityOwnerPickerProps['mode'];
    filters?: ReactNode;
    initiallySelectedNamespaces?: string[];
    pagination?: EntityListPagination;
}

/** @public */
interface DependencyOfComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ComponentEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface DependsOnComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ComponentEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface DependsOnResourcesCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ResourceEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface HasComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ComponentEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface HasResourcesCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ResourceEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface HasSubcomponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ComponentEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface HasSubdomainsCardProps {
    variant?: InfoCardVariants;
    tableOptions?: TableOptions;
    columns?: TableColumn<DomainEntity>[];
    title?: string;
}

/** @public */
interface HasSystemsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<SystemEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
type RelatedEntitiesCardProps<T extends Entity> = {
    variant?: InfoCardVariants;
    title: string;
    columns: TableColumn<T>[];
    entityKind?: string;
    relationType: string;
    emptyMessage: string;
    emptyHelpLink: string;
    asRenderableEntities: (entities: Entity[]) => T[];
    tableOptions?: TableOptions;
};

/** @public */
declare const catalogPlugin: _backstage_core_plugin_api.BackstagePlugin<{
    catalogIndex: _backstage_core_plugin_api.RouteRef<undefined>;
    catalogEntity: _backstage_core_plugin_api.RouteRef<{
        name: string;
        kind: string;
        namespace: string;
    }>;
}, {
    createComponent: _backstage_core_plugin_api.ExternalRouteRef<undefined, true>;
    viewTechDoc: _backstage_core_plugin_api.ExternalRouteRef<{
        name: string;
        kind: string;
        namespace: string;
    }, true>;
    createFromTemplate: _backstage_core_plugin_api.ExternalRouteRef<{
        namespace: string;
        templateName: string;
    }, true>;
    unregisterRedirect: _backstage_core_plugin_api.ExternalRouteRef<undefined, true>;
}>;
/** @public */
declare const CatalogIndexPage: (props: DefaultCatalogPageProps) => JSX.Element;
/** @public */
declare const CatalogEntityPage: () => JSX.Element;
/**
 * An example About card to show at the top of entity pages.
 *
 * @public
 * @remarks
 *
 * This card collects some high level information about the entity, but is just
 * an example component. Many organizations will want to replace it with a
 * custom card that is more tailored to their specific needs. The card itself is
 * not extremely customizable; feel free to make a copy of it as a starting
 * point if you like.
 */
declare const EntityAboutCard: (props: AboutCardProps) => JSX.Element;
/** @public */
declare const EntityLinksCard: (props: EntityLinksCardProps) => React$1.JSX.Element;
/** @public */
declare const EntityLabelsCard: (props: EntityLabelsCardProps) => React$1.JSX.Element;
/** @public */
declare const EntityHasSystemsCard: (props: HasSystemsCardProps) => JSX.Element;
/** @public */
declare const EntityHasComponentsCard: (props: HasComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityHasSubcomponentsCard: (props: HasSubcomponentsCardProps) => JSX.Element;
/** @public */
declare const EntityHasSubdomainsCard: (props: HasSubdomainsCardProps) => JSX.Element;
/** @public */
declare const EntityHasResourcesCard: (props: HasResourcesCardProps) => JSX.Element;
/** @public */
declare const EntityDependsOnComponentsCard: (props: DependsOnComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityDependencyOfComponentsCard: (props: DependencyOfComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityDependsOnResourcesCard: (props: DependsOnResourcesCardProps) => JSX.Element;
/** @public */
declare const RelatedEntitiesCard: <T extends Entity>(props: RelatedEntitiesCardProps<T>) => JSX.Element;
/** @public */
declare const CatalogSearchResultListItem: (props: SearchResultListItemExtensionProps<CatalogSearchResultListItemProps>) => JSX.Element | null;

export { type AboutCardProps, AboutContent, type AboutContentProps, AboutField, type AboutFieldProps, type BackstageOverrides, type Breakpoint, CatalogEntityPage, CatalogIndexPage, CatalogKindHeader, type CatalogKindHeaderProps, CatalogSearchResultListItem, type CatalogSearchResultListItemClassKey, type CatalogSearchResultListItemProps, CatalogTable, type CatalogTableColumnsFunc, type CatalogTableProps, type CatalogTableRow, type CatalogTableToolbarClassKey, type ColumnBreakpoints, type DefaultCatalogPageProps, DefaultEntityPresentationApi, type DefaultEntityPresentationApiOptions, type DefaultEntityPresentationApiRenderer, DefaultStarredEntitiesApi, type DependencyOfComponentsCardProps, type DependsOnComponentsCardProps, type DependsOnResourcesCardProps, EntityAboutCard, type EntityContextMenuClassKey, EntityDependencyOfComponentsCard, EntityDependsOnComponentsCard, EntityDependsOnResourcesCard, EntityHasComponentsCard, EntityHasResourcesCard, EntityHasSubcomponentsCard, EntityHasSubdomainsCard, EntityHasSystemsCard, EntityLabelsCard, type EntityLabelsCardProps, type EntityLabelsEmptyStateClassKey, EntityLayout, type EntityLayoutProps, type EntityLayoutRouteProps, EntityLinksCard, type EntityLinksCardProps, type EntityLinksEmptyStateClassKey, EntityListContainer, EntityOrphanWarning, type EntityPredicates, EntityProcessingErrorsPanel, EntityRelationWarning, EntitySwitch, type EntitySwitchCaseProps, type EntitySwitchProps, FilterContainer, FilteredEntityLayout, type HasComponentsCardProps, type HasResourcesCardProps, type HasSubcomponentsCardProps, type HasSubdomainsCardProps, type HasSystemsCardProps, type PluginCatalogComponentsNameToClassKey, RelatedEntitiesCard, type RelatedEntitiesCardProps, type SystemDiagramCardClassKey, catalogPlugin, hasCatalogProcessingErrors, hasLabels, hasRelationWarnings, isApiType, isComponentType, isEntityWith, isKind, isNamespace, isOrphan, isResourceType };
