import { InputError } from '@backstage/errors';
import { createKindMatcher } from './matchers/createKindMatcher.esm.js';
import { createTypeMatcher } from './matchers/createTypeMatcher.esm.js';
import { createIsMatcher } from './matchers/createIsMatcher.esm.js';
import { createHasMatcher } from './matchers/createHasMatcher.esm.js';

const rootMatcherFactories = {
  kind: createKindMatcher,
  type: createTypeMatcher,
  is: createIsMatcher,
  has: createHasMatcher
};
function parseFilterExpression(expression) {
  const expressionParseErrors = [];
  const parts = splitFilterExpression(
    expression,
    (e) => expressionParseErrors.push(e)
  );
  const matchers = parts.flatMap((part) => {
    const factory = rootMatcherFactories[part.key];
    const negation = part.negation;
    if (!factory) {
      const known = Object.keys(rootMatcherFactories).map((m) => `'${m}'`);
      expressionParseErrors.push(
        new InputError(
          `'${part.key}' is not a valid filter expression key, expected one of ${known}`
        )
      );
      return [];
    }
    const matcher = factory(
      part.parameters,
      (e) => expressionParseErrors.push(e)
    );
    return [negation ? (entity) => !matcher(entity) : matcher];
  });
  const filterFn = (entity) => matchers.every((matcher) => {
    try {
      return matcher(entity);
    } catch {
      return false;
    }
  });
  return {
    filterFn,
    expressionParseErrors
  };
}
function splitFilterExpression(expression, onParseError) {
  const words = expression.split(" ").map((w) => w.trim()).filter(Boolean);
  const result = new Array();
  for (const word of words) {
    const match = word.match(/^(not:)?([^:]+):(.+)$/);
    if (!match) {
      onParseError(
        new InputError(
          `'${word}' is not a valid filter expression, expected 'key:parameter' form`
        )
      );
      continue;
    }
    const key = match[2];
    const parameters = match[3].split(",").filter(Boolean);
    const negation = Boolean(match[1]);
    result.push({ key, parameters, negation });
  }
  return result;
}

export { parseFilterExpression, splitFilterExpression };
//# sourceMappingURL=parseFilterExpression.esm.js.map
