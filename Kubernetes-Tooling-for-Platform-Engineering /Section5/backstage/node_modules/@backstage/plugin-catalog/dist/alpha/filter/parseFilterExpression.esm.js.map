{"version":3,"file":"parseFilterExpression.esm.js","sources":["../../../src/alpha/filter/parseFilterExpression.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { InputError } from '@backstage/errors';\nimport { EntityMatcherFn } from './matchers/types';\nimport { createKindMatcher } from './matchers/createKindMatcher';\nimport { createTypeMatcher } from './matchers/createTypeMatcher';\nimport { createIsMatcher } from './matchers/createIsMatcher';\nimport { createHasMatcher } from './matchers/createHasMatcher';\n\nconst rootMatcherFactories: Record<\n  string,\n  (\n    parameters: string[],\n    onParseError: (error: Error) => void,\n    negation?: boolean,\n  ) => EntityMatcherFn\n> = {\n  kind: createKindMatcher,\n  type: createTypeMatcher,\n  is: createIsMatcher,\n  has: createHasMatcher,\n};\n\n/**\n * Parses a filter expression that decides whether to render an entity component\n * or not. Returns a function that matches entities based on that expression.\n *\n * @remarks\n *\n * Filter strings are on the form `kind:user,group is:orphan`. There's\n * effectively an AND between the space separated parts, and an OR between comma\n * separated parameters. So the example filter string semantically means\n * \"entities that are of either User or Group kind, and also are orphans\".\n *\n * The `expressionParseErrors` array contains any errors that were encountered\n * during initial parsing of the expression. Note that the parts of the input\n * expression that had errors are ignored entirely and parsing continues as if\n * they didn't exist.\n */\nexport function parseFilterExpression(expression: string): {\n  filterFn: (entity: Entity) => boolean;\n  expressionParseErrors: Error[];\n} {\n  const expressionParseErrors: Error[] = [];\n\n  const parts = splitFilterExpression(expression, e =>\n    expressionParseErrors.push(e),\n  );\n  const matchers = parts.flatMap(part => {\n    const factory = rootMatcherFactories[part.key];\n    const negation = part.negation;\n    if (!factory) {\n      const known = Object.keys(rootMatcherFactories).map(m => `'${m}'`);\n      expressionParseErrors.push(\n        new InputError(\n          `'${part.key}' is not a valid filter expression key, expected one of ${known}`,\n        ),\n      );\n      return [];\n    }\n\n    const matcher = factory(part.parameters, e =>\n      expressionParseErrors.push(e),\n    );\n\n    return [negation ? (entity: Entity) => !matcher(entity) : matcher];\n  });\n\n  const filterFn = (entity: Entity) =>\n    matchers.every(matcher => {\n      try {\n        return matcher(entity);\n      } catch {\n        return false;\n      }\n    });\n\n  return {\n    filterFn,\n    expressionParseErrors,\n  };\n}\n\nexport function splitFilterExpression(\n  expression: string,\n  onParseError: (error: Error) => void,\n): Array<{ key: string; parameters: string[]; negation: boolean }> {\n  const words = expression\n    .split(' ')\n    .map(w => w.trim())\n    .filter(Boolean);\n\n  const result = new Array<{\n    key: string;\n    parameters: string[];\n    negation: boolean;\n  }>();\n\n  for (const word of words) {\n    const match = word.match(/^(not:)?([^:]+):(.+)$/);\n    if (!match) {\n      onParseError(\n        new InputError(\n          `'${word}' is not a valid filter expression, expected 'key:parameter' form`,\n        ),\n      );\n      continue;\n    }\n    const key = match[2];\n    const parameters = match[3].split(',').filter(Boolean); // silently ignore double commas\n    const negation = Boolean(match[1]);\n    result.push({ key, parameters, negation });\n  }\n\n  return result;\n}\n"],"names":[],"mappings":";;;;;;AAwBA,MAAM,oBAOF,GAAA;AAAA,EACF,IAAM,EAAA,iBAAA;AAAA,EACN,IAAM,EAAA,iBAAA;AAAA,EACN,EAAI,EAAA,eAAA;AAAA,EACJ,GAAK,EAAA;AACP,CAAA;AAkBO,SAAS,sBAAsB,UAGpC,EAAA;AACA,EAAA,MAAM,wBAAiC,EAAC;AAExC,EAAA,MAAM,KAAQ,GAAA,qBAAA;AAAA,IAAsB,UAAA;AAAA,IAAY,CAAA,CAAA,KAC9C,qBAAsB,CAAA,IAAA,CAAK,CAAC;AAAA,GAC9B;AACA,EAAM,MAAA,QAAA,GAAW,KAAM,CAAA,OAAA,CAAQ,CAAQ,IAAA,KAAA;AACrC,IAAM,MAAA,OAAA,GAAU,oBAAqB,CAAA,IAAA,CAAK,GAAG,CAAA;AAC7C,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA;AACtB,IAAA,IAAI,CAAC,OAAS,EAAA;AACZ,MAAM,MAAA,KAAA,GAAQ,OAAO,IAAK,CAAA,oBAAoB,EAAE,GAAI,CAAA,CAAA,CAAA,KAAK,CAAI,CAAA,EAAA,CAAC,CAAG,CAAA,CAAA,CAAA;AACjE,MAAsB,qBAAA,CAAA,IAAA;AAAA,QACpB,IAAI,UAAA;AAAA,UACF,CAAI,CAAA,EAAA,IAAA,CAAK,GAAG,CAAA,wDAAA,EAA2D,KAAK,CAAA;AAAA;AAC9E,OACF;AACA,MAAA,OAAO,EAAC;AAAA;AAGV,IAAA,MAAM,OAAU,GAAA,OAAA;AAAA,MAAQ,IAAK,CAAA,UAAA;AAAA,MAAY,CAAA,CAAA,KACvC,qBAAsB,CAAA,IAAA,CAAK,CAAC;AAAA,KAC9B;AAEA,IAAO,OAAA,CAAC,WAAW,CAAC,MAAA,KAAmB,CAAC,OAAQ,CAAA,MAAM,IAAI,OAAO,CAAA;AAAA,GAClE,CAAA;AAED,EAAA,MAAM,QAAW,GAAA,CAAC,MAChB,KAAA,QAAA,CAAS,MAAM,CAAW,OAAA,KAAA;AACxB,IAAI,IAAA;AACF,MAAA,OAAO,QAAQ,MAAM,CAAA;AAAA,KACf,CAAA,MAAA;AACN,MAAO,OAAA,KAAA;AAAA;AACT,GACD,CAAA;AAEH,EAAO,OAAA;AAAA,IACL,QAAA;AAAA,IACA;AAAA,GACF;AACF;AAEgB,SAAA,qBAAA,CACd,YACA,YACiE,EAAA;AACjE,EAAA,MAAM,KAAQ,GAAA,UAAA,CACX,KAAM,CAAA,GAAG,CACT,CAAA,GAAA,CAAI,CAAK,CAAA,KAAA,CAAA,CAAE,IAAK,EAAC,CACjB,CAAA,MAAA,CAAO,OAAO,CAAA;AAEjB,EAAM,MAAA,MAAA,GAAS,IAAI,KAIhB,EAAA;AAEH,EAAA,KAAA,MAAW,QAAQ,KAAO,EAAA;AACxB,IAAM,MAAA,KAAA,GAAQ,IAAK,CAAA,KAAA,CAAM,uBAAuB,CAAA;AAChD,IAAA,IAAI,CAAC,KAAO,EAAA;AACV,MAAA,YAAA;AAAA,QACE,IAAI,UAAA;AAAA,UACF,IAAI,IAAI,CAAA,iEAAA;AAAA;AACV,OACF;AACA,MAAA;AAAA;AAEF,IAAM,MAAA,GAAA,GAAM,MAAM,CAAC,CAAA;AACnB,IAAM,MAAA,UAAA,GAAa,MAAM,CAAC,CAAA,CAAE,MAAM,GAAG,CAAA,CAAE,OAAO,OAAO,CAAA;AACrD,IAAA,MAAM,QAAW,GAAA,OAAA,CAAQ,KAAM,CAAA,CAAC,CAAC,CAAA;AACjC,IAAA,MAAA,CAAO,IAAK,CAAA,EAAE,GAAK,EAAA,UAAA,EAAY,UAAU,CAAA;AAAA;AAG3C,EAAO,OAAA,MAAA;AACT;;;;"}