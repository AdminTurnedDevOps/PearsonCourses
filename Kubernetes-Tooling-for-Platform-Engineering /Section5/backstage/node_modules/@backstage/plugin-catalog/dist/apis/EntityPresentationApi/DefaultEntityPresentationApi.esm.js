import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { durationToMilliseconds } from '@backstage/types';
import DataLoader from 'dataloader';
import ExpiryMap from 'expiry-map';
import ObservableImpl from 'zen-observable';
import { createDefaultRenderer, DEFAULT_CACHE_TTL, DEFAULT_BATCH_DELAY, DEFAULT_ICONS } from './defaults.esm.js';

class DefaultEntityPresentationApi {
  /**
   * Creates a new presentation API that does not reach out to the catalog.
   */
  static createLocal() {
    return new DefaultEntityPresentationApi({
      renderer: createDefaultRenderer({ async: false })
    });
  }
  /**
   * Creates a new presentation API that calls out to the catalog as needed to
   * get additional information about entities.
   */
  static create(options) {
    return new DefaultEntityPresentationApi(options);
  }
  // This cache holds on to all entity data ever loaded, no matter how old. Each
  // entry is tagged with a timestamp of when it was inserted. We use this map
  // to be able to always render SOME data even though the information is old.
  // Entities change very rarely, so it's likely that the rendered information
  // was perfectly fine in the first place.
  #cache;
  #cacheTtlMs;
  #loader;
  #kindIcons;
  // lowercased kinds
  #renderer;
  constructor(options) {
    const cacheTtl = options.cacheTtl ?? DEFAULT_CACHE_TTL;
    const batchDelay = options.batchDelay ?? DEFAULT_BATCH_DELAY;
    const renderer = options.renderer ?? createDefaultRenderer({ async: true });
    const kindIcons = {};
    Object.entries(DEFAULT_ICONS).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    Object.entries(options.kindIcons ?? {}).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    if (renderer.async) {
      if (!options.catalogApi) {
        throw new TypeError(`Asynchronous rendering requires a catalog API`);
      }
      this.#loader = this.#createLoader({
        cacheTtl,
        batchDelay,
        renderer,
        catalogApi: options.catalogApi
      });
    }
    this.#cacheTtlMs = durationToMilliseconds(cacheTtl);
    this.#cache = /* @__PURE__ */ new Map();
    this.#kindIcons = kindIcons;
    this.#renderer = renderer;
  }
  /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */
  forEntity(entityOrRef, context) {
    const { entityRef, kind, entity, needsLoad } = this.#getEntityForInitialRender(entityOrRef);
    const render = (options) => {
      const { snapshot } = this.#renderer.render({
        entityRef,
        loading: options.loading,
        entity: options.entity,
        context: context || {}
      });
      return {
        ...snapshot,
        entityRef,
        Icon: this.#maybeFallbackIcon(snapshot.Icon, kind)
      };
    };
    let initialSnapshot;
    try {
      initialSnapshot = render({
        loading: needsLoad,
        entity
      });
    } catch {
      initialSnapshot = {
        primaryTitle: entityRef,
        entityRef
      };
    }
    if (!needsLoad) {
      return {
        snapshot: initialSnapshot,
        promise: Promise.resolve(initialSnapshot)
      };
    }
    const maybeUpdatedSnapshot = Promise.resolve().then(() => {
      return this.#loader?.load(entityRef);
    }).then((newEntity) => {
      return render({
        loading: false,
        entity: newEntity ?? entity
      });
    }).catch(() => {
      return void 0;
    });
    const observable = new ObservableImpl(
      (subscriber) => {
        let aborted = false;
        maybeUpdatedSnapshot.then((updatedSnapshot) => {
          if (updatedSnapshot) {
            subscriber.next(updatedSnapshot);
          }
        }).finally(() => {
          if (!aborted) {
            subscriber.complete();
          }
        });
        return () => {
          aborted = true;
        };
      }
    );
    const promise = maybeUpdatedSnapshot.then((updatedSnapshot) => {
      return updatedSnapshot ?? initialSnapshot;
    });
    return {
      snapshot: initialSnapshot,
      update$: observable,
      promise
    };
  }
  #getEntityForInitialRender(entityOrRef) {
    if (typeof entityOrRef !== "string") {
      return {
        entity: entityOrRef,
        kind: entityOrRef.kind,
        entityRef: stringifyEntityRef(entityOrRef),
        needsLoad: false
      };
    }
    const cached = this.#cache.get(entityOrRef);
    const cachedEntity = cached?.entity;
    const cacheNeedsUpdate = !cached || Date.now() - cached.updatedAt > this.#cacheTtlMs;
    const needsLoad = cacheNeedsUpdate && this.#renderer.async !== false && this.#loader !== void 0;
    return {
      entity: cachedEntity,
      kind: parseEntityRef(entityOrRef).kind,
      entityRef: entityOrRef,
      needsLoad
    };
  }
  #createLoader(options) {
    const cacheTtlMs = durationToMilliseconds(options.cacheTtl);
    const batchDelayMs = durationToMilliseconds(options.batchDelay);
    return new DataLoader(
      async (entityRefs) => {
        const { items } = await options.catalogApi.getEntitiesByRefs({
          entityRefs,
          fields: [
            "kind",
            "metadata.name",
            "metadata.namespace",
            "metadata.title",
            "metadata.description",
            "spec.profile.displayName",
            "spec.type"
          ]
        });
        const now = Date.now();
        entityRefs.forEach((entityRef, index) => {
          this.#cache.set(entityRef, {
            updatedAt: now,
            entity: items[index]
          });
        });
        return items;
      },
      {
        name: "DefaultEntityPresentationApi",
        // This cache is the one that the data loader uses internally for
        // memoizing requests; essentially what it achieves is that multiple
        // requests for the same entity ref will be batched up into a single
        // request and then the resulting promises are held on to. We put an
        // expiring map here, which makes it so that it re-fetches data with the
        // expiry cadence of that map. Otherwise it would only fetch a given ref
        // once and then never try again. This cache does therefore not fulfill
        // the same purpose as the one that is in the root of the class.
        cacheMap: new ExpiryMap(cacheTtlMs),
        maxBatchSize: 100,
        batchScheduleFn: batchDelayMs ? (cb) => setTimeout(cb, batchDelayMs) : void 0
      }
    );
  }
  #maybeFallbackIcon(renderedIcon, kind) {
    if (renderedIcon) {
      return renderedIcon;
    } else if (renderedIcon === false) {
      return false;
    }
    return this.#kindIcons[kind.toLocaleLowerCase("en-US")];
  }
}

export { DefaultEntityPresentationApi };
//# sourceMappingURL=DefaultEntityPresentationApi.esm.js.map
