'use strict';

var catalogClient = require('@backstage/catalog-client');
var errors = require('@backstage/errors');
var Router = require('express-promise-router');
var minimatch = require('minimatch');
var CatalogAuthResolverContext = require('../lib/resolvers/CatalogAuthResolverContext.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

function bindProviderRouters(targetRouter, options) {
  const {
    providers,
    appUrl,
    baseUrl,
    config,
    logger,
    discovery,
    auth,
    httpAuth,
    tokenManager,
    tokenIssuer,
    catalogApi,
    ownershipResolver
  } = options;
  const providersConfig = config.getOptionalConfig("auth.providers");
  const isOriginAllowed = createOriginFilter(config);
  for (const [providerId, providerFactory] of Object.entries(providers)) {
    if (providersConfig?.has(providerId)) {
      logger.info(`Configuring auth provider: ${providerId}`);
      try {
        const provider = providerFactory({
          providerId,
          appUrl,
          baseUrl,
          isOriginAllowed,
          globalConfig: {
            baseUrl,
            appUrl,
            isOriginAllowed
          },
          config: providersConfig.getConfig(providerId),
          logger,
          resolverContext: CatalogAuthResolverContext.CatalogAuthResolverContext.create({
            logger,
            catalogApi: catalogApi ?? new catalogClient.CatalogClient({ discoveryApi: discovery }),
            tokenIssuer,
            tokenManager,
            discovery,
            auth,
            httpAuth,
            ownershipResolver
          })
        });
        const r = Router__default.default();
        r.get("/start", provider.start.bind(provider));
        r.get("/handler/frame", provider.frameHandler.bind(provider));
        r.post("/handler/frame", provider.frameHandler.bind(provider));
        if (provider.logout) {
          r.post("/logout", provider.logout.bind(provider));
        }
        if (provider.refresh) {
          r.get("/refresh", provider.refresh.bind(provider));
          r.post("/refresh", provider.refresh.bind(provider));
        }
        targetRouter.use(`/${providerId}`, r);
      } catch (e) {
        errors.assertError(e);
        if (process.env.NODE_ENV !== "development") {
          throw new Error(
            `Failed to initialize ${providerId} auth provider, ${e.message}`
          );
        }
        logger.warn(`Skipping ${providerId} auth provider, ${e.message}`);
        targetRouter.use(`/${providerId}`, () => {
          throw new errors.NotFoundError(
            `Auth provider registered for '${providerId}' is misconfigured. This could mean the configs under auth.providers.${providerId} are missing or the environment variables used are not defined. Check the auth backend plugin logs when the backend starts to see more details.`
          );
        });
      }
    } else {
      targetRouter.use(`/${providerId}`, () => {
        throw new errors.NotFoundError(
          `No auth provider registered for '${providerId}'`
        );
      });
    }
  }
}
function createOriginFilter(config) {
  const appUrl = config.getString("app.baseUrl");
  const { origin: appOrigin } = new URL(appUrl);
  const allowedOrigins = config.getOptionalStringArray(
    "auth.experimentalExtraAllowedOrigins"
  );
  const allowedOriginPatterns = allowedOrigins?.map(
    (pattern) => new minimatch.Minimatch(pattern, { nocase: true, noglobstar: true })
  ) ?? [];
  return (origin) => {
    if (origin === appOrigin) {
      return true;
    }
    return allowedOriginPatterns.some((pattern) => pattern.match(origin));
  };
}

exports.bindProviderRouters = bindProviderRouters;
exports.createOriginFilter = createOriginFilter;
//# sourceMappingURL=router.cjs.js.map
