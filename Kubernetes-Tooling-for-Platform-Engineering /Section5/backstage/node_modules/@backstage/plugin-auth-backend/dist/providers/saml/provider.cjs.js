'use strict';

var passportSaml = require('@node-saml/passport-saml');
var PassportStrategyHelper = require('../../lib/passport/PassportStrategyHelper.cjs.js');
var authFlowHelpers = require('../../lib/flow/authFlowHelpers.cjs.js');
var createAuthProviderIntegration = require('../createAuthProviderIntegration.cjs.js');
var errors = require('@backstage/errors');
var prepareBackstageIdentityResponse = require('../prepareBackstageIdentityResponse.cjs.js');

class SamlAuthProvider {
  strategy;
  signInResolver;
  authHandler;
  resolverContext;
  appUrl;
  constructor(options) {
    this.appUrl = options.appUrl;
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    const verifier = (profile, done) => {
      done(null, { fullProfile: profile });
    };
    this.strategy = new passportSaml.Strategy(options, verifier, verifier);
  }
  async start(req, res) {
    const { url } = await PassportStrategyHelper.executeRedirectStrategy(req, this.strategy, {});
    res.redirect(url);
  }
  async frameHandler(req, res) {
    try {
      const { result } = await PassportStrategyHelper.executeFrameHandlerStrategy(
        req,
        this.strategy
      );
      const { profile } = await this.authHandler(result, this.resolverContext);
      const response = {
        profile,
        providerInfo: {}
      };
      if (this.signInResolver) {
        const signInResponse = await this.signInResolver(
          {
            result,
            profile
          },
          this.resolverContext
        );
        response.backstageIdentity = prepareBackstageIdentityResponse.prepareBackstageIdentityResponse(signInResponse);
      }
      return authFlowHelpers.postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        response
      });
    } catch (error) {
      const { name, message } = errors.isError(error) ? error : new Error("Encountered invalid error");
      return authFlowHelpers.postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        error: { name, message }
      });
    }
  }
  async logout(_req, res) {
    res.end();
  }
}
const saml = createAuthProviderIntegration.createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => {
      const authHandler = options?.authHandler ? options.authHandler : async ({ fullProfile }) => ({
        profile: {
          email: fullProfile.email,
          displayName: fullProfile.displayName
        }
      });
      return new SamlAuthProvider({
        callbackUrl: `${globalConfig.baseUrl}/${providerId}/handler/frame`,
        entryPoint: config.getString("entryPoint"),
        logoutUrl: config.getOptionalString("logoutUrl"),
        audience: config.getString("audience"),
        issuer: config.getString("issuer"),
        idpCert: config.getString("cert"),
        privateKey: config.getOptionalString("privateKey"),
        authnContext: config.getOptionalStringArray("authnContext"),
        identifierFormat: config.getOptionalString("identifierFormat"),
        decryptionPvk: config.getOptionalString("decryptionPvk"),
        signatureAlgorithm: config.getOptionalString("signatureAlgorithm"),
        digestAlgorithm: config.getOptionalString("digestAlgorithm"),
        acceptedClockSkewMs: config.getOptionalNumber("acceptedClockSkewMs"),
        wantAuthnResponseSigned: config.getOptionalBoolean(
          "wantAuthnResponseSigned"
        ),
        wantAssertionsSigned: config.getOptionalBoolean("wantAssertionsSigned"),
        appUrl: globalConfig.appUrl,
        authHandler,
        signInResolver: options?.signIn?.resolver,
        resolverContext
      });
    };
  },
  resolvers: {
    /**
     * Looks up the user by matching their nameID to the entity name.
     */
    nameIdMatchingUserEntityName() {
      return async (info, ctx) => {
        const id = info.result.fullProfile.nameID;
        if (!id) {
          throw new errors.AuthenticationError("No nameID found in SAML response");
        }
        return ctx.signInWithCatalogUser({
          entityRef: { name: id }
        });
      };
    }
  }
});

exports.SamlAuthProvider = SamlAuthProvider;
exports.saml = saml;
//# sourceMappingURL=provider.cjs.js.map
