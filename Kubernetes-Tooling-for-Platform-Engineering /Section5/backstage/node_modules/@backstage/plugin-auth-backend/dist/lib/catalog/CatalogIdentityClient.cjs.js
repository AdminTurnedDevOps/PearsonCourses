'use strict';

var errors = require('@backstage/errors');
var catalogModel = require('@backstage/catalog-model');
var backendCommon = require('@backstage/backend-common');

class CatalogIdentityClient {
  catalogApi;
  auth;
  constructor(options) {
    this.catalogApi = options.catalogApi;
    const { auth } = backendCommon.createLegacyAuthAdapters({
      auth: options.auth,
      httpAuth: options.httpAuth,
      discovery: options.discovery,
      tokenManager: options.tokenManager
    });
    this.auth = auth;
  }
  /**
   * Looks up a single user using a query.
   *
   * Throws a NotFoundError or ConflictError if 0 or multiple users are found.
   */
  async findUser(query) {
    const filter = {
      kind: "user"
    };
    for (const [key, value] of Object.entries(query.annotations)) {
      filter[`metadata.annotations.${key}`] = value;
    }
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: await this.auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    const { items } = await this.catalogApi.getEntities({ filter }, { token });
    if (items.length !== 1) {
      if (items.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      } else {
        throw new errors.NotFoundError("User not found");
      }
    }
    return items[0];
  }
  /**
   * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed
   * to be used within a `signInResolver` where additional entity claims might be provided, but
   * group membership and transient group membership lean on imported catalog relations.
   *
   * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.
   */
  async resolveCatalogMembership(query) {
    const { entityRefs, logger } = query;
    const resolvedEntityRefs = entityRefs.map((ref) => {
      try {
        const parsedRef = catalogModel.parseEntityRef(ref.toLocaleLowerCase("en-US"), {
          defaultKind: "user",
          defaultNamespace: "default"
        });
        return parsedRef;
      } catch {
        logger?.warn(`Failed to parse entityRef from ${ref}, ignoring`);
        return null;
      }
    }).filter((ref) => ref !== null);
    const filter = resolvedEntityRefs.map((ref) => ({
      kind: ref.kind,
      "metadata.namespace": ref.namespace,
      "metadata.name": ref.name
    }));
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: await this.auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    const entities = await this.catalogApi.getEntities({ filter }, { token }).then((r) => r.items);
    if (entityRefs.length !== entities.length) {
      const foundEntityNames = entities.map(catalogModel.stringifyEntityRef);
      const missingEntityNames = resolvedEntityRefs.map(catalogModel.stringifyEntityRef).filter((s) => !foundEntityNames.includes(s));
      logger?.debug(`Entities not found for refs ${missingEntityNames.join()}`);
    }
    const memberOf = entities.flatMap(
      (e) => e.relations?.filter((r) => r.type === catalogModel.RELATION_MEMBER_OF).map((r) => r.targetRef) ?? []
    );
    const newEntityRefs = [
      ...new Set(resolvedEntityRefs.map(catalogModel.stringifyEntityRef).concat(memberOf))
    ];
    logger?.debug(`Found catalog membership: ${newEntityRefs.join()}`);
    return newEntityRefs;
  }
}

exports.CatalogIdentityClient = CatalogIdentityClient;
//# sourceMappingURL=CatalogIdentityClient.cjs.js.map
