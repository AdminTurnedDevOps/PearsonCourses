'use strict';

var crypto = require('crypto');
var url = require('url');
var errors = require('@backstage/errors');
var helpers = require('./helpers.cjs.js');
var authFlowHelpers = require('../flow/authFlowHelpers.cjs.js');
var prepareBackstageIdentityResponse = require('../../providers/prepareBackstageIdentityResponse.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const THOUSAND_DAYS_MS = 1e3 * 24 * 60 * 60 * 1e3;
const TEN_MINUTES_MS = 600 * 1e3;
class OAuthAdapter {
  constructor(handlers, options) {
    this.handlers = handlers;
    this.options = options;
    this.baseCookieOptions = {
      httpOnly: true,
      sameSite: "lax"
    };
  }
  static fromConfig(config, handlers, options) {
    const { appUrl, baseUrl, isOriginAllowed } = config;
    const { origin: appOrigin } = new url.URL(appUrl);
    const cookieConfigurer = config.cookieConfigurer ?? helpers.defaultCookieConfigurer;
    return new OAuthAdapter(handlers, {
      ...options,
      appOrigin,
      baseUrl,
      cookieConfigurer,
      isOriginAllowed
    });
  }
  baseCookieOptions;
  async start(req, res) {
    const scope = req.query.scope?.toString() ?? "";
    const env = req.query.env?.toString();
    const origin = req.query.origin?.toString();
    const redirectUrl = req.query.redirectUrl?.toString();
    const flow = req.query.flow?.toString();
    if (!env) {
      throw new errors.InputError("No env provided in request query parameters");
    }
    const cookieConfig = this.getCookieConfig(origin);
    const nonce = crypto__default.default.randomBytes(16).toString("base64");
    this.setNonceCookie(res, nonce, cookieConfig);
    const state = { nonce, env, origin, redirectUrl, flow };
    if (this.options.persistScopes) {
      state.scope = scope;
    }
    const forwardReq = Object.assign(req, { scope, state });
    const { url, status } = await this.handlers.start(
      forwardReq
    );
    res.statusCode = status || 302;
    res.setHeader("Location", url);
    res.setHeader("Content-Length", "0");
    res.end();
  }
  async frameHandler(req, res) {
    let appOrigin = this.options.appOrigin;
    try {
      const state = helpers.readState(req.query.state?.toString() ?? "");
      if (state.origin) {
        try {
          appOrigin = new url.URL(state.origin).origin;
        } catch {
          throw new errors.NotAllowedError("App origin is invalid, failed to parse");
        }
        if (!this.options.isOriginAllowed(appOrigin)) {
          throw new errors.NotAllowedError(`Origin '${appOrigin}' is not allowed`);
        }
      }
      helpers.verifyNonce(req, this.options.providerId);
      const { response, refreshToken } = await this.handlers.handler(req);
      const cookieConfig = this.getCookieConfig(appOrigin);
      if (this.options.persistScopes && state.scope) {
        this.setGrantedScopeCookie(res, state.scope, cookieConfig);
        response.providerInfo.scope = state.scope;
      }
      if (refreshToken) {
        this.setRefreshTokenCookie(res, refreshToken, cookieConfig);
      }
      const identity = await this.populateIdentity(response.backstageIdentity);
      const responseObj = {
        type: "authorization_response",
        response: { ...response, backstageIdentity: identity }
      };
      if (state.flow === "redirect") {
        if (!state.redirectUrl) {
          throw new errors.InputError(
            "No redirectUrl provided in request query parameters"
          );
        }
        res.redirect(state.redirectUrl);
        return void 0;
      }
      return authFlowHelpers.postMessageResponse(res, appOrigin, responseObj);
    } catch (error) {
      const { name, message } = errors.isError(error) ? error : new Error("Encountered invalid error");
      return authFlowHelpers.postMessageResponse(res, appOrigin, {
        type: "authorization_response",
        error: { name, message }
      });
    }
  }
  async logout(req, res) {
    if (!authFlowHelpers.ensuresXRequestedWith(req)) {
      throw new errors.AuthenticationError("Invalid X-Requested-With header");
    }
    if (this.handlers.logout) {
      const refreshToken = this.getRefreshTokenFromCookie(req);
      const revokeRequest = Object.assign(req, {
        refreshToken
      });
      await this.handlers.logout(revokeRequest);
    }
    const origin = req.get("origin");
    const cookieConfig = this.getCookieConfig(origin);
    this.removeRefreshTokenCookie(res, cookieConfig);
    res.status(200).end();
  }
  async refresh(req, res) {
    if (!authFlowHelpers.ensuresXRequestedWith(req)) {
      throw new errors.AuthenticationError("Invalid X-Requested-With header");
    }
    if (!this.handlers.refresh) {
      throw new errors.InputError(
        `Refresh token is not supported for provider ${this.options.providerId}`
      );
    }
    try {
      const refreshToken = this.getRefreshTokenFromCookie(req);
      if (!refreshToken) {
        throw new errors.InputError("Missing session cookie");
      }
      let scope = req.query.scope?.toString() ?? "";
      if (this.options.persistScopes) {
        scope = this.getGrantedScopeFromCookie(req);
      }
      const forwardReq = Object.assign(req, { scope, refreshToken });
      const { response, refreshToken: newRefreshToken } = await this.handlers.refresh(forwardReq);
      const backstageIdentity = await this.populateIdentity(
        response.backstageIdentity
      );
      if (newRefreshToken && newRefreshToken !== refreshToken) {
        const origin = req.get("origin");
        const cookieConfig = this.getCookieConfig(origin);
        this.setRefreshTokenCookie(res, newRefreshToken, cookieConfig);
      }
      res.status(200).json({ ...response, backstageIdentity });
    } catch (error) {
      throw new errors.AuthenticationError("Refresh failed", error);
    }
  }
  /**
   * If the response from the OAuth provider includes a Backstage identity, we
   * make sure it's populated with all the information we can derive from the user ID.
   */
  async populateIdentity(identity) {
    if (!identity) {
      return void 0;
    }
    if (!identity.token) {
      throw new errors.InputError(`Identity response must return a token`);
    }
    return prepareBackstageIdentityResponse.prepareBackstageIdentityResponse(identity);
  }
  setNonceCookie = (res, nonce, cookieConfig) => {
    res.cookie(`${this.options.providerId}-nonce`, nonce, {
      maxAge: TEN_MINUTES_MS,
      ...this.baseCookieOptions,
      ...cookieConfig,
      path: `${cookieConfig.path}/handler`
    });
  };
  setGrantedScopeCookie = (res, scope, cookieConfig) => {
    res.cookie(`${this.options.providerId}-granted-scope`, scope, {
      maxAge: THOUSAND_DAYS_MS,
      ...this.baseCookieOptions,
      ...cookieConfig
    });
  };
  getRefreshTokenFromCookie = (req) => {
    return req.cookies[`${this.options.providerId}-refresh-token`];
  };
  getGrantedScopeFromCookie = (req) => {
    return req.cookies[`${this.options.providerId}-granted-scope`];
  };
  setRefreshTokenCookie = (res, refreshToken, cookieConfig) => {
    res.cookie(`${this.options.providerId}-refresh-token`, refreshToken, {
      maxAge: THOUSAND_DAYS_MS,
      ...this.baseCookieOptions,
      ...cookieConfig
    });
  };
  removeRefreshTokenCookie = (res, cookieConfig) => {
    res.cookie(`${this.options.providerId}-refresh-token`, "", {
      maxAge: 0,
      ...this.baseCookieOptions,
      ...cookieConfig
    });
  };
  getCookieConfig = (origin) => {
    return this.options.cookieConfigurer({
      providerId: this.options.providerId,
      baseUrl: this.options.baseUrl,
      callbackUrl: this.options.callbackUrl,
      appOrigin: origin ?? this.options.appOrigin
    });
  };
}

exports.OAuthAdapter = OAuthAdapter;
exports.TEN_MINUTES_MS = TEN_MINUTES_MS;
exports.THOUSAND_DAYS_MS = THOUSAND_DAYS_MS;
//# sourceMappingURL=OAuthAdapter.cjs.js.map
