'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var CatalogIdentityClient = require('../catalog/CatalogIdentityClient.cjs.js');

function getDefaultOwnershipEntityRefs(entity) {
  const membershipRefs = entity.relations?.filter(
    (r) => r.type === catalogModel.RELATION_MEMBER_OF && r.targetRef.startsWith("group:")
  ).map((r) => r.targetRef) ?? [];
  return Array.from(/* @__PURE__ */ new Set([catalogModel.stringifyEntityRef(entity), ...membershipRefs]));
}
class CatalogAuthResolverContext {
  constructor(logger, tokenIssuer, catalogIdentityClient, catalogApi, auth, ownershipResolver) {
    this.logger = logger;
    this.tokenIssuer = tokenIssuer;
    this.catalogIdentityClient = catalogIdentityClient;
    this.catalogApi = catalogApi;
    this.auth = auth;
    this.ownershipResolver = ownershipResolver;
  }
  static create(options) {
    const catalogIdentityClient = new CatalogIdentityClient.CatalogIdentityClient({
      catalogApi: options.catalogApi,
      tokenManager: options.tokenManager,
      discovery: options.discovery,
      auth: options.auth,
      httpAuth: options.httpAuth
    });
    return new CatalogAuthResolverContext(
      options.logger,
      options.tokenIssuer,
      catalogIdentityClient,
      options.catalogApi,
      options.auth,
      options.ownershipResolver
    );
  }
  async issueToken(params) {
    const token = await this.tokenIssuer.issueToken(params);
    return { token };
  }
  async findCatalogUser(query) {
    let result = void 0;
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: await this.auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    if ("entityRef" in query) {
      const entityRef = catalogModel.parseEntityRef(query.entityRef, {
        defaultKind: "User",
        defaultNamespace: catalogModel.DEFAULT_NAMESPACE
      });
      result = await this.catalogApi.getEntityByRef(entityRef, { token });
    } else if ("annotations" in query) {
      const filter = {
        kind: "user"
      };
      for (const [key, value] of Object.entries(query.annotations)) {
        filter[`metadata.annotations.${key}`] = value;
      }
      const res = await this.catalogApi.getEntities({ filter }, { token });
      result = res.items;
    } else if ("filter" in query) {
      const filter = [query.filter].flat().map((value) => {
        if (!Object.keys(value).some(
          (key) => key.toLocaleLowerCase("en-US") === "kind"
        )) {
          return {
            ...value,
            kind: "user"
          };
        }
        return value;
      });
      const res = await this.catalogApi.getEntities(
        { filter },
        { token }
      );
      result = res.items;
    } else {
      throw new errors.InputError("Invalid user lookup query");
    }
    if (Array.isArray(result)) {
      if (result.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      }
      result = result[0];
    }
    if (!result) {
      throw new errors.NotFoundError("User not found");
    }
    return { entity: result };
  }
  async signInWithCatalogUser(query) {
    const { entity } = await this.findCatalogUser(query);
    let ent;
    if (this.ownershipResolver) {
      const { ownershipEntityRefs } = await this.ownershipResolver.resolveOwnershipEntityRefs(entity);
      ent = ownershipEntityRefs;
    } else {
      ent = getDefaultOwnershipEntityRefs(entity);
    }
    const token = await this.tokenIssuer.issueToken({
      claims: {
        sub: catalogModel.stringifyEntityRef(entity),
        ent
      }
    });
    return { token };
  }
}

exports.CatalogAuthResolverContext = CatalogAuthResolverContext;
exports.getDefaultOwnershipEntityRefs = getDefaultOwnershipEntityRefs;
//# sourceMappingURL=CatalogAuthResolverContext.cjs.js.map
