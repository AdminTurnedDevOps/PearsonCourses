'use strict';

var jose = require('jose');
var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');

const MS_IN_S = 1e3;
class StaticTokenIssuer {
  issuer;
  logger;
  keyStore;
  sessionExpirationSeconds;
  constructor(options, keyStore) {
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.sessionExpirationSeconds = options.sessionExpirationSeconds;
    this.keyStore = keyStore;
  }
  async issueToken(params) {
    const key = await this.getSigningKey();
    const iss = this.issuer;
    const { sub, ent, ...additionalClaims } = params.claims;
    const aud = "backstage";
    const iat = Math.floor(Date.now() / MS_IN_S);
    const exp = iat + this.sessionExpirationSeconds;
    try {
      catalogModel.parseEntityRef(sub);
    } catch (error) {
      throw new Error(
        '"sub" claim provided by the auth resolver is not a valid EntityRef.'
      );
    }
    this.logger.info(`Issuing token for ${sub}, with entities ${ent ?? []}`);
    if (!key.alg) {
      throw new errors.AuthenticationError("No algorithm was provided in the key");
    }
    return new jose.SignJWT({ ...additionalClaims, iss, sub, ent, aud, iat, exp }).setProtectedHeader({ alg: key.alg, kid: key.kid }).setIssuer(iss).setAudience(aud).setSubject(sub).setIssuedAt(iat).setExpirationTime(exp).sign(await jose.importJWK(key));
  }
  async getSigningKey() {
    const { items: keys } = await this.keyStore.listKeys();
    if (keys.length >= 1) {
      return this.keyStore.getPrivateKey(keys[0].key.kid);
    }
    throw new Error("Keystore should hold at least 1 key");
  }
  async listPublicKeys() {
    const { items: keys } = await this.keyStore.listKeys();
    return { keys: keys.map(({ key }) => key) };
  }
}

exports.StaticTokenIssuer = StaticTokenIssuer;
//# sourceMappingURL=StaticTokenIssuer.cjs.js.map
