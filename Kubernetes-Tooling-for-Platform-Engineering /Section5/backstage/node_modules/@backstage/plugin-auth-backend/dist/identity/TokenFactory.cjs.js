'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var jose = require('jose');
var lodash = require('lodash');
var luxon = require('luxon');
var uuid = require('uuid');
var pluginAuthNode = require('@backstage/plugin-auth-node');

const MS_IN_S = 1e3;
const MAX_TOKEN_LENGTH = 32768;
class TokenFactory {
  issuer;
  logger;
  keyStore;
  keyDurationSeconds;
  algorithm;
  userInfoDatabaseHandler;
  keyExpiry;
  privateKeyPromise;
  constructor(options) {
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.keyStore = options.keyStore;
    this.keyDurationSeconds = options.keyDurationSeconds;
    this.algorithm = options.algorithm ?? "ES256";
    this.userInfoDatabaseHandler = options.userInfoDatabaseHandler;
  }
  async issueToken(params) {
    const key = await this.getKey();
    const iss = this.issuer;
    const { sub, ent = [sub], ...additionalClaims } = params.claims;
    const aud = pluginAuthNode.tokenTypes.user.audClaim;
    const iat = Math.floor(Date.now() / MS_IN_S);
    const exp = iat + this.keyDurationSeconds;
    try {
      catalogModel.parseEntityRef(sub);
    } catch (error) {
      throw new Error(
        '"sub" claim provided by the auth resolver is not a valid EntityRef.'
      );
    }
    if (!key.alg) {
      throw new errors.AuthenticationError("No algorithm was provided in the key");
    }
    this.logger.info(`Issuing token for ${sub}, with entities ${ent}`);
    const signingKey = await jose.importJWK(key);
    const uip = await this.createUserIdentityClaim({
      header: {
        typ: pluginAuthNode.tokenTypes.limitedUser.typParam,
        alg: key.alg,
        kid: key.kid
      },
      payload: { sub, iat, exp },
      key: signingKey
    });
    const claims = {
      ...additionalClaims,
      iss,
      sub,
      ent,
      aud,
      iat,
      exp,
      uip
    };
    const token = await new jose.SignJWT(claims).setProtectedHeader({
      typ: pluginAuthNode.tokenTypes.user.typParam,
      alg: key.alg,
      kid: key.kid
    }).sign(signingKey);
    if (token.length > MAX_TOKEN_LENGTH) {
      throw new Error(
        `Failed to issue a new user token. The resulting token is excessively large, with either too many ownership claims or too large custom claims. You likely have a bug either in the sign-in resolver or catalog data. The following claims were requested: '${JSON.stringify(
          claims
        )}'`
      );
    }
    await this.userInfoDatabaseHandler.addUserInfo({
      claims: lodash.omit(claims, ["aud", "iat", "iss", "uip"])
    });
    return token;
  }
  // This will be called by other services that want to verify ID tokens.
  // It is important that it returns a list of all public keys that could
  // have been used to sign tokens that have not yet expired.
  async listPublicKeys() {
    const { items: keys } = await this.keyStore.listKeys();
    const validKeys = [];
    const expiredKeys = [];
    for (const key of keys) {
      const expireAt = luxon.DateTime.fromJSDate(key.createdAt).plus({
        seconds: 3 * this.keyDurationSeconds
      });
      if (expireAt < luxon.DateTime.local()) {
        expiredKeys.push(key);
      } else {
        validKeys.push(key);
      }
    }
    if (expiredKeys.length > 0) {
      const kids = expiredKeys.map(({ key }) => key.kid);
      this.logger.info(`Removing expired signing keys, '${kids.join("', '")}'`);
      this.keyStore.removeKeys(kids).catch((error) => {
        this.logger.error(`Failed to remove expired keys, ${error}`);
      });
    }
    return { keys: validKeys.map(({ key }) => key) };
  }
  async getKey() {
    if (this.privateKeyPromise) {
      if (this.keyExpiry && luxon.DateTime.fromJSDate(this.keyExpiry) > luxon.DateTime.local()) {
        return this.privateKeyPromise;
      }
      this.logger.info(`Signing key has expired, generating new key`);
      delete this.privateKeyPromise;
    }
    this.keyExpiry = luxon.DateTime.utc().plus({
      seconds: this.keyDurationSeconds
    }).toJSDate();
    const promise = (async () => {
      const key = await jose.generateKeyPair(this.algorithm);
      const publicKey = await jose.exportJWK(key.publicKey);
      const privateKey = await jose.exportJWK(key.privateKey);
      publicKey.kid = privateKey.kid = uuid.v4();
      publicKey.alg = privateKey.alg = this.algorithm;
      this.logger.info(`Created new signing key ${publicKey.kid}`);
      await this.keyStore.addKey(publicKey);
      return privateKey;
    })();
    this.privateKeyPromise = promise;
    try {
      await promise;
    } catch (error) {
      this.logger.error(`Failed to generate new signing key, ${error}`);
      delete this.keyExpiry;
      delete this.privateKeyPromise;
    }
    return promise;
  }
  // Creates a string claim that can be used as part of reconstructing a limited
  // user token. The output of this function is only the signature part of a
  // JWS.
  async createUserIdentityClaim(options) {
    const header = {
      typ: options.header.typ,
      alg: options.header.alg,
      ...options.header.kid ? { kid: options.header.kid } : {}
    };
    const payload = {
      sub: options.payload.sub,
      iat: options.payload.iat,
      exp: options.payload.exp
    };
    const jws = await new jose.GeneralSign(
      new TextEncoder().encode(JSON.stringify(payload))
    ).addSignature(options.key).setProtectedHeader(header).done().sign();
    return jws.signatures[0].signature;
  }
}

exports.TokenFactory = TokenFactory;
//# sourceMappingURL=TokenFactory.cjs.js.map
