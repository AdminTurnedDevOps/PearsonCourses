{"version":3,"file":"googleStorage.cjs.js","sources":["../../../src/stages/publish/googleStorage.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Entity, CompoundEntityRef } from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { assertError } from '@backstage/errors';\nimport {\n  File,\n  FileExistsResponse,\n  Storage,\n  StorageOptions,\n} from '@google-cloud/storage';\nimport express from 'express';\nimport JSON5 from 'json5';\nimport path from 'path';\nimport { Readable } from 'stream';\nimport {\n  getFileTreeRecursively,\n  getHeadersForFileExtension,\n  isValidContentPath,\n  lowerCaseEntityTriplet,\n  lowerCaseEntityTripletInStoragePath,\n  bulkStorageOperation,\n  getCloudPathForLocalPath,\n  getStaleFiles,\n  normalizeExternalStorageRootPath,\n} from './helpers';\nimport { MigrateWriteStream } from './migrations';\nimport {\n  PublisherBase,\n  PublishRequest,\n  PublishResponse,\n  ReadinessResponse,\n  TechDocsMetadata,\n} from './types';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\nexport class GoogleGCSPublish implements PublisherBase {\n  private readonly storageClient: Storage;\n  private readonly bucketName: string;\n  private readonly legacyPathCasing: boolean;\n  private readonly logger: LoggerService;\n  private readonly bucketRootPath: string;\n\n  constructor(options: {\n    storageClient: Storage;\n    bucketName: string;\n    legacyPathCasing: boolean;\n    logger: LoggerService;\n    bucketRootPath: string;\n  }) {\n    this.storageClient = options.storageClient;\n    this.bucketName = options.bucketName;\n    this.legacyPathCasing = options.legacyPathCasing;\n    this.logger = options.logger;\n    this.bucketRootPath = options.bucketRootPath;\n  }\n\n  static fromConfig(\n    config: Config,\n    logger: LoggerService,\n    options?: StorageOptions,\n  ): PublisherBase {\n    let bucketName = '';\n    try {\n      bucketName = config.getString('techdocs.publisher.googleGcs.bucketName');\n    } catch (error) {\n      throw new Error(\n        \"Since techdocs.publisher.type is set to 'googleGcs' in your app config, \" +\n          'techdocs.publisher.googleGcs.bucketName is required.',\n      );\n    }\n\n    const bucketRootPath = normalizeExternalStorageRootPath(\n      config.getOptionalString('techdocs.publisher.googleGcs.bucketRootPath') ||\n        '',\n    );\n\n    // Credentials is an optional config. If missing, default GCS environment variables will be used.\n    // Read more here https://cloud.google.com/docs/authentication/production\n    const credentials = config.getOptionalString(\n      'techdocs.publisher.googleGcs.credentials',\n    );\n    const projectId = config.getOptionalString(\n      'techdocs.publisher.googleGcs.projectId',\n    );\n    let credentialsJson: any = {};\n    if (credentials) {\n      try {\n        credentialsJson = JSON.parse(credentials);\n      } catch (err) {\n        throw new Error(\n          'Error in parsing techdocs.publisher.googleGcs.credentials config to JSON.',\n        );\n      }\n    }\n\n    const clientOpts: StorageOptions = options ?? {};\n    if (projectId) {\n      clientOpts.projectId = projectId;\n    }\n\n    const storageClient = new Storage({\n      ...(credentials && {\n        projectId: credentialsJson.project_id,\n        credentials: credentialsJson,\n      }),\n      ...clientOpts,\n    });\n\n    const legacyPathCasing =\n      config.getOptionalBoolean(\n        'techdocs.legacyUseCaseSensitiveTripletPaths',\n      ) || false;\n\n    return new GoogleGCSPublish({\n      storageClient,\n      bucketName,\n      legacyPathCasing,\n      logger,\n      bucketRootPath,\n    });\n  }\n\n  /**\n   * Check if the defined bucket exists. Being able to connect means the configuration is good\n   * and the storage client will work.\n   */\n  async getReadiness(): Promise<ReadinessResponse> {\n    try {\n      await this.storageClient.bucket(this.bucketName).getMetadata();\n      this.logger.info(\n        `Successfully connected to the GCS bucket ${this.bucketName}.`,\n      );\n\n      return {\n        isAvailable: true,\n      };\n    } catch (err) {\n      assertError(err);\n      this.logger.error(\n        `Could not retrieve metadata about the GCS bucket ${this.bucketName}. ` +\n          'Make sure the bucket exists. Also make sure that authentication is setup either by explicitly defining ' +\n          'techdocs.publisher.googleGcs.credentials in app config or by using environment variables. ' +\n          'Refer to https://backstage.io/docs/features/techdocs/using-cloud-storage',\n      );\n      this.logger.error(`from GCS client library: ${err.message}`);\n\n      return { isAvailable: false };\n    }\n  }\n\n  /**\n   * Upload all the files from the generated `directory` to the GCS bucket.\n   * Directory structure used in the bucket is - entityNamespace/entityKind/entityName/index.html\n   */\n  async publish({\n    entity,\n    directory,\n  }: PublishRequest): Promise<PublishResponse> {\n    const objects: string[] = [];\n    const useLegacyPathCasing = this.legacyPathCasing;\n    const bucket = this.storageClient.bucket(this.bucketName);\n    const bucketRootPath = this.bucketRootPath;\n\n    // First, try to retrieve a list of all individual files currently existing\n    let existingFiles: string[] = [];\n    try {\n      const remoteFolder = getCloudPathForLocalPath(\n        entity,\n        undefined,\n        useLegacyPathCasing,\n        bucketRootPath,\n      );\n      existingFiles = await this.getFilesForFolder(remoteFolder);\n    } catch (e) {\n      assertError(e);\n      this.logger.error(\n        `Unable to list files for Entity ${entity.metadata.name}: ${e.message}`,\n      );\n    }\n\n    // Then, merge new files into the same folder\n    let absoluteFilesToUpload;\n    try {\n      // Remove the absolute path prefix of the source directory\n      // Path of all files to upload, relative to the root of the source directory\n      // e.g. ['index.html', 'sub-page/index.html', 'assets/images/favicon.png']\n      absoluteFilesToUpload = await getFileTreeRecursively(directory);\n\n      await bulkStorageOperation(\n        async absoluteFilePath => {\n          const relativeFilePath = path.relative(directory, absoluteFilePath);\n          const destination = getCloudPathForLocalPath(\n            entity,\n            relativeFilePath,\n            useLegacyPathCasing,\n            bucketRootPath,\n          );\n          objects.push(destination);\n          return await bucket.upload(absoluteFilePath, { destination });\n        },\n        absoluteFilesToUpload,\n        { concurrencyLimit: 10 },\n      );\n\n      this.logger.info(\n        `Successfully uploaded all the generated files for Entity ${entity.metadata.name}. Total number of files: ${absoluteFilesToUpload.length}`,\n      );\n    } catch (e) {\n      const errorMessage = `Unable to upload file(s) to Google Cloud Storage. ${e}`;\n      this.logger.error(errorMessage);\n      throw new Error(errorMessage);\n    }\n\n    // Last, try to remove the files that were *only* present previously\n    try {\n      const relativeFilesToUpload = absoluteFilesToUpload.map(\n        absoluteFilePath =>\n          getCloudPathForLocalPath(\n            entity,\n            path.relative(directory, absoluteFilePath),\n            useLegacyPathCasing,\n            bucketRootPath,\n          ),\n      );\n      const staleFiles = getStaleFiles(relativeFilesToUpload, existingFiles);\n\n      await bulkStorageOperation(\n        async relativeFilePath => {\n          return await bucket.file(relativeFilePath).delete();\n        },\n        staleFiles,\n        { concurrencyLimit: 10 },\n      );\n\n      this.logger.info(\n        `Successfully deleted stale files for Entity ${entity.metadata.name}. Total number of files: ${staleFiles.length}`,\n      );\n    } catch (error) {\n      const errorMessage = `Unable to delete file(s) from Google Cloud Storage. ${error}`;\n      this.logger.error(errorMessage);\n    }\n\n    return { objects };\n  }\n\n  fetchTechDocsMetadata(\n    entityName: CompoundEntityRef,\n  ): Promise<TechDocsMetadata> {\n    return new Promise((resolve, reject) => {\n      const entityTriplet = `${entityName.namespace}/${entityName.kind}/${entityName.name}`;\n      const entityDir = this.legacyPathCasing\n        ? entityTriplet\n        : lowerCaseEntityTriplet(entityTriplet);\n\n      const entityRootDir = path.posix.join(this.bucketRootPath, entityDir);\n      if (!isValidContentPath(this.bucketRootPath, entityRootDir)) {\n        this.logger.error(\n          `Invalid content path found while fetching TechDocs metadata: ${entityRootDir}`,\n        );\n        reject(new Error(`Metadata Not Found`));\n      }\n\n      const fileStreamChunks: Array<any> = [];\n      this.storageClient\n        .bucket(this.bucketName)\n        .file(`${entityRootDir}/techdocs_metadata.json`)\n        .createReadStream()\n        .on('error', err => {\n          this.logger.error(err.message);\n          reject(err);\n        })\n        .on('data', chunk => {\n          fileStreamChunks.push(chunk);\n        })\n        .on('end', () => {\n          const techdocsMetadataJson =\n            Buffer.concat(fileStreamChunks).toString('utf-8');\n          resolve(JSON5.parse(techdocsMetadataJson));\n        });\n    });\n  }\n\n  /**\n   * Express route middleware to serve static files on a route in techdocs-backend.\n   */\n  docsRouter(): express.Handler {\n    return (req, res) => {\n      const decodedUri = decodeURI(req.path.replace(/^\\//, ''));\n\n      // filePath example - /default/component/documented-component/index.html\n      const filePathNoRoot = this.legacyPathCasing\n        ? decodedUri\n        : lowerCaseEntityTripletInStoragePath(decodedUri);\n\n      // Prepend the root path to the relative file path\n      const filePath = path.posix.join(this.bucketRootPath, filePathNoRoot);\n      if (!isValidContentPath(this.bucketRootPath, filePath)) {\n        this.logger.error(\n          `Attempted to fetch TechDocs content for a file outside of the bucket root: ${filePathNoRoot}`,\n        );\n        res.status(404).send('File Not Found');\n        return;\n      }\n\n      // Files with different extensions (CSS, HTML) need to be served with different headers\n      const fileExtension = path.extname(filePath);\n      const responseHeaders = getHeadersForFileExtension(fileExtension);\n\n      // Pipe file chunks directly from storage to client.\n      this.storageClient\n        .bucket(this.bucketName)\n        .file(filePath)\n        .createReadStream()\n        .on('pipe', () => {\n          res.writeHead(200, responseHeaders);\n        })\n        .on('error', err => {\n          this.logger.warn(\n            `TechDocs Google GCS router failed to serve content from bucket ${this.bucketName} at path ${filePath}: ${err.message}`,\n          );\n          // Send a 404 with a meaningful message if possible.\n          if (!res.headersSent) {\n            res.status(404).send('File Not Found');\n          } else {\n            res.destroy();\n          }\n        })\n        .pipe(res);\n    };\n  }\n\n  /**\n   * A helper function which checks if index.html of an Entity's docs site is available. This\n   * can be used to verify if there are any pre-generated docs available to serve.\n   */\n  async hasDocsBeenGenerated(entity: Entity): Promise<boolean> {\n    return new Promise(resolve => {\n      const entityTriplet = `${entity.metadata.namespace}/${entity.kind}/${entity.metadata.name}`;\n      const entityDir = this.legacyPathCasing\n        ? entityTriplet\n        : lowerCaseEntityTriplet(entityTriplet);\n\n      const entityRootDir = path.posix.join(this.bucketRootPath, entityDir);\n      if (!isValidContentPath(this.bucketRootPath, entityRootDir)) {\n        this.logger.error(\n          `Invalid content path found while checking if docs have been generated: ${entityRootDir}`,\n        );\n        resolve(false);\n      }\n\n      this.storageClient\n        .bucket(this.bucketName)\n        .file(`${entityRootDir}/index.html`)\n        .exists()\n        .then((response: FileExistsResponse) => {\n          resolve(response[0]);\n        })\n        .catch(() => {\n          resolve(false);\n        });\n    });\n  }\n\n  migrateDocsCase({ removeOriginal = false, concurrency = 25 }): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Iterate through every file in the root of the publisher.\n      const allFileMetadata: Readable = this.storageClient\n        .bucket(this.bucketName)\n        .getFilesStream();\n      const migrateFiles = new MigrateWriteStream(\n        this.logger,\n        removeOriginal,\n        concurrency,\n      );\n      migrateFiles.on('finish', resolve).on('error', reject);\n      allFileMetadata.pipe(migrateFiles).on('error', error => {\n        migrateFiles.destroy();\n        reject(error);\n      });\n    });\n  }\n\n  private getFilesForFolder(folder: string): Promise<string[]> {\n    const fileMetadataStream: Readable = this.storageClient\n      .bucket(this.bucketName)\n      .getFilesStream({ prefix: folder });\n\n    return new Promise((resolve, reject) => {\n      const files: string[] = [];\n\n      fileMetadataStream.on('error', error => {\n        // push file to file array\n        reject(error);\n      });\n\n      fileMetadataStream.on('data', (file: File) => {\n        // push file to file array\n        files.push(file.name);\n      });\n\n      fileMetadataStream.on('end', () => {\n        // resolve promise\n        resolve(files);\n      });\n    });\n  }\n}\n"],"names":["normalizeExternalStorageRootPath","Storage","assertError","getCloudPathForLocalPath","getFileTreeRecursively","bulkStorageOperation","path","getStaleFiles","lowerCaseEntityTriplet","isValidContentPath","JSON5","lowerCaseEntityTripletInStoragePath","getHeadersForFileExtension","MigrateWriteStream"],"mappings":"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"}