{"version":3,"file":"helpers.cjs.js","sources":["../../../src/stages/publish/helpers.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Entity, DEFAULT_NAMESPACE } from '@backstage/catalog-model';\nimport mime from 'mime-types';\nimport path from 'path';\nimport createLimiter from 'p-limit';\nimport recursiveReadDir from 'recursive-readdir';\n\n/**\n * Helper to get the expected content-type for a given file extension. Also\n * takes XSS mitigation into account.\n */\nconst getContentTypeForExtension = (ext: string): string => {\n  const defaultContentType = 'text/plain; charset=utf-8';\n  const excludedTypes = [\n    'text/html',\n    'text/xml',\n    'image/svg+xml',\n    'text/xsl',\n    'application/vnd.wap.xhtml+xml',\n    'multipart/x-mixed-replace',\n    'text/rdf',\n    'application/mathml+xml',\n    'application/octet-stream',\n    'application/rdf+xml',\n    'application/xhtml+xml',\n    'application/xml',\n    'text/cache-manifest',\n    'text/vtt',\n  ];\n\n  // Prevent sanitization bypass by preventing browsers from directly rendering\n  // the contents of untrusted files.\n  if (\n    ext.match(\n      /htm|xml|svg|appcache|manifest|mathml|owl|rdf|rng|vtt|xht|xsd|xsl/i,\n    )\n  ) {\n    return defaultContentType;\n  }\n\n  // Check again to make sure that the content type is not in the excluded mime-type list\n  // We use .lookup here to avoid the \"; charset=...\" addition\n  const contentType = mime.lookup(ext);\n  if (contentType && excludedTypes.includes(contentType)) {\n    return defaultContentType;\n  }\n\n  return mime.contentType(ext) || defaultContentType;\n};\n\nexport type responseHeadersType = {\n  'Content-Type': string;\n};\n\n/**\n * Some files need special headers to be used correctly by the frontend. This function\n * generates headers in the response to those file requests.\n * @param fileExtension - .html, .css, .js, .png etc.\n */\nexport const getHeadersForFileExtension = (\n  fileExtension: string,\n): responseHeadersType => {\n  return {\n    'Content-Type': getContentTypeForExtension(fileExtension),\n  };\n};\n\n/**\n * Recursively traverse all the sub-directories of a path and return\n * a list of absolute paths of all the files. e.g. tree command in Unix\n *\n * @example\n *\n * /User/username/my_dir\n *     dirA\n *     |   subDirA\n *     |   |   file1\n *     EmptyDir\n *     dirB\n *     |   file2\n *     file3\n *\n * getFileListRecursively('/Users/username/myDir')\n * // returns\n * [\n *   '/User/username/my_dir/dirA/subDirA/file1',\n *   '/User/username/my_dir/dirB/file2',\n *   '/User/username/my_dir/file3'\n * ]\n * @param rootDirPath - Absolute path to the root directory.\n */\nexport const getFileTreeRecursively = async (\n  rootDirPath: string,\n): Promise<string[]> => {\n  // Iterate on all the files in the directory and its sub-directories\n  const fileList = await recursiveReadDir(rootDirPath).catch(error => {\n    throw new Error(`Failed to read template directory: ${error.message}`);\n  });\n  return fileList;\n};\n\n/**\n * Takes a posix path and returns a lower-cased version of entity's triplet\n * with the remaining path in posix.\n *\n * Path must not include a starting slash.\n *\n * @example\n * lowerCaseEntityTriplet('default/Component/backstage')\n * // return default/component/backstage\n */\nexport const lowerCaseEntityTriplet = (posixPath: string): string => {\n  const [namespace, kind, name, ...rest] = posixPath.split(path.posix.sep);\n  const lowerNamespace = namespace.toLowerCase();\n  const lowerKind = kind.toLowerCase();\n  const lowerName = name.toLowerCase();\n  return [lowerNamespace, lowerKind, lowerName, ...rest].join(path.posix.sep);\n};\n\n/**\n * Takes either a win32 or posix path and returns a lower-cased version of entity's triplet\n * with the remaining path in posix.\n *\n * Starting slashes will be trimmed.\n *\n * Throws an error if the path does not appear to be an entity triplet.\n *\n * @example\n * lowerCaseEntityTripletInStoragePath('/default/Component/backstage/file.txt')\n * // return default/component/backstage/file.txt\n */\nexport const lowerCaseEntityTripletInStoragePath = (\n  originalPath: string,\n): string => {\n  let posixPath = originalPath;\n  if (originalPath.includes(path.win32.sep)) {\n    posixPath = originalPath.split(path.win32.sep).join(path.posix.sep);\n  }\n\n  // remove leading slash\n  const parts = posixPath.split(path.posix.sep);\n  if (parts[0] === '') {\n    parts.shift();\n  }\n\n  // check if all parts of the entity exist (name, namespace, kind) plus filename\n  if (parts.length <= 3) {\n    throw new Error(\n      `Encountered file unmanaged by TechDocs ${originalPath}. Skipping.`,\n    );\n  }\n\n  return lowerCaseEntityTriplet(parts.join(path.posix.sep));\n};\n\n/**\n * Take a posix path and return a path without leading and trailing\n * separators\n *\n * @example\n * normalizeExternalStorageRootPath('/backstage-data/techdocs/')\n * // return backstage-data/techdocs\n */\nexport const normalizeExternalStorageRootPath = (posixPath: string): string => {\n  // remove leading slash\n  let normalizedPath = posixPath;\n  if (posixPath.startsWith(path.posix.sep)) {\n    normalizedPath = posixPath.slice(1);\n  }\n\n  // remove trailing slash\n  if (normalizedPath.endsWith(path.posix.sep)) {\n    normalizedPath = normalizedPath.slice(0, normalizedPath.length - 1);\n  }\n\n  return normalizedPath;\n};\n\n// Only returns the files that existed previously and are not present anymore.\nexport const getStaleFiles = (\n  newFiles: string[],\n  oldFiles: string[],\n): string[] => {\n  const staleFiles = new Set(oldFiles);\n  const removedParentDirs = new Set();\n  newFiles.forEach(newFile => {\n    staleFiles.delete(newFile);\n\n    // We have to traverse through the directory hierarchy of a new file and\n    // ensure that we won't try to delete one of the parent directories.\n    let parentDir = newFile.substring(0, newFile.lastIndexOf('/'));\n    while (\n      !removedParentDirs.has(parentDir) &&\n      parentDir.length >= newFile.indexOf('/')\n    ) {\n      staleFiles.delete(parentDir);\n      removedParentDirs.add(parentDir);\n      parentDir = parentDir.substring(0, parentDir.lastIndexOf('/'));\n    }\n  });\n  return Array.from(staleFiles);\n};\n\n// Compose actual filename on remote bucket including entity information\nexport const getCloudPathForLocalPath = (\n  entity: Entity,\n  localPath = '',\n  useLegacyPathCasing = false,\n  externalStorageRootPath = '',\n): string => {\n  // Convert destination file path to a POSIX path for uploading.\n  // GCS expects / as path separator and relativeFilePath will contain \\\\ on Windows.\n  // https://cloud.google.com/storage/docs/gsutil/addlhelp/HowSubdirectoriesWork\n  const relativeFilePathPosix = localPath.split(path.sep).join(path.posix.sep);\n\n  // The / delimiter is intentional since it represents the cloud storage and not the local file system.\n  const entityRootDir = `${entity.metadata?.namespace ?? DEFAULT_NAMESPACE}/${\n    entity.kind\n  }/${entity.metadata.name}`;\n\n  const relativeFilePathTriplet = `${entityRootDir}/${relativeFilePathPosix}`;\n\n  const destination = useLegacyPathCasing\n    ? relativeFilePathTriplet\n    : lowerCaseEntityTriplet(relativeFilePathTriplet);\n\n  // Again, the / delimiter is intentional, as it represents remote storage.\n  const destinationWithRoot = [\n    // The extra filter prevents unintended double slashes and prefixes.\n    ...externalStorageRootPath.split(path.posix.sep).filter(s => s !== ''),\n    destination,\n  ].join('/');\n\n  return destinationWithRoot; // Remote storage file relative path\n};\n\n// Perform rate limited generic operations by passing a function and a list of arguments\nexport const bulkStorageOperation = async <T>(\n  operation: (arg: T) => Promise<unknown>,\n  args: T[],\n  { concurrencyLimit } = { concurrencyLimit: 25 },\n) => {\n  const limiter = createLimiter(concurrencyLimit);\n  await Promise.all(args.map(arg => limiter(operation, arg)));\n};\n\n// Checks content path is the same as or a child path of bucketRoot, specifically for posix paths.\nexport const isValidContentPath = (\n  bucketRoot: string,\n  contentPath: string,\n): boolean => {\n  const relativePath = path.posix.relative(bucketRoot, contentPath);\n  if (relativePath === '') {\n    // The same directory\n    return true;\n  }\n\n  const outsideBase = relativePath.startsWith('..'); // not outside base\n  const differentDrive = path.posix.isAbsolute(relativePath); // on Windows, this means dir is on a different drive from base.\n\n  return !outsideBase && !differentDrive;\n};\n"],"names":["mime","recursiveReadDir","path","DEFAULT_NAMESPACE","createLimiter"],"mappings":"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"}