{"version":3,"file":"url.cjs.js","sources":["../../../src/stages/prepare/url.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { Entity } from '@backstage/catalog-model';\nimport { getDocFilesFromRepository } from '../../helpers';\nimport {\n  PreparerBase,\n  PreparerConfig,\n  PreparerOptions,\n  PreparerResponse,\n} from './types';\nimport { LoggerService, UrlReaderService } from '@backstage/backend-plugin-api';\n\n/**\n * Preparer used to retrieve documentation files from a remote repository\n * @public\n */\nexport class UrlPreparer implements PreparerBase {\n  private readonly logger: LoggerService;\n  private readonly reader: UrlReaderService;\n\n  /**\n   * Returns a directory preparer instance\n   * @param config - A URL preparer config containing the a logger and reader\n   */\n  static fromConfig(options: PreparerConfig): UrlPreparer {\n    return new UrlPreparer(options.reader, options.logger);\n  }\n\n  private constructor(reader: UrlReaderService, logger: LoggerService) {\n    this.logger = logger;\n    this.reader = reader;\n  }\n\n  /** {@inheritDoc PreparerBase.shouldCleanPreparedDirectory} */\n  shouldCleanPreparedDirectory() {\n    return true;\n  }\n\n  /** {@inheritDoc PreparerBase.prepare} */\n  async prepare(\n    entity: Entity,\n    options?: PreparerOptions,\n  ): Promise<PreparerResponse> {\n    try {\n      return await getDocFilesFromRepository(this.reader, entity, {\n        etag: options?.etag,\n        logger: this.logger,\n      });\n    } catch (error) {\n      assertError(error);\n      // NotModifiedError means that etag based cache is still valid.\n      if (error.name === 'NotModifiedError') {\n        this.logger.debug(`Cache is valid for etag ${options?.etag}`);\n      } else {\n        this.logger.debug(\n          `Unable to fetch files for building docs ${error.message}`,\n        );\n      }\n\n      throw error;\n    }\n  }\n}\n"],"names":["getDocFilesFromRepository","assertError"],"mappings":";;;;;AA+BO,MAAM,WAAoC,CAAA;AAAA,EAC9B,MAAA;AAAA,EACA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,OAAO,WAAW,OAAsC,EAAA;AACtD,IAAA,OAAO,IAAI,WAAA,CAAY,OAAQ,CAAA,MAAA,EAAQ,QAAQ,MAAM,CAAA;AAAA;AACvD,EAEQ,WAAA,CAAY,QAA0B,MAAuB,EAAA;AACnE,IAAA,IAAA,CAAK,MAAS,GAAA,MAAA;AACd,IAAA,IAAA,CAAK,MAAS,GAAA,MAAA;AAAA;AAChB;AAAA,EAGA,4BAA+B,GAAA;AAC7B,IAAO,OAAA,IAAA;AAAA;AACT;AAAA,EAGA,MAAM,OACJ,CAAA,MAAA,EACA,OAC2B,EAAA;AAC3B,IAAI,IAAA;AACF,MAAA,OAAO,MAAMA,iCAAA,CAA0B,IAAK,CAAA,MAAA,EAAQ,MAAQ,EAAA;AAAA,QAC1D,MAAM,OAAS,EAAA,IAAA;AAAA,QACf,QAAQ,IAAK,CAAA;AAAA,OACd,CAAA;AAAA,aACM,KAAO,EAAA;AACd,MAAAC,kBAAA,CAAY,KAAK,CAAA;AAEjB,MAAI,IAAA,KAAA,CAAM,SAAS,kBAAoB,EAAA;AACrC,QAAA,IAAA,CAAK,MAAO,CAAA,KAAA,CAAM,CAA2B,wBAAA,EAAA,OAAA,EAAS,IAAI,CAAE,CAAA,CAAA;AAAA,OACvD,MAAA;AACL,QAAA,IAAA,CAAK,MAAO,CAAA,KAAA;AAAA,UACV,CAAA,wCAAA,EAA2C,MAAM,OAAO,CAAA;AAAA,SAC1D;AAAA;AAGF,MAAM,MAAA,KAAA;AAAA;AACR;AAEJ;;;;"}