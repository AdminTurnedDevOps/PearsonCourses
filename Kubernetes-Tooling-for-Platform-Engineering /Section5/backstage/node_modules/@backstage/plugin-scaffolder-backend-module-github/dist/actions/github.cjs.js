'use strict';

var errors = require('@backstage/errors');
var octokit = require('octokit');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var helpers = require('./helpers.cjs.js');
var inputProperties = require('./inputProperties.cjs.js');
var outputProperties = require('./outputProperties.cjs.js');
var github_examples = require('./github.examples.cjs.js');

function createPublishGithubAction(options) {
  const { integrations, config, githubCredentialsProvider } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:github",
    description: "Initializes a git repository of contents in workspace and publishes it to GitHub.",
    examples: github_examples.examples,
    schema: {
      input: {
        type: "object",
        required: ["repoUrl"],
        properties: {
          repoUrl: inputProperties.repoUrl,
          description: inputProperties.description,
          homepage: inputProperties.homepage,
          access: inputProperties.access,
          bypassPullRequestAllowances: inputProperties.bypassPullRequestAllowances,
          requiredApprovingReviewCount: inputProperties.requiredApprovingReviewCount,
          restrictions: inputProperties.restrictions,
          requireCodeOwnerReviews: inputProperties.requireCodeOwnerReviews,
          dismissStaleReviews: inputProperties.dismissStaleReviews,
          requiredStatusCheckContexts: inputProperties.requiredStatusCheckContexts,
          requireBranchesToBeUpToDate: inputProperties.requireBranchesToBeUpToDate,
          requiredConversationResolution: inputProperties.requiredConversationResolution,
          requireLastPushApproval: inputProperties.requireLastPushApproval,
          repoVisibility: inputProperties.repoVisibility,
          defaultBranch: inputProperties.defaultBranch,
          protectDefaultBranch: inputProperties.protectDefaultBranch,
          protectEnforceAdmins: inputProperties.protectEnforceAdmins,
          deleteBranchOnMerge: inputProperties.deleteBranchOnMerge,
          gitCommitMessage: inputProperties.gitCommitMessage,
          gitAuthorName: inputProperties.gitAuthorName,
          gitAuthorEmail: inputProperties.gitAuthorEmail,
          allowMergeCommit: inputProperties.allowMergeCommit,
          allowSquashMerge: inputProperties.allowSquashMerge,
          squashMergeCommitTitle: inputProperties.squashMergeCommitTitle,
          squashMergeCommitMessage: inputProperties.squashMergeCommitMessage,
          allowRebaseMerge: inputProperties.allowRebaseMerge,
          allowAutoMerge: inputProperties.allowAutoMerge,
          sourcePath: inputProperties.sourcePath,
          collaborators: inputProperties.collaborators,
          hasProjects: inputProperties.hasProjects,
          hasWiki: inputProperties.hasWiki,
          hasIssues: inputProperties.hasIssues,
          token: inputProperties.token,
          topics: inputProperties.topics,
          repoVariables: inputProperties.repoVariables,
          secrets: inputProperties.secrets,
          oidcCustomization: inputProperties.oidcCustomization,
          requiredCommitSigning: inputProperties.requiredCommitSigning,
          requiredLinearHistory: inputProperties.requiredLinearHistory,
          customProperties: inputProperties.customProperties
        }
      },
      output: {
        type: "object",
        properties: {
          remoteUrl: outputProperties.remoteUrl,
          repoContentsUrl: outputProperties.repoContentsUrl,
          commitHash: outputProperties.commitHash
        }
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        homepage,
        access,
        requireCodeOwnerReviews = false,
        dismissStaleReviews = false,
        bypassPullRequestAllowances,
        requiredApprovingReviewCount = 1,
        restrictions,
        requiredStatusCheckContexts = [],
        requireBranchesToBeUpToDate = true,
        requiredConversationResolution = false,
        requireLastPushApproval = false,
        repoVisibility = "private",
        defaultBranch = "master",
        protectDefaultBranch = true,
        protectEnforceAdmins = true,
        deleteBranchOnMerge = false,
        gitCommitMessage,
        gitAuthorName,
        gitAuthorEmail,
        allowMergeCommit = true,
        allowSquashMerge = true,
        squashMergeCommitTitle = "COMMIT_OR_PR_TITLE",
        squashMergeCommitMessage = "COMMIT_MESSAGES",
        allowRebaseMerge = true,
        allowAutoMerge = false,
        collaborators,
        hasProjects = void 0,
        hasWiki = void 0,
        hasIssues = void 0,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        token: providedToken,
        customProperties,
        requiredCommitSigning = false,
        requiredLinearHistory = false
      } = ctx.input;
      const octokitOptions = await helpers.getOctokitOptions({
        integrations,
        credentialsProvider: githubCredentialsProvider,
        token: providedToken,
        repoUrl
      });
      const client = new octokit.Octokit(octokitOptions);
      const { owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError("Invalid repository owner provided in repoUrl");
      }
      const newRepo = await helpers.createGithubRepoWithCollaboratorsAndTopics(
        client,
        repo,
        owner,
        repoVisibility,
        description,
        homepage,
        deleteBranchOnMerge,
        allowMergeCommit,
        allowSquashMerge,
        squashMergeCommitTitle,
        squashMergeCommitMessage,
        allowRebaseMerge,
        allowAutoMerge,
        access,
        collaborators,
        hasProjects,
        hasWiki,
        hasIssues,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        customProperties,
        ctx.logger
      );
      const remoteUrl = newRepo.clone_url;
      const repoContentsUrl = `${newRepo.html_url}/blob/${defaultBranch}`;
      const commitResult = await helpers.initRepoPushAndProtect(
        remoteUrl,
        octokitOptions.auth,
        ctx.workspacePath,
        ctx.input.sourcePath,
        defaultBranch,
        protectDefaultBranch,
        protectEnforceAdmins,
        owner,
        client,
        repo,
        requireCodeOwnerReviews,
        bypassPullRequestAllowances,
        requiredApprovingReviewCount,
        restrictions,
        requiredStatusCheckContexts,
        requireBranchesToBeUpToDate,
        requiredConversationResolution,
        requireLastPushApproval,
        config,
        ctx.logger,
        gitCommitMessage,
        gitAuthorName,
        gitAuthorEmail,
        dismissStaleReviews,
        requiredCommitSigning,
        requiredLinearHistory
      );
      ctx.output("commitHash", commitResult?.commitHash);
      ctx.output("remoteUrl", remoteUrl);
      ctx.output("repoContentsUrl", repoContentsUrl);
    }
  });
}

exports.createPublishGithubAction = createPublishGithubAction;
//# sourceMappingURL=github.cjs.js.map
