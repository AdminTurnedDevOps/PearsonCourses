'use strict';

var errors = require('@backstage/errors');
var integration = require('@backstage/integration');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var Sodium = require('libsodium-wrappers');
var gitHelpers = require('./gitHelpers.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Sodium__default = /*#__PURE__*/_interopDefaultCompat(Sodium);

const DEFAULT_TIMEOUT_MS = 6e4;
async function getOctokitOptions(options) {
  const { integrations, credentialsProvider, repoUrl, token } = options;
  const { owner, repo, host } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
  const requestOptions = {
    // set timeout to 60 seconds
    timeout: DEFAULT_TIMEOUT_MS
  };
  if (!owner) {
    throw new errors.InputError(`No owner provided for repo ${repoUrl}`);
  }
  const integrationConfig = integrations.github.byHost(host)?.config;
  if (!integrationConfig) {
    throw new errors.InputError(`No integration for host ${host}`);
  }
  if (token) {
    return {
      auth: token,
      baseUrl: integrationConfig.apiBaseUrl,
      previews: ["nebula-preview"],
      request: requestOptions
    };
  }
  const githubCredentialsProvider = credentialsProvider ?? integration.DefaultGithubCredentialsProvider.fromIntegrations(integrations);
  const { token: credentialProviderToken } = await githubCredentialsProvider.getCredentials({
    url: `https://${host}/${encodeURIComponent(owner)}/${encodeURIComponent(
      repo
    )}`
  });
  if (!credentialProviderToken) {
    throw new errors.InputError(
      `No token available for host: ${host}, with owner ${owner}, and repo ${repo}. Make sure GitHub auth is configured correctly. See https://backstage.io/docs/auth/github/provider for more details.`
    );
  }
  return {
    auth: credentialProviderToken,
    baseUrl: integrationConfig.apiBaseUrl,
    previews: ["nebula-preview"]
  };
}
async function createGithubRepoWithCollaboratorsAndTopics(client, repo, owner, repoVisibility, description, homepage, deleteBranchOnMerge, allowMergeCommit, allowSquashMerge, squashMergeCommitTitle, squashMergeCommitMessage, allowRebaseMerge, allowAutoMerge, access, collaborators, hasProjects, hasWiki, hasIssues, topics, repoVariables, secrets, oidcCustomization, customProperties, logger) {
  const user = await client.rest.users.getByUsername({
    username: owner
  });
  if (access?.startsWith(`${owner}/`)) {
    await validateAccessTeam(client, access);
  }
  const repoCreationPromise = user.data.type === "Organization" ? client.rest.repos.createInOrg({
    name: repo,
    org: owner,
    private: repoVisibility === "private",
    // @ts-ignore https://github.com/octokit/types.ts/issues/522
    visibility: repoVisibility,
    description,
    delete_branch_on_merge: deleteBranchOnMerge,
    allow_merge_commit: allowMergeCommit,
    allow_squash_merge: allowSquashMerge,
    squash_merge_commit_title: squashMergeCommitTitle,
    squash_merge_commit_message: squashMergeCommitMessage,
    allow_rebase_merge: allowRebaseMerge,
    allow_auto_merge: allowAutoMerge,
    homepage,
    has_projects: hasProjects,
    has_wiki: hasWiki,
    has_issues: hasIssues,
    // Custom properties only available on org repos
    custom_properties: customProperties
  }) : client.rest.repos.createForAuthenticatedUser({
    name: repo,
    private: repoVisibility === "private",
    description,
    delete_branch_on_merge: deleteBranchOnMerge,
    allow_merge_commit: allowMergeCommit,
    allow_squash_merge: allowSquashMerge,
    squash_merge_commit_title: squashMergeCommitTitle,
    squash_merge_commit_message: squashMergeCommitMessage,
    allow_rebase_merge: allowRebaseMerge,
    allow_auto_merge: allowAutoMerge,
    homepage,
    has_projects: hasProjects,
    has_wiki: hasWiki,
    has_issues: hasIssues
  });
  let newRepo;
  try {
    newRepo = (await repoCreationPromise).data;
  } catch (e) {
    errors.assertError(e);
    if (e.message === "Resource not accessible by integration") {
      logger.warn(
        `The GitHub app or token provided may not have the required permissions to create the ${user.data.type} repository ${owner}/${repo}.`
      );
    }
    throw new Error(
      `Failed to create the ${user.data.type} repository ${owner}/${repo}, ${e.message}`
    );
  }
  if (access?.startsWith(`${owner}/`)) {
    const [, team] = access.split("/");
    await client.rest.teams.addOrUpdateRepoPermissionsInOrg({
      org: owner,
      team_slug: team,
      owner,
      repo,
      permission: "admin"
    });
  } else if (access && access !== owner) {
    await client.rest.repos.addCollaborator({
      owner,
      repo,
      username: access,
      permission: "admin"
    });
  }
  if (collaborators) {
    for (const collaborator of collaborators) {
      try {
        if ("user" in collaborator) {
          await client.rest.repos.addCollaborator({
            owner,
            repo,
            username: gitHelpers.entityRefToName(collaborator.user),
            permission: collaborator.access
          });
        } else if ("team" in collaborator) {
          await client.rest.teams.addOrUpdateRepoPermissionsInOrg({
            org: owner,
            team_slug: gitHelpers.entityRefToName(collaborator.team),
            owner,
            repo,
            permission: collaborator.access
          });
        }
      } catch (e) {
        errors.assertError(e);
        const name = extractCollaboratorName(collaborator);
        logger.warn(
          `Skipping ${collaborator.access} access for ${name}, ${e.message}`
        );
      }
    }
  }
  if (topics) {
    try {
      await client.rest.repos.replaceAllTopics({
        owner,
        repo,
        names: topics.map((t) => t.toLowerCase())
      });
    } catch (e) {
      errors.assertError(e);
      logger.warn(`Skipping topics ${topics.join(" ")}, ${e.message}`);
    }
  }
  for (const [key, value] of Object.entries(repoVariables ?? {})) {
    await client.rest.actions.createRepoVariable({
      owner,
      repo,
      name: key,
      value
    });
  }
  if (secrets) {
    const publicKeyResponse = await client.rest.actions.getRepoPublicKey({
      owner,
      repo
    });
    await Sodium__default.default.ready;
    const binaryKey = Sodium__default.default.from_base64(
      publicKeyResponse.data.key,
      Sodium__default.default.base64_variants.ORIGINAL
    );
    for (const [key, value] of Object.entries(secrets)) {
      const binarySecret = Sodium__default.default.from_string(value);
      const encryptedBinarySecret = Sodium__default.default.crypto_box_seal(
        binarySecret,
        binaryKey
      );
      const encryptedBase64Secret = Sodium__default.default.to_base64(
        encryptedBinarySecret,
        Sodium__default.default.base64_variants.ORIGINAL
      );
      await client.rest.actions.createOrUpdateRepoSecret({
        owner,
        repo,
        secret_name: key,
        encrypted_value: encryptedBase64Secret,
        key_id: publicKeyResponse.data.key_id
      });
    }
  }
  if (oidcCustomization) {
    await client.request(
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub",
      {
        owner,
        repo,
        use_default: oidcCustomization.useDefault,
        include_claim_keys: oidcCustomization.includeClaimKeys
      }
    );
  }
  return newRepo;
}
async function initRepoPushAndProtect(remoteUrl, password, workspacePath, sourcePath, defaultBranch, protectDefaultBranch, protectEnforceAdmins, owner, client, repo, requireCodeOwnerReviews, bypassPullRequestAllowances, requiredApprovingReviewCount, restrictions, requiredStatusCheckContexts, requireBranchesToBeUpToDate, requiredConversationResolution, requireLastPushApproval, config, logger, gitCommitMessage, gitAuthorName, gitAuthorEmail, dismissStaleReviews, requiredCommitSigning, requiredLinearHistory) {
  const gitAuthorInfo = {
    name: gitAuthorName ? gitAuthorName : config.getOptionalString("scaffolder.defaultAuthor.name"),
    email: gitAuthorEmail ? gitAuthorEmail : config.getOptionalString("scaffolder.defaultAuthor.email")
  };
  const commitMessage = getGitCommitMessage(gitCommitMessage, config) || "initial commit";
  const commitResult = await pluginScaffolderNode.initRepoAndPush({
    dir: pluginScaffolderNode.getRepoSourceDirectory(workspacePath, sourcePath),
    remoteUrl,
    defaultBranch,
    auth: {
      username: "x-access-token",
      password
    },
    logger,
    commitMessage,
    gitAuthorInfo
  });
  if (protectDefaultBranch) {
    try {
      await gitHelpers.enableBranchProtectionOnDefaultRepoBranch({
        owner,
        client,
        repoName: repo,
        logger,
        defaultBranch,
        bypassPullRequestAllowances,
        requiredApprovingReviewCount,
        restrictions,
        requireCodeOwnerReviews,
        requiredStatusCheckContexts,
        requireBranchesToBeUpToDate,
        requiredConversationResolution,
        requireLastPushApproval,
        enforceAdmins: protectEnforceAdmins,
        dismissStaleReviews,
        requiredCommitSigning,
        requiredLinearHistory
      });
    } catch (e) {
      errors.assertError(e);
      logger.warn(
        `Skipping: default branch protection on '${repo}', ${e.message}`
      );
    }
  }
  return { commitHash: commitResult.commitHash };
}
function extractCollaboratorName(collaborator) {
  if ("username" in collaborator) return collaborator.username;
  if ("user" in collaborator) return collaborator.user;
  return collaborator.team;
}
async function validateAccessTeam(client, access) {
  const [org, team_slug] = access.split("/");
  try {
    await client.rest.teams.getByName({
      org,
      team_slug
    });
  } catch (e) {
    if (e.response.data.message === "Not Found") {
      const message = `Received 'Not Found' from the API; one of org:
        ${org} or team: ${team_slug} was not found within GitHub.`;
      throw new errors.NotFoundError(message);
    }
  }
}
function getGitCommitMessage(gitCommitMessage, config) {
  return gitCommitMessage ? gitCommitMessage : config.getOptionalString("scaffolder.defaultCommitMessage");
}

exports.createGithubRepoWithCollaboratorsAndTopics = createGithubRepoWithCollaboratorsAndTopics;
exports.getGitCommitMessage = getGitCommitMessage;
exports.getOctokitOptions = getOctokitOptions;
exports.initRepoPushAndProtect = initRepoPushAndProtect;
//# sourceMappingURL=helpers.cjs.js.map
