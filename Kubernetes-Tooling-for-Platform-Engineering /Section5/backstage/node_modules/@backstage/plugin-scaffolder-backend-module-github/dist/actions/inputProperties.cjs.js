'use strict';

const repoUrl = {
  title: "Repository Location",
  description: `Accepts the format 'github.com?repo=reponame&owner=owner' where 'reponame' is the new repository name and 'owner' is an organization or username`,
  type: "string"
};
const description = {
  title: "Repository Description",
  type: "string"
};
const homepage = {
  title: "Repository Homepage",
  type: "string"
};
const access = {
  title: "Repository Access",
  description: `Sets an admin collaborator on the repository. Can either be a user reference different from 'owner' in 'repoUrl' or team reference, eg. 'org/team-name'`,
  type: "string"
};
const requireCodeOwnerReviews = {
  title: "Require CODEOWNER Reviews?",
  description: "Require an approved review in PR including files with a designated Code Owner",
  type: "boolean"
};
const dismissStaleReviews = {
  title: "Dismiss Stale Reviews",
  description: "New reviewable commits pushed to a matching branch will dismiss pull request review approvals.",
  type: "boolean"
};
const requiredStatusCheckContexts = {
  title: "Required Status Check Contexts",
  description: "The list of status checks to require in order to merge into this branch",
  type: "array",
  items: {
    type: "string"
  }
};
const requireBranchesToBeUpToDate = {
  title: "Require Branches To Be Up To Date?",
  description: `Require branches to be up to date before merging. The default value is 'true'`,
  type: "boolean"
};
const requiredConversationResolution = {
  title: "Required Conversation Resolution",
  description: "Requires all conversations on code to be resolved before a pull request can be merged into this branch",
  type: "boolean"
};
const requireLastPushApproval = {
  title: "Require last push approval",
  type: "boolean",
  description: `Whether the most recent push to a PR must be approved by someone other than the person who pushed it. The default value is 'false'`
};
const repoVisibility = {
  title: "Repository Visibility",
  type: "string",
  enum: ["private", "public", "internal"]
};
const deleteBranchOnMerge = {
  title: "Delete Branch On Merge",
  type: "boolean",
  description: `Delete the branch after merging the PR. The default value is 'false'`
};
const gitAuthorName = {
  title: "Default Author Name",
  type: "string",
  description: `Sets the default author name for the commit. The default value is 'Scaffolder'`
};
const gitAuthorEmail = {
  title: "Default Author Email",
  type: "string",
  description: `Sets the default author email for the commit.`
};
const allowMergeCommit = {
  title: "Allow Merge Commits",
  type: "boolean",
  description: `Allow merge commits. The default value is 'true'`
};
const allowSquashMerge = {
  title: "Allow Squash Merges",
  type: "boolean",
  description: `Allow squash merges. The default value is 'true'`
};
const squashMergeCommitTitle = {
  title: "Default squash merge commit title",
  enum: ["PR_TITLE", "COMMIT_OR_PR_TITLE"],
  description: `Sets the default value for a squash merge commit title. The default value is 'COMMIT_OR_PR_TITLE'`
};
const squashMergeCommitMessage = {
  title: "Default squash merge commit message",
  enum: ["PR_BODY", "COMMIT_MESSAGES", "BLANK"],
  description: `Sets the default value for a squash merge commit message. The default value is 'COMMIT_MESSAGES'`
};
const allowRebaseMerge = {
  title: "Allow Rebase Merges",
  type: "boolean",
  description: `Allow rebase merges. The default value is 'true'`
};
const allowAutoMerge = {
  title: "Allow Auto Merges",
  type: "boolean",
  description: `Allow individual PRs to merge automatically when all merge requirements are met. The default value is 'false'`
};
const collaborators = {
  title: "Collaborators",
  description: "Provide additional users or teams with permissions",
  type: "array",
  items: {
    type: "object",
    additionalProperties: false,
    required: ["access"],
    properties: {
      access: {
        type: "string",
        description: "The type of access for the user"
      },
      user: {
        type: "string",
        description: "The name of the user that will be added as a collaborator"
      },
      team: {
        type: "string",
        description: "The name of the team that will be added as a collaborator"
      }
    },
    oneOf: [{ required: ["user"] }, { required: ["team"] }]
  }
};
const hasProjects = {
  title: "Enable projects",
  type: "boolean",
  description: `Enable projects for the repository. The default value is 'true' unless the organization has disabled repository projects`
};
const hasWiki = {
  title: "Enable the wiki",
  type: "boolean",
  description: `Enable the wiki for the repository. The default value is 'true'`
};
const hasIssues = {
  title: "Enable issues",
  type: "boolean",
  description: `Enable issues for the repository. The default value is 'true'`
};
const token = {
  title: "Authentication Token",
  type: "string",
  description: "The token to use for authorization to GitHub"
};
const topics = {
  title: "Topics",
  type: "array",
  items: {
    type: "string"
  }
};
const defaultBranch = {
  title: "Default Branch",
  type: "string",
  description: `Sets the default branch on the repository. The default value is 'master'`
};
const protectDefaultBranch = {
  title: "Protect Default Branch",
  type: "boolean",
  description: `Protect the default branch after creating the repository. The default value is 'true'`
};
const protectEnforceAdmins = {
  title: "Enforce Admins On Protected Branches",
  type: "boolean",
  description: `Enforce admins to adhere to default branch protection. The default value is 'true'`
};
const bypassPullRequestAllowances = {
  title: "Bypass pull request requirements",
  description: "Allow specific users, teams, or apps to bypass pull request requirements.",
  type: "object",
  additionalProperties: false,
  properties: {
    apps: {
      type: "array",
      items: {
        type: "string"
      }
    },
    users: {
      type: "array",
      items: {
        type: "string"
      }
    },
    teams: {
      type: "array",
      items: {
        type: "string"
      }
    }
  }
};
const gitCommitMessage = {
  title: "Git Commit Message",
  type: "string",
  description: `Sets the commit message on the repository. The default value is 'initial commit'`
};
const sourcePath = {
  title: "Source Path",
  description: "Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.",
  type: "string"
};
const requiredApprovingReviewCount = {
  title: "Required approving review count",
  type: "number",
  description: `Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers. Defaults to 1.`
};
const restrictions = {
  title: "Restrict who can push to the protected branch",
  description: "Restrict who can push to the protected branch. User, app, and team restrictions are only available for organization-owned repositories.",
  type: "object",
  additionalProperties: false,
  properties: {
    apps: {
      type: "array",
      items: {
        type: "string"
      }
    },
    users: {
      type: "array",
      items: {
        type: "string"
      }
    },
    teams: {
      type: "array",
      items: {
        type: "string"
      }
    }
  }
};
const requiredCommitSigning = {
  title: "Require commit signing",
  type: "boolean",
  description: `Require commit signing so that you must sign commits on this branch.`
};
const requiredLinearHistory = {
  title: "Require linear history",
  type: "boolean",
  description: `Prevent merge commits from being pushed to matching branches.`
};
const repoVariables = {
  title: "Repository Variables",
  description: `Variables attached to the repository`,
  type: "object"
};
const secrets = {
  title: "Repository Secrets",
  description: `Secrets attached to the repository`,
  type: "object"
};
const oidcCustomization = {
  title: "Repository OIDC customization template",
  description: `OIDC customization template attached to the repository.`,
  type: "object",
  additionalProperties: false,
  properties: {
    useDefault: {
      title: "Use Default",
      type: "boolean",
      description: `Whether to use the default OIDC template or not.`
    },
    includeClaimKeys: {
      title: "Include claim keys",
      type: "array",
      items: {
        type: "string"
      },
      description: `Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.`
    }
  }
};
const customProperties = {
  title: "Custom Repository Properties",
  description: "Custom properties to be added to the repository (note, this only works for organization repositories)",
  type: "object"
};

exports.access = access;
exports.allowAutoMerge = allowAutoMerge;
exports.allowMergeCommit = allowMergeCommit;
exports.allowRebaseMerge = allowRebaseMerge;
exports.allowSquashMerge = allowSquashMerge;
exports.bypassPullRequestAllowances = bypassPullRequestAllowances;
exports.collaborators = collaborators;
exports.customProperties = customProperties;
exports.defaultBranch = defaultBranch;
exports.deleteBranchOnMerge = deleteBranchOnMerge;
exports.description = description;
exports.dismissStaleReviews = dismissStaleReviews;
exports.gitAuthorEmail = gitAuthorEmail;
exports.gitAuthorName = gitAuthorName;
exports.gitCommitMessage = gitCommitMessage;
exports.hasIssues = hasIssues;
exports.hasProjects = hasProjects;
exports.hasWiki = hasWiki;
exports.homepage = homepage;
exports.oidcCustomization = oidcCustomization;
exports.protectDefaultBranch = protectDefaultBranch;
exports.protectEnforceAdmins = protectEnforceAdmins;
exports.repoUrl = repoUrl;
exports.repoVariables = repoVariables;
exports.repoVisibility = repoVisibility;
exports.requireBranchesToBeUpToDate = requireBranchesToBeUpToDate;
exports.requireCodeOwnerReviews = requireCodeOwnerReviews;
exports.requireLastPushApproval = requireLastPushApproval;
exports.requiredApprovingReviewCount = requiredApprovingReviewCount;
exports.requiredCommitSigning = requiredCommitSigning;
exports.requiredConversationResolution = requiredConversationResolution;
exports.requiredLinearHistory = requiredLinearHistory;
exports.requiredStatusCheckContexts = requiredStatusCheckContexts;
exports.restrictions = restrictions;
exports.secrets = secrets;
exports.sourcePath = sourcePath;
exports.squashMergeCommitMessage = squashMergeCommitMessage;
exports.squashMergeCommitTitle = squashMergeCommitTitle;
exports.token = token;
exports.topics = topics;
//# sourceMappingURL=inputProperties.cjs.js.map
