'use strict';

var errors = require('@backstage/errors');
var octokit = require('octokit');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var helpers = require('./helpers.cjs.js');
var inputProperties = require('./inputProperties.cjs.js');
var outputProperties = require('./outputProperties.cjs.js');
var githubRepoCreate_examples = require('./githubRepoCreate.examples.cjs.js');

function createGithubRepoCreateAction(options) {
  const { integrations, githubCredentialsProvider } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "github:repo:create",
    description: "Creates a GitHub repository.",
    examples: githubRepoCreate_examples.examples,
    schema: {
      input: {
        type: "object",
        required: ["repoUrl"],
        properties: {
          repoUrl: inputProperties.repoUrl,
          description: inputProperties.description,
          homepage: inputProperties.homepage,
          access: inputProperties.access,
          requireCodeOwnerReviews: inputProperties.requireCodeOwnerReviews,
          bypassPullRequestAllowances: inputProperties.bypassPullRequestAllowances,
          requiredApprovingReviewCount: inputProperties.requiredApprovingReviewCount,
          restrictions: inputProperties.restrictions,
          requiredStatusCheckContexts: inputProperties.requiredStatusCheckContexts,
          requireBranchesToBeUpToDate: inputProperties.requireBranchesToBeUpToDate,
          requiredConversationResolution: inputProperties.requiredConversationResolution,
          repoVisibility: inputProperties.repoVisibility,
          deleteBranchOnMerge: inputProperties.deleteBranchOnMerge,
          allowMergeCommit: inputProperties.allowMergeCommit,
          allowSquashMerge: inputProperties.allowSquashMerge,
          squashMergeCommitTitle: inputProperties.squashMergeCommitTitle,
          squashMergeCommitMessage: inputProperties.squashMergeCommitMessage,
          allowRebaseMerge: inputProperties.allowRebaseMerge,
          allowAutoMerge: inputProperties.allowAutoMerge,
          collaborators: inputProperties.collaborators,
          hasProjects: inputProperties.hasProjects,
          hasWiki: inputProperties.hasWiki,
          hasIssues: inputProperties.hasIssues,
          token: inputProperties.token,
          topics: inputProperties.topics,
          repoVariables: inputProperties.repoVariables,
          secrets: inputProperties.secrets,
          oidcCustomization: inputProperties.oidcCustomization,
          requiredCommitSigning: inputProperties.requiredCommitSigning,
          requiredLinearHistory: inputProperties.requiredLinearHistory,
          customProperties: inputProperties.customProperties
        }
      },
      output: {
        type: "object",
        properties: {
          remoteUrl: outputProperties.remoteUrl,
          repoContentsUrl: outputProperties.repoContentsUrl
        }
      }
    },
    async handler(ctx) {
      const {
        repoUrl,
        description,
        homepage,
        access,
        repoVisibility = "private",
        deleteBranchOnMerge = false,
        allowMergeCommit = true,
        allowSquashMerge = true,
        squashMergeCommitTitle = "COMMIT_OR_PR_TITLE",
        squashMergeCommitMessage = "COMMIT_MESSAGES",
        allowRebaseMerge = true,
        allowAutoMerge = false,
        collaborators,
        hasProjects = void 0,
        hasWiki = void 0,
        hasIssues = void 0,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        customProperties,
        token: providedToken
      } = ctx.input;
      const octokitOptions = await helpers.getOctokitOptions({
        integrations,
        credentialsProvider: githubCredentialsProvider,
        token: providedToken,
        repoUrl
      });
      const client = new octokit.Octokit(octokitOptions);
      const { owner, repo } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      if (!owner) {
        throw new errors.InputError("Invalid repository owner provided in repoUrl");
      }
      const newRepo = await helpers.createGithubRepoWithCollaboratorsAndTopics(
        client,
        repo,
        owner,
        repoVisibility,
        description,
        homepage,
        deleteBranchOnMerge,
        allowMergeCommit,
        allowSquashMerge,
        squashMergeCommitTitle,
        squashMergeCommitMessage,
        allowRebaseMerge,
        allowAutoMerge,
        access,
        collaborators,
        hasProjects,
        hasWiki,
        hasIssues,
        topics,
        repoVariables,
        secrets,
        oidcCustomization,
        customProperties,
        ctx.logger
      );
      ctx.output("remoteUrl", newRepo.clone_url);
    }
  });
}

exports.createGithubRepoCreateAction = createGithubRepoCreateAction;
//# sourceMappingURL=githubRepoCreate.cjs.js.map
