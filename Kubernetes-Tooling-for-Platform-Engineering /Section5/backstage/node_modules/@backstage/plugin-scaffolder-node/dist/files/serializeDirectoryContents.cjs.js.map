{"version":3,"file":"serializeDirectoryContents.cjs.js","sources":["../../src/files/serializeDirectoryContents.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { promises as fs } from 'fs';\nimport globby from 'globby';\nimport limiterFactory from 'p-limit';\nimport { resolveSafeChildPath } from '@backstage/backend-plugin-api';\nimport { SerializedFile } from './types';\nimport { isError } from '@backstage/errors';\n\nconst DEFAULT_GLOB_PATTERNS = ['./**', '!.git'];\n\nexport const isExecutable = (fileMode: number | undefined) => {\n  if (!fileMode) {\n    return false;\n  }\n\n  const executeBitMask = 0o000111;\n  const res = fileMode & executeBitMask;\n  return res > 0;\n};\n\nasync function asyncFilter<T>(\n  array: T[],\n  callback: (value: T, index: number, array: T[]) => Promise<boolean>,\n): Promise<T[]> {\n  const filterMap = await Promise.all(array.map(callback));\n  return array.filter((_value, index) => filterMap[index]);\n}\n\n/**\n * @public\n */\nexport async function serializeDirectoryContents(\n  sourcePath: string,\n  options?: {\n    gitignore?: boolean;\n    globPatterns?: string[];\n  },\n): Promise<SerializedFile[]> {\n  const paths = await globby(options?.globPatterns ?? DEFAULT_GLOB_PATTERNS, {\n    cwd: sourcePath,\n    dot: true,\n    gitignore: options?.gitignore,\n    followSymbolicLinks: false,\n    // In order to pick up 'broken' symlinks, we oxymoronically request files AND folders yet we filter out folders\n    // This is because broken symlinks aren't classed as files so we need to glob everything\n    onlyFiles: false,\n    objectMode: true,\n    stats: true,\n  });\n\n  const limiter = limiterFactory(10);\n\n  const valid = await asyncFilter(paths, async ({ dirent, path }) => {\n    if (dirent.isDirectory()) return false;\n    if (!dirent.isSymbolicLink()) return true;\n\n    const safePath = resolveSafeChildPath(sourcePath, path);\n\n    // we only want files that don't exist\n    try {\n      await fs.stat(safePath);\n      return false;\n    } catch (e) {\n      return isError(e) && e.code === 'ENOENT';\n    }\n  });\n\n  return Promise.all(\n    valid.map(async ({ dirent, path, stats }) => ({\n      path,\n      content: await limiter(async () => {\n        const absFilePath = resolveSafeChildPath(sourcePath, path);\n        if (dirent.isSymbolicLink()) {\n          return fs.readlink(absFilePath, 'buffer');\n        }\n        return fs.readFile(absFilePath);\n      }),\n      executable: isExecutable(stats?.mode),\n      symlink: dirent.isSymbolicLink(),\n    })),\n  );\n}\n"],"names":["globby","limiterFactory","resolveSafeChildPath","fs","isError"],"mappings":";;;;;;;;;;;;;AAuBA,MAAM,qBAAA,GAAwB,CAAC,MAAA,EAAQ,OAAO,CAAA;AAEjC,MAAA,YAAA,GAAe,CAAC,QAAiC,KAAA;AAC5D,EAAA,IAAI,CAAC,QAAU,EAAA;AACb,IAAO,OAAA,KAAA;AAAA;AAGT,EAAA,MAAM,cAAiB,GAAA,EAAA;AACvB,EAAA,MAAM,MAAM,QAAW,GAAA,cAAA;AACvB,EAAA,OAAO,GAAM,GAAA,CAAA;AACf;AAEA,eAAe,WAAA,CACb,OACA,QACc,EAAA;AACd,EAAA,MAAM,YAAY,MAAM,OAAA,CAAQ,IAAI,KAAM,CAAA,GAAA,CAAI,QAAQ,CAAC,CAAA;AACvD,EAAA,OAAO,MAAM,MAAO,CAAA,CAAC,QAAQ,KAAU,KAAA,SAAA,CAAU,KAAK,CAAC,CAAA;AACzD;AAKsB,eAAA,0BAAA,CACpB,YACA,OAI2B,EAAA;AAC3B,EAAA,MAAM,KAAQ,GAAA,MAAMA,uBAAO,CAAA,OAAA,EAAS,gBAAgB,qBAAuB,EAAA;AAAA,IACzE,GAAK,EAAA,UAAA;AAAA,IACL,GAAK,EAAA,IAAA;AAAA,IACL,WAAW,OAAS,EAAA,SAAA;AAAA,IACpB,mBAAqB,EAAA,KAAA;AAAA;AAAA;AAAA,IAGrB,SAAW,EAAA,KAAA;AAAA,IACX,UAAY,EAAA,IAAA;AAAA,IACZ,KAAO,EAAA;AAAA,GACR,CAAA;AAED,EAAM,MAAA,OAAA,GAAUC,gCAAe,EAAE,CAAA;AAEjC,EAAM,MAAA,KAAA,GAAQ,MAAM,WAAY,CAAA,KAAA,EAAO,OAAO,EAAE,MAAA,EAAQ,MAAW,KAAA;AACjE,IAAI,IAAA,MAAA,CAAO,WAAY,EAAA,EAAU,OAAA,KAAA;AACjC,IAAA,IAAI,CAAC,MAAA,CAAO,cAAe,EAAA,EAAU,OAAA,IAAA;AAErC,IAAM,MAAA,QAAA,GAAWC,qCAAqB,CAAA,UAAA,EAAY,IAAI,CAAA;AAGtD,IAAI,IAAA;AACF,MAAM,MAAAC,WAAA,CAAG,KAAK,QAAQ,CAAA;AACtB,MAAO,OAAA,KAAA;AAAA,aACA,CAAG,EAAA;AACV,MAAA,OAAOC,cAAQ,CAAA,CAAC,CAAK,IAAA,CAAA,CAAE,IAAS,KAAA,QAAA;AAAA;AAClC,GACD,CAAA;AAED,EAAA,OAAO,OAAQ,CAAA,GAAA;AAAA,IACb,MAAM,GAAI,CAAA,OAAO,EAAE,MAAQ,EAAA,IAAA,EAAM,OAAa,MAAA;AAAA,MAC5C,IAAA;AAAA,MACA,OAAA,EAAS,MAAM,OAAA,CAAQ,YAAY;AACjC,QAAM,MAAA,WAAA,GAAcF,qCAAqB,CAAA,UAAA,EAAY,IAAI,CAAA;AACzD,QAAI,IAAA,MAAA,CAAO,gBAAkB,EAAA;AAC3B,UAAO,OAAAC,WAAA,CAAG,QAAS,CAAA,WAAA,EAAa,QAAQ,CAAA;AAAA;AAE1C,QAAO,OAAAA,WAAA,CAAG,SAAS,WAAW,CAAA;AAAA,OAC/B,CAAA;AAAA,MACD,UAAA,EAAY,YAAa,CAAA,KAAA,EAAO,IAAI,CAAA;AAAA,MACpC,OAAA,EAAS,OAAO,cAAe;AAAA,KAC/B,CAAA;AAAA,GACJ;AACF;;;;;"}