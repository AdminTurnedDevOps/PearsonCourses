import { toInternalExtension } from '../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';

function indent(str) {
  return str.replace(/^/gm, "  ");
}
class SerializableAppNode {
  spec;
  edges = {
    attachedTo: void 0,
    attachments: /* @__PURE__ */ new Map()
  };
  instance;
  constructor(spec) {
    this.spec = spec;
  }
  setParent(parent, input) {
    this.edges.attachedTo = { node: parent, input };
    const parentInputEdges = parent.edges.attachments.get(input);
    if (parentInputEdges) {
      parentInputEdges.push(this);
    } else {
      parent.edges.attachments.set(input, [this]);
    }
  }
  toJSON() {
    const dataRefs = this.instance && [...this.instance.getDataRefs()];
    return {
      id: this.spec.id,
      output: dataRefs && dataRefs.length > 0 ? dataRefs.map((ref) => ref.id) : void 0,
      attachments: this.edges.attachments.size > 0 ? Object.fromEntries(this.edges.attachments) : void 0
    };
  }
  toString() {
    const dataRefs = this.instance && [...this.instance.getDataRefs()];
    const out = dataRefs && dataRefs.length > 0 ? ` out=[${[...dataRefs].map((r) => r.id).join(", ")}]` : "";
    if (this.edges.attachments.size === 0) {
      return `<${this.spec.id}${out} />`;
    }
    return [
      `<${this.spec.id}${out}>`,
      ...[...this.edges.attachments.entries()].map(
        ([k, v]) => indent([`${k} [`, ...v.map((e) => indent(e.toString())), `]`].join("\n"))
      ),
      `</${this.spec.id}>`
    ].join("\n");
  }
}
function makeRedirectKey(attachTo) {
  return `${attachTo.id}%${attachTo.input}`;
}
const isValidAttachmentPoint = (attachTo, nodes) => {
  if (!nodes.has(attachTo.id)) {
    return false;
  }
  return attachTo.input in toInternalExtension(nodes.get(attachTo.id).spec.extension).inputs;
};
function resolveAppTree(rootNodeId, specs) {
  const nodes = /* @__PURE__ */ new Map();
  const redirectTargetsByKey = /* @__PURE__ */ new Map();
  for (const spec of specs) {
    if (nodes.has(spec.id)) {
      throw new Error(`Unexpected duplicate extension id '${spec.id}'`);
    }
    const node = new SerializableAppNode(spec);
    nodes.set(spec.id, node);
    const internal = toInternalExtension(spec.extension);
    for (const [inputName, input] of Object.entries(internal.inputs)) {
      if (input.replaces) {
        for (const replace of input.replaces) {
          const key = makeRedirectKey(replace);
          if (redirectTargetsByKey.has(key)) {
            throw new Error(
              `Duplicate redirect target for input '${inputName}' in extension '${spec.id}'`
            );
          }
          redirectTargetsByKey.set(key, { id: spec.id, input: inputName });
        }
      }
    }
  }
  const orphans = new Array();
  let rootNode = void 0;
  for (const node of nodes.values()) {
    const spec = node.spec;
    if (spec.id === rootNodeId) {
      rootNode = node;
    } else {
      let attachTo = node.spec.attachTo;
      if (!isValidAttachmentPoint(attachTo, nodes)) {
        attachTo = redirectTargetsByKey.get(makeRedirectKey(attachTo)) ?? attachTo;
      }
      const parent = nodes.get(attachTo.id);
      if (parent) {
        node.setParent(parent, attachTo.input);
      } else {
        orphans.push(node);
      }
    }
  }
  if (!rootNode) {
    throw new Error(`No root node with id '${rootNodeId}' found in app tree`);
  }
  return {
    root: rootNode,
    nodes,
    orphans
  };
}

export { resolveAppTree };
//# sourceMappingURL=resolveAppTree.esm.js.map
