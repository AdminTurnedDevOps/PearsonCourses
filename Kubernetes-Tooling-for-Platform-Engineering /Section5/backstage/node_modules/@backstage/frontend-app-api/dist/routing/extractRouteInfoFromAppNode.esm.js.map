{"version":3,"file":"extractRouteInfoFromAppNode.esm.js","sources":["../../src/routing/extractRouteInfoFromAppNode.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RouteRef, coreExtensionData } from '@backstage/frontend-plugin-api';\nimport { BackstageRouteObject } from './types';\nimport { AppNode } from '@backstage/frontend-plugin-api';\nimport { toLegacyPlugin } from './toLegacyPlugin';\n\n// We always add a child that matches all subroutes but without any route refs. This makes\n// sure that we're always able to match each route no matter how deep the navigation goes.\n// The route resolver then takes care of selecting the most specific match in order to find\n// mount points that are as deep in the routing tree as possible.\nexport const MATCH_ALL_ROUTE: BackstageRouteObject = {\n  caseSensitive: false,\n  path: '*',\n  element: 'match-all', // These elements aren't used, so we add in a bit of debug information\n  routeRefs: new Set(),\n  plugins: new Set(),\n};\n\n// Joins a list of paths together, avoiding trailing and duplicate slashes\nexport function joinPaths(...paths: string[]): string {\n  const normalized = paths.join('/').replace(/\\/\\/+/g, '/');\n  if (normalized !== '/' && normalized.endsWith('/')) {\n    return normalized.slice(0, -1);\n  }\n  return normalized;\n}\n\nexport function extractRouteInfoFromAppNode(node: AppNode): {\n  routePaths: Map<RouteRef, string>;\n  routeParents: Map<RouteRef, RouteRef | undefined>;\n  routeObjects: BackstageRouteObject[];\n} {\n  // This tracks the route path for each route ref, the value is the route path relative to the parent ref\n  const routePaths = new Map<RouteRef, string>();\n  // This tracks the parents of each route ref. To find the full path of any route ref you traverse\n  // upwards in this tree and substitute each route ref for its route path along then way.\n  const routeParents = new Map<RouteRef, RouteRef | undefined>();\n  // This route object tree is passed to react-router in order to be able to look up the current route\n  // ref or extension/source based on our current location.\n  const routeObjects = new Array<BackstageRouteObject>();\n\n  function visit(\n    current: AppNode,\n    collectedPath?: string,\n    foundRefForCollectedPath: boolean = false,\n    parentRef?: RouteRef,\n    candidateParentRef?: RouteRef,\n    parentObj?: BackstageRouteObject,\n  ) {\n    const routePath = current.instance\n      ?.getData(coreExtensionData.routePath)\n      ?.replace(/^\\//, '');\n    const routeRef = current.instance?.getData(coreExtensionData.routeRef);\n    const parentChildren = parentObj?.children ?? routeObjects;\n    let currentObj = parentObj;\n\n    let newCollectedPath = collectedPath;\n    let newFoundRefForCollectedPath = foundRefForCollectedPath;\n\n    let newParentRef = parentRef;\n    let newCandidateParentRef = candidateParentRef;\n\n    // Whenever a route path is encountered, a new node is created in the routing tree.\n    if (routePath !== undefined) {\n      currentObj = {\n        path: routePath,\n        element: 'mounted',\n        routeRefs: new Set<RouteRef>(),\n        caseSensitive: false,\n        children: [MATCH_ALL_ROUTE],\n        plugins: new Set(),\n        appNode: current,\n      };\n      parentChildren.push(currentObj);\n\n      // Each route path that we discover creates a new node in the routing tree, at that point\n      // we also switch out our candidate parent ref to be the active one.\n      newParentRef = candidateParentRef;\n      newCandidateParentRef = undefined;\n\n      // We need to collect and concatenate route paths until the path has been assigned a route ref:\n      // Once we find a route ref the collection starts over from an empty path, that way each route\n      // path assignment only contains the diff from the parent ref.\n      if (newFoundRefForCollectedPath) {\n        newCollectedPath = routePath;\n        newFoundRefForCollectedPath = false;\n      } else {\n        newCollectedPath = collectedPath\n          ? joinPaths(collectedPath, routePath)\n          : routePath;\n      }\n    }\n\n    // Whenever a route ref is encountered, we need to give it a route path and position in the ref tree.\n    if (routeRef) {\n      // The first route ref we find after encountering a route path is selected to be used as the\n      // parent ref further down the tree. We don't start using this candidate ref until we encounter\n      // another route path though, at which point we repeat the process and select another candidate.\n      if (!newCandidateParentRef) {\n        newCandidateParentRef = routeRef;\n      }\n\n      // Check if we've encountered any route paths since the closest route ref, in that case we assign\n      // that path to this and following route refs until we encounter another route path.\n      if (newCollectedPath !== undefined) {\n        routePaths.set(routeRef, newCollectedPath);\n        newFoundRefForCollectedPath = true;\n      }\n\n      routeParents.set(routeRef, newParentRef);\n      currentObj?.routeRefs.add(routeRef);\n      if (current.spec.source) {\n        currentObj?.plugins.add(toLegacyPlugin(current.spec.source));\n      }\n    }\n\n    for (const children of current.edges.attachments.values()) {\n      for (const child of children) {\n        visit(\n          child,\n          newCollectedPath,\n          newFoundRefForCollectedPath,\n          newParentRef,\n          newCandidateParentRef,\n          currentObj,\n        );\n      }\n    }\n  }\n\n  visit(node);\n\n  return { routePaths, routeParents, routeObjects };\n}\n"],"names":[],"mappings":"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"}