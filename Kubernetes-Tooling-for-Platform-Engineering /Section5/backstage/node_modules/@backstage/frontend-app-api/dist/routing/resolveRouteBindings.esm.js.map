{"version":3,"file":"resolveRouteBindings.esm.js","sources":["../../src/routing/resolveRouteBindings.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  RouteRef,\n  SubRouteRef,\n  ExternalRouteRef,\n} from '@backstage/frontend-plugin-api';\nimport { RouteRefsById } from './collectRouteIds';\nimport { Config } from '@backstage/config';\nimport { JsonObject } from '@backstage/types';\n// eslint-disable-next-line @backstage/no-relative-monorepo-imports\nimport { toInternalExternalRouteRef } from '../../../frontend-plugin-api/src/routing/ExternalRouteRef';\n\n/**\n * Extracts a union of the keys in a map whose value extends the given type\n *\n * @ignore\n */\ntype KeysWithType<Obj extends { [key in string]: any }, Type> = {\n  [key in keyof Obj]: Obj[key] extends Type ? key : never;\n}[keyof Obj];\n\n/**\n * Takes a map Map required values and makes all keys matching Keys optional\n *\n * @ignore\n */\ntype PartialKeys<\n  Map extends { [name in string]: any },\n  Keys extends keyof Map,\n> = Partial<Pick<Map, Keys>> & Required<Omit<Map, Keys>>;\n\n/**\n * Creates a map of target routes with matching parameters based on a map of external routes.\n *\n * @ignore\n */\ntype TargetRouteMap<\n  ExternalRoutes extends { [name: string]: ExternalRouteRef },\n> = {\n  [name in keyof ExternalRoutes]: ExternalRoutes[name] extends ExternalRouteRef<\n    infer Params\n  >\n    ? RouteRef<Params> | SubRouteRef<Params> | false\n    : never;\n};\n\n/**\n * A function that can bind from external routes of a given plugin, to concrete\n * routes of other plugins. See {@link @backstage/frontend-defaults#createApp}.\n *\n * @public\n */\nexport type CreateAppRouteBinder = <\n  TExternalRoutes extends { [name: string]: ExternalRouteRef },\n>(\n  externalRoutes: TExternalRoutes,\n  targetRoutes: PartialKeys<\n    TargetRouteMap<TExternalRoutes>,\n    KeysWithType<TExternalRoutes, ExternalRouteRef<any>>\n  >,\n) => void;\n\n/** @internal */\nexport function resolveRouteBindings(\n  bindRoutes: ((context: { bind: CreateAppRouteBinder }) => void) | undefined,\n  config: Config,\n  routesById: RouteRefsById,\n): Map<ExternalRouteRef, RouteRef | SubRouteRef> {\n  const result = new Map<ExternalRouteRef, RouteRef | SubRouteRef>();\n  const disabledExternalRefs = new Set<ExternalRouteRef>();\n\n  // Perform callback bindings first with highest priority\n  if (bindRoutes) {\n    const bind: CreateAppRouteBinder = (\n      externalRoutes,\n      targetRoutes: { [name: string]: RouteRef | SubRouteRef },\n    ) => {\n      for (const [key, value] of Object.entries(targetRoutes)) {\n        const externalRoute = externalRoutes[key];\n        if (!externalRoute) {\n          throw new Error(`Key ${key} is not an existing external route`);\n        }\n        if (value) {\n          result.set(externalRoute, value);\n        } else if (value === false) {\n          disabledExternalRefs.add(externalRoute);\n        }\n      }\n    };\n    bindRoutes({ bind });\n  }\n\n  // Then perform config based bindings with lower priority\n  const bindings = config\n    .getOptionalConfig('app.routes.bindings')\n    ?.get<JsonObject>();\n  if (bindings) {\n    for (const [externalRefId, targetRefId] of Object.entries(bindings)) {\n      if (!isValidTargetRefId(targetRefId)) {\n        throw new Error(\n          `Invalid config at app.routes.bindings['${externalRefId}'], value must be a non-empty string or false`,\n        );\n      }\n\n      const externalRef = routesById.externalRoutes.get(externalRefId);\n      if (!externalRef) {\n        throw new Error(\n          `Invalid config at app.routes.bindings, '${externalRefId}' is not a valid external route`,\n        );\n      }\n\n      // Skip if binding was already defined in code\n      if (result.has(externalRef) || disabledExternalRefs.has(externalRef)) {\n        continue;\n      }\n\n      if (targetRefId === false) {\n        disabledExternalRefs.add(externalRef);\n      } else {\n        const targetRef = routesById.routes.get(targetRefId);\n        if (!targetRef) {\n          throw new Error(\n            `Invalid config at app.routes.bindings['${externalRefId}'], '${targetRefId}' is not a valid route`,\n          );\n        }\n\n        result.set(externalRef, targetRef);\n      }\n    }\n  }\n\n  // Finally fall back to attempting to map defaults, at lowest priority\n  for (const externalRef of routesById.externalRoutes.values()) {\n    if (!result.has(externalRef) && !disabledExternalRefs.has(externalRef)) {\n      const defaultRefId =\n        toInternalExternalRouteRef(externalRef).getDefaultTarget();\n      if (defaultRefId) {\n        const defaultRef = routesById.routes.get(defaultRefId);\n        if (defaultRef) {\n          result.set(externalRef, defaultRef);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isValidTargetRefId(value: unknown): value is string | false {\n  if (value === false) {\n    return true;\n  }\n\n  if (typeof value === 'string' && value) {\n    return true;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"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"}