import { coreExtensionData } from '@backstage/frontend-plugin-api';
import { toLegacyPlugin } from './toLegacyPlugin.esm.js';

const MATCH_ALL_ROUTE = {
  caseSensitive: false,
  path: "*",
  element: "match-all",
  // These elements aren't used, so we add in a bit of debug information
  routeRefs: /* @__PURE__ */ new Set(),
  plugins: /* @__PURE__ */ new Set()
};
function joinPaths(...paths) {
  const normalized = paths.join("/").replace(/\/\/+/g, "/");
  if (normalized !== "/" && normalized.endsWith("/")) {
    return normalized.slice(0, -1);
  }
  return normalized;
}
function extractRouteInfoFromAppNode(node) {
  const routePaths = /* @__PURE__ */ new Map();
  const routeParents = /* @__PURE__ */ new Map();
  const routeObjects = new Array();
  function visit(current, collectedPath, foundRefForCollectedPath = false, parentRef, candidateParentRef, parentObj) {
    const routePath = current.instance?.getData(coreExtensionData.routePath)?.replace(/^\//, "");
    const routeRef = current.instance?.getData(coreExtensionData.routeRef);
    const parentChildren = parentObj?.children ?? routeObjects;
    let currentObj = parentObj;
    let newCollectedPath = collectedPath;
    let newFoundRefForCollectedPath = foundRefForCollectedPath;
    let newParentRef = parentRef;
    let newCandidateParentRef = candidateParentRef;
    if (routePath !== void 0) {
      currentObj = {
        path: routePath,
        element: "mounted",
        routeRefs: /* @__PURE__ */ new Set(),
        caseSensitive: false,
        children: [MATCH_ALL_ROUTE],
        plugins: /* @__PURE__ */ new Set(),
        appNode: current
      };
      parentChildren.push(currentObj);
      newParentRef = candidateParentRef;
      newCandidateParentRef = void 0;
      if (newFoundRefForCollectedPath) {
        newCollectedPath = routePath;
        newFoundRefForCollectedPath = false;
      } else {
        newCollectedPath = collectedPath ? joinPaths(collectedPath, routePath) : routePath;
      }
    }
    if (routeRef) {
      if (!newCandidateParentRef) {
        newCandidateParentRef = routeRef;
      }
      if (newCollectedPath !== void 0) {
        routePaths.set(routeRef, newCollectedPath);
        newFoundRefForCollectedPath = true;
      }
      routeParents.set(routeRef, newParentRef);
      currentObj?.routeRefs.add(routeRef);
      if (current.spec.source) {
        currentObj?.plugins.add(toLegacyPlugin(current.spec.source));
      }
    }
    for (const children of current.edges.attachments.values()) {
      for (const child of children) {
        visit(
          child,
          newCollectedPath,
          newFoundRefForCollectedPath,
          newParentRef,
          newCandidateParentRef,
          currentObj
        );
      }
    }
  }
  visit(node);
  return { routePaths, routeParents, routeObjects };
}

export { MATCH_ALL_ROUTE, extractRouteInfoFromAppNode, joinPaths };
//# sourceMappingURL=extractRouteInfoFromAppNode.esm.js.map
