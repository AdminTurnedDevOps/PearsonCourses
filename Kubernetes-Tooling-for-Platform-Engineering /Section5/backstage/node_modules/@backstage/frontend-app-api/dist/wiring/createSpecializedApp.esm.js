import React from 'react';
import { ConfigReader } from '@backstage/config';
import { createApiFactory, appTreeApiRef, routeResolutionApiRef, coreExtensionData, ApiBlueprint } from '@backstage/frontend-plugin-api';
import { configApiRef, identityApiRef, featureFlagsApiRef } from '@backstage/core-plugin-api';
import { ApiFactoryRegistry, ApiResolver } from '@backstage/core-app-api';
import { resolveExtensionDefinition } from '../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';
import { extractRouteInfoFromAppNode } from '../routing/extractRouteInfoFromAppNode.esm.js';
import { RouteResolver } from '../routing/RouteResolver.esm.js';
import { resolveRouteBindings } from '../routing/resolveRouteBindings.esm.js';
import { collectRouteIds } from '../routing/collectRouteIds.esm.js';
import { isInternalFrontendModule, toInternalFrontendModule } from '../frontend-plugin-api/src/wiring/createFrontendModule.esm.js';
import { getBasePath } from '../routing/getBasePath.esm.js';
import { Root } from '../extensions/Root.esm.js';
import { resolveAppTree } from '../tree/resolveAppTree.esm.js';
import { resolveAppNodeSpecs } from '../tree/resolveAppNodeSpecs.esm.js';
import { readAppExtensionsConfig } from '../tree/readAppExtensionsConfig.esm.js';
import { instantiateAppNodeTree } from '../tree/instantiateAppNodeTree.esm.js';
import { ApiRegistry } from '../core-app-api/src/apis/system/ApiRegistry.esm.js';
import { AppIdentityProxy } from '../core-app-api/src/apis/implementations/IdentityApi/AppIdentityProxy.esm.js';
import { OpaqueFrontendPlugin } from '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';

function deduplicateFeatures(allFeatures) {
  const features = Array.from(new Set(allFeatures));
  const seenIds = /* @__PURE__ */ new Set();
  return features.reverse().filter((feature) => {
    if (!OpaqueFrontendPlugin.isType(feature)) {
      return true;
    }
    if (seenIds.has(feature.id)) {
      return false;
    }
    seenIds.add(feature.id);
    return true;
  }).reverse();
}
class AppTreeApiProxy {
  constructor(tree) {
    this.tree = tree;
  }
  #safeToUse = false;
  getTree() {
    if (!this.#safeToUse) {
      throw new Error(
        `You can't access the AppTreeApi during initialization of the app tree. Please move occurrences of this out of the initialization of the factory`
      );
    }
    return { tree: this.tree };
  }
  initialize() {
    this.#safeToUse = true;
  }
}
class RouteResolutionApiProxy {
  constructor(tree, routeBindings, basePath) {
    this.tree = tree;
    this.routeBindings = routeBindings;
    this.basePath = basePath;
  }
  #delegate;
  #routeObjects;
  resolve(anyRouteRef, options) {
    if (!this.#delegate) {
      throw new Error(
        `You can't access the RouteResolver during initialization of the app tree. Please move occurrences of this out of the initialization of the factory`
      );
    }
    return this.#delegate.resolve(anyRouteRef, options);
  }
  initialize() {
    const routeInfo = extractRouteInfoFromAppNode(this.tree.root);
    this.#delegate = new RouteResolver(
      routeInfo.routePaths,
      routeInfo.routeParents,
      routeInfo.routeObjects,
      this.routeBindings,
      this.basePath
    );
    this.#routeObjects = routeInfo.routeObjects;
    return routeInfo;
  }
  getRouteObjects() {
    return this.#routeObjects;
  }
}
function createSpecializedApp(options) {
  const config = options?.config ?? new ConfigReader({}, "empty-config");
  const features = deduplicateFeatures(options?.features ?? []);
  const tree = resolveAppTree(
    "root",
    resolveAppNodeSpecs({
      features,
      builtinExtensions: [
        resolveExtensionDefinition(Root, { namespace: "root" })
      ],
      parameters: readAppExtensionsConfig(config),
      forbidden: /* @__PURE__ */ new Set(["root"])
    })
  );
  const factories = createApiFactories({ tree });
  const appTreeApi = new AppTreeApiProxy(tree);
  const routeResolutionApi = new RouteResolutionApiProxy(
    tree,
    resolveRouteBindings(
      options?.bindRoutes,
      config,
      collectRouteIds(features)
    ),
    getBasePath(config)
  );
  const appIdentityProxy = new AppIdentityProxy();
  const apiHolder = createApiHolder({
    factories,
    staticFactories: [
      createApiFactory(appTreeApiRef, appTreeApi),
      createApiFactory(configApiRef, config),
      createApiFactory(routeResolutionApiRef, routeResolutionApi),
      createApiFactory(identityApiRef, appIdentityProxy)
    ]
  });
  const featureFlagApi = apiHolder.get(featureFlagsApiRef);
  if (featureFlagApi) {
    for (const feature of features) {
      if (OpaqueFrontendPlugin.isType(feature)) {
        OpaqueFrontendPlugin.toInternal(feature).featureFlags.forEach(
          (flag) => featureFlagApi.registerFlag({
            name: flag.name,
            pluginId: feature.id
          })
        );
      }
      if (isInternalFrontendModule(feature)) {
        toInternalFrontendModule(feature).featureFlags.forEach(
          (flag) => featureFlagApi.registerFlag({
            name: flag.name,
            pluginId: feature.pluginId
          })
        );
      }
    }
  }
  instantiateAppNodeTree(tree.root, apiHolder);
  routeResolutionApi.initialize();
  appTreeApi.initialize();
  const rootEl = tree.root.instance.getData(coreExtensionData.reactElement);
  const AppComponent = () => rootEl;
  return {
    createRoot() {
      return /* @__PURE__ */ React.createElement(AppComponent, null);
    }
  };
}
function createApiFactories(options) {
  const emptyApiHolder = ApiRegistry.from([]);
  const factories = new Array();
  for (const apiNode of options.tree.root.edges.attachments.get("apis") ?? []) {
    instantiateAppNodeTree(apiNode, emptyApiHolder);
    const apiFactory = apiNode.instance?.getData(ApiBlueprint.dataRefs.factory);
    if (!apiFactory) {
      throw new Error(
        `No API factory found in for extension ${apiNode.spec.id}`
      );
    }
    factories.push(apiFactory);
  }
  return factories;
}
function createApiHolder(options) {
  const factoryRegistry = new ApiFactoryRegistry();
  for (const factory of options.factories.slice().reverse()) {
    factoryRegistry.register("default", factory);
  }
  for (const factory of options.staticFactories) {
    factoryRegistry.register("static", factory);
  }
  ApiResolver.validateFactories(factoryRegistry, factoryRegistry.getAllApis());
  return new ApiResolver(factoryRegistry);
}

export { createSpecializedApp };
//# sourceMappingURL=createSpecializedApp.esm.js.map
