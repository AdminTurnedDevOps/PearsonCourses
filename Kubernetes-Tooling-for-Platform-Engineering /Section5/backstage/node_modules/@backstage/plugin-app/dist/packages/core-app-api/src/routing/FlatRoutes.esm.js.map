{"version":3,"file":"FlatRoutes.esm.js","sources":["../../../../../../../packages/core-app-api/src/routing/FlatRoutes.tsx"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactNode, useMemo } from 'react';\nimport { useRoutes } from 'react-router-dom';\nimport {\n  attachComponentData,\n  useApp,\n  useElementFilter,\n} from '@backstage/core-plugin-api';\nimport { isReactRouterBeta } from '../app/isReactRouterBeta';\n\nlet warned = false;\n\ntype RouteObject = {\n  path: string;\n  element: ReactNode;\n  children?: RouteObject[];\n};\n\n/**\n * Props for the {@link FlatRoutes} component.\n *\n * @public\n */\nexport type FlatRoutesProps = {\n  children: ReactNode;\n};\n\n/**\n * A wrapper around a set of routes.\n *\n * @remarks\n *\n * The root of the routing hierarchy in your app should use this component,\n * instead of the one from `react-router-dom`. This ensures that all of the\n * plugin route and utility API wiring happens under the hood.\n *\n * @public\n */\nexport const FlatRoutes = (props: FlatRoutesProps): JSX.Element | null => {\n  const app = useApp();\n  const { NotFoundErrorPage } = app.getComponents();\n  const isBeta = useMemo(() => isReactRouterBeta(), []);\n  const routes = useElementFilter(props.children, elements =>\n    elements\n      .getElements<{\n        path?: string;\n        element?: ReactNode;\n        children?: ReactNode;\n      }>()\n      .flatMap<RouteObject>(child => {\n        let path = child.props.path;\n\n        // TODO(Rugvip): Work around plugins registering empty paths, remove once deprecated routes are gone\n        if (path === '') {\n          return [];\n        }\n        path = path?.replace(/\\/\\*$/, '') ?? '/';\n\n        let element = isBeta ? child : child.props.element;\n        if (!isBeta && !element) {\n          element = child;\n          if (!warned && process.env.NODE_ENV !== 'test') {\n            // eslint-disable-next-line no-console\n            console.warn(\n              'DEPRECATION WARNING: All elements within <FlatRoutes> must be of type <Route> with an element prop. ' +\n                'Existing usages of <Navigate key=[path] to=[to] /> should be replaced with <Route path=[path] element={<Navigate to=[to] />} />.',\n            );\n            warned = true;\n          }\n        }\n\n        return [\n          {\n            // Each route matches any sub route, except for the explicit root path\n            path,\n            element,\n            children: child.props.children\n              ? [\n                  // These are the children of each route, which we all add in under a catch-all\n                  // subroute in order to make them available to `useOutlet`\n                  {\n                    path: path === '/' ? '/' : '*', // The root path must require an exact match\n                    element: child.props.children,\n                  },\n                ]\n              : undefined,\n          },\n        ];\n      })\n      // Routes are sorted to work around a bug where prefixes are unexpectedly matched\n      // TODO(Rugvip): This can be removed once react-router v6 beta is no longer supported\n      .sort((a, b) => b.path.localeCompare(a.path))\n      .map(obj => ({ ...obj, path: obj.path === '/' ? '/' : `${obj.path}/*` })),\n  );\n\n  // TODO(Rugvip): Possibly add a way to skip this, like a noNotFoundPage prop\n  const withNotFound = [\n    ...routes,\n    {\n      path: '*',\n      element: <NotFoundErrorPage />,\n    },\n  ];\n\n  return useRoutes(withNotFound);\n};\n\nattachComponentData(FlatRoutes, 'core.type', 'FlatRoutes');\n"],"names":[],"mappings":";;;;;AAyBA,IAAI,MAAS,GAAA,KAAA;AA4BA,MAAA,UAAA,GAAa,CAAC,KAA+C,KAAA;AACxE,EAAA,MAAM,MAAM,MAAO,EAAA;AACnB,EAAA,MAAM,EAAE,iBAAA,EAAsB,GAAA,GAAA,CAAI,aAAc,EAAA;AAChD,EAAA,MAAM,SAAS,OAAQ,CAAA,MAAM,iBAAkB,EAAA,EAAG,EAAE,CAAA;AACpD,EAAA,MAAM,MAAS,GAAA,gBAAA;AAAA,IAAiB,KAAM,CAAA,QAAA;AAAA,IAAU,CAC9C,QAAA,KAAA,QAAA,CACG,WAIE,EAAA,CACF,QAAqB,CAAS,KAAA,KAAA;AAC7B,MAAI,IAAA,IAAA,GAAO,MAAM,KAAM,CAAA,IAAA;AAGvB,MAAA,IAAI,SAAS,EAAI,EAAA;AACf,QAAA,OAAO,EAAC;AAAA;AAEV,MAAA,IAAA,GAAO,IAAM,EAAA,OAAA,CAAQ,OAAS,EAAA,EAAE,CAAK,IAAA,GAAA;AAErC,MAAA,IAAI,OAAU,GAAA,MAAA,GAAS,KAAQ,GAAA,KAAA,CAAM,KAAM,CAAA,OAAA;AAC3C,MAAI,IAAA,CAAC,MAAU,IAAA,CAAC,OAAS,EAAA;AACvB,QAAU,OAAA,GAAA,KAAA;AACV,QAAA,IAAI,CAAC,MAAA,IAAU,OAAQ,CAAA,GAAA,CAAI,aAAa,MAAQ,EAAA;AAE9C,UAAQ,OAAA,CAAA,IAAA;AAAA,YACN;AAAA,WAEF;AACA,UAAS,MAAA,GAAA,IAAA;AAAA;AACX;AAGF,MAAO,OAAA;AAAA,QACL;AAAA;AAAA,UAEE,IAAA;AAAA,UACA,OAAA;AAAA,UACA,QAAA,EAAU,KAAM,CAAA,KAAA,CAAM,QAClB,GAAA;AAAA;AAAA;AAAA,YAGE;AAAA,cACE,IAAA,EAAM,IAAS,KAAA,GAAA,GAAM,GAAM,GAAA,GAAA;AAAA;AAAA,cAC3B,OAAA,EAAS,MAAM,KAAM,CAAA;AAAA;AACvB,WAEF,GAAA,KAAA;AAAA;AACN,OACF;AAAA,KACD,CAGA,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,IAAK,CAAA,aAAA,CAAc,CAAE,CAAA,IAAI,CAAC,CAAA,CAC3C,GAAI,CAAA,CAAA,GAAA,MAAQ,EAAE,GAAG,GAAK,EAAA,IAAA,EAAM,GAAI,CAAA,IAAA,KAAS,GAAM,GAAA,GAAA,GAAM,CAAG,EAAA,GAAA,CAAI,IAAI,CAAA,EAAA,CAAA,EAAO,CAAA;AAAA,GAC5E;AAGA,EAAA,MAAM,YAAe,GAAA;AAAA,IACnB,GAAG,MAAA;AAAA,IACH;AAAA,MACE,IAAM,EAAA,GAAA;AAAA,MACN,OAAA,sCAAU,iBAAkB,EAAA,IAAA;AAAA;AAC9B,GACF;AAEA,EAAA,OAAO,UAAU,YAAY,CAAA;AAC/B;AAEA,mBAAoB,CAAA,UAAA,EAAY,aAAa,YAAY,CAAA;;;;"}