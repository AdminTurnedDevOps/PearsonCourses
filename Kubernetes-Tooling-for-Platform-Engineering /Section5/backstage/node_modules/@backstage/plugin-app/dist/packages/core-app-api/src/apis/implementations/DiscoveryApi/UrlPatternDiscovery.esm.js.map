{"version":3,"file":"UrlPatternDiscovery.esm.js","sources":["../../../../../../../../../packages/core-app-api/src/apis/implementations/DiscoveryApi/UrlPatternDiscovery.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiscoveryApi } from '@backstage/core-plugin-api';\n\nconst ERROR_PREFIX = 'Invalid discovery URL pattern,';\n\n/**\n * UrlPatternDiscovery is a lightweight DiscoveryApi implementation.\n * It uses a single template string to construct URLs for each plugin.\n *\n * @public\n */\nexport class UrlPatternDiscovery implements DiscoveryApi {\n  /**\n   * Creates a new UrlPatternDiscovery given a template. The only\n   * interpolation done for the template is to replace instances of `{{pluginId}}`\n   * with the ID of the plugin being requested.\n   *\n   * Example pattern: `http://localhost:7007/api/{{ pluginId }}`\n   */\n  static compile(pattern: string): UrlPatternDiscovery {\n    const parts = pattern.split(/\\{\\{\\s*pluginId\\s*\\}\\}/);\n    const urlStr = parts.join('pluginId');\n\n    let url;\n    try {\n      url = new URL(urlStr);\n    } catch {\n      throw new Error(`${ERROR_PREFIX} URL '${urlStr}' is invalid`);\n    }\n    if (url.hash) {\n      throw new Error(`${ERROR_PREFIX} URL must not have a hash`);\n    }\n    if (url.search) {\n      throw new Error(`${ERROR_PREFIX} URL must not have a query`);\n    }\n    if (urlStr.endsWith('/')) {\n      throw new Error(`${ERROR_PREFIX} URL must not end with a slash`);\n    }\n\n    return new UrlPatternDiscovery(parts);\n  }\n\n  private constructor(private readonly parts: string[]) {}\n\n  async getBaseUrl(pluginId: string): Promise<string> {\n    return this.parts.join(encodeURIComponent(pluginId));\n  }\n}\n"],"names":[],"mappings":"AAkBA,MAAM,YAAe,GAAA,gCAAA;AAQd,MAAM,mBAA4C,CAAA;AAAA,EA+B/C,YAA6B,KAAiB,EAAA;AAAjB,IAAA,IAAA,CAAA,KAAA,GAAA,KAAA;AAAA;AAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAvBvD,OAAO,QAAQ,OAAsC,EAAA;AACnD,IAAM,MAAA,KAAA,GAAQ,OAAQ,CAAA,KAAA,CAAM,wBAAwB,CAAA;AACpD,IAAM,MAAA,MAAA,GAAS,KAAM,CAAA,IAAA,CAAK,UAAU,CAAA;AAEpC,IAAI,IAAA,GAAA;AACJ,IAAI,IAAA;AACF,MAAM,GAAA,GAAA,IAAI,IAAI,MAAM,CAAA;AAAA,KACd,CAAA,MAAA;AACN,MAAA,MAAM,IAAI,KAAM,CAAA,CAAA,EAAG,YAAY,CAAA,MAAA,EAAS,MAAM,CAAc,YAAA,CAAA,CAAA;AAAA;AAE9D,IAAA,IAAI,IAAI,IAAM,EAAA;AACZ,MAAA,MAAM,IAAI,KAAA,CAAM,CAAG,EAAA,YAAY,CAA2B,yBAAA,CAAA,CAAA;AAAA;AAE5D,IAAA,IAAI,IAAI,MAAQ,EAAA;AACd,MAAA,MAAM,IAAI,KAAA,CAAM,CAAG,EAAA,YAAY,CAA4B,0BAAA,CAAA,CAAA;AAAA;AAE7D,IAAI,IAAA,MAAA,CAAO,QAAS,CAAA,GAAG,CAAG,EAAA;AACxB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAG,EAAA,YAAY,CAAgC,8BAAA,CAAA,CAAA;AAAA;AAGjE,IAAO,OAAA,IAAI,oBAAoB,KAAK,CAAA;AAAA;AACtC,EAIA,MAAM,WAAW,QAAmC,EAAA;AAClD,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,kBAAA,CAAmB,QAAQ,CAAC,CAAA;AAAA;AAEvD;;;;"}