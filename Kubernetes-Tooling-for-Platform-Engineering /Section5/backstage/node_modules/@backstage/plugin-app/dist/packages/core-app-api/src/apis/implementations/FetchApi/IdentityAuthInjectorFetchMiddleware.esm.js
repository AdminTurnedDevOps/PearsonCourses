class IdentityAuthInjectorFetchMiddleware {
  constructor(identityApi, allowUrl, headerName, headerValue) {
    this.identityApi = identityApi;
    this.allowUrl = allowUrl;
    this.headerName = headerName;
    this.headerValue = headerValue;
  }
  static create(options) {
    const matcher = buildMatcher(options);
    const headerName = options.header?.name || "authorization";
    const headerValue = options.header?.value || ((token) => `Bearer ${token}`);
    return new IdentityAuthInjectorFetchMiddleware(
      options.identityApi,
      matcher,
      headerName,
      headerValue
    );
  }
  apply(next) {
    return async (input, init) => {
      const request = new Request(input, init);
      const { token } = await this.identityApi.getCredentials();
      if (request.headers.get(this.headerName) || typeof token !== "string" || !token || !this.allowUrl(request.url)) {
        return next(input, init);
      }
      request.headers.set(this.headerName, this.headerValue(token));
      return next(request);
    };
  }
}
function buildMatcher(options) {
  if (options.allowUrl) {
    return options.allowUrl;
  } else if (options.urlPrefixAllowlist) {
    return buildPrefixMatcher(options.urlPrefixAllowlist);
  } else if (options.config) {
    return buildPrefixMatcher([options.config.getString("backend.baseUrl")]);
  }
  return () => false;
}
function buildPrefixMatcher(prefixes) {
  const trimmedPrefixes = prefixes.map((prefix) => prefix.replace(/\/$/, ""));
  return (url) => trimmedPrefixes.some(
    (prefix) => url === prefix || url.startsWith(`${prefix}/`)
  );
}

export { IdentityAuthInjectorFetchMiddleware };
//# sourceMappingURL=IdentityAuthInjectorFetchMiddleware.esm.js.map
