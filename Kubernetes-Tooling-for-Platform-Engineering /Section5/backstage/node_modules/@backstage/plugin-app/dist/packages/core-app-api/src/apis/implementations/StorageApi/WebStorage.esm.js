import ObservableImpl from 'zen-observable';

const buckets = /* @__PURE__ */ new Map();
class WebStorage {
  constructor(namespace, errorApi) {
    this.namespace = namespace;
    this.errorApi = errorApi;
  }
  static hasSubscribed = false;
  static create(options) {
    return new WebStorage(options.namespace ?? "", options.errorApi);
  }
  static addStorageEventListener() {
    window.addEventListener("storage", (event) => {
      for (const [bucketPath, webStorage] of buckets.entries()) {
        if (event.key?.startsWith(bucketPath)) {
          webStorage.handleStorageChange(event.key);
        }
      }
    });
  }
  get(key) {
    return this.snapshot(key).value;
  }
  snapshot(key) {
    let value = void 0;
    let presence = "absent";
    try {
      const item = localStorage.getItem(this.getKeyName(key));
      if (item) {
        value = JSON.parse(item, (_key, val) => {
          if (typeof val === "object" && val !== null) {
            Object.freeze(val);
          }
          return val;
        });
        presence = "present";
      }
    } catch (e) {
      this.errorApi.post(
        new Error(`Error when parsing JSON config from storage for: ${key}`)
      );
    }
    return { key, value, presence };
  }
  forBucket(name) {
    const bucketPath = `${this.namespace}/${name}`;
    if (!buckets.has(bucketPath)) {
      buckets.set(bucketPath, new WebStorage(bucketPath, this.errorApi));
    }
    return buckets.get(bucketPath);
  }
  async set(key, data) {
    localStorage.setItem(this.getKeyName(key), JSON.stringify(data));
    this.notifyChanges(key);
  }
  async remove(key) {
    localStorage.removeItem(this.getKeyName(key));
    this.notifyChanges(key);
  }
  observe$(key) {
    if (!WebStorage.hasSubscribed) {
      WebStorage.addStorageEventListener();
      WebStorage.hasSubscribed = true;
    }
    return this.observable.filter(({ key: messageKey }) => messageKey === key);
  }
  handleStorageChange(eventKey) {
    if (!eventKey?.startsWith(this.namespace)) {
      return;
    }
    const trimmedKey = eventKey?.slice(`${this.namespace}/`.length);
    if (!trimmedKey.includes("/")) {
      this.notifyChanges(decodeURIComponent(trimmedKey));
    }
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(key) {
    const snapshot = this.snapshot(key);
    for (const subscription of this.subscribers) {
      subscription.next(snapshot);
    }
  }
  subscribers = /* @__PURE__ */ new Set();
  observable = new ObservableImpl((subscriber) => {
    this.subscribers.add(subscriber);
    return () => {
      this.subscribers.delete(subscriber);
    };
  });
}

export { WebStorage, buckets };
//# sourceMappingURL=WebStorage.esm.js.map
