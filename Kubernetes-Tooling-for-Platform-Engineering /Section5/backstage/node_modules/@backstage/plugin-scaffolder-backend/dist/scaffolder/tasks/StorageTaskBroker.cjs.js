'use strict';

var types = require('@backstage/types');
var ObservableImpl = require('zen-observable');
var helper = require('./helper.cjs.js');
var WorkspaceService = require('./WorkspaceService.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var ObservableImpl__default = /*#__PURE__*/_interopDefaultCompat(ObservableImpl);

class TaskManager {
  // Runs heartbeat internally
  constructor(task, storage, signal, logger, workspaceService, auth) {
    this.task = task;
    this.storage = storage;
    this.signal = signal;
    this.logger = logger;
    this.workspaceService = workspaceService;
    this.auth = auth;
  }
  isDone = false;
  heartbeatTimeoutId;
  static create(task, storage, abortSignal, logger, auth, config, additionalWorkspaceProviders) {
    const workspaceService = WorkspaceService.DefaultWorkspaceService.create(
      task,
      storage,
      additionalWorkspaceProviders,
      config
    );
    const agent = new TaskManager(
      task,
      storage,
      abortSignal,
      logger,
      workspaceService,
      auth
    );
    agent.startTimeout();
    return agent;
  }
  get spec() {
    return this.task.spec;
  }
  get cancelSignal() {
    return this.signal;
  }
  get secrets() {
    return this.task.secrets;
  }
  get createdBy() {
    return this.task.createdBy;
  }
  async getWorkspaceName() {
    return this.task.taskId;
  }
  async rehydrateWorkspace(options) {
    await this.workspaceService.rehydrateWorkspace(options);
  }
  get done() {
    return this.isDone;
  }
  async emitLog(message, logMetadata) {
    await this.storage.emitLogEvent({
      taskId: this.task.taskId,
      body: { message, ...logMetadata }
    });
  }
  async getTaskState() {
    return this.storage.getTaskState?.({ taskId: this.task.taskId });
  }
  async updateCheckpoint(options) {
    const { key, ...value } = options;
    if (this.task.state) {
      this.task.state.checkpoints[key] = value;
    } else {
      this.task.state = { checkpoints: { [key]: value } };
    }
    await this.storage.saveTaskState?.({
      taskId: this.task.taskId,
      state: this.task.state
    });
  }
  async serializeWorkspace(options) {
    await this.workspaceService.serializeWorkspace(options);
  }
  async cleanWorkspace() {
    await this.workspaceService.cleanWorkspace();
  }
  async complete(result, metadata) {
    await this.storage.completeTask({
      taskId: this.task.taskId,
      status: result === "failed" ? "failed" : "completed",
      eventBody: {
        message: `Run completed with status: ${result}`,
        ...metadata
      }
    });
    this.isDone = true;
    if (this.heartbeatTimeoutId) {
      clearTimeout(this.heartbeatTimeoutId);
    }
  }
  startTimeout() {
    this.heartbeatTimeoutId = setTimeout(async () => {
      try {
        await this.storage.heartbeatTask(this.task.taskId);
        this.startTimeout();
      } catch (error) {
        this.isDone = true;
        this.logger.error(
          `Heartbeat for task ${this.task.taskId} failed`,
          error
        );
      }
    }, 1e3);
  }
  async getInitiatorCredentials() {
    const secrets = this.task.secrets;
    if (secrets && secrets.__initiatorCredentials) {
      return JSON.parse(secrets.__initiatorCredentials);
    }
    if (!this.auth) {
      throw new Error(
        "Failed to create none credentials in scaffolder task. The TaskManager has not been initialized with an auth service implementation"
      );
    }
    return this.auth.getNoneCredentials();
  }
}
class StorageTaskBroker {
  constructor(storage, logger, config, auth, additionalWorkspaceProviders) {
    this.storage = storage;
    this.logger = logger;
    this.config = config;
    this.auth = auth;
    this.additionalWorkspaceProviders = additionalWorkspaceProviders;
  }
  async list(options) {
    if (!this.storage.list) {
      throw new Error(
        "TaskStore does not implement the list method. Please implement the list method to be able to list tasks"
      );
    }
    return await this.storage.list(options ?? {});
  }
  deferredDispatch = types.createDeferred();
  async registerCancellable(taskId, abortController) {
    let shouldUnsubscribe = false;
    const subscription = this.event$({ taskId, after: void 0 }).subscribe({
      error: (_) => {
        subscription.unsubscribe();
      },
      next: ({ events }) => {
        for (const event of events) {
          if (event.type === "cancelled") {
            abortController.abort();
            shouldUnsubscribe = true;
          }
          if (event.type === "completion" && !event.isTaskRecoverable) {
            shouldUnsubscribe = true;
          }
        }
        if (shouldUnsubscribe) {
          subscription.unsubscribe();
        }
      }
    });
  }
  async recoverTasks() {
    const enabled = (this.config && this.config.getOptionalBoolean(
      "scaffolder.EXPERIMENTAL_recoverTasks"
    )) ?? false;
    if (enabled) {
      const defaultTimeout = { seconds: 30 };
      const timeout = helper.readDuration(
        this.config,
        "scaffolder.EXPERIMENTAL_recoverTasksTimeout",
        defaultTimeout
      );
      const { ids: recoveredTaskIds } = await this.storage.recoverTasks?.({
        timeout
      }) ?? { ids: [] };
      if (recoveredTaskIds.length > 0) {
        this.signalDispatch();
      }
    }
  }
  /**
   * {@inheritdoc TaskBroker.claim}
   */
  async claim() {
    for (; ; ) {
      const pendingTask = await this.storage.claimTask();
      if (pendingTask) {
        const abortController = new AbortController();
        await this.registerCancellable(pendingTask.id, abortController);
        return TaskManager.create(
          {
            taskId: pendingTask.id,
            spec: pendingTask.spec,
            secrets: pendingTask.secrets,
            createdBy: pendingTask.createdBy,
            state: pendingTask.state
          },
          this.storage,
          abortController.signal,
          this.logger,
          this.auth,
          this.config,
          this.additionalWorkspaceProviders
        );
      }
      await this.waitForDispatch();
    }
  }
  /**
   * {@inheritdoc TaskBroker.dispatch}
   */
  async dispatch(options) {
    const taskRow = await this.storage.createTask(options);
    this.signalDispatch();
    return {
      taskId: taskRow.taskId
    };
  }
  /**
   * {@inheritdoc TaskBroker.get}
   */
  async get(taskId) {
    return this.storage.getTask(taskId);
  }
  /**
   * {@inheritdoc TaskBroker.event$}
   */
  event$(options) {
    return new ObservableImpl__default.default((observer) => {
      const { taskId } = options;
      let after = options.after;
      let cancelled = false;
      (async () => {
        const task = await this.storage.getTask(taskId);
        const isTaskRecoverable = task.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy === "startOver";
        while (!cancelled) {
          const result = await this.storage.listEvents({
            isTaskRecoverable,
            taskId,
            after
          });
          const { events } = result;
          if (events.length) {
            after = events[events.length - 1].id;
            observer.next(result);
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      })();
      return () => {
        cancelled = true;
      };
    });
  }
  /**
   * {@inheritdoc TaskBroker.vacuumTasks}
   */
  async vacuumTasks(options) {
    const { tasks } = await this.storage.listStaleTasks(options);
    await Promise.all(
      tasks.map(async (task) => {
        try {
          await this.storage.completeTask({
            taskId: task.taskId,
            status: "failed",
            eventBody: {
              message: "The task was cancelled because the task worker lost connection to the task broker"
            }
          });
        } catch (error) {
          this.logger.warn(`Failed to cancel task '${task.taskId}', ${error}`);
        }
      })
    );
  }
  waitForDispatch() {
    return this.deferredDispatch;
  }
  signalDispatch() {
    this.deferredDispatch.resolve();
    this.deferredDispatch = types.createDeferred();
  }
  async cancel(taskId) {
    const { events } = await this.storage.listEvents({ taskId });
    const currentStepId = events.length > 0 ? events.filter(({ body }) => body?.stepId).reduce((prev, curr) => prev.id > curr.id ? prev : curr).body.stepId : 0;
    await this.storage.cancelTask?.({
      taskId,
      body: {
        message: `Step ${currentStepId} has been cancelled.`,
        stepId: currentStepId,
        status: "cancelled"
      }
    });
  }
  async retry(taskId) {
    await this.storage.retryTask?.({ taskId });
    this.signalDispatch();
  }
}

exports.StorageTaskBroker = StorageTaskBroker;
exports.TaskManager = TaskManager;
//# sourceMappingURL=StorageTaskBroker.cjs.js.map
