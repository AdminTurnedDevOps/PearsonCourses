'use strict';

var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var z = require('zod');
var catalogModel = require('@backstage/catalog-model');
var fetch_examples = require('./fetch.examples.cjs.js');

const id = "catalog:fetch";
function createFetchCatalogEntityAction(options) {
  const { catalogClient, auth } = options;
  return pluginScaffolderNode.createTemplateAction({
    id,
    description: "Returns entity or entities from the catalog by entity reference(s)",
    examples: fetch_examples.examples,
    supportsDryRun: true,
    schema: {
      input: z.z.object({
        entityRef: z.z.string({
          description: "Entity reference of the entity to get"
        }).optional(),
        entityRefs: z.z.array(z.z.string(), {
          description: "Entity references of the entities to get"
        }).optional(),
        optional: z.z.boolean({
          description: "Allow the entity or entities to optionally exist. Default: false"
        }).optional(),
        defaultKind: z.z.string({ description: "The default kind" }).optional(),
        defaultNamespace: z.z.string({ description: "The default namespace" }).optional()
      }),
      output: z.z.object({
        entity: z.z.any({
          description: "Object containing same values used in the Entity schema. Only when used with `entityRef` parameter."
        }).optional(),
        entities: z.z.array(
          z.z.any({
            description: "Array containing objects with same values used in the Entity schema. Only when used with `entityRefs` parameter."
          })
        ).optional()
      })
    },
    async handler(ctx) {
      const { entityRef, entityRefs, optional, defaultKind, defaultNamespace } = ctx.input;
      if (!entityRef && !entityRefs) {
        if (optional) {
          return;
        }
        throw new Error("Missing entity reference or references");
      }
      const { token } = await auth?.getPluginRequestToken({
        onBehalfOf: await ctx.getInitiatorCredentials(),
        targetPluginId: "catalog"
      }) ?? { token: ctx.secrets?.backstageToken };
      if (entityRef) {
        const entity = await catalogClient.getEntityByRef(
          catalogModel.stringifyEntityRef(
            catalogModel.parseEntityRef(entityRef, { defaultKind, defaultNamespace })
          ),
          {
            token
          }
        );
        if (!entity && !optional) {
          throw new Error(`Entity ${entityRef} not found`);
        }
        ctx.output("entity", entity ?? null);
      }
      if (entityRefs) {
        const entities = await catalogClient.getEntitiesByRefs(
          {
            entityRefs: entityRefs.map(
              (ref) => catalogModel.stringifyEntityRef(
                catalogModel.parseEntityRef(ref, { defaultKind, defaultNamespace })
              )
            )
          },
          {
            token
          }
        );
        const finalEntities = entities.items.map((e, i) => {
          if (!e && !optional) {
            throw new Error(`Entity ${entityRefs[i]} not found`);
          }
          return e ?? null;
        });
        ctx.output("entities", finalEntities);
      }
    }
  });
}

exports.createFetchCatalogEntityAction = createFetchCatalogEntityAction;
//# sourceMappingURL=fetch.cjs.js.map
