'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var uuid = require('uuid');
var luxon = require('luxon');
var taskRecoveryHelper = require('./taskRecoveryHelper.cjs.js');
var dbUtil = require('./dbUtil.cjs.js');
var alpha = require('@backstage/plugin-scaffolder-node/alpha');
var helpers = require('../../service/helpers.cjs.js');

const migrationsDir = backendPluginApi.resolvePackagePath(
  "@backstage/plugin-scaffolder-backend",
  "migrations"
);
function isPluginDatabaseManager(opt) {
  return opt.getClient !== void 0;
}
const parseSqlDateToIsoString = (input) => {
  if (typeof input === "string") {
    const parsed = luxon.DateTime.fromSQL(input, { zone: "UTC" });
    if (!parsed.isValid) {
      throw new Error(
        `Failed to parse database timestamp '${input}', ${parsed.invalidReason}: ${parsed.invalidExplanation}`
      );
    }
    return parsed.toISO();
  }
  return input;
};
class DatabaseTaskStore {
  db;
  events;
  static async create(options) {
    const { database } = options;
    const client = await this.getClient(database);
    await this.runMigrations(database, client);
    return new DatabaseTaskStore(client, options.events);
  }
  isRecoverableTask(spec) {
    return ["startOver"].includes(
      spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? "none"
    );
  }
  parseSpec({ spec, id }) {
    try {
      return JSON.parse(spec);
    } catch (error) {
      throw new Error(`Failed to parse spec of task '${id}', ${error}`);
    }
  }
  parseTaskSecrets(taskRow) {
    try {
      return taskRow.secrets ? JSON.parse(taskRow.secrets) : void 0;
    } catch (error) {
      throw new Error(
        `Failed to parse secrets of task '${taskRow.id}', ${error}`
      );
    }
  }
  static async getClient(database) {
    if (isPluginDatabaseManager(database)) {
      return database.getClient();
    }
    return database;
  }
  static async runMigrations(database, client) {
    if (!isPluginDatabaseManager(database)) {
      await client.migrate.latest({
        directory: migrationsDir
      });
      return;
    }
    if (!database.migrations?.skip) {
      await client.migrate.latest({
        directory: migrationsDir
      });
    }
  }
  constructor(client, events) {
    this.db = client;
    this.events = events;
  }
  getState(task) {
    try {
      return task.state ? JSON.parse(task.state).state : void 0;
    } catch (error) {
      throw new Error(
        `Failed to parse state of the task '${task.id}', ${error}`
      );
    }
  }
  async list(options) {
    const { createdBy, status, pagination, order, filters } = options ?? {};
    const queryBuilder = this.db("tasks");
    if (createdBy || filters?.createdBy) {
      const arr = helpers.flattenParams(
        createdBy,
        filters?.createdBy
      );
      queryBuilder.whereIn("created_by", [...new Set(arr)]);
    }
    if (status || filters?.status) {
      const arr = helpers.flattenParams(
        status,
        filters?.status
      );
      queryBuilder.whereIn("status", [...new Set(arr)]);
    }
    const countQuery = queryBuilder.clone();
    countQuery.count("tasks.id", { as: "count" });
    if (order) {
      order.forEach((f) => {
        queryBuilder.orderBy(f.field, f.order);
      });
    } else {
      queryBuilder.orderBy("created_at", "desc");
    }
    if (pagination?.limit !== void 0) {
      queryBuilder.limit(pagination.limit);
    }
    if (pagination?.offset !== void 0) {
      queryBuilder.offset(pagination.offset);
    }
    const [results, [{ count }]] = await Promise.all([
      queryBuilder.select(),
      countQuery
    ]);
    const tasks = results.map((result) => ({
      id: result.id,
      spec: JSON.parse(result.spec),
      status: result.status,
      createdBy: result.created_by ?? void 0,
      lastHeartbeatAt: parseSqlDateToIsoString(result.last_heartbeat_at),
      createdAt: parseSqlDateToIsoString(result.created_at)
    }));
    return { tasks, totalTasks: count };
  }
  async getTask(taskId) {
    const [result] = await this.db("tasks").where({ id: taskId }).select();
    if (!result) {
      throw new errors.NotFoundError(`No task with id '${taskId}' found`);
    }
    try {
      const spec = JSON.parse(result.spec);
      const secrets = result.secrets ? JSON.parse(result.secrets) : void 0;
      const state = this.getState(result);
      return {
        id: result.id,
        spec,
        status: result.status,
        lastHeartbeatAt: parseSqlDateToIsoString(result.last_heartbeat_at),
        createdAt: parseSqlDateToIsoString(result.created_at),
        createdBy: result.created_by ?? void 0,
        secrets,
        state
      };
    } catch (error) {
      throw new Error(`Failed to parse spec of task '${taskId}', ${error}`);
    }
  }
  async createTask(options) {
    const taskId = uuid.v4();
    await this.db("tasks").insert({
      id: taskId,
      spec: JSON.stringify(options.spec),
      secrets: options.secrets ? JSON.stringify(options.secrets) : void 0,
      created_by: options.createdBy ?? null,
      status: "open"
    });
    this.events?.publish({
      topic: "scaffolder.task",
      eventPayload: {
        id: taskId,
        spec: options.spec,
        createdBy: options.createdBy,
        status: "open"
      }
    });
    return { taskId };
  }
  async claimTask() {
    return this.db.transaction(async (tx) => {
      const [task] = await tx("tasks").where({
        status: "open"
      }).limit(1).select();
      if (!task) {
        return void 0;
      }
      const spec = this.parseSpec(task);
      const updateCount = await tx("tasks").where({ id: task.id, status: "open" }).update({
        status: "processing",
        last_heartbeat_at: this.db.fn.now(),
        // remove the secrets for non-recoverable tasks when moving to processing state.
        secrets: this.isRecoverableTask(spec) ? task.secrets : null
      });
      if (updateCount < 1) {
        return void 0;
      }
      const ret = {
        id: task.id,
        spec,
        status: "processing",
        lastHeartbeatAt: task.last_heartbeat_at,
        createdAt: task.created_at,
        createdBy: task.created_by ?? void 0,
        state: this.getState(task)
      };
      this.events?.publish({
        topic: "scaffolder.task",
        eventPayload: ret
      });
      const secrets = this.parseTaskSecrets(task);
      return { ...ret, secrets };
    });
  }
  async heartbeatTask(taskId) {
    const updateCount = await this.db("tasks").where({ id: taskId, status: "processing" }).update({
      last_heartbeat_at: this.db.fn.now()
    });
    if (updateCount === 0) {
      throw new errors.ConflictError(`No running task with taskId ${taskId} found`);
    }
  }
  async listStaleTasks(options) {
    const { timeoutS } = options;
    const heartbeatInterval = dbUtil.intervalFromNowTill(timeoutS, this.db);
    const rawRows = await this.db("tasks").where("status", "processing").andWhere("last_heartbeat_at", "<=", heartbeatInterval);
    const tasks = rawRows.map((row) => ({
      recovery: JSON.parse(row.spec).EXPERIMENTAL_recovery,
      taskId: row.id
    }));
    return { tasks };
  }
  async completeTask(options) {
    const { taskId, status, eventBody } = options;
    let oldStatus;
    if (["failed", "completed", "cancelled"].includes(status)) {
      oldStatus = "processing";
    } else {
      throw new Error(
        `Invalid status update of run '${taskId}' to status '${status}'`
      );
    }
    await this.db.transaction(async (tx) => {
      const [task] = await tx("tasks").where({
        id: taskId
      }).limit(1).select();
      const updateTask = async (criteria) => {
        const updateCount = await tx("tasks").where(criteria).update({
          status,
          secrets: null
        });
        if (updateCount !== 1) {
          throw new errors.ConflictError(
            `Failed to update status to '${status}' for taskId ${taskId}`
          );
        }
        this.events?.publish({
          topic: "scaffolder.task",
          eventPayload: {
            id: taskId,
            status,
            lastHeartbeatAt: task.last_heartbeat_at,
            createdAt: task.created_at,
            createdBy: task.created_by,
            state: this.getState(task)
          }
        });
        await tx("task_events").insert({
          task_id: taskId,
          event_type: "completion",
          body: JSON.stringify(eventBody)
        }).returning("id");
      };
      if (status === "cancelled") {
        await updateTask({
          id: taskId
        });
        return;
      }
      if (task.status === "cancelled") {
        return;
      }
      if (!task) {
        throw new Error(`No task with taskId ${taskId} found`);
      }
      if (task.status !== oldStatus) {
        throw new errors.ConflictError(
          `Refusing to update status of run '${taskId}' to status '${status}' as it is currently '${task.status}', expected '${oldStatus}'`
        );
      }
      await updateTask({
        id: taskId,
        status: oldStatus
      });
    });
  }
  async emitLogEvent(options) {
    const { taskId, body } = options;
    const serializedBody = JSON.stringify(body);
    await this.db("task_events").insert({
      task_id: taskId,
      event_type: "log",
      body: serializedBody
    }).returning("id");
  }
  async getTaskState({ taskId }) {
    const [result] = await this.db("tasks").where({ id: taskId }).select("state");
    return result.state ? JSON.parse(result.state) : void 0;
  }
  async saveTaskState(options) {
    if (options.state) {
      const serializedState = JSON.stringify({ state: options.state });
      await this.db("tasks").where({ id: options.taskId }).update({
        state: serializedState
      });
    }
  }
  async listEvents(options) {
    const { isTaskRecoverable, taskId, after } = options;
    const rawEvents = await this.db("task_events").where({
      task_id: taskId
    }).andWhere((builder) => {
      if (typeof after === "number") {
        builder.where("id", ">", after).orWhere("event_type", "completion");
      }
    }).orderBy("id").select();
    const events = rawEvents.map((event) => {
      try {
        const body = JSON.parse(event.body);
        return {
          id: Number(event.id),
          isTaskRecoverable,
          taskId,
          body,
          type: event.event_type,
          createdAt: parseSqlDateToIsoString(event.created_at)
        };
      } catch (error) {
        throw new Error(
          `Failed to parse event body from event taskId=${taskId} id=${event.id}, ${error}`
        );
      }
    });
    return taskRecoveryHelper.trimEventsTillLastRecovery(events);
  }
  async shutdownTask(options) {
    const { taskId } = options;
    const message = `This task was marked as stale as it exceeded its timeout`;
    const statusStepEvents = (await this.listEvents({ taskId })).events.filter(
      ({ body }) => body?.stepId
    );
    const completedSteps = statusStepEvents.filter(
      ({ body: { status } }) => status === "failed" || status === "completed"
    ).map((step) => step.body.stepId);
    const hungProcessingSteps = statusStepEvents.filter(({ body: { status } }) => status === "processing").map((event) => event.body.stepId).filter((step) => !completedSteps.includes(step));
    for (const step of hungProcessingSteps) {
      await this.emitLogEvent({
        taskId,
        body: {
          message,
          stepId: step,
          status: "failed"
        }
      });
    }
    await this.completeTask({
      taskId,
      status: "failed",
      eventBody: {
        message
      }
    });
  }
  async rehydrateWorkspace(options) {
    const [result] = await this.db("tasks").where({ id: options.taskId }).select("workspace");
    await alpha.restoreWorkspace({
      path: options.targetPath,
      buffer: result.workspace
    });
  }
  async cleanWorkspace({ taskId }) {
    await this.db("tasks").where({ id: taskId }).update({
      workspace: null
    });
  }
  async serializeWorkspace(options) {
    if (options.path) {
      const workspace = (await alpha.serializeWorkspace(options)).contents;
      await this.db("tasks").where({ id: options.taskId }).update({
        workspace
      });
    }
  }
  async cancelTask(options) {
    const { taskId, body } = options;
    const serializedBody = JSON.stringify(body);
    const [ret] = await this.db("task_events").insert({
      task_id: taskId,
      event_type: "cancelled",
      body: serializedBody
    }).returning("id");
    this.events?.publish({
      topic: "scaffolder.task",
      eventPayload: {
        id: ret.id,
        taskId,
        status: "cancelled",
        body
      }
    });
  }
  async retryTask(options) {
    await this.db.transaction(async (tx) => {
      const result = await tx("tasks").where("id", options.taskId).update(
        {
          status: "open",
          last_heartbeat_at: this.db.fn.now()
        },
        ["id", "spec"]
      );
      for (const { id, spec } of result) {
        const taskSpec = JSON.parse(spec);
        await tx("task_events").where("task_id", id).andWhere((q) => q.whereIn("event_type", ["cancelled", "completion"])).del();
        await tx("task_events").insert({
          task_id: id,
          event_type: "recovered",
          body: JSON.stringify({
            recoverStrategy: taskSpec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? "none"
          })
        });
      }
    });
  }
  async recoverTasks(options) {
    const taskIdsToRecover = [];
    const timeoutS = luxon.Duration.fromObject(options.timeout).as("seconds");
    await this.db.transaction(async (tx) => {
      const heartbeatInterval = dbUtil.intervalFromNowTill(timeoutS, this.db);
      const result = await tx("tasks").where("status", "processing").andWhere("last_heartbeat_at", "<=", heartbeatInterval).update(
        {
          status: "open",
          last_heartbeat_at: this.db.fn.now()
        },
        ["id", "spec"]
      );
      taskIdsToRecover.push(...result.map((i) => i.id));
      for (const { id, spec } of result) {
        const taskSpec = JSON.parse(spec);
        const event = {
          recoverStrategy: taskSpec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? "none"
        };
        const [ret] = await tx("task_events").insert({
          task_id: id,
          event_type: "recovered",
          body: JSON.stringify(event)
        }).returning("id");
        this.events?.publish({
          topic: "scaffolder.task",
          eventPayload: {
            id: ret.id,
            taskId: id,
            status: "recovered",
            body: event
          }
        });
      }
    });
    return { ids: taskIdsToRecover };
  }
}

exports.DatabaseTaskStore = DatabaseTaskStore;
//# sourceMappingURL=DatabaseTaskStore.cjs.js.map
