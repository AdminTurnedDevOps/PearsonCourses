{"version":3,"file":"DatabaseTaskStore.cjs.js","sources":["../../../src/scaffolder/tasks/DatabaseTaskStore.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '@backstage/types';\nimport { PluginDatabaseManager } from '@backstage/backend-common';\nimport { resolvePackagePath } from '@backstage/backend-plugin-api';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\nimport { Knex } from 'knex';\nimport { v4 as uuid } from 'uuid';\nimport {\n  TaskStore,\n  TaskStoreCreateTaskOptions,\n  TaskStoreCreateTaskResult,\n  TaskStoreEmitOptions,\n  TaskStoreListEventsOptions,\n  TaskStoreRecoverTaskOptions,\n  TaskStoreShutDownTaskOptions,\n} from './types';\nimport {\n  SerializedTask,\n  SerializedTaskEvent,\n  TaskEventType,\n  TaskSecrets,\n  TaskStatus,\n} from '@backstage/plugin-scaffolder-node';\nimport { DateTime, Duration } from 'luxon';\nimport { TaskRecovery, TaskSpec } from '@backstage/plugin-scaffolder-common';\nimport { trimEventsTillLastRecovery } from './taskRecoveryHelper';\nimport { intervalFromNowTill } from './dbUtil';\nimport {\n  restoreWorkspace,\n  serializeWorkspace,\n} from '@backstage/plugin-scaffolder-node/alpha';\nimport { flattenParams } from '../../service/helpers';\nimport { EventsService } from '@backstage/plugin-events-node';\n\nconst migrationsDir = resolvePackagePath(\n  '@backstage/plugin-scaffolder-backend',\n  'migrations',\n);\n\nexport type RawDbTaskRow = {\n  id: string;\n  spec: string;\n  status: TaskStatus;\n  state?: string;\n  last_heartbeat_at?: string;\n  created_at: string;\n  created_by: string | null;\n  secrets?: string | null;\n  workspace?: Buffer;\n};\n\nexport type RawDbTaskEventRow = {\n  id: number;\n  task_id: string;\n  body: string;\n  event_type: TaskEventType;\n  created_at: string;\n};\n\n/**\n * DatabaseTaskStore\n *\n * @public\n */\nexport type DatabaseTaskStoreOptions = {\n  database: PluginDatabaseManager | Knex;\n  events?: EventsService;\n};\n\n/**\n * Type guard to help DatabaseTaskStore understand when database is PluginDatabaseManager vs. when database is a Knex instance.\n *\n * * @public\n */\nfunction isPluginDatabaseManager(\n  opt: PluginDatabaseManager | Knex,\n): opt is PluginDatabaseManager {\n  return (opt as PluginDatabaseManager).getClient !== undefined;\n}\n\nconst parseSqlDateToIsoString = <T>(input: T): T | string => {\n  if (typeof input === 'string') {\n    const parsed = DateTime.fromSQL(input, { zone: 'UTC' });\n    if (!parsed.isValid) {\n      throw new Error(\n        `Failed to parse database timestamp '${input}', ${parsed.invalidReason}: ${parsed.invalidExplanation}`,\n      );\n    }\n    return parsed.toISO()!;\n  }\n\n  return input;\n};\n\n/**\n * DatabaseTaskStore\n *\n * @public\n */\nexport class DatabaseTaskStore implements TaskStore {\n  private readonly db: Knex;\n  private readonly events?: EventsService;\n\n  static async create(\n    options: DatabaseTaskStoreOptions,\n  ): Promise<DatabaseTaskStore> {\n    const { database } = options;\n    const client = await this.getClient(database);\n\n    await this.runMigrations(database, client);\n\n    return new DatabaseTaskStore(client, options.events);\n  }\n\n  private isRecoverableTask(spec: TaskSpec): boolean {\n    return ['startOver'].includes(\n      spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? 'none',\n    );\n  }\n\n  private parseSpec({ spec, id }: { spec: string; id: string }): TaskSpec {\n    try {\n      return JSON.parse(spec);\n    } catch (error) {\n      throw new Error(`Failed to parse spec of task '${id}', ${error}`);\n    }\n  }\n\n  private parseTaskSecrets(taskRow: RawDbTaskRow): TaskSecrets | undefined {\n    try {\n      return taskRow.secrets ? JSON.parse(taskRow.secrets) : undefined;\n    } catch (error) {\n      throw new Error(\n        `Failed to parse secrets of task '${taskRow.id}', ${error}`,\n      );\n    }\n  }\n\n  private static async getClient(\n    database: PluginDatabaseManager | Knex,\n  ): Promise<Knex> {\n    if (isPluginDatabaseManager(database)) {\n      return database.getClient();\n    }\n\n    return database;\n  }\n\n  private static async runMigrations(\n    database: PluginDatabaseManager | Knex,\n    client: Knex,\n  ): Promise<void> {\n    if (!isPluginDatabaseManager(database)) {\n      await client.migrate.latest({\n        directory: migrationsDir,\n      });\n\n      return;\n    }\n\n    if (!database.migrations?.skip) {\n      await client.migrate.latest({\n        directory: migrationsDir,\n      });\n    }\n  }\n\n  private constructor(client: Knex, events?: EventsService) {\n    this.db = client;\n    this.events = events;\n  }\n\n  private getState(task: RawDbTaskRow) {\n    try {\n      return task.state ? JSON.parse(task.state).state : undefined;\n    } catch (error) {\n      throw new Error(\n        `Failed to parse state of the task '${task.id}', ${error}`,\n      );\n    }\n  }\n\n  async list(options: {\n    createdBy?: string;\n    status?: TaskStatus;\n    filters?: {\n      createdBy?: string | string[];\n      status?: TaskStatus | TaskStatus[];\n    };\n    pagination?: {\n      limit?: number;\n      offset?: number;\n    };\n    order?: { order: 'asc' | 'desc'; field: string }[];\n  }): Promise<{ tasks: SerializedTask[]; totalTasks?: number }> {\n    const { createdBy, status, pagination, order, filters } = options ?? {};\n    const queryBuilder = this.db<RawDbTaskRow & { count: number }>('tasks');\n\n    if (createdBy || filters?.createdBy) {\n      const arr: string[] = flattenParams<string>(\n        createdBy,\n        filters?.createdBy,\n      );\n      queryBuilder.whereIn('created_by', [...new Set(arr)]);\n    }\n\n    if (status || filters?.status) {\n      const arr: TaskStatus[] = flattenParams<TaskStatus>(\n        status,\n        filters?.status,\n      );\n      queryBuilder.whereIn('status', [...new Set(arr)]);\n    }\n\n    const countQuery = queryBuilder.clone();\n    countQuery.count('tasks.id', { as: 'count' });\n\n    if (order) {\n      order.forEach(f => {\n        queryBuilder.orderBy(f.field, f.order);\n      });\n    } else {\n      queryBuilder.orderBy('created_at', 'desc');\n    }\n\n    if (pagination?.limit !== undefined) {\n      queryBuilder.limit(pagination.limit);\n    }\n\n    if (pagination?.offset !== undefined) {\n      queryBuilder.offset(pagination.offset);\n    }\n\n    const [results, [{ count }]] = await Promise.all([\n      queryBuilder.select(),\n      countQuery,\n    ]);\n\n    const tasks = results.map(result => ({\n      id: result.id,\n      spec: JSON.parse(result.spec),\n      status: result.status,\n      createdBy: result.created_by ?? undefined,\n      lastHeartbeatAt: parseSqlDateToIsoString(result.last_heartbeat_at),\n      createdAt: parseSqlDateToIsoString(result.created_at),\n    }));\n\n    return { tasks, totalTasks: count };\n  }\n\n  async getTask(taskId: string): Promise<SerializedTask> {\n    const [result] = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: taskId })\n      .select();\n    if (!result) {\n      throw new NotFoundError(`No task with id '${taskId}' found`);\n    }\n    try {\n      const spec = JSON.parse(result.spec);\n      const secrets = result.secrets ? JSON.parse(result.secrets) : undefined;\n      const state = this.getState(result);\n      return {\n        id: result.id,\n        spec,\n        status: result.status,\n        lastHeartbeatAt: parseSqlDateToIsoString(result.last_heartbeat_at),\n        createdAt: parseSqlDateToIsoString(result.created_at),\n        createdBy: result.created_by ?? undefined,\n        secrets,\n        state,\n      };\n    } catch (error) {\n      throw new Error(`Failed to parse spec of task '${taskId}', ${error}`);\n    }\n  }\n\n  async createTask(\n    options: TaskStoreCreateTaskOptions,\n  ): Promise<TaskStoreCreateTaskResult> {\n    const taskId = uuid();\n    await this.db<RawDbTaskRow>('tasks').insert({\n      id: taskId,\n      spec: JSON.stringify(options.spec),\n      secrets: options.secrets ? JSON.stringify(options.secrets) : undefined,\n      created_by: options.createdBy ?? null,\n      status: 'open',\n    });\n\n    this.events?.publish({\n      topic: 'scaffolder.task',\n      eventPayload: {\n        id: taskId,\n        spec: options.spec,\n        createdBy: options.createdBy,\n        status: 'open',\n      },\n    });\n\n    return { taskId };\n  }\n\n  async claimTask(): Promise<SerializedTask | undefined> {\n    return this.db.transaction(async tx => {\n      const [task] = await tx<RawDbTaskRow>('tasks')\n        .where({\n          status: 'open',\n        })\n        .limit(1)\n        .select();\n\n      if (!task) {\n        return undefined;\n      }\n\n      const spec = this.parseSpec(task);\n\n      const updateCount = await tx<RawDbTaskRow>('tasks')\n        .where({ id: task.id, status: 'open' })\n        .update({\n          status: 'processing',\n          last_heartbeat_at: this.db.fn.now(),\n          // remove the secrets for non-recoverable tasks when moving to processing state.\n          secrets: this.isRecoverableTask(spec) ? task.secrets : null,\n        });\n\n      if (updateCount < 1) {\n        return undefined;\n      }\n\n      const ret: SerializedTask = {\n        id: task.id,\n        spec,\n        status: 'processing',\n        lastHeartbeatAt: task.last_heartbeat_at,\n        createdAt: task.created_at,\n        createdBy: task.created_by ?? undefined,\n        state: this.getState(task),\n      };\n\n      this.events?.publish({\n        topic: 'scaffolder.task',\n        eventPayload: ret,\n      });\n\n      const secrets = this.parseTaskSecrets(task);\n      return { ...ret, secrets };\n    });\n  }\n\n  async heartbeatTask(taskId: string): Promise<void> {\n    const updateCount = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: taskId, status: 'processing' })\n      .update({\n        last_heartbeat_at: this.db.fn.now(),\n      });\n    if (updateCount === 0) {\n      throw new ConflictError(`No running task with taskId ${taskId} found`);\n    }\n  }\n\n  async listStaleTasks(options: { timeoutS: number }): Promise<{\n    tasks: { taskId: string; recovery?: TaskRecovery }[];\n  }> {\n    const { timeoutS } = options;\n    const heartbeatInterval = intervalFromNowTill(timeoutS, this.db);\n    const rawRows = await this.db<RawDbTaskRow>('tasks')\n      .where('status', 'processing')\n      .andWhere('last_heartbeat_at', '<=', heartbeatInterval);\n    const tasks = rawRows.map(row => ({\n      recovery: (JSON.parse(row.spec) as TaskSpec).EXPERIMENTAL_recovery,\n      taskId: row.id,\n    }));\n    return { tasks };\n  }\n\n  async completeTask(options: {\n    taskId: string;\n    status: TaskStatus;\n    eventBody: JsonObject;\n  }): Promise<void> {\n    const { taskId, status, eventBody } = options;\n\n    let oldStatus: TaskStatus;\n    if (['failed', 'completed', 'cancelled'].includes(status)) {\n      oldStatus = 'processing';\n    } else {\n      throw new Error(\n        `Invalid status update of run '${taskId}' to status '${status}'`,\n      );\n    }\n\n    await this.db.transaction(async tx => {\n      const [task] = await tx<RawDbTaskRow>('tasks')\n        .where({\n          id: taskId,\n        })\n        .limit(1)\n        .select();\n\n      const updateTask = async (criteria: {\n        id: string;\n        status?: TaskStatus;\n      }) => {\n        const updateCount = await tx<RawDbTaskRow>('tasks')\n          .where(criteria)\n          .update({\n            status,\n            secrets: null,\n          });\n\n        if (updateCount !== 1) {\n          throw new ConflictError(\n            `Failed to update status to '${status}' for taskId ${taskId}`,\n          );\n        }\n\n        this.events?.publish({\n          topic: 'scaffolder.task',\n          eventPayload: {\n            id: taskId,\n            status: status,\n            lastHeartbeatAt: task.last_heartbeat_at,\n            createdAt: task.created_at,\n            createdBy: task.created_by,\n            state: this.getState(task),\n          },\n        });\n\n        await tx<RawDbTaskEventRow>('task_events')\n          .insert({\n            task_id: taskId,\n            event_type: 'completion',\n            body: JSON.stringify(eventBody),\n          })\n          .returning('id');\n      };\n\n      if (status === 'cancelled') {\n        await updateTask({\n          id: taskId,\n        });\n        return;\n      }\n\n      if (task.status === 'cancelled') {\n        return;\n      }\n\n      if (!task) {\n        throw new Error(`No task with taskId ${taskId} found`);\n      }\n      if (task.status !== oldStatus) {\n        throw new ConflictError(\n          `Refusing to update status of run '${taskId}' to status '${status}' ` +\n            `as it is currently '${task.status}', expected '${oldStatus}'`,\n        );\n      }\n\n      await updateTask({\n        id: taskId,\n        status: oldStatus,\n      });\n    });\n  }\n\n  async emitLogEvent(\n    options: TaskStoreEmitOptions<{ message: string } & JsonObject>,\n  ): Promise<void> {\n    const { taskId, body } = options;\n    const serializedBody = JSON.stringify(body);\n    await this.db<RawDbTaskEventRow>('task_events')\n      .insert({\n        task_id: taskId,\n        event_type: 'log',\n        body: serializedBody,\n      })\n      .returning('id');\n  }\n\n  async getTaskState({ taskId }: { taskId: string }): Promise<\n    | {\n        state: JsonObject;\n      }\n    | undefined\n  > {\n    const [result] = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: taskId })\n      .select('state');\n    return result.state ? JSON.parse(result.state) : undefined;\n  }\n\n  async saveTaskState(options: {\n    taskId: string;\n    state?: JsonObject;\n  }): Promise<void> {\n    if (options.state) {\n      const serializedState = JSON.stringify({ state: options.state });\n      await this.db<RawDbTaskRow>('tasks')\n        .where({ id: options.taskId })\n        .update({\n          state: serializedState,\n        });\n    }\n  }\n\n  async listEvents(\n    options: TaskStoreListEventsOptions,\n  ): Promise<{ events: SerializedTaskEvent[] }> {\n    const { isTaskRecoverable, taskId, after } = options;\n    const rawEvents = await this.db<RawDbTaskEventRow>('task_events')\n      .where({\n        task_id: taskId,\n      })\n      .andWhere(builder => {\n        if (typeof after === 'number') {\n          builder.where('id', '>', after).orWhere('event_type', 'completion');\n        }\n      })\n      .orderBy('id')\n      .select();\n\n    const events = rawEvents.map(event => {\n      try {\n        const body = JSON.parse(event.body) as JsonObject;\n        return {\n          id: Number(event.id),\n          isTaskRecoverable,\n          taskId,\n          body,\n          type: event.event_type,\n          createdAt: parseSqlDateToIsoString(event.created_at),\n        };\n      } catch (error) {\n        throw new Error(\n          `Failed to parse event body from event taskId=${taskId} id=${event.id}, ${error}`,\n        );\n      }\n    });\n\n    return trimEventsTillLastRecovery(events);\n  }\n\n  async shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void> {\n    const { taskId } = options;\n    const message = `This task was marked as stale as it exceeded its timeout`;\n\n    const statusStepEvents = (await this.listEvents({ taskId })).events.filter(\n      ({ body }) => body?.stepId,\n    );\n\n    const completedSteps = statusStepEvents\n      .filter(\n        ({ body: { status } }) => status === 'failed' || status === 'completed',\n      )\n      .map(step => step.body.stepId);\n\n    const hungProcessingSteps = statusStepEvents\n      .filter(({ body: { status } }) => status === 'processing')\n      .map(event => event.body.stepId)\n      .filter(step => !completedSteps.includes(step));\n\n    for (const step of hungProcessingSteps) {\n      await this.emitLogEvent({\n        taskId,\n        body: {\n          message,\n          stepId: step,\n          status: 'failed',\n        },\n      });\n    }\n\n    await this.completeTask({\n      taskId,\n      status: 'failed',\n      eventBody: {\n        message,\n      },\n    });\n  }\n\n  async rehydrateWorkspace(options: {\n    taskId: string;\n    targetPath: string;\n  }): Promise<void> {\n    const [result] = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: options.taskId })\n      .select('workspace');\n\n    await restoreWorkspace({\n      path: options.targetPath,\n      buffer: result.workspace,\n    });\n  }\n\n  async cleanWorkspace({ taskId }: { taskId: string }): Promise<void> {\n    await this.db('tasks').where({ id: taskId }).update({\n      workspace: null,\n    });\n  }\n\n  async serializeWorkspace(options: {\n    path: string;\n    taskId: string;\n  }): Promise<void> {\n    if (options.path) {\n      const workspace = (await serializeWorkspace(options)).contents;\n      await this.db<RawDbTaskRow>('tasks')\n        .where({ id: options.taskId })\n        .update({\n          workspace,\n        });\n    }\n  }\n\n  async cancelTask(\n    options: TaskStoreEmitOptions<{ message: string } & JsonObject>,\n  ): Promise<void> {\n    const { taskId, body } = options;\n    const serializedBody = JSON.stringify(body);\n    const [ret] = await this.db<RawDbTaskEventRow>('task_events')\n      .insert({\n        task_id: taskId,\n        event_type: 'cancelled',\n        body: serializedBody,\n      })\n      .returning('id');\n\n    this.events?.publish({\n      topic: 'scaffolder.task',\n      eventPayload: {\n        id: ret.id,\n        taskId,\n        status: 'cancelled',\n        body,\n      },\n    });\n  }\n\n  async retryTask?(options: { taskId: string }): Promise<void> {\n    await this.db.transaction(async tx => {\n      const result = await tx<RawDbTaskRow>('tasks')\n        .where('id', options.taskId)\n        .update(\n          {\n            status: 'open',\n            last_heartbeat_at: this.db.fn.now(),\n          },\n          ['id', 'spec'],\n        );\n\n      for (const { id, spec } of result) {\n        const taskSpec = JSON.parse(spec as string) as TaskSpec;\n\n        /**\n         * Once task is picked up, all event types are replayed.\n         * We have to remove cancelled or completion event_type as these are as actions for frontend to perform.\n         * In contrary, we send 'recovered' event_type to reset the state on the frontend side.\n         *\n         */\n        await tx<RawDbTaskEventRow>('task_events')\n          .where('task_id', id)\n          .andWhere(q => q.whereIn('event_type', ['cancelled', 'completion']))\n          .del();\n\n        await tx<RawDbTaskEventRow>('task_events').insert({\n          task_id: id,\n          event_type: 'recovered',\n          body: JSON.stringify({\n            recoverStrategy:\n              taskSpec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? 'none',\n          }),\n        });\n      }\n    });\n  }\n\n  async recoverTasks(\n    options: TaskStoreRecoverTaskOptions,\n  ): Promise<{ ids: string[] }> {\n    const taskIdsToRecover: string[] = [];\n    const timeoutS = Duration.fromObject(options.timeout).as('seconds');\n\n    await this.db.transaction(async tx => {\n      const heartbeatInterval = intervalFromNowTill(timeoutS, this.db);\n\n      const result = await tx<RawDbTaskRow>('tasks')\n        .where('status', 'processing')\n        .andWhere('last_heartbeat_at', '<=', heartbeatInterval)\n        .update(\n          {\n            status: 'open',\n            last_heartbeat_at: this.db.fn.now(),\n          },\n          ['id', 'spec'],\n        );\n\n      taskIdsToRecover.push(...result.map(i => i.id));\n\n      for (const { id, spec } of result) {\n        const taskSpec = JSON.parse(spec as string) as TaskSpec;\n        const event = {\n          recoverStrategy:\n            taskSpec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ?? 'none',\n        };\n        const [ret] = await tx<RawDbTaskEventRow>('task_events')\n          .insert({\n            task_id: id,\n            event_type: 'recovered',\n            body: JSON.stringify(event),\n          })\n          .returning('id');\n\n        this.events?.publish({\n          topic: 'scaffolder.task',\n          eventPayload: {\n            id: ret.id,\n            taskId: id,\n            status: 'recovered',\n            body: event,\n          },\n        });\n      }\n    });\n\n    return { ids: taskIdsToRecover };\n  }\n}\n"],"names":["resolvePackagePath","DateTime","flattenParams","NotFoundError","uuid","ConflictError","intervalFromNowTill","trimEventsTillLastRecovery","restoreWorkspace","serializeWorkspace","Duration"],"mappings":"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"}