'use strict';

var path = require('path');
var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var globby = require('globby');
var fs = require('fs-extra');
var isbinaryfile = require('isbinaryfile');
var SecureTemplater = require('../../../../lib/templating/SecureTemplater.cjs.js');
var filters = require('../../../../lib/templating/filters.cjs.js');
var template_examples = require('./template.examples.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var globby__default = /*#__PURE__*/_interopDefaultCompat(globby);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function createFetchTemplateAction(options) {
  const {
    reader,
    integrations,
    additionalTemplateFilters,
    additionalTemplateGlobals
  } = options;
  const defaultTemplateFilters = filters.createDefaultFilters({ integrations });
  return pluginScaffolderNode.createTemplateAction({
    id: "fetch:template",
    description: "Downloads a skeleton, templates variables into file and directory names and content, and places the result in the workspace, or optionally in a subdirectory specified by the `targetPath` input option.",
    examples: template_examples.examples,
    schema: {
      input: {
        type: "object",
        required: ["url"],
        properties: {
          url: {
            title: "Fetch URL",
            description: "Relative path or absolute URL pointing to the directory tree to fetch",
            type: "string"
          },
          targetPath: {
            title: "Target Path",
            description: "Target path within the working directory to download the contents to. Defaults to the working directory root.",
            type: "string"
          },
          values: {
            title: "Template Values",
            description: "Values to pass on to the templating engine",
            type: "object"
          },
          copyWithoutRender: {
            title: "[Deprecated] Copy Without Render",
            description: "An array of glob patterns. Any files or directories which match are copied without being processed as templates.",
            type: "array",
            items: {
              type: "string"
            }
          },
          copyWithoutTemplating: {
            title: "Copy Without Templating",
            description: "An array of glob patterns. Contents of matched files or directories are copied without being processed, but paths are subject to rendering.",
            type: "array",
            items: {
              type: "string"
            }
          },
          cookiecutterCompat: {
            title: "Cookiecutter compatibility mode",
            description: "Enable features to maximise compatibility with templates built for fetch:cookiecutter",
            type: "boolean"
          },
          templateFileExtension: {
            title: "Template File Extension",
            description: "If set, only files with the given extension will be templated. If set to `true`, the default extension `.njk` is used.",
            type: ["string", "boolean"]
          },
          replace: {
            title: "Replace files",
            description: "If set, replace files in targetPath instead of skipping existing ones.",
            type: "boolean"
          },
          token: {
            title: "Token",
            description: "An optional token to use for authentication when reading the resources.",
            type: "string"
          }
        }
      }
    },
    supportsDryRun: true,
    async handler(ctx) {
      ctx.logger.info("Fetching template content from remote URL");
      const workDir = await ctx.createTemporaryDirectory();
      const templateDir = backendPluginApi.resolveSafeChildPath(workDir, "template");
      const targetPath = ctx.input.targetPath ?? "./";
      const outputDir = backendPluginApi.resolveSafeChildPath(ctx.workspacePath, targetPath);
      if (ctx.input.copyWithoutRender && ctx.input.copyWithoutTemplating) {
        throw new errors.InputError(
          "Fetch action input copyWithoutRender and copyWithoutTemplating can not be used at the same time"
        );
      }
      let copyOnlyPatterns;
      let renderFilename;
      if (ctx.input.copyWithoutRender) {
        ctx.logger.warn(
          "[Deprecated] copyWithoutRender is deprecated Please use copyWithoutTemplating instead."
        );
        copyOnlyPatterns = ctx.input.copyWithoutRender;
        renderFilename = false;
      } else {
        copyOnlyPatterns = ctx.input.copyWithoutTemplating;
        renderFilename = true;
      }
      if (copyOnlyPatterns && !Array.isArray(copyOnlyPatterns)) {
        throw new errors.InputError(
          "Fetch action input copyWithoutRender/copyWithoutTemplating must be an Array"
        );
      }
      if (ctx.input.templateFileExtension && (copyOnlyPatterns || ctx.input.cookiecutterCompat)) {
        throw new errors.InputError(
          "Fetch action input extension incompatible with copyWithoutRender/copyWithoutTemplating and cookiecutterCompat"
        );
      }
      let extension = false;
      if (ctx.input.templateFileExtension) {
        extension = ctx.input.templateFileExtension === true ? ".njk" : ctx.input.templateFileExtension;
        if (!extension.startsWith(".")) {
          extension = `.${extension}`;
        }
      }
      await pluginScaffolderNode.fetchContents({
        reader,
        integrations,
        baseUrl: ctx.templateInfo?.baseUrl,
        fetchUrl: ctx.input.url,
        outputPath: templateDir,
        token: ctx.input.token
      });
      ctx.logger.info("Listing files and directories in template");
      const allEntriesInTemplate = await globby__default.default(`**/*`, {
        cwd: templateDir,
        dot: true,
        onlyFiles: false,
        markDirectories: true,
        followSymbolicLinks: false
      });
      const nonTemplatedEntries = new Set(
        await globby__default.default(copyOnlyPatterns || [], {
          cwd: templateDir,
          dot: true,
          onlyFiles: false,
          markDirectories: true,
          followSymbolicLinks: false
        })
      );
      const { cookiecutterCompat, values } = ctx.input;
      const context = {
        [cookiecutterCompat ? "cookiecutter" : "values"]: values
      };
      ctx.logger.info(
        `Processing ${allEntriesInTemplate.length} template files/directories with input values`,
        ctx.input.values
      );
      const renderTemplate = await SecureTemplater.SecureTemplater.loadRenderer({
        cookiecutterCompat: ctx.input.cookiecutterCompat,
        templateFilters: {
          ...defaultTemplateFilters,
          ...additionalTemplateFilters
        },
        templateGlobals: additionalTemplateGlobals,
        nunjucksConfigs: {
          trimBlocks: ctx.input.trimBlocks,
          lstripBlocks: ctx.input.lstripBlocks
        }
      });
      for (const location of allEntriesInTemplate) {
        let renderContents;
        let localOutputPath = location;
        if (extension) {
          renderContents = path.extname(localOutputPath) === extension;
          if (renderContents) {
            localOutputPath = localOutputPath.slice(0, -extension.length);
          }
          localOutputPath = renderTemplate(localOutputPath, context);
        } else {
          renderContents = !nonTemplatedEntries.has(location);
          if (renderFilename) {
            localOutputPath = renderTemplate(localOutputPath, context);
          } else {
            localOutputPath = renderContents ? renderTemplate(localOutputPath, context) : localOutputPath;
          }
        }
        if (containsSkippedContent(localOutputPath)) {
          continue;
        }
        const outputPath = backendPluginApi.resolveSafeChildPath(outputDir, localOutputPath);
        if (fs__default.default.existsSync(outputPath) && !ctx.input.replace) {
          continue;
        }
        if (!renderContents && !extension) {
          ctx.logger.info(
            `Copying file/directory ${location} without processing.`
          );
        }
        if (location.endsWith("/")) {
          ctx.logger.info(
            `Writing directory ${location} to template output path.`
          );
          await fs__default.default.ensureDir(outputPath);
        } else {
          const inputFilePath = backendPluginApi.resolveSafeChildPath(templateDir, location);
          const stats = await fs__default.default.promises.lstat(inputFilePath);
          if (stats.isSymbolicLink() || await isbinaryfile.isBinaryFile(inputFilePath)) {
            ctx.logger.info(
              `Copying file binary or symbolic link at ${location}, to template output path.`
            );
            await fs__default.default.copy(inputFilePath, outputPath);
          } else {
            const statsObj = await fs__default.default.stat(inputFilePath);
            ctx.logger.info(
              `Writing file ${location} to template output path with mode ${statsObj.mode}.`
            );
            const inputFileContents = await fs__default.default.readFile(inputFilePath, "utf-8");
            await fs__default.default.outputFile(
              outputPath,
              renderContents ? renderTemplate(inputFileContents, context) : inputFileContents,
              { mode: statsObj.mode }
            );
          }
        }
      }
      ctx.logger.info(`Template result written to ${outputDir}`);
    }
  });
}
function containsSkippedContent(localOutputPath) {
  return localOutputPath === "" || localOutputPath.startsWith("/") || localOutputPath.includes("//");
}

exports.createFetchTemplateAction = createFetchTemplateAction;
//# sourceMappingURL=template.cjs.js.map
