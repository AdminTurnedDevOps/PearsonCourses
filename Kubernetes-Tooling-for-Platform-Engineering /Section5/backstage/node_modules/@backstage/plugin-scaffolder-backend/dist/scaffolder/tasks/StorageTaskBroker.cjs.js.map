{"version":3,"file":"StorageTaskBroker.cjs.js","sources":["../../../src/scaffolder/tasks/StorageTaskBroker.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { TaskSpec } from '@backstage/plugin-scaffolder-common';\nimport {\n  JsonObject,\n  JsonValue,\n  Observable,\n  createDeferred,\n} from '@backstage/types';\nimport { Logger } from 'winston';\nimport ObservableImpl from 'zen-observable';\nimport {\n  SerializedTask,\n  SerializedTaskEvent,\n  TaskBroker,\n  TaskBrokerDispatchOptions,\n  TaskCompletionState,\n  TaskContext,\n  TaskSecrets,\n  TaskStatus,\n} from '@backstage/plugin-scaffolder-node';\nimport { InternalTaskSecrets, TaskStore } from './types';\nimport { readDuration } from './helper';\nimport {\n  AuthService,\n  BackstageCredentials,\n} from '@backstage/backend-plugin-api';\nimport { DefaultWorkspaceService, WorkspaceService } from './WorkspaceService';\nimport { WorkspaceProvider } from '@backstage/plugin-scaffolder-node/alpha';\n\ntype TaskState = {\n  checkpoints: {\n    [key: string]:\n      | {\n          status: 'failed';\n          reason: string;\n        }\n      | {\n          status: 'success';\n          value: JsonValue;\n        };\n  };\n};\n/**\n * TaskManager\n *\n * @public\n */\nexport class TaskManager implements TaskContext {\n  private isDone = false;\n\n  private heartbeatTimeoutId?: ReturnType<typeof setInterval>;\n\n  static create(\n    task: CurrentClaimedTask,\n    storage: TaskStore,\n    abortSignal: AbortSignal,\n    logger: Logger,\n    auth?: AuthService,\n    config?: Config,\n    additionalWorkspaceProviders?: Record<string, WorkspaceProvider>,\n  ) {\n    const workspaceService = DefaultWorkspaceService.create(\n      task,\n      storage,\n      additionalWorkspaceProviders,\n      config,\n    );\n\n    const agent = new TaskManager(\n      task,\n      storage,\n      abortSignal,\n      logger,\n      workspaceService,\n      auth,\n    );\n    agent.startTimeout();\n    return agent;\n  }\n\n  // Runs heartbeat internally\n  private constructor(\n    private readonly task: CurrentClaimedTask,\n    private readonly storage: TaskStore,\n    private readonly signal: AbortSignal,\n    private readonly logger: Logger,\n    private readonly workspaceService: WorkspaceService,\n    private readonly auth?: AuthService,\n  ) {}\n\n  get spec() {\n    return this.task.spec;\n  }\n\n  get cancelSignal() {\n    return this.signal;\n  }\n\n  get secrets() {\n    return this.task.secrets;\n  }\n\n  get createdBy() {\n    return this.task.createdBy;\n  }\n\n  async getWorkspaceName() {\n    return this.task.taskId;\n  }\n\n  async rehydrateWorkspace?(options: {\n    taskId: string;\n    targetPath: string;\n  }): Promise<void> {\n    await this.workspaceService.rehydrateWorkspace(options);\n  }\n\n  get done() {\n    return this.isDone;\n  }\n\n  async emitLog(message: string, logMetadata?: JsonObject): Promise<void> {\n    await this.storage.emitLogEvent({\n      taskId: this.task.taskId,\n      body: { message, ...logMetadata },\n    });\n  }\n\n  async getTaskState?(): Promise<\n    | {\n        state?: JsonObject;\n      }\n    | undefined\n  > {\n    return this.storage.getTaskState?.({ taskId: this.task.taskId });\n  }\n\n  async updateCheckpoint?(\n    options:\n      | {\n          key: string;\n          status: 'success';\n          value: JsonValue;\n        }\n      | {\n          key: string;\n          status: 'failed';\n          reason: string;\n        },\n  ): Promise<void> {\n    const { key, ...value } = options;\n    if (this.task.state) {\n      (this.task.state as TaskState).checkpoints[key] = value;\n    } else {\n      this.task.state = { checkpoints: { [key]: value } };\n    }\n    await this.storage.saveTaskState?.({\n      taskId: this.task.taskId,\n      state: this.task.state,\n    });\n  }\n\n  async serializeWorkspace?(options: { path: string }): Promise<void> {\n    await this.workspaceService.serializeWorkspace(options);\n  }\n\n  async cleanWorkspace?(): Promise<void> {\n    await this.workspaceService.cleanWorkspace();\n  }\n\n  async complete(\n    result: TaskCompletionState,\n    metadata?: JsonObject,\n  ): Promise<void> {\n    await this.storage.completeTask({\n      taskId: this.task.taskId,\n      status: result === 'failed' ? 'failed' : 'completed',\n      eventBody: {\n        message: `Run completed with status: ${result}`,\n        ...metadata,\n      },\n    });\n    this.isDone = true;\n    if (this.heartbeatTimeoutId) {\n      clearTimeout(this.heartbeatTimeoutId);\n    }\n  }\n\n  private startTimeout() {\n    this.heartbeatTimeoutId = setTimeout(async () => {\n      try {\n        await this.storage.heartbeatTask(this.task.taskId);\n        this.startTimeout();\n      } catch (error) {\n        this.isDone = true;\n\n        this.logger.error(\n          `Heartbeat for task ${this.task.taskId} failed`,\n          error,\n        );\n      }\n    }, 1000);\n  }\n\n  async getInitiatorCredentials(): Promise<BackstageCredentials> {\n    const secrets = this.task.secrets as InternalTaskSecrets;\n\n    if (secrets && secrets.__initiatorCredentials) {\n      return JSON.parse(secrets.__initiatorCredentials);\n    }\n    if (!this.auth) {\n      throw new Error(\n        'Failed to create none credentials in scaffolder task. The TaskManager has not been initialized with an auth service implementation',\n      );\n    }\n    return this.auth.getNoneCredentials();\n  }\n}\n\n/**\n * Stores the state of the current claimed task passed to the TaskContext\n *\n * @public\n */\nexport interface CurrentClaimedTask {\n  /**\n   * The TaskSpec of the current claimed task.\n   */\n  spec: TaskSpec;\n  /**\n   * The uuid of the current claimed task.\n   */\n  taskId: string;\n  /**\n   * The secrets that are stored with the task.\n   */\n  secrets?: TaskSecrets;\n  /**\n   * The state of checkpoints of the task.\n   */\n  state?: JsonObject;\n  /**\n   * The creator of the task.\n   */\n  createdBy?: string;\n  /**\n   * The workspace of the task.\n   */\n  workspace?: Promise<Buffer>;\n}\n\nexport class StorageTaskBroker implements TaskBroker {\n  constructor(\n    private readonly storage: TaskStore,\n    private readonly logger: Logger,\n    private readonly config?: Config,\n    private readonly auth?: AuthService,\n    private readonly additionalWorkspaceProviders?: Record<\n      string,\n      WorkspaceProvider\n    >,\n  ) {}\n\n  async list(options?: {\n    createdBy?: string;\n    status?: TaskStatus;\n    filters?: {\n      createdBy?: string | string[];\n      status?: TaskStatus | TaskStatus[];\n    };\n    pagination?: {\n      limit?: number;\n      offset?: number;\n    };\n    order?: { order: 'asc' | 'desc'; field: string }[];\n  }): Promise<{ tasks: SerializedTask[]; totalTasks?: number }> {\n    if (!this.storage.list) {\n      throw new Error(\n        'TaskStore does not implement the list method. Please implement the list method to be able to list tasks',\n      );\n    }\n    return await this.storage.list(options ?? {});\n  }\n\n  private deferredDispatch = createDeferred();\n\n  private async registerCancellable(\n    taskId: string,\n    abortController: AbortController,\n  ) {\n    let shouldUnsubscribe = false;\n    const subscription = this.event$({ taskId, after: undefined }).subscribe({\n      error: _ => {\n        subscription.unsubscribe();\n      },\n      next: ({ events }) => {\n        for (const event of events) {\n          if (event.type === 'cancelled') {\n            abortController.abort();\n            shouldUnsubscribe = true;\n          }\n\n          if (event.type === 'completion' && !event.isTaskRecoverable) {\n            shouldUnsubscribe = true;\n          }\n        }\n        if (shouldUnsubscribe) {\n          subscription.unsubscribe();\n        }\n      },\n    });\n  }\n\n  public async recoverTasks(): Promise<void> {\n    const enabled =\n      (this.config &&\n        this.config.getOptionalBoolean(\n          'scaffolder.EXPERIMENTAL_recoverTasks',\n        )) ??\n      false;\n\n    if (enabled) {\n      const defaultTimeout = { seconds: 30 };\n      const timeout = readDuration(\n        this.config,\n        'scaffolder.EXPERIMENTAL_recoverTasksTimeout',\n        defaultTimeout,\n      );\n      const { ids: recoveredTaskIds } = (await this.storage.recoverTasks?.({\n        timeout,\n      })) ?? { ids: [] };\n      if (recoveredTaskIds.length > 0) {\n        this.signalDispatch();\n      }\n    }\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.claim}\n   */\n  async claim(): Promise<TaskContext> {\n    for (;;) {\n      const pendingTask = await this.storage.claimTask();\n      if (pendingTask) {\n        const abortController = new AbortController();\n        await this.registerCancellable(pendingTask.id, abortController);\n        return TaskManager.create(\n          {\n            taskId: pendingTask.id,\n            spec: pendingTask.spec,\n            secrets: pendingTask.secrets,\n            createdBy: pendingTask.createdBy,\n            state: pendingTask.state,\n          },\n          this.storage,\n          abortController.signal,\n          this.logger,\n          this.auth,\n          this.config,\n          this.additionalWorkspaceProviders,\n        );\n      }\n\n      await this.waitForDispatch();\n    }\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.dispatch}\n   */\n  async dispatch(\n    options: TaskBrokerDispatchOptions,\n  ): Promise<{ taskId: string }> {\n    const taskRow = await this.storage.createTask(options);\n    this.signalDispatch();\n    return {\n      taskId: taskRow.taskId,\n    };\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.get}\n   */\n  async get(taskId: string): Promise<SerializedTask> {\n    return this.storage.getTask(taskId);\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.event$}\n   */\n  event$(options: {\n    taskId: string;\n    after?: number;\n  }): Observable<{ events: SerializedTaskEvent[] }> {\n    return new ObservableImpl(observer => {\n      const { taskId } = options;\n\n      let after = options.after;\n      let cancelled = false;\n\n      (async () => {\n        const task = await this.storage.getTask(taskId);\n        const isTaskRecoverable =\n          task.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy ===\n          'startOver';\n\n        while (!cancelled) {\n          const result = await this.storage.listEvents({\n            isTaskRecoverable,\n            taskId,\n            after,\n          });\n          const { events } = result;\n          if (events.length) {\n            after = events[events.length - 1].id;\n            observer.next(result);\n          }\n\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      })();\n\n      return () => {\n        cancelled = true;\n      };\n    });\n  }\n\n  /**\n   * {@inheritdoc TaskBroker.vacuumTasks}\n   */\n  async vacuumTasks(options: { timeoutS: number }): Promise<void> {\n    const { tasks } = await this.storage.listStaleTasks(options);\n    await Promise.all(\n      tasks.map(async task => {\n        try {\n          await this.storage.completeTask({\n            taskId: task.taskId,\n            status: 'failed',\n            eventBody: {\n              message:\n                'The task was cancelled because the task worker lost connection to the task broker',\n            },\n          });\n        } catch (error) {\n          this.logger.warn(`Failed to cancel task '${task.taskId}', ${error}`);\n        }\n      }),\n    );\n  }\n\n  private waitForDispatch() {\n    return this.deferredDispatch;\n  }\n\n  private signalDispatch() {\n    this.deferredDispatch.resolve();\n    this.deferredDispatch = createDeferred();\n  }\n\n  async cancel(taskId: string) {\n    const { events } = await this.storage.listEvents({ taskId });\n    const currentStepId =\n      events.length > 0\n        ? events\n            .filter(({ body }) => body?.stepId)\n            .reduce((prev, curr) => (prev.id > curr.id ? prev : curr)).body\n            .stepId\n        : 0;\n\n    await this.storage.cancelTask?.({\n      taskId,\n      body: {\n        message: `Step ${currentStepId} has been cancelled.`,\n        stepId: currentStepId,\n        status: 'cancelled',\n      },\n    });\n  }\n\n  async retry?(taskId: string): Promise<void> {\n    await this.storage.retryTask?.({ taskId });\n    this.signalDispatch();\n  }\n}\n"],"names":["DefaultWorkspaceService","createDeferred","readDuration","ObservableImpl"],"mappings":"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"}