'use strict';

var winston = require('winston');
var fs = require('fs-extra');
var path = require('path');
var nunjucks = require('nunjucks');
var errors = require('@backstage/errors');
var stream = require('stream');
var helper = require('./helper.cjs.js');
var jsonschema = require('jsonschema');
var api = require('@opentelemetry/api');
var SecureTemplater = require('../../lib/templating/SecureTemplater.cjs.js');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var metrics = require('../../util/metrics.cjs.js');
var filters = require('../../lib/templating/filters.cjs.js');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var rules = require('../../service/rules.cjs.js');
var alpha = require('@backstage/plugin-scaffolder-common/alpha');
var backendCommon = require('@backstage/backend-common');
var logger = require('./logger.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var winston__namespace = /*#__PURE__*/_interopNamespaceCompat(winston);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var nunjucks__default = /*#__PURE__*/_interopDefaultCompat(nunjucks);

const isValidTaskSpec = (taskSpec) => {
  return taskSpec.apiVersion === "scaffolder.backstage.io/v1beta3";
};
const createStepLogger = ({
  task,
  step,
  rootLogger
}) => {
  const taskLogger = logger.WinstonLogger.create({
    level: process.env.LOG_LEVEL || "info",
    format: winston__namespace.format.combine(
      winston__namespace.format.colorize(),
      winston__namespace.format.simple()
    ),
    transports: [new logger.BackstageLoggerTransport(rootLogger, task, step.id)]
  });
  taskLogger.addRedactions(Object.values(task.secrets ?? {}));
  const streamLogger = new stream.PassThrough();
  streamLogger.on("data", async (data) => {
    const message = data.toString().trim();
    if (message?.length > 1) {
      taskLogger.info(message);
    }
  });
  return { taskLogger, streamLogger };
};
const isActionAuthorized = pluginPermissionNode.createConditionAuthorizer(
  Object.values(rules.scaffolderActionRules)
);
class NunjucksWorkflowRunner {
  constructor(options) {
    this.options = options;
    this.defaultTemplateFilters = filters.createDefaultFilters({
      integrations: this.options.integrations
    });
  }
  defaultTemplateFilters;
  tracker = scaffoldingTracker();
  isSingleTemplateString(input) {
    const { parser, nodes } = nunjucks__default.default;
    const parsed = parser.parse(
      input,
      {},
      {
        autoescape: false,
        tags: {
          variableStart: "${{",
          variableEnd: "}}"
        }
      }
    );
    return parsed.children.length === 1 && !(parsed.children[0]?.children?.[0] instanceof nodes.TemplateData);
  }
  render(input, context, renderTemplate) {
    return JSON.parse(JSON.stringify(input), (_key, value) => {
      try {
        if (typeof value === "string") {
          try {
            if (this.isSingleTemplateString(value)) {
              const wrappedDumped = value.replace(
                /\${{(.+)}}/g,
                "${{ ( $1 ) | dump }}"
              );
              const templated2 = renderTemplate(wrappedDumped, context);
              if (templated2 === "") {
                return void 0;
              }
              return JSON.parse(templated2);
            }
          } catch (ex) {
            this.options.logger.error(
              `Failed to parse template string: ${value} with error ${ex.message}`
            );
          }
          const templated = renderTemplate(value, context);
          if (templated === "") {
            return void 0;
          }
          return templated;
        }
      } catch {
        return value;
      }
      return value;
    });
  }
  async executeStep(task, step, context, renderTemplate, taskTrack, workspacePath, decision) {
    const stepTrack = await this.tracker.stepStart(task, step);
    if (task.cancelSignal.aborted) {
      throw new Error(`Step ${step.name} has been cancelled.`);
    }
    try {
      if (step.if === false || typeof step.if === "string" && !helper.isTruthy(this.render(step.if, context, renderTemplate))) {
        await stepTrack.skipFalsy();
        return;
      }
      const action = this.options.actionRegistry.get(step.action);
      const { taskLogger, streamLogger } = createStepLogger({
        task,
        step,
        rootLogger: this.options.logger
      });
      if (task.isDryRun) {
        const redactedSecrets = Object.fromEntries(
          Object.entries(task.secrets ?? {}).map((secret) => [secret[0], "***"])
        );
        const debugInput = (step.input && this.render(
          step.input,
          {
            ...context,
            secrets: redactedSecrets
          },
          renderTemplate
        )) ?? {};
        taskLogger.info(
          `Running ${action.id} in dry-run mode with inputs (secrets redacted): ${JSON.stringify(
            debugInput,
            void 0,
            2
          )}`
        );
        if (!action.supportsDryRun) {
          await taskTrack.skipDryRun(step, action);
          const outputSchema = action.schema?.output;
          if (outputSchema) {
            context.steps[step.id] = {
              output: helper.generateExampleOutput(outputSchema)
            };
          } else {
            context.steps[step.id] = { output: {} };
          }
          return;
        }
      }
      const iterations = (step.each ? Object.entries(this.render(step.each, context, renderTemplate)).map(
        ([key, value]) => ({
          each: { key, value }
        })
      ) : [{}]).map((i) => ({
        ...i,
        // Secrets are only passed when templating the input to actions for security reasons
        input: step.input ? this.render(
          step.input,
          { ...context, secrets: task.secrets ?? {}, ...i },
          renderTemplate
        ) : {}
      }));
      for (const iteration of iterations) {
        const actionId = `${action.id}${iteration.each ? `[${iteration.each.key}]` : ""}`;
        if (action.schema?.input) {
          const validateResult = jsonschema.validate(
            iteration.input,
            action.schema.input
          );
          if (!validateResult.valid) {
            const errors$1 = validateResult.errors.join(", ");
            throw new errors.InputError(
              `Invalid input passed to action ${actionId}, ${errors$1}`
            );
          }
        }
        if (!isActionAuthorized(decision, {
          action: action.id,
          input: iteration.input
        })) {
          throw new errors.NotAllowedError(
            `Unauthorized action: ${actionId}. The action is not allowed. Input: ${JSON.stringify(
              iteration.input,
              null,
              2
            )}`
          );
        }
      }
      const tmpDirs = new Array();
      const stepOutput = {};
      const prevTaskState = await task.getTaskState?.();
      for (const iteration of iterations) {
        if (iteration.each) {
          taskLogger.info(
            `Running step each: ${JSON.stringify(
              iteration.each,
              (k, v) => k ? v.toString() : v,
              0
            )}`
          );
        }
        await action.handler({
          input: iteration.input,
          secrets: task.secrets ?? {},
          // TODO(blam): move to LoggerService and away from Winston
          logger: backendCommon.loggerToWinstonLogger(taskLogger),
          logStream: streamLogger,
          workspacePath,
          async checkpoint(opts) {
            const { key: checkpointKey, fn } = opts;
            const key = `v1.task.checkpoint.${step.id}.${checkpointKey}`;
            try {
              let prevValue;
              if (prevTaskState) {
                const prevState = prevTaskState.state?.checkpoints?.[key];
                if (prevState && prevState.status === "success") {
                  prevValue = prevState.value;
                }
              }
              const value = prevValue ? prevValue : await fn();
              if (!prevValue) {
                task.updateCheckpoint?.({
                  key,
                  status: "success",
                  value: value ?? {}
                });
              }
              return value;
            } catch (err) {
              task.updateCheckpoint?.({
                key,
                status: "failed",
                reason: errors.stringifyError(err)
              });
              throw err;
            } finally {
              await task.serializeWorkspace?.({ path: workspacePath });
            }
          },
          createTemporaryDirectory: async () => {
            const tmpDir = await fs__default.default.mkdtemp(
              `${workspacePath}_step-${step.id}-`
            );
            tmpDirs.push(tmpDir);
            return tmpDir;
          },
          output(name, value) {
            if (step.each) {
              stepOutput[name] = stepOutput[name] || [];
              stepOutput[name].push(value);
            } else {
              stepOutput[name] = value;
            }
          },
          templateInfo: task.spec.templateInfo,
          user: task.spec.user,
          isDryRun: task.isDryRun,
          signal: task.cancelSignal,
          getInitiatorCredentials: () => task.getInitiatorCredentials()
        });
      }
      for (const tmpDir of tmpDirs) {
        await fs__default.default.remove(tmpDir);
      }
      context.steps[step.id] = { output: stepOutput };
      if (task.cancelSignal.aborted) {
        throw new Error(`Step ${step.name} has been cancelled.`);
      }
      await stepTrack.markSuccessful();
    } catch (err) {
      await taskTrack.markFailed(step, err);
      await stepTrack.markFailed();
      throw err;
    } finally {
      await task.serializeWorkspace?.({ path: workspacePath });
    }
  }
  async execute(task) {
    if (!isValidTaskSpec(task.spec)) {
      throw new errors.InputError(
        "Wrong template version executed with the workflow engine"
      );
    }
    const taskId = await task.getWorkspaceName();
    const workspacePath = path__default.default.join(this.options.workingDirectory, taskId);
    const { additionalTemplateFilters, additionalTemplateGlobals } = this.options;
    const renderTemplate = await SecureTemplater.SecureTemplater.loadRenderer({
      templateFilters: {
        ...this.defaultTemplateFilters,
        ...additionalTemplateFilters
      },
      templateGlobals: additionalTemplateGlobals
    });
    try {
      await task.rehydrateWorkspace?.({ taskId, targetPath: workspacePath });
      const taskTrack = await this.tracker.taskStart(task);
      await fs__default.default.ensureDir(workspacePath);
      const context = {
        parameters: task.spec.parameters,
        steps: {},
        user: task.spec.user
      };
      const [decision] = this.options.permissions && task.spec.steps.length ? await this.options.permissions.authorizeConditional(
        [{ permission: alpha.actionExecutePermission }],
        { credentials: await task.getInitiatorCredentials() }
      ) : [{ result: pluginPermissionCommon.AuthorizeResult.ALLOW }];
      for (const step of task.spec.steps) {
        await this.executeStep(
          task,
          step,
          context,
          renderTemplate,
          taskTrack,
          workspacePath,
          decision
        );
      }
      const output = this.render(task.spec.output, context, renderTemplate);
      await taskTrack.markSuccessful();
      await task.cleanWorkspace?.();
      return { output };
    } finally {
      if (workspacePath) {
        await fs__default.default.remove(workspacePath);
      }
    }
  }
}
function scaffoldingTracker() {
  const promTaskCount = metrics.createCounterMetric({
    name: "scaffolder_task_count",
    help: "Count of task runs",
    labelNames: ["template", "user", "result"]
  });
  const promTaskDuration = metrics.createHistogramMetric({
    name: "scaffolder_task_duration",
    help: "Duration of a task run",
    labelNames: ["template", "result"]
  });
  const promtStepCount = metrics.createCounterMetric({
    name: "scaffolder_step_count",
    help: "Count of step runs",
    labelNames: ["template", "step", "result"]
  });
  const promStepDuration = metrics.createHistogramMetric({
    name: "scaffolder_step_duration",
    help: "Duration of a step runs",
    labelNames: ["template", "step", "result"]
  });
  const meter = api.metrics.getMeter("default");
  const taskCount = meter.createCounter("scaffolder.task.count", {
    description: "Count of task runs"
  });
  const taskDuration = meter.createHistogram("scaffolder.task.duration", {
    description: "Duration of a task run",
    unit: "seconds"
  });
  const stepCount = meter.createCounter("scaffolder.step.count", {
    description: "Count of step runs"
  });
  const stepDuration = meter.createHistogram("scaffolder.step.duration", {
    description: "Duration of a step runs",
    unit: "seconds"
  });
  async function taskStart(task) {
    await task.emitLog(`Starting up task with ${task.spec.steps.length} steps`);
    const template = task.spec.templateInfo?.entityRef || "";
    const user = task.spec.user?.ref || "";
    const startTime = process.hrtime();
    const taskTimer = promTaskDuration.startTimer({
      template
    });
    function endTime() {
      const delta = process.hrtime(startTime);
      return delta[0] + delta[1] / 1e9;
    }
    async function skipDryRun(step, action) {
      task.emitLog(`Skipping because ${action.id} does not support dry-run`, {
        stepId: step.id,
        status: "skipped"
      });
    }
    async function markSuccessful() {
      promTaskCount.inc({
        template,
        user,
        result: "ok"
      });
      taskTimer({ result: "ok" });
      taskCount.add(1, { template, user, result: "ok" });
      taskDuration.record(endTime(), {
        result: "ok"
      });
    }
    async function markFailed(step, err) {
      await task.emitLog(String(err.stack), {
        stepId: step.id,
        status: "failed"
      });
      promTaskCount.inc({
        template,
        user,
        result: "failed"
      });
      taskTimer({ result: "failed" });
      taskCount.add(1, { template, user, result: "failed" });
      taskDuration.record(endTime(), {
        result: "failed"
      });
    }
    async function markCancelled(step) {
      await task.emitLog(`Step ${step.id} has been cancelled.`, {
        stepId: step.id,
        status: "cancelled"
      });
      promTaskCount.inc({
        template,
        user,
        result: "cancelled"
      });
      taskTimer({ result: "cancelled" });
      taskCount.add(1, { template, user, result: "cancelled" });
      taskDuration.record(endTime(), {
        result: "cancelled"
      });
    }
    return {
      skipDryRun,
      markCancelled,
      markSuccessful,
      markFailed
    };
  }
  async function stepStart(task, step) {
    await task.emitLog(`Beginning step ${step.name}`, {
      stepId: step.id,
      status: "processing"
    });
    const template = task.spec.templateInfo?.entityRef || "";
    const startTime = process.hrtime();
    const stepTimer = promStepDuration.startTimer({
      template,
      step: step.name
    });
    function endTime() {
      const delta = process.hrtime(startTime);
      return delta[0] + delta[1] / 1e9;
    }
    async function markSuccessful() {
      await task.emitLog(`Finished step ${step.name}`, {
        stepId: step.id,
        status: "completed"
      });
      promtStepCount.inc({
        template,
        step: step.name,
        result: "ok"
      });
      stepTimer({ result: "ok" });
      stepCount.add(1, { template, step: step.name, result: "ok" });
      stepDuration.record(endTime(), {
        result: "ok"
      });
    }
    async function markCancelled() {
      promtStepCount.inc({
        template,
        step: step.name,
        result: "cancelled"
      });
      stepTimer({ result: "cancelled" });
      stepCount.add(1, { template, step: step.name, result: "cancelled" });
      stepDuration.record(endTime(), {
        result: "cancelled"
      });
    }
    async function markFailed() {
      promtStepCount.inc({
        template,
        step: step.name,
        result: "failed"
      });
      stepTimer({ result: "failed" });
      stepCount.add(1, { template, step: step.name, result: "failed" });
      stepDuration.record(endTime(), {
        result: "failed"
      });
    }
    async function skipFalsy() {
      await task.emitLog(
        `Skipping step ${step.id} because its if condition was false`,
        { stepId: step.id, status: "skipped" }
      );
      stepTimer({ result: "skipped" });
      stepCount.add(1, { template, step: step.name, result: "skipped" });
      stepDuration.record(endTime(), {
        result: "skipped"
      });
    }
    return {
      markCancelled,
      markFailed,
      markSuccessful,
      skipFalsy
    };
  }
  return {
    taskStart,
    stepStart
  };
}

exports.NunjucksWorkflowRunner = NunjucksWorkflowRunner;
//# sourceMappingURL=NunjucksWorkflowRunner.cjs.js.map
