'use strict';

var PQueue = require('p-queue');
var NunjucksWorkflowRunner = require('./NunjucksWorkflowRunner.cjs.js');
var errors = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

class TaskWorker {
  constructor(options) {
    this.options = options;
    this.stopWorkers = false;
    this.logger = options.logger;
    this.taskQueue = new PQueue__default.default({
      concurrency: options.concurrentTasksLimit
    });
  }
  taskQueue;
  logger;
  stopWorkers;
  static async create(options) {
    const {
      taskBroker,
      logger,
      actionRegistry,
      integrations,
      workingDirectory,
      additionalTemplateFilters,
      concurrentTasksLimit = 10,
      // from 1 to Infinity
      additionalTemplateGlobals,
      permissions
    } = options;
    const workflowRunner = new NunjucksWorkflowRunner.NunjucksWorkflowRunner({
      actionRegistry,
      integrations,
      logger,
      workingDirectory,
      additionalTemplateFilters,
      additionalTemplateGlobals,
      permissions
    });
    return new TaskWorker({
      taskBroker,
      runners: { workflowRunner },
      concurrentTasksLimit,
      permissions
    });
  }
  async recoverTasks() {
    try {
      await this.options.taskBroker.recoverTasks?.();
    } catch (err) {
      this.logger?.error(errors.stringifyError(err));
    }
  }
  start() {
    (async () => {
      while (!this.stopWorkers) {
        await new Promise((resolve) => setTimeout(resolve, 1e4));
        await this.recoverTasks();
      }
    })();
    (async () => {
      while (!this.stopWorkers) {
        await this.onReadyToClaimTask();
        if (!this.stopWorkers) {
          const task = await this.options.taskBroker.claim();
          void this.taskQueue.add(() => this.runOneTask(task));
        }
      }
    })();
  }
  stop() {
    this.stopWorkers = true;
  }
  onReadyToClaimTask() {
    if (this.taskQueue.pending < this.options.concurrentTasksLimit) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.taskQueue.once("next", () => {
        resolve();
      });
    });
  }
  async runOneTask(task) {
    try {
      if (task.spec.apiVersion !== "scaffolder.backstage.io/v1beta3") {
        throw new Error(
          `Unsupported Template apiVersion ${task.spec.apiVersion}`
        );
      }
      const { output } = await this.options.runners.workflowRunner.execute(
        task
      );
      await task.complete("completed", { output });
    } catch (error) {
      errors.assertError(error);
      await task.complete("failed", {
        error: { name: error.name, message: error.message }
      });
    }
  }
}

exports.TaskWorker = TaskWorker;
//# sourceMappingURL=TaskWorker.cjs.js.map
