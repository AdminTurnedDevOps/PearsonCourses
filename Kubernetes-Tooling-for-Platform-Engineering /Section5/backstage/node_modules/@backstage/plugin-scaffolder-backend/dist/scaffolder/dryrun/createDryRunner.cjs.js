'use strict';

var url = require('url');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var path = require('path');
var NunjucksWorkflowRunner = require('../tasks/NunjucksWorkflowRunner.cjs.js');
var DecoratedActionsRegistry = require('./DecoratedActionsRegistry.cjs.js');
var fs = require('fs-extra');
var uuid = require('uuid');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function createDryRunner(options) {
  return async function dryRun(input) {
    let contentPromise;
    const workflowRunner = new NunjucksWorkflowRunner.NunjucksWorkflowRunner({
      ...options,
      actionRegistry: new DecoratedActionsRegistry.DecoratedActionsRegistry(options.actionRegistry, [
        pluginScaffolderNode.createTemplateAction({
          id: "dry-run:extract",
          supportsDryRun: true,
          async handler(ctx) {
            contentPromise = pluginScaffolderNode.serializeDirectoryContents(ctx.workspacePath);
            await contentPromise.catch(() => {
            });
          }
        })
      ])
    });
    const baseUrl = input.templateInfo.baseUrl;
    if (!baseUrl) {
      throw new Error("baseUrl is required");
    }
    const basePath = url.fileURLToPath(new URL(baseUrl));
    const contentsPath = path__default.default.dirname(basePath);
    const dryRunId = uuid.v4();
    const log = new Array();
    try {
      await pluginScaffolderNode.deserializeDirectoryContents(contentsPath, input.directoryContents);
      const abortSignal = new AbortController().signal;
      const result = await workflowRunner.execute({
        spec: {
          ...input.spec,
          steps: [
            ...input.spec.steps,
            {
              id: dryRunId,
              name: "dry-run:extract",
              action: "dry-run:extract"
            }
          ],
          templateInfo: input.templateInfo
        },
        secrets: input.secrets,
        getInitiatorCredentials: () => Promise.resolve(input.credentials),
        // No need to update this at the end of the run, so just hard-code it
        done: false,
        isDryRun: true,
        getWorkspaceName: async () => `dry-run-${dryRunId}`,
        cancelSignal: abortSignal,
        async emitLog(message, logMetadata) {
          if (logMetadata?.stepId === dryRunId) {
            return;
          }
          log.push({
            body: {
              ...logMetadata,
              message
            }
          });
        },
        complete: async () => {
          throw new Error("Not implemented");
        }
      });
      if (!contentPromise) {
        throw new Error("Content extraction step was skipped");
      }
      const directoryContents = await contentPromise;
      return {
        log,
        directoryContents,
        output: result.output
      };
    } finally {
      await fs__default.default.remove(contentsPath);
    }
  };
}

exports.createDryRunner = createDryRunner;
//# sourceMappingURL=createDryRunner.cjs.js.map
