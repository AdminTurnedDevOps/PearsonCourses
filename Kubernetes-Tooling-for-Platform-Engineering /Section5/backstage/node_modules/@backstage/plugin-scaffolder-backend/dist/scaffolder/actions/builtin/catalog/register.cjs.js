'use strict';

var errors = require('@backstage/errors');
var catalogModel = require('@backstage/catalog-model');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var register_examples = require('./register.examples.cjs.js');

const id = "catalog:register";
function createCatalogRegisterAction(options) {
  const { catalogClient, integrations, auth } = options;
  return pluginScaffolderNode.createTemplateAction({
    id,
    description: "Registers entities from a catalog descriptor file in the workspace into the software catalog.",
    examples: register_examples.examples,
    schema: {
      input: {
        oneOf: [
          {
            type: "object",
            required: ["catalogInfoUrl"],
            properties: {
              catalogInfoUrl: {
                title: "Catalog Info URL",
                description: "An absolute URL pointing to the catalog info file location",
                type: "string"
              },
              optional: {
                title: "Optional",
                description: "Permit the registered location to optionally exist. Default: false",
                type: "boolean"
              }
            }
          },
          {
            type: "object",
            required: ["repoContentsUrl"],
            properties: {
              repoContentsUrl: {
                title: "Repository Contents URL",
                description: "An absolute URL pointing to the root of a repository directory tree",
                type: "string"
              },
              catalogInfoPath: {
                title: "Fetch URL",
                description: "A relative path from the repo root pointing to the catalog info file, defaults to /catalog-info.yaml",
                type: "string"
              },
              optional: {
                title: "Optional",
                description: "Permit the registered location to optionally exist. Default: false",
                type: "boolean"
              }
            }
          }
        ]
      },
      output: {
        type: "object",
        required: ["catalogInfoUrl"],
        properties: {
          entityRef: {
            type: "string"
          },
          catalogInfoUrl: {
            type: "string"
          }
        }
      }
    },
    async handler(ctx) {
      const { input } = ctx;
      let catalogInfoUrl;
      if ("catalogInfoUrl" in input) {
        catalogInfoUrl = input.catalogInfoUrl;
      } else {
        const { repoContentsUrl, catalogInfoPath = "/catalog-info.yaml" } = input;
        const integration = integrations.byUrl(repoContentsUrl);
        if (!integration) {
          throw new errors.InputError(
            `No integration found for host ${repoContentsUrl}`
          );
        }
        catalogInfoUrl = integration.resolveUrl({
          base: repoContentsUrl,
          url: catalogInfoPath
        });
      }
      ctx.logger.info(`Registering ${catalogInfoUrl} in the catalog`);
      const { token } = await auth?.getPluginRequestToken({
        onBehalfOf: await ctx.getInitiatorCredentials(),
        targetPluginId: "catalog"
      }) ?? { token: ctx.secrets?.backstageToken };
      try {
        await catalogClient.addLocation(
          {
            type: "url",
            target: catalogInfoUrl
          },
          token ? { token } : {}
        );
      } catch (e) {
        if (!input.optional) {
          throw e;
        }
      }
      try {
        const result = await catalogClient.addLocation(
          {
            dryRun: true,
            type: "url",
            target: catalogInfoUrl
          },
          token ? { token } : {}
        );
        if (result.entities.length) {
          const { entities } = result;
          let entity;
          entity = entities.find(
            (e) => !e.metadata.name.startsWith("generated-") && e.kind === "Component"
          );
          if (!entity) {
            entity = entities.find(
              (e) => !e.metadata.name.startsWith("generated-")
            );
          }
          if (!entity) {
            entity = entities[0];
          }
          ctx.output("entityRef", catalogModel.stringifyEntityRef(entity));
        }
      } catch (e) {
        if (!input.optional) {
          throw e;
        }
      }
      ctx.output("catalogInfoUrl", catalogInfoUrl);
    }
  });
}

exports.createCatalogRegisterAction = createCatalogRegisterAction;
//# sourceMappingURL=register.cjs.js.map
