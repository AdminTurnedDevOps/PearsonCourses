'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var templateFile_examples = require('./templateFile.examples.cjs.js');
var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var SecureTemplater = require('../../../../lib/templating/SecureTemplater.cjs.js');
var filters = require('../../../../lib/templating/filters.cjs.js');
var path = require('path');
var fs = require('fs-extra');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function createFetchTemplateFileAction(options) {
  const {
    reader,
    integrations,
    additionalTemplateFilters,
    additionalTemplateGlobals
  } = options;
  const defaultTemplateFilters = filters.createDefaultFilters({ integrations });
  return pluginScaffolderNode.createTemplateAction({
    id: "fetch:template:file",
    description: "Downloads single file and places it in the workspace.",
    examples: templateFile_examples.examples,
    schema: {
      input: {
        type: "object",
        required: ["url", "targetPath"],
        properties: {
          url: {
            title: "Fetch URL",
            description: "Relative path or absolute URL pointing to the single file to fetch.",
            type: "string"
          },
          targetPath: {
            title: "Target Path",
            description: "Target path within the working directory to download the file as.",
            type: "string"
          },
          values: {
            title: "Template Values",
            description: "Values to pass on to the templating engine",
            type: "object"
          },
          cookiecutterCompat: {
            title: "Cookiecutter compatibility mode",
            description: "Enable features to maximise compatibility with templates built for fetch:cookiecutter",
            type: "boolean"
          },
          replace: {
            title: "Replace file",
            description: "If set, replace file in targetPath instead of overwriting existing one.",
            type: "boolean"
          },
          token: {
            title: "Token",
            description: "An optional token to use for authentication when reading the resources.",
            type: "string"
          }
        }
      }
    },
    supportsDryRun: true,
    async handler(ctx) {
      ctx.logger.info("Fetching template file content from remote URL");
      const workDir = await ctx.createTemporaryDirectory();
      const tmpFilePath = path__default.default.join(workDir, "tmp");
      const outputPath = backendPluginApi.resolveSafeChildPath(
        ctx.workspacePath,
        ctx.input.targetPath
      );
      if (fs__default.default.existsSync(outputPath) && !ctx.input.replace) {
        ctx.logger.info(
          `File ${ctx.input.targetPath} already exists in workspace, not replacing.`
        );
        return;
      }
      await pluginScaffolderNode.fetchFile({
        reader,
        integrations,
        baseUrl: ctx.templateInfo?.baseUrl,
        fetchUrl: ctx.input.url,
        outputPath: tmpFilePath,
        token: ctx.input.token
      });
      const { cookiecutterCompat, values } = ctx.input;
      const context = {
        [cookiecutterCompat ? "cookiecutter" : "values"]: values
      };
      ctx.logger.info(
        `Processing template file with input values`,
        ctx.input.values
      );
      const renderTemplate = await SecureTemplater.SecureTemplater.loadRenderer({
        cookiecutterCompat,
        templateFilters: {
          ...defaultTemplateFilters,
          ...additionalTemplateFilters
        },
        templateGlobals: additionalTemplateGlobals,
        nunjucksConfigs: {
          trimBlocks: ctx.input.trimBlocks,
          lstripBlocks: ctx.input.lstripBlocks
        }
      });
      const contents = await fs__default.default.readFile(tmpFilePath, "utf-8");
      const result = renderTemplate(contents, context);
      await fs__default.default.ensureDir(path__default.default.dirname(outputPath));
      await fs__default.default.outputFile(outputPath, result);
      ctx.logger.info(`Template file has been written to ${outputPath}`);
    }
  });
}

exports.createFetchTemplateFileAction = createFetchTemplateFileAction;
//# sourceMappingURL=templateFile.cjs.js.map
