'use strict';

var isolatedVm = require('isolated-vm');
var backendPluginApi = require('@backstage/backend-plugin-api');
var fs = require('fs-extra');
var helpers = require('./helpers.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const mkScript = (nunjucksSource) => `
const { render, renderCompat } = (() => {
  const module = {};
  const process = { env: {} };
  const require = (pkg) => { if (pkg === 'events') { return function (){}; }};

  ${nunjucksSource}

  const env = module.exports.configure({
    autoescape: false,
    ...JSON.parse(nunjucksConfigs),
    tags: {
      variableStart: '\${{',
      variableEnd: '}}',
    },
  });

  const compatEnv = module.exports.configure({
    autoescape: false,
    ...JSON.parse(nunjucksConfigs),
    tags: {
      variableStart: '{{',
      variableEnd: '}}',
    },
  });
  compatEnv.addFilter('jsonify', compatEnv.getFilter('dump'));

  const handleFunctionResult = (value) => {
    return value === '' ? undefined : JSON.parse(value);
  };
  for (const name of JSON.parse(availableTemplateFilters)) {
    env.addFilter(name, (...args) => handleFunctionResult(callFilter(name, args)));
  }
  for (const [name, value] of Object.entries(JSON.parse(availableTemplateGlobals))) {
    env.addGlobal(name, value);
  }
  for (const name of JSON.parse(availableTemplateCallbacks)) {
    env.addGlobal(name, (...args) => handleFunctionResult(callGlobal(name, args)));
  }

  let uninstallCompat = undefined;

  function render(str, values) {
    try {
      if (uninstallCompat) {
        uninstallCompat();
        uninstallCompat = undefined;
      }
      return env.renderString(str, JSON.parse(values));
    } catch (error) {
      // Make sure errors don't leak anything
      throw new Error(String(error.message));
    }
  }

  function renderCompat(str, values) {
    try {
      if (!uninstallCompat) {
        uninstallCompat = module.exports.installJinjaCompat();
      }
      return compatEnv.renderString(str, JSON.parse(values));
    } catch (error) {
      // Make sure errors don't leak anything
      throw new Error(String(error.message));
    }
  }

  return { render, renderCompat };
})();
`;
class SecureTemplater {
  static async loadRenderer(options = {}) {
    const {
      cookiecutterCompat,
      templateFilters = {},
      templateGlobals = {},
      nunjucksConfigs = {}
    } = options;
    const nodeVersion = helpers.getMajorNodeVersion();
    if (nodeVersion >= 20 && !helpers.isNoNodeSnapshotOptionProvided()) {
      throw new Error(
        `When using Node.js version 20 or newer, the scaffolder backend plugin requires that it be started with the --no-node-snapshot option. 
        Please make sure that you have NODE_OPTIONS=--no-node-snapshot in your environment.`
      );
    }
    const isolate = new isolatedVm.Isolate({ memoryLimit: 128 });
    const context = await isolate.createContext();
    const contextGlobal = context.global;
    const nunjucksSource = await fs__default.default.readFile(
      backendPluginApi.resolvePackagePath(
        "@backstage/plugin-scaffolder-backend",
        "assets/nunjucks.js.txt"
      ),
      "utf-8"
    );
    const nunjucksScript = await isolate.compileScript(
      mkScript(nunjucksSource)
    );
    await contextGlobal.set("nunjucksConfigs", JSON.stringify(nunjucksConfigs));
    const availableFilters = Object.keys(templateFilters);
    await contextGlobal.set(
      "availableTemplateFilters",
      JSON.stringify(availableFilters)
    );
    const globalCallbacks = [];
    const globalValues = {};
    for (const [name, value] of Object.entries(templateGlobals)) {
      if (typeof value === "function") {
        globalCallbacks.push(name);
      } else {
        globalValues[name] = value;
      }
    }
    await contextGlobal.set(
      "availableTemplateGlobals",
      JSON.stringify(globalValues)
    );
    await contextGlobal.set(
      "availableTemplateCallbacks",
      JSON.stringify(globalCallbacks)
    );
    await contextGlobal.set(
      "callFilter",
      (filterName, args) => {
        if (!Object.hasOwn(templateFilters, filterName)) {
          return "";
        }
        const rz = templateFilters[filterName](...args);
        return rz === void 0 ? "" : JSON.stringify(rz);
      }
    );
    await contextGlobal.set(
      "callGlobal",
      (globalName, args) => {
        if (!Object.hasOwn(templateGlobals, globalName)) {
          return "";
        }
        const global = templateGlobals[globalName];
        if (typeof global !== "function") {
          return "";
        }
        const rz = global(...args);
        return rz === void 0 ? "" : JSON.stringify(rz);
      }
    );
    await nunjucksScript.run(context);
    const render = (template, values) => {
      if (!context) {
        throw new Error("SecureTemplater has not been initialized");
      }
      contextGlobal.setSync("templateStr", String(template));
      contextGlobal.setSync("templateValues", JSON.stringify(values));
      if (cookiecutterCompat) {
        return context.evalSync(`renderCompat(templateStr, templateValues)`);
      }
      return context.evalSync(`render(templateStr, templateValues)`);
    };
    return render;
  }
}

exports.SecureTemplater = SecureTemplater;
//# sourceMappingURL=SecureTemplater.cjs.js.map
