{"version":3,"file":"helpers.cjs.js","sources":["../../src/service/helpers.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CatalogApi } from '@backstage/catalog-client';\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_SOURCE_LOCATION,\n  CompoundEntityRef,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { assertError, InputError, NotFoundError } from '@backstage/errors';\nimport { TemplateEntityV1beta3 } from '@backstage/plugin-scaffolder-common';\nimport fs from 'fs-extra';\nimport os from 'os';\nimport { Logger } from 'winston';\n\nexport async function getWorkingDirectory(\n  config: Config,\n  logger: Logger,\n): Promise<string> {\n  if (!config.has('backend.workingDirectory')) {\n    return os.tmpdir();\n  }\n\n  const workingDirectory = config.getString('backend.workingDirectory');\n  try {\n    // Check if working directory exists and is writable\n    await fs.access(workingDirectory, fs.constants.F_OK | fs.constants.W_OK);\n    logger.info(`using working directory: ${workingDirectory}`);\n  } catch (err) {\n    assertError(err);\n    logger.error(\n      `working directory ${workingDirectory} ${\n        err.code === 'ENOENT' ? 'does not exist' : 'is not writable'\n      }`,\n    );\n    throw err;\n  }\n  return workingDirectory;\n}\n\n/**\n * Gets the base URL of the entity location that points to the source location\n * of the entity description within a repo. If there is not source location\n * or if it has an invalid type, undefined will be returned instead.\n *\n * For file locations this will return a `file://` URL.\n */\nexport function getEntityBaseUrl(entity: Entity): string | undefined {\n  let location = entity.metadata.annotations?.[ANNOTATION_SOURCE_LOCATION];\n  if (!location) {\n    location = entity.metadata.annotations?.[ANNOTATION_LOCATION];\n  }\n  if (!location) {\n    return undefined;\n  }\n\n  const { type, target } = parseLocationRef(location);\n  if (type === 'url') {\n    return target;\n  } else if (type === 'file') {\n    return `file://${target}`;\n  }\n\n  // Only url and file location are handled, as we otherwise don't know if\n  // what the url is pointing to makes sense to use as a baseUrl\n  return undefined;\n}\n\n/**\n * Will use the provided CatalogApi to go find the given template entity with an additional token.\n * Returns the matching template, or throws a NotFoundError if no such template existed.\n */\nexport async function findTemplate(options: {\n  entityRef: CompoundEntityRef;\n  token?: string;\n  catalogApi: CatalogApi;\n}): Promise<TemplateEntityV1beta3> {\n  const { entityRef, token, catalogApi } = options;\n\n  if (entityRef.kind.toLocaleLowerCase('en-US') !== 'template') {\n    throw new InputError(`Invalid kind, only 'Template' kind is supported`);\n  }\n\n  const template = await catalogApi.getEntityByRef(entityRef, { token });\n  if (!template) {\n    throw new NotFoundError(\n      `Template ${stringifyEntityRef(entityRef)} not found`,\n    );\n  }\n\n  return template as TemplateEntityV1beta3;\n}\n\n/**\n * Takes a single unknown parameter and makes sure that it's a single string or\n * an array of strings, and returns as an array.\n */\nexport function parseStringsParam(\n  param: unknown,\n  paramName: string,\n): string[] | undefined {\n  if (param === undefined) {\n    return undefined;\n  }\n\n  const array = [param].flat();\n  if (array.some(p => typeof p !== 'string')) {\n    throw new InputError(\n      `Invalid ${paramName}, not a string or array of strings`,\n    );\n  }\n\n  return array as string[];\n}\n\nexport function parseNumberParam(\n  param: unknown,\n  paramName: string,\n): number[] | undefined {\n  return parseStringsParam(param, paramName)?.map(val => {\n    const ret = Number.parseInt(val, 10);\n    if (isNaN(ret)) {\n      throw new InputError(\n        `Invalid ${paramName} parameter \"${val}\", expected a number or array of numbers`,\n      );\n    }\n    return ret;\n  });\n}\n\nexport function flattenParams<T>(...params: (undefined | T | T[])[]): T[] {\n  return [...params].flat().filter(Boolean) as T[];\n}\n"],"names":["os","fs","assertError","ANNOTATION_SOURCE_LOCATION","ANNOTATION_LOCATION","parseLocationRef","InputError","NotFoundError","stringifyEntityRef"],"mappings":"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"}