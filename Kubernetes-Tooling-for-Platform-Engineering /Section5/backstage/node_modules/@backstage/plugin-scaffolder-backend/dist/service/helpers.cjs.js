'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var fs = require('fs-extra');
var os = require('os');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var os__default = /*#__PURE__*/_interopDefaultCompat(os);

async function getWorkingDirectory(config, logger) {
  if (!config.has("backend.workingDirectory")) {
    return os__default.default.tmpdir();
  }
  const workingDirectory = config.getString("backend.workingDirectory");
  try {
    await fs__default.default.access(workingDirectory, fs__default.default.constants.F_OK | fs__default.default.constants.W_OK);
    logger.info(`using working directory: ${workingDirectory}`);
  } catch (err) {
    errors.assertError(err);
    logger.error(
      `working directory ${workingDirectory} ${err.code === "ENOENT" ? "does not exist" : "is not writable"}`
    );
    throw err;
  }
  return workingDirectory;
}
function getEntityBaseUrl(entity) {
  let location = entity.metadata.annotations?.[catalogModel.ANNOTATION_SOURCE_LOCATION];
  if (!location) {
    location = entity.metadata.annotations?.[catalogModel.ANNOTATION_LOCATION];
  }
  if (!location) {
    return void 0;
  }
  const { type, target } = catalogModel.parseLocationRef(location);
  if (type === "url") {
    return target;
  } else if (type === "file") {
    return `file://${target}`;
  }
  return void 0;
}
async function findTemplate(options) {
  const { entityRef, token, catalogApi } = options;
  if (entityRef.kind.toLocaleLowerCase("en-US") !== "template") {
    throw new errors.InputError(`Invalid kind, only 'Template' kind is supported`);
  }
  const template = await catalogApi.getEntityByRef(entityRef, { token });
  if (!template) {
    throw new errors.NotFoundError(
      `Template ${catalogModel.stringifyEntityRef(entityRef)} not found`
    );
  }
  return template;
}
function parseStringsParam(param, paramName) {
  if (param === void 0) {
    return void 0;
  }
  const array = [param].flat();
  if (array.some((p) => typeof p !== "string")) {
    throw new errors.InputError(
      `Invalid ${paramName}, not a string or array of strings`
    );
  }
  return array;
}
function parseNumberParam(param, paramName) {
  return parseStringsParam(param, paramName)?.map((val) => {
    const ret = Number.parseInt(val, 10);
    if (isNaN(ret)) {
      throw new errors.InputError(
        `Invalid ${paramName} parameter "${val}", expected a number or array of numbers`
      );
    }
    return ret;
  });
}
function flattenParams(...params) {
  return [...params].flat().filter(Boolean);
}

exports.findTemplate = findTemplate;
exports.flattenParams = flattenParams;
exports.getEntityBaseUrl = getEntityBaseUrl;
exports.getWorkingDirectory = getWorkingDirectory;
exports.parseNumberParam = parseNumberParam;
exports.parseStringsParam = parseStringsParam;
//# sourceMappingURL=helpers.cjs.js.map
