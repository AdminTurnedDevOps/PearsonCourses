/// <reference types="node" />
import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { AuthService, UrlReaderService, BackstageCredentials, LifecycleService, DatabaseService, SchedulerService, PermissionsService, HttpAuthService, DiscoveryService } from '@backstage/backend-plugin-api';
import * as _backstage_plugin_scaffolder_node from '@backstage/plugin-scaffolder-node';
import { TemplateFilter as TemplateFilter$1, TemplateGlobal as TemplateGlobal$1, TemplateAction as TemplateAction$1, TaskStatus as TaskStatus$1, TaskCompletionState as TaskCompletionState$1, SerializedTask as SerializedTask$1, TaskEventType as TaskEventType$1, SerializedTaskEvent as SerializedTaskEvent$1, TaskBrokerDispatchResult as TaskBrokerDispatchResult$1, TaskBrokerDispatchOptions as TaskBrokerDispatchOptions$1, TaskContext as TaskContext$1, TaskBroker as TaskBroker$1, TaskSecrets as TaskSecrets$1, ActionContext as ActionContext$1, ExecuteShellCommandOptions, executeShellCommand as executeShellCommand$1, fetchContents as fetchContents$1 } from '@backstage/plugin-scaffolder-node';
import * as _backstage_types from '@backstage/types';
import { HumanDuration, JsonObject, JsonValue } from '@backstage/types';
import * as _backstage_integration from '@backstage/integration';
import { ScmIntegrations } from '@backstage/integration';
import { CatalogApi } from '@backstage/catalog-client';
import { Config } from '@backstage/config';
import { Duration } from 'luxon';
import * as github from '@backstage/plugin-scaffolder-backend-module-github';
import * as gitlab from '@backstage/plugin-scaffolder-backend-module-gitlab';
import * as azure from '@backstage/plugin-scaffolder-backend-module-azure';
import * as bitbucket from '@backstage/plugin-scaffolder-backend-module-bitbucket';
import * as bitbucketCloud from '@backstage/plugin-scaffolder-backend-module-bitbucket-cloud';
import * as bitbucketServer from '@backstage/plugin-scaffolder-backend-module-bitbucket-server';
import * as gerrit from '@backstage/plugin-scaffolder-backend-module-gerrit';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { Knex } from 'knex';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TaskSpec, TaskRecovery, TemplateEntityStepV1beta3, TemplateParametersV1beta3 } from '@backstage/plugin-scaffolder-common';
import { EventsService } from '@backstage/plugin-events-node';
import { Logger } from 'winston';
import { WorkspaceProvider, AutocompleteHandler } from '@backstage/plugin-scaffolder-node/alpha';
import { PermissionEvaluator, PermissionRuleParams } from '@backstage/plugin-permission-common';
import { RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, RESOURCE_TYPE_SCAFFOLDER_ACTION } from '@backstage/plugin-scaffolder-common/alpha';
import express from 'express';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { IdentityApi } from '@backstage/plugin-auth-node';
import * as jsonschema from 'jsonschema';
import * as zod from 'zod';
import { ScaffolderEntitiesProcessor as ScaffolderEntitiesProcessor$1 } from '@backstage/plugin-catalog-backend-module-scaffolder-entity-model';

/**
 * Scaffolder plugin
 *
 * @public
 */
declare const scaffolderPlugin: _backstage_backend_plugin_api.BackendFeature;

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
    auth?: AuthService;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    catalogInfoUrl: string;
    optional?: boolean | undefined;
} | {
    repoContentsUrl: string;
    catalogInfoPath?: string | undefined;
    optional?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
declare function createCatalogWriteAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    entity: Record<string, any>;
    filePath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Returns entity or entities from the catalog by entity reference(s).
 *
 * @public
 */
declare function createFetchCatalogEntityAction(options: {
    catalogClient: CatalogApi;
    auth?: AuthService;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    optional?: boolean | undefined;
    defaultKind?: string | undefined;
    defaultNamespace?: string | undefined;
    entityRef?: string | undefined;
    entityRefs?: string[] | undefined;
}, {
    entities?: any[] | undefined;
    entity?: any;
}>;

/**
 * The options passed to {@link createBuiltinActions}
 * @public
 */
interface CreateBuiltInActionsOptions {
    /**
     * The {@link @backstage/backend-plugin-api#UrlReaderService} interface that will be used in the default actions.
     */
    reader: UrlReaderService;
    /**
     * The {@link @backstage/integrations#ScmIntegrations} that will be used in the default actions.
     */
    integrations: ScmIntegrations;
    /**
     * The {@link @backstage/catalog-client#CatalogApi} that will be used in the default actions.
     */
    catalogClient: CatalogApi;
    /**
     * The {@link @backstage/backend-plugin-api#AuthService} that will be used in the default actions.
     */
    auth?: AuthService;
    /**
     * The {@link @backstage/config#Config} that will be used in the default actions.
     */
    config: Config;
    /**
     * Additional custom filters that will be passed to the nunjucks template engine for use in
     * Template Manifests and also template skeleton files when using `fetch:template`.
     */
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}
/**
 * A function to generate create a list of default actions that the scaffolder provides.
 * Is called internally in the default setup, but can be used when adding your own actions or overriding the default ones
 *
 * TODO(blam): version 2 of the scaffolder shouldn't ship with the additional modules. We should ship the basics, and let people install
 * modules for the providers they want to use.
 * @public
 * @returns A list of actions that can be used in the scaffolder
 *
 */
declare const createBuiltinActions: (options: CreateBuiltInActionsOptions) => TemplateAction$1[];

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
declare function createDebugLogAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    message?: string | undefined;
    listWorkspace?: boolean | "with-contents" | "with-filenames" | undefined;
}, _backstage_types.JsonObject>;

/**
 * Waits for a certain period of time.
 *
 * @remarks
 *
 * This task is useful to give some waiting time for manual intervention.
 * Has to be used in a combination with other actions.
 *
 * @public
 */
declare function createWaitAction(options?: {
    maxWaitTime?: Duration | HumanDuration;
}): _backstage_plugin_scaffolder_node.TemplateAction<HumanDuration, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
declare function createFetchTemplateAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    values: any;
    templateFileExtension?: string | boolean | undefined;
    /**
     * @deprecated This field is deprecated in favor of copyWithoutTemplating.
     */
    copyWithoutRender?: string[] | undefined;
    copyWithoutTemplating?: string[] | undefined;
    cookiecutterCompat?: boolean | undefined;
    replace?: boolean | undefined;
    trimBlocks?: boolean | undefined;
    lstripBlocks?: boolean | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Downloads a single file and templates variables into file.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchTemplateFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    values: any;
    cookiecutterCompat?: boolean | undefined;
    replace?: boolean | undefined;
    trimBlocks?: boolean | undefined;
    lstripBlocks?: boolean | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
declare const createFilesystemDeleteAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: string[];
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
declare const createFilesystemRenameAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: Array<{
        from: string;
        to: string;
        overwrite?: boolean;
    }>;
}, _backstage_types.JsonObject>;

/**
 * Creates new action that enables reading directories in the workspace.
 * @public
 */
declare const createFilesystemReadDirAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    paths: string[];
    recursive?: boolean | undefined;
}, {
    files: {
        name: string;
        path: string;
        fullPath: string;
    }[];
    folders: {
        name: string;
        path: string;
        fullPath: string;
    }[];
}>;

/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubActionsDispatchAction: typeof github.createGithubActionsDispatchAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubDeployKeyAction: typeof github.createGithubDeployKeyAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubEnvironmentAction: typeof github.createGithubEnvironmentAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubIssuesLabelAction: typeof github.createGithubIssuesLabelAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
type CreateGithubPullRequestActionOptions = github.CreateGithubPullRequestActionOptions;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubRepoCreateAction: typeof github.createGithubRepoCreateAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubRepoPushAction: typeof github.createGithubRepoPushAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubWebhookAction: typeof github.createGithubWebhookAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createPublishGithubAction: typeof github.createPublishGithubAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createPublishGithubPullRequestAction: (options: github.CreateGithubPullRequestActionOptions) => _backstage_plugin_scaffolder_node.TemplateAction<{
    title: string;
    branchName: string;
    targetBranchName?: string | undefined;
    description: string;
    repoUrl: string;
    draft?: boolean | undefined;
    targetPath?: string | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    reviewers?: string[] | undefined;
    teamReviewers?: string[] | undefined;
    commitMessage?: string | undefined;
    update?: boolean | undefined;
    forceFork?: boolean | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    forceEmptyGitAuthor?: boolean | undefined;
}, _backstage_types.JsonObject>;
/**
 * @public @deprecated use "createPublishBitbucketCloudAction" from \@backstage/plugin-scaffolder-backend-module-bitbucket-cloud or "createPublishBitbucketServerAction" from \@backstage/plugin-scaffolder-backend-module-bitbucket-server instead
 */
declare const createPublishBitbucketAction: typeof bitbucket.createPublishBitbucketAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-cloud` instead
 */
declare const createPublishBitbucketCloudAction: typeof bitbucketCloud.createPublishBitbucketCloudAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-server` instead
 */
declare const createPublishBitbucketServerAction: typeof bitbucketServer.createPublishBitbucketServerAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-server` instead
 */
declare const createPublishBitbucketServerPullRequestAction: typeof bitbucketServer.createPublishBitbucketServerPullRequestAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-azure` instead
 */
declare const createPublishAzureAction: typeof azure.createPublishAzureAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gerrit` instead
 */
declare const createPublishGerritAction: typeof gerrit.createPublishGerritAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gerrit` instead
 */
declare const createPublishGerritReviewAction: typeof gerrit.createPublishGerritReviewAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gitlab` instead
 */
declare const createPublishGitlabAction: typeof gitlab.createPublishGitlabAction;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gitlab` instead
 */
declare const createPublishGitlabMergeRequestAction: (options: {
    integrations: _backstage_integration.ScmIntegrationRegistry;
}) => _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    title: string;
    description: string;
    branchName: string;
    targetBranchName?: string | undefined;
    sourcePath?: string | undefined;
    targetPath?: string | undefined;
    token?: string | undefined;
    commitAction?: "auto" | "update" | "delete" | "create" | "skip" | undefined;
    projectid?: string | undefined;
    removeSourceBranch?: boolean | undefined;
    assignee?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Registry of all registered template actions.
 * @public
 */
declare class TemplateActionRegistry {
    private readonly actions;
    register(action: TemplateAction$1): void;
    get(actionId: string): TemplateAction$1;
    list(): TemplateAction$1[];
}

/**
 * The status of each step of the Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskStatus = TaskStatus$1;
/**
 * The state of a completed task.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskCompletionState = TaskCompletionState$1;
/**
 * SerializedTask
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTask = SerializedTask$1;
/**
 * TaskEventType
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskEventType = TaskEventType$1;
/**
 * SerializedTaskEvent
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTaskEvent = SerializedTaskEvent$1;
/**
 * The result of `TaskBroker.dispatch`.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchResult = TaskBrokerDispatchResult$1;
/**
 * The options passed to `TaskBroker.dispatch`.
 * Currently a spec and optional secrets
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchOptions = TaskBrokerDispatchOptions$1;
/**
 * Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskContext = TaskContext$1;
/**
 * TaskBroker
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBroker = TaskBroker$1;
/**
 * TaskStoreEmitOptions
 *
 * @public
 */
type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};
/**
 * TaskStoreListEventsOptions
 *
 * @public
 */
type TaskStoreListEventsOptions = {
    isTaskRecoverable?: boolean;
    taskId: string;
    after?: number | undefined;
};
/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 */
type TaskStoreShutDownTaskOptions = {
    taskId: string;
};
/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets$1;
};
/**
 * The options passed to {@link TaskStore.recoverTasks}
 * @public
 */
type TaskStoreRecoverTaskOptions = {
    timeout: HumanDuration;
};
/**
 * The response from {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskResult = {
    taskId: string;
};
/**
 * TaskStore
 *
 * @public
 */
interface TaskStore {
    cancelTask?(options: TaskStoreEmitOptions): Promise<void>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    retryTask?(options: {
        taskId: string;
    }): Promise<void>;
    recoverTasks?(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    /**
     * @deprecated Make sure to pass `createdBy` and `status` in the `filters` parameter instead
     */
    list?(options: {
        createdBy?: string;
        status?: TaskStatus;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    emitLogEvent(options: TaskStoreEmitOptions): Promise<void>;
    getTaskState?({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState?(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace?({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace?({ path, taskId, }: {
        path: string;
        taskId: string;
    }): Promise<void>;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
type DatabaseTaskStoreOptions = {
    database: PluginDatabaseManager | Knex;
    events?: EventsService;
};
/**
 * DatabaseTaskStore
 *
 * @public
 */
declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    private readonly events?;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private isRecoverableTask;
    private parseSpec;
    private parseTaskSecrets;
    private static getClient;
    private static runMigrations;
    private constructor();
    private getState;
    list(options: {
        createdBy?: string;
        status?: TaskStatus$1;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus$1 | TaskStatus$1[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask$1[];
        totalTasks?: number;
    }>;
    getTask(taskId: string): Promise<SerializedTask$1>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask$1 | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
            recovery?: TaskRecovery;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus$1;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    getTaskState({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent$1[];
    }>;
    shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace(options: {
        path: string;
        taskId: string;
    }): Promise<void>;
    cancelTask(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    retryTask?(options: {
        taskId: string;
    }): Promise<void>;
    recoverTasks(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
}

/**
 * TaskManager
 *
 * @public
 */
declare class TaskManager implements TaskContext$1 {
    private readonly task;
    private readonly storage;
    private readonly signal;
    private readonly logger;
    private readonly workspaceService;
    private readonly auth?;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, abortSignal: AbortSignal, logger: Logger, auth?: AuthService, config?: Config, additionalWorkspaceProviders?: Record<string, WorkspaceProvider>): TaskManager;
    private constructor();
    get spec(): _backstage_plugin_scaffolder_common.TaskSpecV1beta3;
    get cancelSignal(): AbortSignal;
    get secrets(): TaskSecrets$1 | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getTaskState?(): Promise<{
        state?: JsonObject;
    } | undefined>;
    updateCheckpoint?(options: {
        key: string;
        status: 'success';
        value: JsonValue;
    } | {
        key: string;
        status: 'failed';
        reason: string;
    }): Promise<void>;
    serializeWorkspace?(options: {
        path: string;
    }): Promise<void>;
    cleanWorkspace?(): Promise<void>;
    complete(result: TaskCompletionState$1, metadata?: JsonObject): Promise<void>;
    private startTimeout;
    getInitiatorCredentials(): Promise<BackstageCredentials>;
}
/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets$1;
    /**
     * The state of checkpoints of the task.
     */
    state?: JsonObject;
    /**
     * The creator of the task.
     */
    createdBy?: string;
    /**
     * The workspace of the task.
     */
    workspace?: Promise<Buffer>;
}

/**
 * CreateWorkerOptions
 *
 * @public
 */
type CreateWorkerOptions = {
    taskBroker: TaskBroker$1;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: Logger;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    /**
     * The number of tasks that can be executed at the same time by the worker
     * @defaultValue 10
     * @example
     * ```
     * {
     *   concurrentTasksLimit: 1,
     *   // OR
     *   concurrentTasksLimit: Infinity
     * }
     * ```
     */
    concurrentTasksLimit?: number;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
    permissions?: PermissionEvaluator;
};
/**
 * TaskWorker
 *
 * @public
 */
declare class TaskWorker {
    private readonly options;
    private taskQueue;
    private logger;
    private stopWorkers;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    recoverTasks(): Promise<void>;
    start(): void;
    stop(): void;
    protected onReadyToClaimTask(): Promise<void>;
    runOneTask(task: TaskContext$1): Promise<void>;
}

/**
 *
 * @public
 */
type TemplatePermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, TParams>;
/**
 *
 * @public
 */
type ActionPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_ACTION, TParams>;
/**
 * RouterOptions
 *
 * @public
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 */
interface RouterOptions {
    logger: Logger;
    config: Config;
    reader: UrlReaderService;
    lifecycle?: LifecycleService;
    database: DatabaseService;
    catalogClient: CatalogApi;
    scheduler?: SchedulerService;
    actions?: TemplateAction$1<any, any>[];
    /**
     * @deprecated taskWorkers is deprecated in favor of concurrentTasksLimit option with a single TaskWorker
     * @defaultValue 1
     */
    taskWorkers?: number;
    /**
     * Sets the number of concurrent tasks that can be run at any given time on the TaskWorker
     * @defaultValue 10
     */
    concurrentTasksLimit?: number;
    taskBroker?: TaskBroker$1;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
    additionalWorkspaceProviders?: Record<string, WorkspaceProvider>;
    permissions?: PermissionsService;
    permissionRules?: Array<TemplatePermissionRuleInput | ActionPermissionRuleInput>;
    auth?: AuthService;
    httpAuth?: HttpAuthService;
    identity?: IdentityApi;
    discovery?: DiscoveryService;
    events?: EventsService;
    autocompleteHandlers?: Record<string, AutocompleteHandler>;
}
/**
 * A method to create a router for the scaffolder backend plugin.
 * @public
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 */
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateFilter = TemplateFilter$1;
/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateGlobal = TemplateGlobal$1;

/**
 * @public
 * @deprecated Import from {@link @backstage/plugin-scaffolder-node#ActionContext} instead
 */
type ActionContext<TInput extends JsonObject> = ActionContext$1<TInput>;
/**
 * @public
 * @deprecated Use `createTemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
declare const createTemplateAction: <TInputParams extends JsonObject = JsonObject, TOutputParams extends JsonObject = JsonObject, TInputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TOutputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TActionInput extends JsonObject = TInputSchema extends zod.ZodType<any, any, infer IReturn> ? IReturn : TInputParams, TActionOutput extends JsonObject = TOutputSchema extends zod.ZodType<any, any, infer IReturn_1> ? IReturn_1 : TOutputParams>(action: _backstage_plugin_scaffolder_node.TemplateActionOptions<TActionInput, TActionOutput, TInputSchema, TOutputSchema>) => TemplateAction$1<TActionInput, TActionOutput>;
/**
 * @public
 * @deprecated Use `TaskSecrets` from `@backstage/plugin-scaffolder-node` instead
 */
type TaskSecrets = TaskSecrets$1;
/**
 * @public
 * @deprecated Use `TemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
type TemplateAction<TInput extends JsonObject> = TemplateAction$1<TInput>;
/**
 * Options for {@link executeShellCommand}.
 *
 * @public
 * @deprecated Use `ExecuteShellCommandOptions` from `@backstage/plugin-scaffolder-node` instead
 */
type RunCommandOptions = ExecuteShellCommandOptions;
/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 * @deprecated Use `executeShellCommand` from `@backstage/plugin-scaffolder-node` instead
 */
declare const executeShellCommand: typeof executeShellCommand$1;
/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 * @deprecated Use `fetchContents` from `@backstage/plugin-scaffolder-node` instead
 */
declare const fetchContents: typeof fetchContents$1;
/**
 * Adds support for scaffolder specific entity kinds to the catalog.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-catalog-backend-module-scaffolder-entity-model` instead
 */
declare const ScaffolderEntitiesProcessor: typeof ScaffolderEntitiesProcessor$1;

export { type ActionContext, type ActionPermissionRuleInput, type CreateBuiltInActionsOptions, type CreateGithubPullRequestActionOptions, type CreateWorkerOptions, type CurrentClaimedTask, DatabaseTaskStore, type DatabaseTaskStoreOptions, type RouterOptions, type RunCommandOptions, ScaffolderEntitiesProcessor, type SerializedTask, type SerializedTaskEvent, type TaskBroker, type TaskBrokerDispatchOptions, type TaskBrokerDispatchResult, type TaskCompletionState, type TaskContext, type TaskEventType, TaskManager, type TaskSecrets, type TaskStatus, type TaskStore, type TaskStoreCreateTaskOptions, type TaskStoreCreateTaskResult, type TaskStoreEmitOptions, type TaskStoreListEventsOptions, type TaskStoreRecoverTaskOptions, type TaskStoreShutDownTaskOptions, TaskWorker, type TemplateAction, TemplateActionRegistry, type TemplateFilter, type TemplateGlobal, type TemplatePermissionRuleInput, createBuiltinActions, createCatalogRegisterAction, createCatalogWriteAction, createDebugLogAction, createFetchCatalogEntityAction, createFetchPlainAction, createFetchPlainFileAction, createFetchTemplateAction, createFetchTemplateFileAction, createFilesystemDeleteAction, createFilesystemReadDirAction, createFilesystemRenameAction, createGithubActionsDispatchAction, createGithubDeployKeyAction, createGithubEnvironmentAction, createGithubIssuesLabelAction, createGithubRepoCreateAction, createGithubRepoPushAction, createGithubWebhookAction, createPublishAzureAction, createPublishBitbucketAction, createPublishBitbucketCloudAction, createPublishBitbucketServerAction, createPublishBitbucketServerPullRequestAction, createPublishGerritAction, createPublishGerritReviewAction, createPublishGithubAction, createPublishGithubPullRequestAction, createPublishGitlabAction, createPublishGitlabMergeRequestAction, createRouter, createTemplateAction, createWaitAction, scaffolderPlugin as default, executeShellCommand, fetchContents };
