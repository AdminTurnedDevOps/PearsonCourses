{"version":3,"file":"TranslationApi.esm.js","sources":["../../../src/apis/definitions/TranslationApi.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiRef, createApiRef } from '@backstage/core-plugin-api';\nimport { Observable } from '@backstage/types';\nimport { TranslationRef } from '../../translation';\n\n/**\n * Base translation options.\n *\n * @alpha\n */\ninterface BaseOptions {\n  interpolation?: {\n    /** Whether to HTML escape provided values, defaults to false  */\n    escapeValue?: boolean;\n  };\n}\n\n/**\n * All pluralization suffixes supported by i18next\n *\n * @ignore\n */\ntype TranslationPlural = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n\n/**\n * A mapping of i18n formatting types to their corresponding types and options.\n * @ignore\n */\ntype I18nextFormatMap = {\n  number: {\n    type: number;\n    options: Intl.NumberFormatOptions;\n  };\n  currency: {\n    type: number;\n    options: Intl.NumberFormatOptions;\n  };\n  datetime: {\n    type: Date;\n    options: Intl.DateTimeFormatOptions;\n  };\n  relativetime: {\n    type: number;\n    options: {\n      range?: Intl.RelativeTimeFormatUnit;\n    } & Intl.RelativeTimeFormatOptions;\n  };\n  list: {\n    type: string[];\n    options: Intl.ListFormatOptions;\n  };\n};\n\n/**\n * Extracts all pluralized keys from the message map.\n *\n * @example\n * ```\n * { foo: 'foo', bar_one: 'bar', bar_other: 'bars' } -> 'bar'\n * ```\n *\n * @ignore\n */\ntype PluralKeys<TMessages extends { [key in string]: string }> = {\n  [Key in keyof TMessages]: Key extends `${infer K}_${TranslationPlural}`\n    ? K\n    : never;\n}[keyof TMessages];\n\n/**\n * Collapses a message map into normalized keys with union values.\n *\n * @example\n * ```\n * { foo_one: 'foo', foo_other: 'foos' } -> { foo: 'foo' | 'foos' }\n * ```\n *\n * @ignore\n */\ntype CollapsedMessages<TMessages extends { [key in string]: string }> = {\n  [key in keyof TMessages as key extends `${infer K}_${TranslationPlural}`\n    ? K\n    : key]: TMessages[key];\n};\n\n/**\n * Helper type that expands type hints\n *\n * @ignore\n */\ntype Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;\n\n/**\n * Helper type that expands type hints recursively\n *\n * @ignore\n */\ntype ExpandRecursive<T> = T extends infer O\n  ? { [K in keyof O]: ExpandRecursive<O[K]> }\n  : never;\n\n/**\n * Trim away whitespace\n *\n * @ignore\n */\ntype Trim<T> = T extends ` ${infer U}`\n  ? Trim<U>\n  : T extends `${infer U} `\n  ? Trim<U>\n  : T;\n\n/**\n * Extracts the key and format from a replacement string.\n *\n * @example\n * ```\n * 'foo, number' -> { foo: number }, 'foo' -> { foo: undefined }\n * ```\n */\ntype ExtractFormat<Replacement extends string> =\n  Replacement extends `${infer Key},${infer FullFormat}`\n    ? {\n        [key in Trim<Key>]: Lowercase<\n          Trim<\n            FullFormat extends `${infer Format}(${string})${string}`\n              ? Format\n              : FullFormat\n          >\n        >;\n      }\n    : { [key in Trim<Replacement>]: undefined };\n\n/**\n * Expand the keys in a flat map to nested objects.\n *\n * @example\n * ```\n * { 'a.b': 'foo', 'a.c': 'bar' } -> { a: { b: 'foo', c: 'bar' }\n * ```\n *\n * @ignore\n */\ntype ExpandKeys<TMap extends {}> = {\n  [Key in keyof TMap as Key extends `${infer Prefix}.${string}`\n    ? Prefix\n    : Key]: Key extends `${string}.${infer Rest}`\n    ? ExpandKeys<{ [key in Rest]: TMap[Key] }>\n    : TMap[Key];\n};\n\n/**\n * Extracts all option keys and their format from a message string.\n *\n * @example\n * ```\n * 'foo {{bar}} {{baz, number}}' -> { 'bar': undefined, 'baz': 'number' }\n * ```\n *\n * @ignore\n */\ntype ReplaceFormatsFromMessage<TMessage> =\n  TMessage extends `${string}{{${infer Replacement}}}${infer Tail}` // no formatting, e.g. {{foo}}\n    ? ExpandKeys<ExtractFormat<Replacement>> & ReplaceFormatsFromMessage<Tail>\n    : {};\n\n/**\n * Generates the replace options structure\n *\n * @ignore\n */\ntype ReplaceOptionsFromFormats<TFormats extends {}> = {\n  [Key in keyof TFormats]: TFormats[Key] extends keyof I18nextFormatMap\n    ? I18nextFormatMap[TFormats[Key]]['type']\n    : TFormats[Key] extends {}\n    ? Expand<ReplaceOptionsFromFormats<TFormats[Key]>>\n    : string;\n};\n\n/**\n * Generates the formatParams options structure\n *\n * @ignore\n */\ntype ReplaceFormatParamsFromFormats<TFormats extends {}> = {\n  [Key in keyof TFormats]?: TFormats[Key] extends keyof I18nextFormatMap\n    ? I18nextFormatMap[TFormats[Key]]['options']\n    : TFormats[Key] extends {}\n    ? Expand<ReplaceFormatParamsFromFormats<TFormats[Key]>>\n    : undefined;\n};\n\n/**\n * Extracts all nesting keys from a message string.\n *\n * @example\n * ```\n * 'foo $t(bar) $t(baz)' -> 'bar' | 'baz'\n * ```\n *\n * @ignore\n */\ntype NestingKeysFromMessage<TMessage extends string> =\n  TMessage extends `${string}$t(${infer Key})${infer Tail}` // nesting options are not supported\n    ? Trim<Key> | NestingKeysFromMessage<Tail>\n    : never;\n\n/**\n * Find all referenced keys, given a starting key and the full set of messages.\n *\n * This will only discover keys up to 3 levels deep.\n *\n * @example\n * ```\n * <'x', { x: '$t(y) $t(z)', y: 'y', z: '$t(w)', w: 'w', foo: 'foo' }> -> 'x' | 'y' | 'z' | 'w'\n * ```\n *\n * @ignore\n */\ntype NestedMessageKeys<\n  TKey extends keyof TMessages,\n  TMessages extends { [key in string]: string },\n> =\n  | TKey\n  | NestedMessageKeys2<NestingKeysFromMessage<TMessages[TKey]>, TMessages>;\n// Can't recursively reference ourself, so instead we got this beauty\ntype NestedMessageKeys2<\n  TKey extends keyof TMessages,\n  TMessages extends { [key in string]: string },\n> =\n  | TKey\n  | NestedMessageKeys3<NestingKeysFromMessage<TMessages[TKey]>, TMessages>;\n// Only support 3 levels of nesting\ntype NestedMessageKeys3<\n  TKey extends keyof TMessages,\n  TMessages extends { [key in string]: string },\n> = TKey | NestingKeysFromMessage<TMessages[TKey]>;\n\n/**\n * Converts a union type to an intersection type.\n *\n * @example\n * ```\n * { foo: 'foo' } | { bar: 'bar' } -> { foo: 'foo' } & { bar: 'bar' }\n * ```\n *\n * @ignore\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\n/**\n * Collects different types of options into a single object\n *\n * @ignore\n */\ntype CollectOptions<\n  TCount extends { count?: number },\n  TFormats extends {},\n> = TCount &\n  // count is special, omit it from the replacements\n  (keyof Omit<TFormats, 'count'> extends never\n    ? {}\n    : (\n        | Expand<Omit<ReplaceOptionsFromFormats<TFormats>, 'count'>>\n        | {\n            replace: Expand<Omit<ReplaceOptionsFromFormats<TFormats>, 'count'>>;\n          }\n      ) & {\n        formatParams?: Expand<ReplaceFormatParamsFromFormats<TFormats>>;\n      });\n\n/**\n * Helper type to only require options argument if needed\n *\n * @ignore\n */\ntype OptionArgs<TOptions extends {}> = keyof TOptions extends never\n  ? [options?: BaseOptions]\n  : [options: BaseOptions & TOptions];\n\n/**\n * @ignore\n */\ntype TranslationFunctionOptions<\n  TKeys extends keyof TMessages, // All normalized message keys to be considered, i.e. included nested ones\n  TPluralKeys extends keyof TMessages, // All keys in the message map that are pluralized\n  TMessages extends { [key in string]: string }, // Collapsed message map with normalized keys and union values\n> = OptionArgs<\n  Expand<\n    CollectOptions<\n      TKeys & TPluralKeys extends never ? {} : { count: number },\n      ExpandRecursive<\n        UnionToIntersection<ReplaceFormatsFromMessage<TMessages[TKeys]>>\n      >\n    >\n  >\n>;\n\n/** @alpha */\nexport interface TranslationFunction<\n  TMessages extends { [key in string]: string },\n> {\n  <TKey extends keyof CollapsedMessages<TMessages>>(\n    key: TKey,\n    ...[args]: TranslationFunctionOptions<\n      NestedMessageKeys<TKey, CollapsedMessages<TMessages>>,\n      PluralKeys<TMessages>,\n      CollapsedMessages<TMessages>\n    >\n  ): CollapsedMessages<TMessages>[TKey];\n}\n\n/** @alpha */\nexport type TranslationSnapshot<TMessages extends { [key in string]: string }> =\n  { ready: false } | { ready: true; t: TranslationFunction<TMessages> };\n\n/** @alpha */\nexport type TranslationApi = {\n  getTranslation<TMessages extends { [key in string]: string }>(\n    translationRef: TranslationRef<string, TMessages>,\n  ): TranslationSnapshot<TMessages>;\n\n  translation$<TMessages extends { [key in string]: string }>(\n    translationRef: TranslationRef<string, TMessages>,\n  ): Observable<TranslationSnapshot<TMessages>>;\n};\n\n/**\n * @alpha\n */\nexport const translationApiRef: ApiRef<TranslationApi> = createApiRef({\n  id: 'core.translation',\n});\n"],"names":[],"mappings":";;AA6VO,MAAM,oBAA4C,YAAa,CAAA;AAAA,EACpE,EAAI,EAAA;AACN,CAAC;;;;"}