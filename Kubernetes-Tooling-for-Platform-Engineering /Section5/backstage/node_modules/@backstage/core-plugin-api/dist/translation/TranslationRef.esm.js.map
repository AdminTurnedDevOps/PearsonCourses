{"version":3,"file":"TranslationRef.esm.js","sources":["../../src/translation/TranslationRef.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createTranslationResource,\n  TranslationResource,\n} from './TranslationResource';\n\n/** @alpha */\nexport interface TranslationRef<\n  TId extends string = string,\n  TMessages extends { [key in string]: string } = { [key in string]: string },\n> {\n  $$type: '@backstage/TranslationRef';\n\n  id: TId;\n\n  T: TMessages;\n}\n\n/** @internal */\ntype AnyMessages = { [key in string]: string };\n\n/** @ignore */\ntype AnyNestedMessages = { [key in string]: AnyNestedMessages | string };\n\n/**\n * Flattens a nested message declaration into a flat object with dot-separated keys.\n *\n * @ignore\n */\ntype FlattenedMessages<TMessages extends AnyNestedMessages> =\n  // Flatten out object keys into a union structure of objects, e.g. { a: 'a', b: 'b' } -> { a: 'a' } | { b: 'b' }\n  // Any nested object will be flattened into the individual unions, e.g. { a: 'a', b: { x: 'x', y: 'y' } } -> { a: 'a' } | { 'b.x': 'x', 'b.y': 'y' }\n  // We create this structure by first nesting the desired union types into the original object, and\n  // then extract them by indexing with `keyof TMessages` to form the union.\n  // Throughout this the objects are wrapped up in a function parameter, which allows us to have the\n  // final step of flipping this unions around to an intersection by inferring the function parameter.\n  {\n    [TKey in keyof TMessages]: (\n      _: TMessages[TKey] extends infer TValue // \"local variable\" for the value\n        ? TValue extends AnyNestedMessages\n          ? FlattenedMessages<TValue> extends infer TNested // Recurse into nested messages, \"local variable\" for the result\n            ? {\n                [TNestedKey in keyof TNested as `${TKey & string}.${TNestedKey &\n                  string}`]: TNested[TNestedKey];\n              }\n            : never\n          : { [_ in TKey]: TValue } // Primitive object values are passed through with the same key\n        : never,\n    ) => void;\n    // The `[keyof TMessages]` extracts the object values union from our flattened structure, still wrapped up in function parameters.\n    // The `extends (_: infer TIntersection) => void` flips the union to an intersection, at which point we have the correct type.\n  }[keyof TMessages] extends (_: infer TIntersection) => void\n    ? // This object mapping just expands similar to the Expand<> utility type, providing nicer type hints\n      {\n        readonly [TExpandKey in keyof TIntersection]: TIntersection[TExpandKey];\n      }\n    : never;\n\n/** @internal */\nexport interface InternalTranslationRef<\n  TId extends string = string,\n  TMessages extends { [key in string]: string } = { [key in string]: string },\n> extends TranslationRef<TId, TMessages> {\n  version: 'v1';\n\n  getDefaultMessages(): AnyMessages;\n\n  getDefaultResource(): TranslationResource | undefined;\n}\n\n/** @alpha */\nexport interface TranslationRefOptions<\n  TId extends string,\n  TNestedMessages extends AnyNestedMessages,\n  TTranslations extends {\n    [language in string]: () => Promise<{\n      default: {\n        [key in keyof FlattenedMessages<TNestedMessages>]: string | null;\n      };\n    }>;\n  },\n> {\n  id: TId;\n  messages: TNestedMessages;\n  translations?: TTranslations;\n}\n\nfunction flattenMessages(nested: AnyNestedMessages): AnyMessages {\n  const entries = new Array<[string, string]>();\n\n  function visit(obj: AnyNestedMessages, prefix: string): void {\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'string') {\n        entries.push([prefix + key, value]);\n      } else {\n        visit(value, `${prefix}${key}.`);\n      }\n    }\n  }\n\n  visit(nested, '');\n\n  return Object.fromEntries(entries);\n}\n\n/** @internal */\nclass TranslationRefImpl<\n  TId extends string,\n  TNestedMessages extends AnyNestedMessages,\n> implements InternalTranslationRef<TId, FlattenedMessages<TNestedMessages>>\n{\n  #id: TId;\n  #messages: FlattenedMessages<TNestedMessages>;\n  #resources: TranslationResource | undefined;\n\n  constructor(options: TranslationRefOptions<TId, TNestedMessages, any>) {\n    this.#id = options.id;\n    this.#messages = flattenMessages(\n      options.messages,\n    ) as FlattenedMessages<TNestedMessages>;\n  }\n\n  $$type = '@backstage/TranslationRef' as const;\n\n  version = 'v1' as const;\n\n  get id(): TId {\n    return this.#id;\n  }\n\n  get T(): never {\n    throw new Error('Not implemented');\n  }\n\n  getDefaultMessages(): AnyMessages {\n    return this.#messages;\n  }\n\n  setDefaultResource(resources: TranslationResource): void {\n    this.#resources = resources;\n  }\n\n  getDefaultResource(): TranslationResource | undefined {\n    return this.#resources;\n  }\n\n  toString() {\n    return `TranslationRef{id=${this.id}}`;\n  }\n}\n\n/** @alpha */\nexport function createTranslationRef<\n  TId extends string,\n  const TNestedMessages extends AnyNestedMessages,\n  TTranslations extends {\n    [language in string]: () => Promise<{\n      default: {\n        [key in keyof FlattenedMessages<TNestedMessages>]: string | null;\n      };\n    }>;\n  },\n>(\n  config: TranslationRefOptions<TId, TNestedMessages, TTranslations>,\n): TranslationRef<TId, FlattenedMessages<TNestedMessages>> {\n  const ref = new TranslationRefImpl(config);\n  if (config.translations) {\n    ref.setDefaultResource(\n      createTranslationResource({\n        ref,\n        translations: config.translations as any,\n      }),\n    );\n  }\n  return ref;\n}\n\n/** @internal */\nexport function toInternalTranslationRef<\n  TId extends string,\n  TMessages extends AnyMessages,\n>(ref: TranslationRef<TId, TMessages>): InternalTranslationRef<TId, TMessages> {\n  const r = ref as InternalTranslationRef<TId, TMessages>;\n  if (r.$$type !== '@backstage/TranslationRef') {\n    throw new Error(`Invalid translation ref, bad type '${r.$$type}'`);\n  }\n  if (r.version !== 'v1') {\n    throw new Error(`Invalid translation ref, bad version '${r.version}'`);\n  }\n  return r;\n}\n"],"names":[],"mappings":";;AAsGA,SAAS,gBAAgB,MAAwC,EAAA;AAC/D,EAAM,MAAA,OAAA,GAAU,IAAI,KAAwB,EAAA;AAE5C,EAAS,SAAA,KAAA,CAAM,KAAwB,MAAsB,EAAA;AAC3D,IAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,GAAG,CAAG,EAAA;AAC9C,MAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,QAAA,OAAA,CAAQ,IAAK,CAAA,CAAC,MAAS,GAAA,GAAA,EAAK,KAAK,CAAC,CAAA;AAAA,OAC7B,MAAA;AACL,QAAA,KAAA,CAAM,KAAO,EAAA,CAAA,EAAG,MAAM,CAAA,EAAG,GAAG,CAAG,CAAA,CAAA,CAAA;AAAA;AACjC;AACF;AAGF,EAAA,KAAA,CAAM,QAAQ,EAAE,CAAA;AAEhB,EAAO,OAAA,MAAA,CAAO,YAAY,OAAO,CAAA;AACnC;AAGA,MAAM,kBAIN,CAAA;AAAA,EACE,GAAA;AAAA,EACA,SAAA;AAAA,EACA,UAAA;AAAA,EAEA,YAAY,OAA2D,EAAA;AACrE,IAAA,IAAA,CAAK,MAAM,OAAQ,CAAA,EAAA;AACnB,IAAA,IAAA,CAAK,SAAY,GAAA,eAAA;AAAA,MACf,OAAQ,CAAA;AAAA,KACV;AAAA;AACF,EAEA,MAAS,GAAA,2BAAA;AAAA,EAET,OAAU,GAAA,IAAA;AAAA,EAEV,IAAI,EAAU,GAAA;AACZ,IAAA,OAAO,IAAK,CAAA,GAAA;AAAA;AACd,EAEA,IAAI,CAAW,GAAA;AACb,IAAM,MAAA,IAAI,MAAM,iBAAiB,CAAA;AAAA;AACnC,EAEA,kBAAkC,GAAA;AAChC,IAAA,OAAO,IAAK,CAAA,SAAA;AAAA;AACd,EAEA,mBAAmB,SAAsC,EAAA;AACvD,IAAA,IAAA,CAAK,UAAa,GAAA,SAAA;AAAA;AACpB,EAEA,kBAAsD,GAAA;AACpD,IAAA,OAAO,IAAK,CAAA,UAAA;AAAA;AACd,EAEA,QAAW,GAAA;AACT,IAAO,OAAA,CAAA,kBAAA,EAAqB,KAAK,EAAE,CAAA,CAAA,CAAA;AAAA;AAEvC;AAGO,SAAS,qBAWd,MACyD,EAAA;AACzD,EAAM,MAAA,GAAA,GAAM,IAAI,kBAAA,CAAmB,MAAM,CAAA;AACzC,EAAA,IAAI,OAAO,YAAc,EAAA;AACvB,IAAI,GAAA,CAAA,kBAAA;AAAA,MACF,yBAA0B,CAAA;AAAA,QACxB,GAAA;AAAA,QACA,cAAc,MAAO,CAAA;AAAA,OACtB;AAAA,KACH;AAAA;AAEF,EAAO,OAAA,GAAA;AACT;;;;"}