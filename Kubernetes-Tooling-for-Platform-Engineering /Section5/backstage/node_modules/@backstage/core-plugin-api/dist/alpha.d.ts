import { TranslationRef as TranslationRef$1, TranslationMessages as TranslationMessages$1 } from '@backstage/core-plugin-api/alpha';
import { ApiRef } from '@backstage/core-plugin-api';
import { Observable } from '@backstage/types';

/**
 * Represents a collection of messages to be provided for a given translation ref.
 *
 * @alpha
 * @remarks
 *
 * This collection of messages can either be used directly as an override for the
 * default messages, or it can be used to provide translations for a language by
 * by being referenced by a {@link TranslationResource}.
 */
interface TranslationMessages<TId extends string = string, TMessages extends {
    [key in string]: string;
} = {
    [key in string]: string;
}, TFull extends boolean = boolean> {
    $$type: '@backstage/TranslationMessages';
    /** The ID of the translation ref that these messages are for */
    id: TId;
    /** Whether or not these messages override all known messages */
    full: TFull;
    /** The messages provided for the given translation ref */
    messages: TMessages;
}
/**
 * Options for {@link createTranslationMessages}.
 *
 * @alpha
 */
interface TranslationMessagesOptions<TId extends string, TMessages extends {
    [key in string]: string;
}, TFull extends boolean> {
    ref: TranslationRef$1<TId, TMessages>;
    full?: TFull;
    messages: false extends TFull ? {
        [key in keyof TMessages]?: string | null;
    } : {
        [key in keyof TMessages]: string | null;
    };
}
/**
 * Creates a collection of messages for a given translation ref.
 *
 * @alpha
 */
declare function createTranslationMessages<TId extends string, TMessages extends {
    [key in string]: string;
}, TFull extends boolean>(options: TranslationMessagesOptions<TId, TMessages, TFull>): TranslationMessages<TId, TMessages, TFull>;

/** @alpha */
interface TranslationResource<TId extends string = string> {
    $$type: '@backstage/TranslationResource';
    id: TId;
}
/** @alpha */
interface TranslationResourceOptions<TId extends string, TMessages extends {
    [key in string]: string;
}, TTranslations extends {
    [language in string]: () => Promise<{
        default: TranslationMessages$1<TId> | {
            [key in keyof TMessages]: string | null;
        };
    }>;
}> {
    ref: TranslationRef$1<TId, TMessages>;
    translations: TTranslations;
}
/** @alpha */
declare function createTranslationResource<TId extends string, TMessages extends {
    [key in string]: string;
}, TTranslations extends {
    [language in string]: () => Promise<{
        default: TranslationMessages$1<TId> | {
            [key in keyof TMessages]: string | null;
        };
    }>;
}>(options: TranslationResourceOptions<TId, TMessages, TTranslations>): TranslationResource<TId>;

/** @alpha */
interface TranslationRef<TId extends string = string, TMessages extends {
    [key in string]: string;
} = {
    [key in string]: string;
}> {
    $$type: '@backstage/TranslationRef';
    id: TId;
    T: TMessages;
}
/** @ignore */
type AnyNestedMessages = {
    [key in string]: AnyNestedMessages | string;
};
/**
 * Flattens a nested message declaration into a flat object with dot-separated keys.
 *
 * @ignore
 */
type FlattenedMessages<TMessages extends AnyNestedMessages> = {
    [TKey in keyof TMessages]: (_: TMessages[TKey] extends infer TValue ? TValue extends AnyNestedMessages ? FlattenedMessages<TValue> extends infer TNested ? {
        [TNestedKey in keyof TNested as `${TKey & string}.${TNestedKey & string}`]: TNested[TNestedKey];
    } : never : {
        [_ in TKey]: TValue;
    } : never) => void;
}[keyof TMessages] extends (_: infer TIntersection) => void ? {
    readonly [TExpandKey in keyof TIntersection]: TIntersection[TExpandKey];
} : never;
/** @alpha */
interface TranslationRefOptions<TId extends string, TNestedMessages extends AnyNestedMessages, TTranslations extends {
    [language in string]: () => Promise<{
        default: {
            [key in keyof FlattenedMessages<TNestedMessages>]: string | null;
        };
    }>;
}> {
    id: TId;
    messages: TNestedMessages;
    translations?: TTranslations;
}
/** @alpha */
declare function createTranslationRef<TId extends string, const TNestedMessages extends AnyNestedMessages, TTranslations extends {
    [language in string]: () => Promise<{
        default: {
            [key in keyof FlattenedMessages<TNestedMessages>]: string | null;
        };
    }>;
}>(config: TranslationRefOptions<TId, TNestedMessages, TTranslations>): TranslationRef<TId, FlattenedMessages<TNestedMessages>>;

/**
 * Base translation options.
 *
 * @alpha
 */
interface BaseOptions {
    interpolation?: {
        /** Whether to HTML escape provided values, defaults to false  */
        escapeValue?: boolean;
    };
}
/**
 * All pluralization suffixes supported by i18next
 *
 * @ignore
 */
type TranslationPlural = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';
/**
 * A mapping of i18n formatting types to their corresponding types and options.
 * @ignore
 */
type I18nextFormatMap = {
    number: {
        type: number;
        options: Intl.NumberFormatOptions;
    };
    currency: {
        type: number;
        options: Intl.NumberFormatOptions;
    };
    datetime: {
        type: Date;
        options: Intl.DateTimeFormatOptions;
    };
    relativetime: {
        type: number;
        options: {
            range?: Intl.RelativeTimeFormatUnit;
        } & Intl.RelativeTimeFormatOptions;
    };
    list: {
        type: string[];
        options: Intl.ListFormatOptions;
    };
};
/**
 * Extracts all pluralized keys from the message map.
 *
 * @example
 * ```
 * { foo: 'foo', bar_one: 'bar', bar_other: 'bars' } -> 'bar'
 * ```
 *
 * @ignore
 */
type PluralKeys<TMessages extends {
    [key in string]: string;
}> = {
    [Key in keyof TMessages]: Key extends `${infer K}_${TranslationPlural}` ? K : never;
}[keyof TMessages];
/**
 * Collapses a message map into normalized keys with union values.
 *
 * @example
 * ```
 * { foo_one: 'foo', foo_other: 'foos' } -> { foo: 'foo' | 'foos' }
 * ```
 *
 * @ignore
 */
type CollapsedMessages<TMessages extends {
    [key in string]: string;
}> = {
    [key in keyof TMessages as key extends `${infer K}_${TranslationPlural}` ? K : key]: TMessages[key];
};
/**
 * Helper type that expands type hints
 *
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/**
 * Helper type that expands type hints recursively
 *
 * @ignore
 */
type ExpandRecursive<T> = T extends infer O ? {
    [K in keyof O]: ExpandRecursive<O[K]>;
} : never;
/**
 * Trim away whitespace
 *
 * @ignore
 */
type Trim<T> = T extends ` ${infer U}` ? Trim<U> : T extends `${infer U} ` ? Trim<U> : T;
/**
 * Extracts the key and format from a replacement string.
 *
 * @example
 * ```
 * 'foo, number' -> { foo: number }, 'foo' -> { foo: undefined }
 * ```
 */
type ExtractFormat<Replacement extends string> = Replacement extends `${infer Key},${infer FullFormat}` ? {
    [key in Trim<Key>]: Lowercase<Trim<FullFormat extends `${infer Format}(${string})${string}` ? Format : FullFormat>>;
} : {
    [key in Trim<Replacement>]: undefined;
};
/**
 * Expand the keys in a flat map to nested objects.
 *
 * @example
 * ```
 * { 'a.b': 'foo', 'a.c': 'bar' } -> { a: { b: 'foo', c: 'bar' }
 * ```
 *
 * @ignore
 */
type ExpandKeys<TMap extends {}> = {
    [Key in keyof TMap as Key extends `${infer Prefix}.${string}` ? Prefix : Key]: Key extends `${string}.${infer Rest}` ? ExpandKeys<{
        [key in Rest]: TMap[Key];
    }> : TMap[Key];
};
/**
 * Extracts all option keys and their format from a message string.
 *
 * @example
 * ```
 * 'foo {{bar}} {{baz, number}}' -> { 'bar': undefined, 'baz': 'number' }
 * ```
 *
 * @ignore
 */
type ReplaceFormatsFromMessage<TMessage> = TMessage extends `${string}{{${infer Replacement}}}${infer Tail}` ? ExpandKeys<ExtractFormat<Replacement>> & ReplaceFormatsFromMessage<Tail> : {};
/**
 * Generates the replace options structure
 *
 * @ignore
 */
type ReplaceOptionsFromFormats<TFormats extends {}> = {
    [Key in keyof TFormats]: TFormats[Key] extends keyof I18nextFormatMap ? I18nextFormatMap[TFormats[Key]]['type'] : TFormats[Key] extends {} ? Expand<ReplaceOptionsFromFormats<TFormats[Key]>> : string;
};
/**
 * Generates the formatParams options structure
 *
 * @ignore
 */
type ReplaceFormatParamsFromFormats<TFormats extends {}> = {
    [Key in keyof TFormats]?: TFormats[Key] extends keyof I18nextFormatMap ? I18nextFormatMap[TFormats[Key]]['options'] : TFormats[Key] extends {} ? Expand<ReplaceFormatParamsFromFormats<TFormats[Key]>> : undefined;
};
/**
 * Extracts all nesting keys from a message string.
 *
 * @example
 * ```
 * 'foo $t(bar) $t(baz)' -> 'bar' | 'baz'
 * ```
 *
 * @ignore
 */
type NestingKeysFromMessage<TMessage extends string> = TMessage extends `${string}$t(${infer Key})${infer Tail}` ? Trim<Key> | NestingKeysFromMessage<Tail> : never;
/**
 * Find all referenced keys, given a starting key and the full set of messages.
 *
 * This will only discover keys up to 3 levels deep.
 *
 * @example
 * ```
 * <'x', { x: '$t(y) $t(z)', y: 'y', z: '$t(w)', w: 'w', foo: 'foo' }> -> 'x' | 'y' | 'z' | 'w'
 * ```
 *
 * @ignore
 */
type NestedMessageKeys<TKey extends keyof TMessages, TMessages extends {
    [key in string]: string;
}> = TKey | NestedMessageKeys2<NestingKeysFromMessage<TMessages[TKey]>, TMessages>;
type NestedMessageKeys2<TKey extends keyof TMessages, TMessages extends {
    [key in string]: string;
}> = TKey | NestedMessageKeys3<NestingKeysFromMessage<TMessages[TKey]>, TMessages>;
type NestedMessageKeys3<TKey extends keyof TMessages, TMessages extends {
    [key in string]: string;
}> = TKey | NestingKeysFromMessage<TMessages[TKey]>;
/**
 * Converts a union type to an intersection type.
 *
 * @example
 * ```
 * { foo: 'foo' } | { bar: 'bar' } -> { foo: 'foo' } & { bar: 'bar' }
 * ```
 *
 * @ignore
 */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
/**
 * Collects different types of options into a single object
 *
 * @ignore
 */
type CollectOptions<TCount extends {
    count?: number;
}, TFormats extends {}> = TCount & (keyof Omit<TFormats, 'count'> extends never ? {} : (Expand<Omit<ReplaceOptionsFromFormats<TFormats>, 'count'>> | {
    replace: Expand<Omit<ReplaceOptionsFromFormats<TFormats>, 'count'>>;
}) & {
    formatParams?: Expand<ReplaceFormatParamsFromFormats<TFormats>>;
});
/**
 * Helper type to only require options argument if needed
 *
 * @ignore
 */
type OptionArgs<TOptions extends {}> = keyof TOptions extends never ? [options?: BaseOptions] : [options: BaseOptions & TOptions];
/**
 * @ignore
 */
type TranslationFunctionOptions<TKeys extends keyof TMessages, // All normalized message keys to be considered, i.e. included nested ones
TPluralKeys extends keyof TMessages, // All keys in the message map that are pluralized
TMessages extends {
    [key in string]: string;
}> = OptionArgs<Expand<CollectOptions<TKeys & TPluralKeys extends never ? {} : {
    count: number;
}, ExpandRecursive<UnionToIntersection<ReplaceFormatsFromMessage<TMessages[TKeys]>>>>>>;
/** @alpha */
interface TranslationFunction<TMessages extends {
    [key in string]: string;
}> {
    <TKey extends keyof CollapsedMessages<TMessages>>(key: TKey, ...[args]: TranslationFunctionOptions<NestedMessageKeys<TKey, CollapsedMessages<TMessages>>, PluralKeys<TMessages>, CollapsedMessages<TMessages>>): CollapsedMessages<TMessages>[TKey];
}
/** @alpha */
type TranslationSnapshot<TMessages extends {
    [key in string]: string;
}> = {
    ready: false;
} | {
    ready: true;
    t: TranslationFunction<TMessages>;
};
/** @alpha */
type TranslationApi = {
    getTranslation<TMessages extends {
        [key in string]: string;
    }>(translationRef: TranslationRef<string, TMessages>): TranslationSnapshot<TMessages>;
    translation$<TMessages extends {
        [key in string]: string;
    }>(translationRef: TranslationRef<string, TMessages>): Observable<TranslationSnapshot<TMessages>>;
};
/**
 * @alpha
 */
declare const translationApiRef: ApiRef<TranslationApi>;

/** @alpha */
type AppLanguageApi = {
    getAvailableLanguages(): {
        languages: string[];
    };
    setLanguage(language?: string): void;
    getLanguage(): {
        language: string;
    };
    language$(): Observable<{
        language: string;
    }>;
};
/**
 * @alpha
 */
declare const appLanguageApiRef: ApiRef<AppLanguageApi>;

/** @alpha */
declare const useTranslationRef: <TMessages extends {
    [x: string]: string;
}>(translationRef: TranslationRef<string, TMessages>) => {
    t: TranslationFunction<TMessages>;
};

export { type AppLanguageApi, type TranslationApi, type TranslationFunction, type TranslationMessages, type TranslationMessagesOptions, type TranslationRef, type TranslationRefOptions, type TranslationResource, type TranslationResourceOptions, type TranslationSnapshot, appLanguageApiRef, createTranslationMessages, createTranslationRef, createTranslationResource, translationApiRef, useTranslationRef };
