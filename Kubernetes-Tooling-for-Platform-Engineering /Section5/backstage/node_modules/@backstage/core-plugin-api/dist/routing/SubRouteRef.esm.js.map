{"version":3,"file":"SubRouteRef.esm.js","sources":["../../src/routing/SubRouteRef.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AnyParams,\n  OptionalParams,\n  ParamKeys,\n  RouteRef,\n  routeRefType,\n  SubRouteRef,\n} from './types';\n\n// Should match the pattern in react-router\nconst PARAM_PATTERN = /^\\w+$/;\n\n/**\n * @internal\n */\nexport class SubRouteRefImpl<Params extends AnyParams>\n  implements SubRouteRef<Params>\n{\n  // The marker is used for type checking while the symbol is used at runtime.\n  declare $$routeRefType: 'sub';\n  readonly [routeRefType] = 'sub';\n\n  constructor(\n    private readonly id: string,\n    readonly path: string,\n    readonly parent: RouteRef,\n    readonly params: ParamKeys<Params>,\n  ) {}\n\n  toString() {\n    return `routeRef{type=sub,id=${this.id}}`;\n  }\n}\n\n/**\n * Used in {@link PathParams} type declaration.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type ParamPart<S extends string> = S extends `:${infer Param}`\n  ? Param\n  : never;\n\n/**\n * Used in {@link PathParams} type declaration.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type ParamNames<S extends string> =\n  S extends `${infer Part}/${infer Rest}`\n    ? ParamPart<Part> | ParamNames<Rest>\n    : ParamPart<S>;\n/**\n * This utility type helps us infer a Param object type from a string path\n * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type PathParams<S extends string> = { [name in ParamNames<S>]: string };\n\n/**\n * Merges a param object type with an optional params type into a params object.\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type MergeParams<\n  P1 extends { [param in string]: string },\n  P2 extends AnyParams,\n> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);\n\n/**\n * Creates a SubRouteRef type given the desired parameters and parent route parameters.\n * The parameters types are merged together while ensuring that there is no overlap between the two.\n *\n * @public\n * @deprecated this type is deprecated and will be removed in the future\n */\nexport type MakeSubRouteRef<\n  Params extends { [param in string]: string },\n  ParentParams extends AnyParams,\n> = keyof Params & keyof ParentParams extends never\n  ? SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>>\n  : never;\n\n/**\n * Create a {@link SubRouteRef} from a route descriptor.\n *\n * @param config - Description of the route reference to be created.\n * @public\n */\nexport function createSubRouteRef<\n  Path extends string,\n  ParentParams extends AnyParams = never,\n>(config: {\n  id: string;\n  path: Path;\n  parent: RouteRef<ParentParams>;\n}): MakeSubRouteRef<PathParams<Path>, ParentParams> {\n  const { id, path, parent } = config;\n  type Params = PathParams<Path>;\n\n  // Collect runtime parameters from the path, e.g. ['bar', 'baz'] from '/foo/:bar/:baz'\n  const pathParams = path\n    .split('/')\n    .filter(p => p.startsWith(':'))\n    .map(p => p.substring(1));\n  const params = [...parent.params, ...pathParams];\n\n  if (parent.params.some(p => pathParams.includes(p as string))) {\n    throw new Error(\n      'SubRouteRef may not have params that overlap with its parent',\n    );\n  }\n  if (!path.startsWith('/')) {\n    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);\n  }\n  if (path.endsWith('/')) {\n    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);\n  }\n  for (const param of pathParams) {\n    if (!PARAM_PATTERN.test(param)) {\n      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);\n    }\n  }\n\n  // We ensure that the type of the return type is sane here\n  const subRouteRef = new SubRouteRefImpl(\n    id,\n    path,\n    parent,\n    params as ParamKeys<MergeParams<Params, ParentParams>>,\n  ) as SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>>;\n\n  // But skip type checking of the return value itself, because the conditional\n  // type checking of the parent parameter overlap is tricky to express.\n  return subRouteRef as any;\n}\n"],"names":[],"mappings":";;AA0BA,MAAM,aAAgB,GAAA,OAAA;AAKf,MAAM,eAEb,CAAA;AAAA,EAKE,WACmB,CAAA,EAAA,EACR,IACA,EAAA,MAAA,EACA,MACT,EAAA;AAJiB,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA;AACR,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAAA;AACR,EAPH,CAAU,YAAY,IAAI,KAAA;AAAA,EAS1B,QAAW,GAAA;AACT,IAAO,OAAA,CAAA,qBAAA,EAAwB,KAAK,EAAE,CAAA,CAAA,CAAA;AAAA;AAE1C;AA0DO,SAAS,kBAGd,MAIkD,EAAA;AAClD,EAAA,MAAM,EAAE,EAAA,EAAI,IAAM,EAAA,MAAA,EAAW,GAAA,MAAA;AAI7B,EAAA,MAAM,aAAa,IAChB,CAAA,KAAA,CAAM,GAAG,CAAA,CACT,OAAO,CAAK,CAAA,KAAA,CAAA,CAAE,UAAW,CAAA,GAAG,CAAC,CAC7B,CAAA,GAAA,CAAI,OAAK,CAAE,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA;AAC1B,EAAA,MAAM,SAAS,CAAC,GAAG,MAAO,CAAA,MAAA,EAAQ,GAAG,UAAU,CAAA;AAE/C,EAAI,IAAA,MAAA,CAAO,OAAO,IAAK,CAAA,CAAA,CAAA,KAAK,WAAW,QAAS,CAAA,CAAW,CAAC,CAAG,EAAA;AAC7D,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA;AAEF,EAAA,IAAI,CAAC,IAAA,CAAK,UAAW,CAAA,GAAG,CAAG,EAAA;AACzB,IAAA,MAAM,IAAI,KAAA,CAAM,CAA8C,2CAAA,EAAA,IAAI,CAAG,CAAA,CAAA,CAAA;AAAA;AAEvE,EAAI,IAAA,IAAA,CAAK,QAAS,CAAA,GAAG,CAAG,EAAA;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAgD,6CAAA,EAAA,IAAI,CAAG,CAAA,CAAA,CAAA;AAAA;AAEzE,EAAA,KAAA,MAAW,SAAS,UAAY,EAAA;AAC9B,IAAA,IAAI,CAAC,aAAA,CAAc,IAAK,CAAA,KAAK,CAAG,EAAA;AAC9B,MAAA,MAAM,IAAI,KAAA,CAAM,CAA4C,yCAAA,EAAA,KAAK,CAAG,CAAA,CAAA,CAAA;AAAA;AACtE;AAIF,EAAA,MAAM,cAAc,IAAI,eAAA;AAAA,IACtB,EAAA;AAAA,IACA,IAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACF;AAIA,EAAO,OAAA,WAAA;AACT;;;;"}