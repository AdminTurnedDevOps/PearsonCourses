'use strict';

var pluginScaffolderNode = require('@backstage/plugin-scaffolder-node');
var path = require('path');
var errors = require('@backstage/errors');
var backendPluginApi = require('@backstage/backend-plugin-api');
var helpers = require('./helpers.cjs.js');
var gitlabMergeRequest_examples = require('./gitlabMergeRequest.examples.cjs.js');
var crypto = require('crypto');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

function computeSha256(file) {
  const hash = crypto.createHash("sha256");
  hash.update(file.content);
  return hash.digest("hex");
}
async function getFileAction(fileInfo, target, api, logger, remoteFiles, defaultCommitAction = "auto") {
  if (defaultCommitAction === "auto") {
    const filePath = path__default.default.join(fileInfo.targetPath ?? "", fileInfo.file.path);
    if (remoteFiles?.some((remoteFile) => remoteFile.path === filePath)) {
      try {
        const targetFile = await api.RepositoryFiles.show(
          target.repoID,
          filePath,
          target.branch
        );
        if (computeSha256(fileInfo.file) === targetFile.content_sha256) {
          return "skip";
        }
      } catch (error) {
        logger.warn(
          `Unable to retrieve detailed information for remote file ${filePath}`
        );
      }
      return "update";
    }
    return "create";
  }
  return defaultCommitAction;
}
const createPublishGitlabMergeRequestAction = (options) => {
  const { integrations } = options;
  return pluginScaffolderNode.createTemplateAction({
    id: "publish:gitlab:merge-request",
    examples: gitlabMergeRequest_examples.examples,
    schema: {
      input: {
        required: ["repoUrl", "branchName"],
        type: "object",
        properties: {
          repoUrl: {
            type: "string",
            title: "Repository Location",
            description: `Accepts the format 'gitlab.com?repo=project_name&owner=group_name' where 'project_name' is the repository name and 'group_name' is a group or username`
          },
          /** @deprecated projectID is passed as query parameters in the repoUrl */
          projectid: {
            type: "string",
            title: "projectid",
            description: "Project ID/Name(slug) of the Gitlab Project"
          },
          title: {
            type: "string",
            title: "Merge Request Name",
            description: "The name for the merge request"
          },
          description: {
            type: "string",
            title: "Merge Request Description",
            description: "The description of the merge request"
          },
          branchName: {
            type: "string",
            title: "Source Branch Name",
            description: "The source branch name of the merge request"
          },
          targetBranchName: {
            type: "string",
            title: "Target Branch Name",
            description: "The target branch name of the merge request"
          },
          sourcePath: {
            type: "string",
            title: "Working Subdirectory",
            description: `Subdirectory of working directory to copy changes from. For reasons of backward compatibility, any specified 'targetPath' input will be applied in place of an absent/falsy value for this input. Circumvent this behavior using '.'`
          },
          targetPath: {
            type: "string",
            title: "Repository Subdirectory",
            description: "Subdirectory of repository to apply changes to"
          },
          token: {
            title: "Authentication Token",
            type: "string",
            description: "The token to use for authorization to GitLab"
          },
          commitAction: {
            title: "Commit action",
            type: "string",
            enum: ["create", "update", "delete", "auto"],
            description: `The action to be used for git commit. Defaults to the custom 'auto' action provided by backstage,
which uses additional API calls in order to detect whether to 'create', 'update' or 'skip' each source file.`
          },
          removeSourceBranch: {
            title: "Delete source branch",
            type: "boolean",
            description: "Option to delete source branch once the MR has been merged. Default: false"
          },
          assignee: {
            title: "Merge Request Assignee",
            type: "string",
            description: "User this merge request will be assigned to"
          }
        }
      },
      output: {
        type: "object",
        properties: {
          targetBranchName: {
            title: "Target branch name of the merge request",
            type: "string"
          },
          projectid: {
            title: "Gitlab Project id/Name(slug)",
            type: "string"
          },
          projectPath: {
            title: "Gitlab Project path",
            type: "string"
          },
          mergeRequestUrl: {
            title: "MergeRequest(MR) URL",
            type: "string",
            description: "Link to the merge request in GitLab"
          }
        }
      }
    },
    async handler(ctx) {
      const {
        assignee,
        branchName,
        targetBranchName,
        description,
        repoUrl,
        removeSourceBranch,
        targetPath,
        sourcePath,
        title,
        token
      } = ctx.input;
      const { owner, repo, project } = pluginScaffolderNode.parseRepoUrl(repoUrl, integrations);
      const repoID = project ? project : `${owner}/${repo}`;
      const api = helpers.createGitlabApi({
        integrations,
        token,
        repoUrl
      });
      let assigneeId = void 0;
      if (assignee !== void 0) {
        try {
          const assigneeUser = await api.Users.all({ username: assignee });
          assigneeId = assigneeUser[0].id;
        } catch (e) {
          ctx.logger.warn(
            `Failed to find gitlab user id for ${assignee}: ${helpers.getErrorMessage(
              e
            )}. Proceeding with MR creation without an assignee.`
          );
        }
      }
      let fileRoot;
      if (sourcePath) {
        fileRoot = backendPluginApi.resolveSafeChildPath(ctx.workspacePath, sourcePath);
      } else if (targetPath) {
        fileRoot = backendPluginApi.resolveSafeChildPath(ctx.workspacePath, targetPath);
      } else {
        fileRoot = ctx.workspacePath;
      }
      const fileContents = await pluginScaffolderNode.serializeDirectoryContents(fileRoot, {
        gitignore: true
      });
      let targetBranch = targetBranchName;
      if (!targetBranch) {
        const projects = await api.Projects.show(repoID);
        const defaultBranch = projects.default_branch ?? projects.defaultBranch;
        if (typeof defaultBranch !== "string" || !defaultBranch) {
          throw new errors.InputError(
            `The branch creation failed. Target branch was not provided, and could not find default branch from project settings. Project: ${JSON.stringify(
              project
            )}`
          );
        }
        targetBranch = defaultBranch;
      }
      let remoteFiles = [];
      if ((ctx.input.commitAction ?? "auto") === "auto") {
        try {
          remoteFiles = await api.Repositories.allRepositoryTrees(repoID, {
            ref: targetBranch,
            recursive: true,
            path: targetPath ?? void 0
          });
        } catch (e) {
          ctx.logger.warn(
            `Could not retrieve the list of files for ${repoID} (branch: ${targetBranch}) : ${helpers.getErrorMessage(
              e
            )}`
          );
        }
      }
      const actions = ctx.input.commitAction === "skip" ? [] : (await Promise.all(
        fileContents.map(async (file) => {
          const action = await getFileAction(
            { file, targetPath },
            { repoID, branch: targetBranch },
            api,
            ctx.logger,
            remoteFiles,
            ctx.input.commitAction
          );
          return { file, action };
        })
      )).filter((o) => o.action !== "skip").map(({ file, action }) => ({
        action,
        filePath: targetPath ? path__default.default.posix.join(targetPath, file.path) : file.path,
        encoding: "base64",
        content: file.content.toString("base64"),
        execute_filemode: file.executable
      }));
      let createBranch;
      if (actions.length) {
        createBranch = true;
      } else {
        try {
          await api.Branches.show(repoID, branchName);
          createBranch = false;
          ctx.logger.info(
            `Using existing branch ${branchName} without modification.`
          );
        } catch (e) {
          createBranch = true;
        }
      }
      if (createBranch) {
        try {
          await api.Branches.create(repoID, branchName, String(targetBranch));
        } catch (e) {
          throw new errors.InputError(
            `The branch creation failed. Please check that your repo does not already contain a branch named '${branchName}'. ${helpers.getErrorMessage(
              e
            )}`
          );
        }
      }
      if (actions.length) {
        try {
          await api.Commits.create(repoID, branchName, title, actions);
        } catch (e) {
          throw new errors.InputError(
            `Committing the changes to ${branchName} failed. Please check that none of the files created by the template already exists. ${helpers.getErrorMessage(
              e
            )}`
          );
        }
      }
      try {
        const mergeRequestUrl = await api.MergeRequests.create(
          repoID,
          branchName,
          String(targetBranch),
          title,
          {
            description,
            removeSourceBranch: removeSourceBranch ? removeSourceBranch : false,
            assigneeId
          }
        ).then((mergeRequest) => mergeRequest.web_url ?? mergeRequest.webUrl);
        ctx.output("projectid", repoID);
        ctx.output("targetBranchName", targetBranch);
        ctx.output("projectPath", repoID);
        ctx.output("mergeRequestUrl", mergeRequestUrl);
      } catch (e) {
        throw new errors.InputError(
          `Merge request creation failed. ${helpers.getErrorMessage(e)}`
        );
      }
    }
  });
};

exports.createPublishGitlabMergeRequestAction = createPublishGitlabMergeRequestAction;
//# sourceMappingURL=gitlabMergeRequest.cjs.js.map
