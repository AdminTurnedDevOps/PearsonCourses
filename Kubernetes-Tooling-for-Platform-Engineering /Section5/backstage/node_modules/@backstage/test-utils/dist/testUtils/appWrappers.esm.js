import React from 'react';
import { MemoryRouter, Route } from 'react-router-dom';
import { UnifiedThemeProvider, themes } from '@backstage/theme';
import MockIcon from '@material-ui/icons/AcUnit';
import { createSpecializedApp } from '@backstage/core-app-api';
import { createRouteRef, attachComponentData } from '@backstage/core-plugin-api';
import { renderWithEffects } from './testingLibrary.esm.js';
import { defaultApis } from './defaultApis.esm.js';
import { mockApis } from './mockApis.esm.js';

const mockIcons = {
  "kind:api": MockIcon,
  "kind:component": MockIcon,
  "kind:domain": MockIcon,
  "kind:group": MockIcon,
  "kind:location": MockIcon,
  "kind:system": MockIcon,
  "kind:user": MockIcon,
  "kind:resource": MockIcon,
  "kind:template": MockIcon,
  brokenImage: MockIcon,
  catalog: MockIcon,
  scaffolder: MockIcon,
  techdocs: MockIcon,
  search: MockIcon,
  chat: MockIcon,
  dashboard: MockIcon,
  docs: MockIcon,
  email: MockIcon,
  github: MockIcon,
  group: MockIcon,
  help: MockIcon,
  user: MockIcon,
  warning: MockIcon,
  star: MockIcon,
  unstarred: MockIcon
};
const ErrorBoundaryFallback = ({ error }) => {
  throw new Error(`Reached ErrorBoundaryFallback Page with error, ${error}`);
};
const NotFoundErrorPage = () => {
  throw new Error("Reached NotFound Page");
};
const BootErrorPage = ({ step, error }) => {
  throw new Error(`Reached BootError Page at step ${step} with error ${error}`);
};
const Progress = () => /* @__PURE__ */ React.createElement("div", { "data-testid": "progress" });
const NoRender = (_props) => null;
function isExternalRouteRef(routeRef) {
  return String(routeRef).includes("{type=external,");
}
function createTestAppWrapper(options = {}) {
  const { routeEntries = ["/"] } = options;
  const boundRoutes = /* @__PURE__ */ new Map();
  const app = createSpecializedApp({
    apis: mockApis,
    defaultApis,
    // Bit of a hack to make sure that the default config loader isn't used
    // as that would force every single test to wait for config loading.
    configLoader: false,
    components: {
      Progress,
      BootErrorPage,
      NotFoundErrorPage,
      ErrorBoundaryFallback,
      Router: ({ children }) => /* @__PURE__ */ React.createElement(MemoryRouter, { initialEntries: routeEntries, children }),
      ...options.components
    },
    icons: {
      ...mockIcons,
      ...options.icons
    },
    plugins: [],
    themes: [
      {
        id: "light",
        title: "Test App Theme",
        variant: "light",
        Provider: ({ children }) => /* @__PURE__ */ React.createElement(UnifiedThemeProvider, { theme: themes.light }, children)
      }
    ],
    bindRoutes: ({ bind }) => {
      for (const [externalRef, absoluteRef] of boundRoutes) {
        bind(
          { ref: externalRef },
          {
            ref: absoluteRef
          }
        );
      }
    }
  });
  const routeElements = Object.entries(options.mountedRoutes ?? {}).map(
    ([path, routeRef]) => {
      const Page = () => /* @__PURE__ */ React.createElement("div", null, "Mounted at ", path);
      if (isExternalRouteRef(routeRef)) {
        const absoluteRef = createRouteRef({ id: "id" });
        boundRoutes.set(routeRef, absoluteRef);
        attachComponentData(Page, "core.mountPoint", absoluteRef);
      } else {
        attachComponentData(Page, "core.mountPoint", routeRef);
      }
      return /* @__PURE__ */ React.createElement(Route, { key: path, path, element: /* @__PURE__ */ React.createElement(Page, null) });
    }
  );
  const AppProvider = app.getProvider();
  const AppRouter = app.getRouter();
  const TestAppWrapper = ({ children }) => /* @__PURE__ */ React.createElement(AppProvider, null, /* @__PURE__ */ React.createElement(AppRouter, null, /* @__PURE__ */ React.createElement(NoRender, null, routeElements), children));
  return TestAppWrapper;
}
function wrapInTestApp(Component, options = {}) {
  const TestAppWrapper = createTestAppWrapper(options);
  let wrappedElement;
  if (Component instanceof Function) {
    wrappedElement = React.createElement(Component);
  } else {
    wrappedElement = Component;
  }
  return /* @__PURE__ */ React.createElement(TestAppWrapper, null, wrappedElement);
}
async function renderInTestApp(Component, options = {}) {
  let wrappedElement;
  if (Component instanceof Function) {
    wrappedElement = React.createElement(Component);
  } else {
    wrappedElement = Component;
  }
  const { legacyRoot } = options;
  return renderWithEffects(wrappedElement, {
    wrapper: createTestAppWrapper(options),
    legacyRoot
  });
}
const textContentMatcher = (text) => (_, node) => {
  if (!node) {
    return false;
  }
  const hasText = (textNode) => textNode?.textContent?.includes(text) ?? false;
  const childrenDontHaveText = (containerNode) => Array.from(containerNode?.children).every((child) => !hasText(child));
  return hasText(node) && childrenDontHaveText(node);
};

export { createTestAppWrapper, renderInTestApp, textContentMatcher, wrapInTestApp };
//# sourceMappingURL=appWrappers.esm.js.map
