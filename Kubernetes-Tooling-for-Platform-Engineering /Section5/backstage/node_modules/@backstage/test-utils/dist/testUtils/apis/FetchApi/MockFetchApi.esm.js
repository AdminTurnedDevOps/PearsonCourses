import { createFetchApi, FetchMiddlewares } from '@backstage/core-app-api';
import crossFetch, { Response } from 'cross-fetch';

class MockFetchApi {
  implementation;
  /**
   * Creates a mock {@link @backstage/core-plugin-api#FetchApi}.
   */
  constructor(options) {
    this.implementation = build(options);
  }
  /** {@inheritdoc @backstage/core-plugin-api#FetchApi.fetch} */
  get fetch() {
    return this.implementation.fetch;
  }
}
function build(options) {
  return createFetchApi({
    baseImplementation: baseImplementation(options),
    middleware: [
      resolvePluginProtocol(options),
      injectIdentityAuth(options)
    ].filter((x) => Boolean(x))
  });
}
function baseImplementation(options) {
  const implementation = options?.baseImplementation;
  if (!implementation) {
    return crossFetch;
  } else if (implementation === "none") {
    return () => Promise.resolve(new Response());
  }
  return implementation;
}
function resolvePluginProtocol(allOptions) {
  const options = allOptions?.resolvePluginProtocol;
  if (!options) {
    return void 0;
  }
  return FetchMiddlewares.resolvePluginProtocol({
    discoveryApi: options.discoveryApi
  });
}
function injectIdentityAuth(allOptions) {
  const options = allOptions?.injectIdentityAuth;
  if (!options) {
    return void 0;
  }
  const identityApi = "token" in options ? { getCredentials: async () => ({ token: options.token }) } : options.identityApi;
  return FetchMiddlewares.injectIdentityAuth({
    identityApi,
    allowUrl: () => true
  });
}

export { MockFetchApi };
//# sourceMappingURL=MockFetchApi.esm.js.map
