const nullObservable = {
  subscribe: () => ({ unsubscribe: () => {
  }, closed: true }),
  [Symbol.observable]() {
    return this;
  }
};
class MockErrorApi {
  constructor(options = {}) {
    this.options = options;
  }
  errors = new Array();
  waiters = /* @__PURE__ */ new Set();
  post(error, context) {
    if (this.options.collect) {
      this.errors.push({ error, context });
      for (const waiter of this.waiters) {
        if (waiter.pattern.test(error.message)) {
          this.waiters.delete(waiter);
          waiter.resolve({ error, context });
        }
      }
      return;
    }
    throw new Error(`MockErrorApi received unexpected error, ${error}`);
  }
  error$() {
    return nullObservable;
  }
  getErrors() {
    return this.errors;
  }
  waitForError(pattern, timeoutMs = 2e3) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(new Error("Timed out waiting for error"));
      }, timeoutMs);
      this.waiters.add({ resolve, pattern });
    });
  }
}

export { MockErrorApi };
//# sourceMappingURL=MockErrorApi.esm.js.map
