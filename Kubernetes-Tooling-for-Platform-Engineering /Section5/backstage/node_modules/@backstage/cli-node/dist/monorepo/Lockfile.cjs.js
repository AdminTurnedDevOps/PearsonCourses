'use strict';

var parsers = require('@yarnpkg/parsers');
var crypto = require('node:crypto');
var fs = require('fs-extra');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const ENTRY_PATTERN = /^((?:@[^/]+\/)?[^@/]+)@(.+)$/;
const SPECIAL_OBJECT_KEYS = [
  `__metadata`,
  `version`,
  `resolution`,
  `dependencies`,
  `peerDependencies`,
  `dependenciesMeta`,
  `peerDependenciesMeta`,
  `binaries`
];
class Lockfile {
  constructor(packages, data) {
    this.packages = packages;
    this.data = data;
  }
  /**
   * Load a {@link Lockfile} from a file path.
   */
  static async load(path) {
    const lockfileContents = await fs__default.default.readFile(path, "utf8");
    return Lockfile.parse(lockfileContents);
  }
  /**
   * Parse lockfile contents into a {@link Lockfile}.
   *
   * @public
   */
  static parse(content) {
    let data;
    try {
      data = parsers.parseSyml(content);
    } catch (err) {
      throw new Error(`Failed yarn.lock parse, ${err}`);
    }
    const packages = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(data)) {
      if (SPECIAL_OBJECT_KEYS.includes(key)) continue;
      const [, name, ranges] = ENTRY_PATTERN.exec(key) ?? [];
      if (!name) {
        throw new Error(`Failed to parse yarn.lock entry '${key}'`);
      }
      let queries = packages.get(name);
      if (!queries) {
        queries = [];
        packages.set(name, queries);
      }
      for (let range of ranges.split(/\s*,\s*/)) {
        if (range.startsWith(`${name}@`)) {
          range = range.slice(`${name}@`.length);
        }
        if (range.startsWith("npm:")) {
          range = range.slice("npm:".length);
        }
        queries.push({ range, version: value.version, dataKey: key });
      }
    }
    return new Lockfile(packages, data);
  }
  /**
   * Creates a simplified dependency graph from the lockfile data, where each
   * key is a package, and the value is a set of all packages that it depends on
   * across all versions.
   */
  createSimplifiedDependencyGraph() {
    const graph = /* @__PURE__ */ new Map();
    for (const [name, entries] of this.packages) {
      const dependencies = new Set(
        entries.flatMap((e) => {
          const data = this.data[e.dataKey];
          return [
            ...Object.keys(data?.dependencies ?? {}),
            ...Object.keys(data?.peerDependencies ?? {})
          ];
        })
      );
      graph.set(name, dependencies);
    }
    return graph;
  }
  /**
   * Diff with another lockfile, returning entries that have been
   * added, changed, and removed compared to the other lockfile.
   */
  diff(otherLockfile) {
    const diff = {
      added: new Array(),
      changed: new Array(),
      removed: new Array()
    };
    const remainingOldNames = new Set(this.packages.keys());
    for (const [name, otherQueries] of otherLockfile.packages) {
      remainingOldNames.delete(name);
      const thisQueries = this.packages.get(name);
      if (!thisQueries) {
        diff.removed.push(...otherQueries.map((q) => ({ name, range: q.range })));
        continue;
      }
      const remainingOldRanges = new Set(thisQueries.map((q) => q.range));
      for (const otherQuery of otherQueries) {
        remainingOldRanges.delete(otherQuery.range);
        const thisQuery = thisQueries.find((q) => q.range === otherQuery.range);
        if (!thisQuery) {
          diff.removed.push({ name, range: otherQuery.range });
          continue;
        }
        const otherPkg = otherLockfile.data[otherQuery.dataKey];
        const thisPkg = this.data[thisQuery.dataKey];
        if (otherPkg && thisPkg) {
          const thisCheck = thisPkg.integrity || thisPkg.checksum;
          const otherCheck = otherPkg.integrity || otherPkg.checksum;
          if (thisCheck !== otherCheck) {
            diff.changed.push({ name, range: otherQuery.range });
          }
        }
      }
      for (const thisRange of remainingOldRanges) {
        diff.added.push({ name, range: thisRange });
      }
    }
    for (const name of remainingOldNames) {
      const queries = this.packages.get(name) ?? [];
      diff.added.push(...queries.map((q) => ({ name, range: q.range })));
    }
    return diff;
  }
  /**
   * Generates a sha1 hex hash of the dependency graph for a package.
   */
  getDependencyTreeHash(startName) {
    if (!this.packages.has(startName)) {
      throw new Error(`Package '${startName}' not found in lockfile`);
    }
    const hash = crypto__default.default.createHash("sha1");
    const queue = [startName];
    const seen = /* @__PURE__ */ new Set();
    while (queue.length > 0) {
      const name = queue.pop();
      if (seen.has(name)) {
        continue;
      }
      seen.add(name);
      const entries = this.packages.get(name);
      if (!entries) {
        continue;
      }
      hash.update(`pkg:${name}`);
      hash.update("\0");
      const deps = new Array();
      for (const entry of entries) {
        hash.update(entry.version);
        const data = this.data[entry.dataKey];
        if (!data) {
          continue;
        }
        const checksum = data.checksum || data.integrity;
        if (checksum) {
          hash.update("#");
          hash.update(checksum);
        }
        hash.update(" ");
        deps.push(...Object.keys(data.dependencies ?? {}));
        deps.push(...Object.keys(data.peerDependencies ?? {}));
      }
      queue.push(...new Set(deps));
    }
    return hash.digest("hex");
  }
}

exports.Lockfile = Lockfile;
//# sourceMappingURL=Lockfile.cjs.js.map
