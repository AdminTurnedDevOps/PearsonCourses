'use strict';

var path = require('path');
var getPackages = require('@manypkg/get-packages');
var util = require('../util.cjs.js');
var GitUtils = require('../git/GitUtils.cjs.js');
var Lockfile = require('./Lockfile.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

class PackageGraph extends Map {
  /**
   * Lists all local packages in a monorepo.
   */
  static async listTargetPackages() {
    const { packages } = await getPackages.getPackages(util.paths.targetDir);
    return packages;
  }
  /**
   * Creates a package graph from a list of local packages.
   */
  static fromPackages(packages) {
    const graph = new PackageGraph();
    for (const pkg of packages) {
      const name = pkg.packageJson.name;
      const existingPkg = graph.get(name);
      if (existingPkg) {
        throw new Error(
          `Duplicate package name '${name}' at ${pkg.dir} and ${existingPkg.dir}`
        );
      }
      graph.set(name, {
        name,
        dir: pkg.dir,
        packageJson: pkg.packageJson,
        allLocalDependencies: /* @__PURE__ */ new Map(),
        publishedLocalDependencies: /* @__PURE__ */ new Map(),
        localDependencies: /* @__PURE__ */ new Map(),
        localDevDependencies: /* @__PURE__ */ new Map(),
        localOptionalDependencies: /* @__PURE__ */ new Map(),
        allLocalDependents: /* @__PURE__ */ new Map(),
        publishedLocalDependents: /* @__PURE__ */ new Map(),
        localDependents: /* @__PURE__ */ new Map(),
        localDevDependents: /* @__PURE__ */ new Map(),
        localOptionalDependents: /* @__PURE__ */ new Map()
      });
    }
    for (const node of graph.values()) {
      for (const depName of Object.keys(node.packageJson.dependencies || {})) {
        const depPkg = graph.get(depName);
        if (depPkg) {
          node.allLocalDependencies.set(depName, depPkg);
          node.publishedLocalDependencies.set(depName, depPkg);
          node.localDependencies.set(depName, depPkg);
          depPkg.allLocalDependents.set(node.name, node);
          depPkg.publishedLocalDependents.set(node.name, node);
          depPkg.localDependents.set(node.name, node);
        }
      }
      for (const depName of Object.keys(
        node.packageJson.devDependencies || {}
      )) {
        const depPkg = graph.get(depName);
        if (depPkg) {
          node.allLocalDependencies.set(depName, depPkg);
          node.localDevDependencies.set(depName, depPkg);
          depPkg.allLocalDependents.set(node.name, node);
          depPkg.localDevDependents.set(node.name, node);
        }
      }
      for (const depName of Object.keys(
        node.packageJson.optionalDependencies || {}
      )) {
        const depPkg = graph.get(depName);
        if (depPkg) {
          node.allLocalDependencies.set(depName, depPkg);
          node.publishedLocalDependencies.set(depName, depPkg);
          node.localOptionalDependencies.set(depName, depPkg);
          depPkg.allLocalDependents.set(node.name, node);
          depPkg.publishedLocalDependents.set(node.name, node);
          depPkg.localOptionalDependents.set(node.name, node);
        }
      }
    }
    return graph;
  }
  /**
   * Traverses the package graph and collects a set of package names.
   *
   * The traversal starts at the provided list names, and continues
   * throughout all the names returned by the `collectFn`, which is
   * called once for each seen package.
   */
  collectPackageNames(startingPackageNames, collectFn) {
    const targets = /* @__PURE__ */ new Set();
    const searchNames = startingPackageNames.slice();
    while (searchNames.length) {
      const name = searchNames.pop();
      if (targets.has(name)) {
        continue;
      }
      const node = this.get(name);
      if (!node) {
        throw new Error(`Package '${name}' not found`);
      }
      targets.add(name);
      const collected = collectFn(node);
      if (collected) {
        searchNames.push(...collected);
      }
    }
    return targets;
  }
  /**
   * Lists all packages that have changed since a given git ref.
   *
   * @remarks
   *
   * If the `analyzeLockfile` option is set to true, the change detection will
   * also consider changes to the dependency management lockfile.
   */
  async listChangedPackages(options) {
    const changedFiles = await GitUtils.GitUtils.listChangedFiles(options.ref);
    const dirMap = new Map(
      Array.from(this.values()).map((pkg) => [
        // relative from root, convert to posix, and add a / at the end
        path__default.default.relative(util.paths.targetRoot, pkg.dir).split(path__default.default.sep).join(path__default.default.posix.sep) + path__default.default.posix.sep,
        pkg
      ])
    );
    const packageDirs = Array.from(dirMap.keys());
    const result = new Array();
    let searchIndex = 0;
    changedFiles.sort();
    packageDirs.sort();
    for (const packageDir of packageDirs) {
      while (searchIndex < changedFiles.length && changedFiles[searchIndex] < packageDir) {
        searchIndex += 1;
      }
      if (changedFiles[searchIndex]?.startsWith(packageDir)) {
        searchIndex += 1;
        result.push(dirMap.get(packageDir));
        while (changedFiles[searchIndex]?.startsWith(packageDir)) {
          searchIndex += 1;
        }
      }
    }
    if (changedFiles.includes("yarn.lock") && options.analyzeLockfile) {
      let thisLockfile;
      let otherLockfile;
      try {
        thisLockfile = await Lockfile.Lockfile.load(
          util.paths.resolveTargetRoot("yarn.lock")
        );
        otherLockfile = Lockfile.Lockfile.parse(
          await GitUtils.GitUtils.readFileAtRef("yarn.lock", options.ref)
        );
      } catch (error) {
        console.warn(
          `Failed to read lockfiles, assuming all packages have changed, ${error}`
        );
        return Array.from(this.values());
      }
      const diff = thisLockfile.diff(otherLockfile);
      const graph = thisLockfile.createSimplifiedDependencyGraph();
      {
        const otherGraph = thisLockfile.createSimplifiedDependencyGraph();
        for (const [name, dependencies] of otherGraph) {
          const node = graph.get(name);
          if (node) {
            dependencies.forEach((d) => node.add(d));
          } else {
            graph.set(name, dependencies);
          }
        }
      }
      const changedPackages = new Set(
        [...diff.added, ...diff.changed, ...diff.removed].map((e) => e.name)
      );
      let changed = false;
      do {
        changed = false;
        for (const [name, dependencies] of graph) {
          if (changedPackages.has(name)) {
            continue;
          }
          for (const dep of dependencies) {
            if (changedPackages.has(dep)) {
              changed = true;
              changedPackages.add(name);
              break;
            }
          }
        }
      } while (changed);
      for (const node of this.values()) {
        if (changedPackages.has(node.name) && !result.includes(node)) {
          result.push(node);
        }
      }
    }
    return result;
  }
}

exports.PackageGraph = PackageGraph;
//# sourceMappingURL=PackageGraph.cjs.js.map
