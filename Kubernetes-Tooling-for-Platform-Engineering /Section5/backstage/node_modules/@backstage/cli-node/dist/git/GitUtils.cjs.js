'use strict';

var errors = require('@backstage/errors');
var util = require('../util.cjs.js');

async function runGit(...args) {
  try {
    const { stdout } = await util.execFile("git", args, {
      shell: true,
      cwd: util.paths.targetRoot
    });
    return stdout.trim().split(/\r\n|\r|\n/);
  } catch (error) {
    errors.assertError(error);
    if (error.stderr || typeof error.code === "number") {
      const stderr = error.stderr?.toString("utf8");
      const msg = stderr?.trim() ?? `with exit code ${error.code}`;
      throw new Error(`git ${args[0]} failed, ${msg}`);
    }
    throw new errors.ForwardedError("Unknown execution error", error);
  }
}
class GitUtils {
  /**
   * Returns a sorted list of all files that have changed since the merge base
   * of the provided `ref` and HEAD, as well as all files that are not tracked by git.
   */
  static async listChangedFiles(ref) {
    if (!ref) {
      throw new Error("ref is required");
    }
    let diffRef = ref;
    try {
      const [base] = await runGit("merge-base", "HEAD", ref);
      diffRef = base;
    } catch {
    }
    const tracked = await runGit("diff", "--name-only", diffRef);
    const untracked = await runGit(
      "ls-files",
      "--others",
      "--exclude-standard"
    );
    return Array.from(/* @__PURE__ */ new Set([...tracked, ...untracked]));
  }
  /**
   * Returns the contents of a file at a specific ref.
   */
  static async readFileAtRef(path, ref) {
    let showRef = ref;
    try {
      const [base] = await runGit("merge-base", "HEAD", ref);
      showRef = base;
    } catch {
    }
    const { stdout } = await util.execFile("git", ["show", `${showRef}:${path}`], {
      shell: true,
      cwd: util.paths.targetRoot,
      maxBuffer: 1024 * 1024 * 50
    });
    return stdout;
  }
}

exports.GitUtils = GitUtils;
exports.runGit = runGit;
//# sourceMappingURL=GitUtils.cjs.js.map
