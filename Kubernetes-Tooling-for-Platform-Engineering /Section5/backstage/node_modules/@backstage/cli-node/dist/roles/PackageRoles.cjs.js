'use strict';

var zod = require('zod');

const packageRoleInfos = [
  {
    role: "frontend",
    platform: "web",
    output: ["bundle"]
  },
  {
    role: "backend",
    platform: "node",
    output: ["bundle"]
  },
  {
    role: "cli",
    platform: "node",
    output: ["cjs"]
  },
  {
    role: "web-library",
    platform: "web",
    output: ["types", "esm"]
  },
  {
    role: "node-library",
    platform: "node",
    output: ["types", "cjs"]
  },
  {
    role: "common-library",
    platform: "common",
    output: ["types", "esm", "cjs"]
  },
  {
    role: "frontend-plugin",
    platform: "web",
    output: ["types", "esm"]
  },
  {
    role: "frontend-plugin-module",
    platform: "web",
    output: ["types", "esm"]
  },
  {
    role: "frontend-dynamic-container",
    // experimental
    platform: "web",
    output: ["bundle"]
  },
  {
    role: "backend-plugin",
    platform: "node",
    output: ["types", "cjs"]
  },
  {
    role: "backend-plugin-module",
    platform: "node",
    output: ["types", "cjs"]
  }
];
const readSchema = zod.z.object({
  name: zod.z.string().optional(),
  backstage: zod.z.object({
    role: zod.z.string().optional()
  }).optional()
});
const detectionSchema = zod.z.object({
  name: zod.z.string().optional(),
  scripts: zod.z.object({
    start: zod.z.string().optional(),
    build: zod.z.string().optional()
  }).optional(),
  publishConfig: zod.z.object({
    main: zod.z.string().optional(),
    types: zod.z.string().optional(),
    module: zod.z.string().optional()
  }).optional(),
  main: zod.z.string().optional(),
  types: zod.z.string().optional(),
  module: zod.z.string().optional()
});
class PackageRoles {
  /**
   * Get the associated info for a package role.
   */
  static getRoleInfo(role) {
    const roleInfo = packageRoleInfos.find((r) => r.role === role);
    if (!roleInfo) {
      throw new Error(`Unknown package role '${role}'`);
    }
    return roleInfo;
  }
  /**
   * Given package JSON data, get the package role.
   */
  static getRoleFromPackage(pkgJson) {
    const pkg = readSchema.parse(pkgJson);
    if (pkg.backstage) {
      const { role } = pkg.backstage;
      if (!role) {
        throw new Error(
          `Package ${pkg.name} must specify a role in the "backstage" field`
        );
      }
      return this.getRoleInfo(role).role;
    }
    return void 0;
  }
  /**
   * Attempt to detect the role of a package from its package.json.
   */
  static detectRoleFromPackage(pkgJson) {
    const pkg = detectionSchema.parse(pkgJson);
    if (pkg.scripts?.start?.includes("app:serve")) {
      return "frontend";
    }
    if (pkg.scripts?.build?.includes("backend:bundle")) {
      return "backend";
    }
    if (pkg.name?.includes("plugin-") && pkg.name?.includes("-backend-module-")) {
      return "backend-plugin-module";
    }
    if (pkg.name?.includes("plugin-") && pkg.name?.includes("-module-")) {
      return "frontend-plugin-module";
    }
    if (pkg.scripts?.start?.includes("plugin:serve")) {
      return "frontend-plugin";
    }
    if (pkg.scripts?.start?.includes("backend:dev")) {
      return "backend-plugin";
    }
    const mainEntry = pkg.publishConfig?.main || pkg.main;
    const moduleEntry = pkg.publishConfig?.module || pkg.module;
    const typesEntry = pkg.publishConfig?.types || pkg.types;
    if (typesEntry) {
      if (mainEntry && moduleEntry) {
        return "common-library";
      }
      if (moduleEntry || mainEntry?.endsWith(".esm.js")) {
        return "web-library";
      }
      if (mainEntry) {
        return "node-library";
      }
    } else if (mainEntry) {
      return "cli";
    }
    return void 0;
  }
}

exports.PackageRoles = PackageRoles;
//# sourceMappingURL=PackageRoles.cjs.js.map
