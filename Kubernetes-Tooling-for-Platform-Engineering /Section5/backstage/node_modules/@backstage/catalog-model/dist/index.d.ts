import { JsonObject } from '@backstage/types';

/**
 * Validates entities of a certain kind.
 *
 * @public
 */
type KindValidator = {
    /**
     * Validates the entity as a known entity kind.
     *
     * @param entity - The entity to validate
     * @returns Resolves to true, if the entity was of a kind that was known and
     *   handled by this validator, and was found to be valid. Resolves to false,
     *   if the entity was not of a kind that was known by this validator.
     *   Rejects to an Error describing the problem, if the entity was of a kind
     *   that was known by this validator and was not valid.
     */
    check(entity: Entity): Promise<boolean>;
};

/**
 * The parts of the format that's common to all versions/kinds of entity.
 *
 * @remarks
 *
 * See also:
 * {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/}
 * @public
 */
type Entity = {
    /**
     * The version of specification format for this particular entity that
     * this is written against.
     */
    apiVersion: string;
    /**
     * The high level entity type being described.
     */
    kind: string;
    /**
     * Metadata related to the entity.
     */
    metadata: EntityMeta;
    /**
     * The specification data describing the entity itself.
     */
    spec?: JsonObject;
    /**
     * The relations that this entity has with other entities.
     */
    relations?: EntityRelation[];
};
/**
 * Metadata fields common to all versions/kinds of entity.
 *
 * @remarks
 *
 * See also:
 * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta}
 * {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/}
 *
 * @public
 */
type EntityMeta = JsonObject & {
    /**
     * A globally unique ID for the entity.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, but the server is free to reject requests
     * that do so in such a way that it breaks semantics.
     */
    uid?: string;
    /**
     * An opaque string that changes for each update operation to any part of
     * the entity, including metadata.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, and the server will then reject the
     * operation if it does not match the current stored value.
     */
    etag?: string;
    /**
     * The name of the entity.
     *
     * Must be unique within the catalog at any given point in time, for any
     * given namespace + kind pair. This value is part of the technical
     * identifier of the entity, and as such it will appear in URLs, database
     * tables, entity references, and similar. It is subject to restrictions
     * regarding what characters are allowed.
     *
     * If you want to use a different, more human readable string with fewer
     * restrictions on it in user interfaces, see the `title` field below.
     */
    name: string;
    /**
     * The namespace that the entity belongs to.
     */
    namespace?: string;
    /**
     * A display name of the entity, to be presented in user interfaces instead
     * of the `name` property above, when available.
     *
     * This field is sometimes useful when the `name` is cumbersome or ends up
     * being perceived as overly technical. The title generally does not have
     * as stringent format requirements on it, so it may contain special
     * characters and be more explanatory. Do keep it very short though, and
     * avoid situations where a title can be confused with the name of another
     * entity, or where two entities share a title.
     *
     * Note that this is only for display purposes, and may be ignored by some
     * parts of the code. Entity references still always make use of the `name`
     * property, not the title.
     */
    title?: string;
    /**
     * A short (typically relatively few words, on one line) description of the
     * entity.
     */
    description?: string;
    /**
     * Key/value pairs of identifying information attached to the entity.
     */
    labels?: Record<string, string>;
    /**
     * Key/value pairs of non-identifying auxiliary information attached to the
     * entity.
     */
    annotations?: Record<string, string>;
    /**
     * A list of single-valued strings, to for example classify catalog entities in
     * various ways.
     */
    tags?: string[];
    /**
     * A list of external hyperlinks related to the entity.
     */
    links?: EntityLink[];
};
/**
 * A relation of a specific type to another entity in the catalog.
 *
 * @public
 */
type EntityRelation = {
    /**
     * The type of the relation.
     */
    type: string;
    /**
     * The entity ref of the target of this relation.
     */
    targetRef: string;
};
/**
 * A link to external information that is related to the entity.
 *
 * @public
 */
type EntityLink = {
    /**
     * The url to the external site, document, etc.
     */
    url: string;
    /**
     * An optional descriptive title for the link.
     */
    title?: string;
    /**
     * An optional semantic key that represents a visual icon.
     */
    icon?: string;
    /**
     * An optional value to categorize links into specific groups
     */
    type?: string;
};

/**
 * Backstage API kind Entity. APIs describe the interfaces for Components to communicate.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/system-model}
 *
 * @public
 */
interface ApiEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'API';
    spec: {
        type: string;
        lifecycle: string;
        owner: string;
        definition: string;
        system?: string;
    };
}
/**
 * {@link KindValidator} for {@link ApiEntityV1alpha1}.
 *
 * @public
 */
declare const apiEntityV1alpha1Validator: KindValidator;

/**
 * Backstage catalog Component kind Entity. Represents a single, individual piece of software.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/system-model}
 *
 * @public
 */
interface ComponentEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Component';
    spec: {
        type: string;
        lifecycle: string;
        owner: string;
        subcomponentOf?: string;
        providesApis?: string[];
        consumesApis?: string[];
        dependsOn?: string[];
        dependencyOf?: string[];
        system?: string;
    };
}
/**
 * {@link KindValidator} for {@link ComponentEntityV1alpha1}.
 *
 * @public
 */
declare const componentEntityV1alpha1Validator: KindValidator;

/**
 * Backstage Domain kind Entity. Domains group Systems together.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/system-model}
 *
 * @public
 */
interface DomainEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Domain';
    spec: {
        owner: string;
        subdomainOf?: string;
        type?: string;
    };
}
/**
 * {@link KindValidator} for {@link DomainEntityV1alpha1}.
 *
 * @public
 */
declare const domainEntityV1alpha1Validator: KindValidator;

/**
 * Backstage catalog Group kind Entity.
 *
 * @public
 */
interface GroupEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Group';
    spec: {
        type: string;
        profile?: {
            displayName?: string;
            email?: string;
            picture?: string;
        };
        parent?: string;
        children: string[];
        members?: string[];
    };
}
/**
 * {@link KindValidator} for {@link GroupEntityV1alpha1}.
 * @public
 */
declare const groupEntityV1alpha1Validator: KindValidator;

/**
 * Backstage catalog Location kind Entity.
 *
 * @public
 */
interface LocationEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Location';
    spec: {
        type?: string;
        target?: string;
        targets?: string[];
        presence?: 'required' | 'optional';
    };
}
/**
 * {@link KindValidator} for {@link LocationEntityV1alpha1}.
 *
 * @public
 */
declare const locationEntityV1alpha1Validator: KindValidator;

/**
 * An ownership relation where the owner is usually an organizational
 * entity (user or group), and the other entity can be anything. Reversed
 * direction of {@link RELATION_OWNER_OF}.
 *
 * @public
 */
declare const RELATION_OWNED_BY = "ownedBy";
/**
 * A relationship from an owner to the owned entity. Reversed direction of
 * {@link RELATION_OWNED_BY}.
 *
 * @public
 */
declare const RELATION_OWNER_OF = "ownerOf";
/**
 * A relation with an API entity, typically from a component. Reversed direction of
 * {@link RELATION_API_CONSUMED_BY}.
 *
 * @public
 */
declare const RELATION_CONSUMES_API = "consumesApi";
/**
 * A relation of an API being consumed, typically by a component. Reversed direction of
 * {@link RELATION_CONSUMES_API}.
 *
 * @public
 */
declare const RELATION_API_CONSUMED_BY = "apiConsumedBy";
/**
 * A relation from an API provider entity (typically a component) to the API. Reversed direction of
 * {@link RELATION_API_PROVIDED_BY}.
 *
 * @public
 */
declare const RELATION_PROVIDES_API = "providesApi";
/**
 * A relation from an API to its provider entity (typically a component). Reversed direction of
 * {@link RELATION_PROVIDES_API}.
 *
 * @public
 */
declare const RELATION_API_PROVIDED_BY = "apiProvidedBy";
/**
 * A relation denoting a dependency on another entity. Reversed direction of
 * {@link RELATION_DEPENDENCY_OF}.
 *
 * @public
 */
declare const RELATION_DEPENDS_ON = "dependsOn";
/**
 * A relation denoting a reverse dependency by another entity. Reversed direction of
 * {@link RELATION_DEPENDS_ON}.
 *
 * @public
 */
declare const RELATION_DEPENDENCY_OF = "dependencyOf";
/**
 * A parent/child relation to build up a tree, used for example to describe
 * the organizational structure between groups. Reversed direction of
 * {@link RELATION_CHILD_OF}.
 *
 * @public
 */
declare const RELATION_PARENT_OF = "parentOf";
/**
 * A relation from a child to a parent entity, used for example to describe
 * the organizational structure between groups. Reversed direction of
 * {@link RELATION_PARENT_OF}.
 *
 * @public
 */
declare const RELATION_CHILD_OF = "childOf";
/**
 * A membership relation, typically for users in a group. Reversed direction of
 * {@link RELATION_HAS_MEMBER}.
 *
 * @public
 */
declare const RELATION_MEMBER_OF = "memberOf";
/**
 * A relation from a group to its member, typically a user in a group. Reversed direction of
 * {@link RELATION_MEMBER_OF}.
 *
 * @public
 */
declare const RELATION_HAS_MEMBER = "hasMember";
/**
 * A part/whole relation, typically for components in a system and systems
 * in a domain. Reversed direction of {@link RELATION_HAS_PART}.
 *
 * @public
 */
declare const RELATION_PART_OF = "partOf";
/**
 * A relation from a containing entity to a contained entity. Reversed direction of
 * {@link RELATION_PART_OF}.
 *
 * @public
 */
declare const RELATION_HAS_PART = "hasPart";

/**
 * Backstage catalog Resource kind Entity. Represents infrastructure required to operate Components.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/system-model}
 *
 * @public
 */
interface ResourceEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Resource';
    spec: {
        type: string;
        owner: string;
        dependsOn?: string[];
        dependencyOf?: string[];
        system?: string;
    };
}
/**
 * {@link KindValidator} for {@link ResourceEntityV1alpha1}.
 *
 * @public
 */
declare const resourceEntityV1alpha1Validator: KindValidator;

/**
 * Backstage catalog System kind Entity. Systems group Components, Resources and APIs together.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/features/software-catalog/system-model}
 *
 * @public
 */
interface SystemEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'System';
    spec: {
        owner: string;
        domain?: string;
        type?: string;
    };
}
/**
 * {@link KindValidator} for {@link SystemEntityV1alpha1}.
 *
 * @public
 */
declare const systemEntityV1alpha1Validator: KindValidator;

/**
 * Backstage catalog User kind Entity.
 *
 * @public
 */
interface UserEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'User';
    spec: {
        profile?: {
            displayName?: string;
            email?: string;
            picture?: string;
        };
        memberOf?: string[];
    };
}
/**
 * {@link KindValidator} for {@link UserEntityV1alpha1}.
 *
 * @public
 */
declare const userEntityV1alpha1Validator: KindValidator;

/**
 * @public
 */
declare function isApiEntity(entity: Entity): entity is ApiEntityV1alpha1;
/**
 * @public
 */
declare function isComponentEntity(entity: Entity): entity is ComponentEntityV1alpha1;
/**
 * @public
 */
declare function isDomainEntity(entity: Entity): entity is DomainEntityV1alpha1;
/**
 * @public
 */
declare function isGroupEntity(entity: Entity): entity is GroupEntityV1alpha1;
/**
 * @public
 */
declare function isLocationEntity(entity: Entity): entity is LocationEntityV1alpha1;
/**
 * @public
 */
declare function isResourceEntity(entity: Entity): entity is ResourceEntityV1alpha1;
/**
 * @public
 */
declare function isSystemEntity(entity: Entity): entity is SystemEntityV1alpha1;
/**
 * @public
 */
declare function isUserEntity(entity: Entity): entity is UserEntityV1alpha1;

/**
 * The namespace that entities without an explicit namespace fall into.
 *
 * @public
 */
declare const DEFAULT_NAMESPACE = "default";
/**
 * Annotation for linking to entity page from catalog pages.
 *
 * @public
 */
declare const ANNOTATION_VIEW_URL = "backstage.io/view-url";
/**
 * Annotation for linking to entity edit page from catalog pages.
 *
 * @public
 */
declare const ANNOTATION_EDIT_URL = "backstage.io/edit-url";
/**
 * Annotation for specifying the API server of a Kubernetes cluster
 *
 * @deprecated Import this constant from `@backstage/plugin-kubernetes-common` instead
 * @public
 */
declare const ANNOTATION_KUBERNETES_API_SERVER = "kubernetes.io/api-server";
/**
 * Annotation for specifying the Certificate Authority of an API server for a Kubernetes cluster
 *
 * @deprecated Import this constant from `@backstage/plugin-kubernetes-common` instead
 * @public
 */
declare const ANNOTATION_KUBERNETES_API_SERVER_CA = "kubernetes.io/api-server-certificate-authority";
/**
 * Annotation for specifying the auth provider for a Kubernetes cluster
 *
 * @deprecated Import this constant from `@backstage/plugin-kubernetes-common` instead
 * @public
 */
declare const ANNOTATION_KUBERNETES_AUTH_PROVIDER = "kubernetes.io/auth-provider";

/**
 * The envelope skeleton parts of an entity - whatever is necessary to be able
 * to give it a ref and pass to further validation / policy checking.
 *
 * @public
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
type EntityEnvelope = {
    /**
     * The version of specification format for this particular entity that
     * this is written against.
     */
    apiVersion: string;
    /**
     * The high level entity type being described.
     */
    kind: string;
    /**
     * Metadata related to the entity.
     */
    metadata: {
        /**
         * The name of the entity.
         *
         * Must be unique within the catalog at any given point in time, for any
         * given namespace + kind pair.
         */
        name: string;
        /**
         * The namespace that the entity belongs to.
         */
        namespace?: string;
    };
};

/**
 * A policy for validation or mutation to be applied to entities as they are
 * entering the system.
 *
 * @public
 */
type EntityPolicy = {
    /**
     * Applies validation or mutation on an entity.
     *
     * @param entity - The entity, as validated/mutated so far in the policy tree
     * @returns The incoming entity, or a mutated version of the same, or
     *          undefined if this processor could not handle the entity
     * @throws An error if the entity should be rejected
     */
    enforce(entity: Entity): Promise<Entity | undefined>;
};

/**
 * Sets a default namespace if none was set.
 *
 * @public
 */
declare class DefaultNamespaceEntityPolicy implements EntityPolicy {
    private readonly namespace;
    constructor(namespace?: string);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * DefaultParentPolicy is an EntityPolicy that updates group entities
 * with a parent of last resort. This ensures that, while we preserve
 * any existing group hierarchies, we can guarantee that there is a
 * single global root of the group hierarchy.
 *
 * @public
 */
declare class GroupDefaultParentEntityPolicy implements EntityPolicy {
    private readonly parentRef;
    constructor(parentEntityRef: string);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Contains various helper validation and normalization functions that can be
 * composed to form a Validator.
 *
 * @public
 */
declare class CommonValidatorFunctions {
    /**
     * Checks that the value is on the form `<suffix>` or `<prefix><separator><suffix>`, and validates
     * those parts separately.
     *
     * @param value - The value to check
     * @param separator - The separator between parts
     * @param isValidPrefix - Checks that the part before the separator is valid, if present
     * @param isValidSuffix - Checks that the part after the separator (or the entire value if there is no separator) is valid
     */
    static isValidPrefixAndOrSuffix(value: unknown, separator: string, isValidPrefix: (value: string) => boolean, isValidSuffix: (value: string) => boolean): boolean;
    /**
     * Checks that the value can be safely transferred as JSON.
     *
     * @param value - The value to check
     */
    static isJsonSafe(value: unknown): boolean;
    /**
     * Checks that the value is a valid DNS subdomain name.
     *
     * @param value - The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsSubdomain(value: unknown): boolean;
    /**
     * Checks that the value is a valid DNS label.
     *
     * @param value - The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsLabel(value: unknown): boolean;
    /**
     * Checks that the value is a valid tag.
     *
     * @deprecated This will be removed in a future release
     * @param value - The value to check
     */
    static isValidTag(value: unknown): boolean;
    /**
     * Checks that the value is a valid string URL.
     *
     * @param value - The value to check
     */
    static isValidUrl(value: unknown): boolean;
    /**
     * Checks that the value is a non empty string value.
     *
     * @deprecated use isNonEmptyString instead
     * @param value - The value to check
     */
    static isValidString(value: unknown): boolean;
    /**
     * Checks that the value is a string value that's not empty.
     *
     * @param value - The value to check
     */
    static isNonEmptyString(value: unknown): value is string;
}

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to an {@link EntityEnvelope} (or the given subtype)
 * if it matches that schema, or throws a {@link globals#TypeError} describing the
 * errors.
 *
 * @remarks
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * By default, the plain `EntityEnvelope` schema is used. If you pass in your
 * own, it may contain `$ref` references to the following, which are resolved
 * automatically for you:
 *
 * - {@link EntityEnvelope}
 * - {@link Entity}
 * - {@link EntityMeta}
 * - `common#<id>`
 *
 * See also {@link https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema}
 *
 * @public
 *
 */
declare function entityEnvelopeSchemaValidator<T extends EntityEnvelope = EntityEnvelope>(schema?: unknown): (data: unknown) => T;

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to a `T` if it matches that schema, or `false` if the
 * schema apiVersion/kind didn't apply to that data, or throws a
 * {@link globals#TypeError} describing actual errors.
 *
 * @remarks
 *
 * This validator is highly specialized, in that it has special treatment of
 * the `kind` and `apiVersion` root keys. This only works if your schema has
 * their rule set to `"enum"`:
 *
 * ```
 * "apiVersion": {
 *    "enum": ["backstage.io/v1alpha1", "backstage.io/v1beta1"]
 * },
 * "kind": {
 *   "enum": ["Group"]
 * },
 * ```
 *
 * In the above example, the created validator will return `false` if and only
 * if the kind and/or apiVersion mismatch.
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * The given schema may contain `$ref` references to the following, which are
 * resolved automatically for you:
 *
 * - {@link Entity}
 *
 * - {@link EntityEnvelope}
 *
 * - {@link EntityMeta}
 *
 * - `common#<id>`
 * @see {@link https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema}
 *
 * @public
 */
declare function entityKindSchemaValidator<T extends Entity>(schema: unknown): (data: unknown) => T | false;

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to an {@link Entity} (or the given subtype) if it
 * matches that schema, or throws a {@link globals#TypeError} describing the errors.
 *
 * @remarks
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * By default, the plain {@link Entity} schema is used. If you pass in your own, it
 * may contain `$ref` references to the following, which are resolved
 * automatically for you:
 *
 * - {@link Entity}
 * - {@link EntityEnvelope}
 * - {@link EntityMeta}
 * - `common#<id>`
 *
 * @public
 * @see {@link https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema}
 */
declare function entitySchemaValidator<T extends Entity = Entity>(schema?: unknown): (data: unknown) => T;

/**
 * Contains validation functions that match the Kubernetes spec, usable to
 * build a catalog that is compatible with those rule sets.
 *
 * @public
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/names/
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
 */
declare class KubernetesValidatorFunctions {
    static isValidApiVersion(value: unknown): boolean;
    static isValidKind(value: unknown): boolean;
    static isValidObjectName(value: unknown): boolean;
    static isValidNamespace(value: unknown): boolean;
    static isValidLabelKey(value: unknown): boolean;
    static isValidLabelValue(value: unknown): boolean;
    static isValidAnnotationKey(value: unknown): boolean;
    static isValidAnnotationValue(value: unknown): boolean;
}

/**
 * Type alias for implementing validators of various entity objects.
 *
 * @public
 */
type Validators = {
    isValidApiVersion(value: unknown): boolean;
    isValidKind(value: unknown): boolean;
    isValidEntityName(value: unknown): boolean;
    isValidNamespace(value: unknown): boolean;
    isValidLabelKey(value: unknown): boolean;
    isValidLabelValue(value: unknown): boolean;
    isValidAnnotationKey(value: unknown): boolean;
    isValidAnnotationValue(value: unknown): boolean;
    isValidTag(value: unknown): boolean;
};

/**
 * Creates a {@link Validators} object from `overrides`, with default values taken from {@link KubernetesValidatorFunctions}
 *
 * @public
 */
declare function makeValidator(overrides?: Partial<Validators>): Validators;

/**
 * Ensures that the format of individual fields of the entity envelope
 * is valid.
 *
 * @remarks
 *
 * This does not take into account machine generated fields such as uid and etag.
 *
 * @public
 */
declare class FieldFormatEntityPolicy implements EntityPolicy {
    private readonly validators;
    constructor(validators?: Validators);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that there are no foreign root fields in the entity.
 *
 * @public
 */
declare class NoForeignRootFieldsEntityPolicy implements EntityPolicy {
    private readonly knownFields;
    constructor(knownFields?: string[]);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that the entity spec is valid according to a schema.
 *
 * @remarks
 *
 * This should be the first policy in the list, to ensure that other downstream
 * policies can work with a structure that is at least valid in therms of the
 * typescript type.
 *
 * @public
 */
declare class SchemaValidEntityPolicy implements EntityPolicy {
    private validate;
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * All parts of a complete entity ref, forming a full kind-namespace-name
 * triplet.
 *
 * @public
 */
type CompoundEntityRef = {
    kind: string;
    namespace: string;
    name: string;
};

/**
 * Extracts the kind, namespace and name that form the compound entity ref
 * triplet of the given entity.
 *
 * @public
 * @param entity - An entity
 * @returns The compound entity ref
 */
declare function getCompoundEntityRef(entity: Entity): CompoundEntityRef;
/**
 * Parses an entity reference, either on string or compound form, and returns
 * a structure with a name, and optional kind and namespace.
 *
 * @remarks
 *
 * The context object can contain default values for the kind and namespace,
 * that will be used if the input reference did not specify any.
 *
 * @public
 * @param ref - The reference to parse
 * @param context - The context of defaults that the parsing happens within
 * @returns The compound form of the reference
 */
declare function parseEntityRef(ref: string | {
    kind?: string;
    namespace?: string;
    name: string;
}, context?: {
    /** The default kind, if none is given in the reference */
    defaultKind?: string;
    /** The default namespace, if none is given in the reference */
    defaultNamespace?: string;
}): CompoundEntityRef;
/**
 * Takes an entity or entity name/reference, and returns the string form of an
 * entity ref.
 *
 * @remarks
 *
 * This function creates a canonical and unique reference to the entity, converting
 * all parts of the name to lowercase and inserts the default namespace if needed.
 * It is typically not the best way to represent the entity reference to the user.
 *
 * @public
 * @param ref - The reference to serialize
 * @returns The same reference on either string or compound form
 */
declare function stringifyEntityRef(ref: Entity | {
    kind: string;
    namespace?: string;
    name: string;
}): string;

/**
 * Provides helpers for enforcing a set of {@link EntityPolicy} in an `and`/`or` expression.
 *
 * @public
 */
declare const EntityPolicies: {
    allOf(policies: EntityPolicy[]): EntityPolicy;
    oneOf(policies: EntityPolicy[]): EntityPolicy;
};

/**
 * Entity annotation containing the location from which the entity is sourced.
 *
 * @public
 */
declare const ANNOTATION_LOCATION = "backstage.io/managed-by-location";
/**
 * Entity annotation containing the originally sourced location which ultimately
 * led to this entity being ingested.
 *
 * @public
 */
declare const ANNOTATION_ORIGIN_LOCATION = "backstage.io/managed-by-origin-location";
/**
 * Entity annotation pointing to the source (e.g. source code repository root or
 * similar) for this entity.
 *
 * @public
 */
declare const ANNOTATION_SOURCE_LOCATION = "backstage.io/source-location";

/**
 * Parses a string form location reference.
 *
 * @public
 * @param ref - A string-form location ref, e.g. `'url:https://host'`
 * @returns A location ref, e.g. `{ type: 'url', target: 'https://host' }`
 */
declare function parseLocationRef(ref: string): {
    type: string;
    target: string;
};
/**
 * Turns a location ref into its string form.
 *
 * @public
 * @param ref - A location ref, e.g. `{ type: 'url', target: 'https://host' }`
 * @returns A string-form location ref, e.g. `'url:https://host'`
 */
declare function stringifyLocationRef(ref: {
    type: string;
    target: string;
}): string;
/**
 * Returns the source code location of the Entity, to the extent that one exists.
 *
 * @remarks
 *
 * If the returned location type is of type 'url', the target should be readable at least
 * using the UrlReader from `@backstage/backend-common`. If it is not of type 'url', the caller
 * needs to have explicit handling of each location type or signal that it is not supported.
 *
 * @public
 */
declare function getEntitySourceLocation(entity: Entity): {
    type: string;
    target: string;
};

export { ANNOTATION_EDIT_URL, ANNOTATION_KUBERNETES_API_SERVER, ANNOTATION_KUBERNETES_API_SERVER_CA, ANNOTATION_KUBERNETES_AUTH_PROVIDER, ANNOTATION_LOCATION, ANNOTATION_ORIGIN_LOCATION, ANNOTATION_SOURCE_LOCATION, ANNOTATION_VIEW_URL, type ApiEntityV1alpha1 as ApiEntity, type ApiEntityV1alpha1, CommonValidatorFunctions, type ComponentEntityV1alpha1 as ComponentEntity, type ComponentEntityV1alpha1, type CompoundEntityRef, DEFAULT_NAMESPACE, DefaultNamespaceEntityPolicy, type DomainEntityV1alpha1 as DomainEntity, type DomainEntityV1alpha1, type Entity, type EntityEnvelope, type EntityLink, type EntityMeta, EntityPolicies, type EntityPolicy, type EntityRelation, FieldFormatEntityPolicy, GroupDefaultParentEntityPolicy, type GroupEntityV1alpha1 as GroupEntity, type GroupEntityV1alpha1, type KindValidator, KubernetesValidatorFunctions, type LocationEntityV1alpha1 as LocationEntity, type LocationEntityV1alpha1, NoForeignRootFieldsEntityPolicy, RELATION_API_CONSUMED_BY, RELATION_API_PROVIDED_BY, RELATION_CHILD_OF, RELATION_CONSUMES_API, RELATION_DEPENDENCY_OF, RELATION_DEPENDS_ON, RELATION_HAS_MEMBER, RELATION_HAS_PART, RELATION_MEMBER_OF, RELATION_OWNED_BY, RELATION_OWNER_OF, RELATION_PARENT_OF, RELATION_PART_OF, RELATION_PROVIDES_API, type ResourceEntityV1alpha1 as ResourceEntity, type ResourceEntityV1alpha1, SchemaValidEntityPolicy, type SystemEntityV1alpha1 as SystemEntity, type SystemEntityV1alpha1, type UserEntityV1alpha1 as UserEntity, type UserEntityV1alpha1, type Validators, apiEntityV1alpha1Validator, componentEntityV1alpha1Validator, domainEntityV1alpha1Validator, entityEnvelopeSchemaValidator, entityKindSchemaValidator, entitySchemaValidator, getCompoundEntityRef, getEntitySourceLocation, groupEntityV1alpha1Validator, isApiEntity, isComponentEntity, isDomainEntity, isGroupEntity, isLocationEntity, isResourceEntity, isSystemEntity, isUserEntity, locationEntityV1alpha1Validator, makeValidator, parseEntityRef, parseLocationRef, resourceEntityV1alpha1Validator, stringifyEntityRef, stringifyLocationRef, systemEntityV1alpha1Validator, userEntityV1alpha1Validator };
