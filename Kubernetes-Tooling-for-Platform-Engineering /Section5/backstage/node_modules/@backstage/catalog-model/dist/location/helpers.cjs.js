'use strict';

require('lodash');
var ref = require('../entity/ref.cjs.js');
require('ajv');
require('../validation/makeValidator.cjs.js');
var annotation = require('./annotation.cjs.js');

const scriptProtocolPattern = (
  // eslint-disable-next-line no-control-regex
  /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
);
function parseLocationRef(ref) {
  if (typeof ref !== "string") {
    throw new TypeError(
      `Unable to parse location ref '${ref}', unexpected argument ${typeof ref}`
    );
  }
  const splitIndex = ref.indexOf(":");
  if (splitIndex < 0) {
    throw new TypeError(
      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`
    );
  }
  const type = ref.substring(0, splitIndex).trim();
  const target = ref.substring(splitIndex + 1).trim();
  if (!type || !target) {
    throw new TypeError(
      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`
    );
  }
  if (type === "http" || type === "https") {
    throw new TypeError(
      `Invalid location ref '${ref}', please prefix it with 'url:', e.g. 'url:${ref}'`
    );
  }
  if (scriptProtocolPattern.test(target)) {
    throw new TypeError(
      `Invalid location ref '${ref}', target is a javascript: URL`
    );
  }
  return { type, target };
}
function stringifyLocationRef(ref) {
  const { type, target } = ref;
  if (!type) {
    throw new TypeError(`Unable to stringify location ref, empty type`);
  } else if (!target) {
    throw new TypeError(`Unable to stringify location ref, empty target`);
  }
  if (scriptProtocolPattern.test(target)) {
    throw new TypeError(
      `Invalid location ref '${type}:${target}', target is a javascript: URL`
    );
  }
  return `${type}:${target}`;
}
function getEntitySourceLocation(entity) {
  const locationRef = entity.metadata?.annotations?.[annotation.ANNOTATION_SOURCE_LOCATION] ?? entity.metadata?.annotations?.[annotation.ANNOTATION_LOCATION];
  if (!locationRef) {
    throw new Error(
      `Entity '${ref.stringifyEntityRef(entity)}' is missing location`
    );
  }
  return parseLocationRef(locationRef);
}

exports.getEntitySourceLocation = getEntitySourceLocation;
exports.parseLocationRef = parseLocationRef;
exports.stringifyLocationRef = stringifyLocationRef;
//# sourceMappingURL=helpers.cjs.js.map
