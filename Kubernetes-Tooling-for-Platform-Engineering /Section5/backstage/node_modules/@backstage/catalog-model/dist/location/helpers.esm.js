import 'lodash';
import { stringifyEntityRef } from '../entity/ref.esm.js';
import 'ajv';
import '../validation/makeValidator.esm.js';
import { ANNOTATION_SOURCE_LOCATION, ANNOTATION_LOCATION } from './annotation.esm.js';

const scriptProtocolPattern = (
  // eslint-disable-next-line no-control-regex
  /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
);
function parseLocationRef(ref) {
  if (typeof ref !== "string") {
    throw new TypeError(
      `Unable to parse location ref '${ref}', unexpected argument ${typeof ref}`
    );
  }
  const splitIndex = ref.indexOf(":");
  if (splitIndex < 0) {
    throw new TypeError(
      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`
    );
  }
  const type = ref.substring(0, splitIndex).trim();
  const target = ref.substring(splitIndex + 1).trim();
  if (!type || !target) {
    throw new TypeError(
      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`
    );
  }
  if (type === "http" || type === "https") {
    throw new TypeError(
      `Invalid location ref '${ref}', please prefix it with 'url:', e.g. 'url:${ref}'`
    );
  }
  if (scriptProtocolPattern.test(target)) {
    throw new TypeError(
      `Invalid location ref '${ref}', target is a javascript: URL`
    );
  }
  return { type, target };
}
function stringifyLocationRef(ref) {
  const { type, target } = ref;
  if (!type) {
    throw new TypeError(`Unable to stringify location ref, empty type`);
  } else if (!target) {
    throw new TypeError(`Unable to stringify location ref, empty target`);
  }
  if (scriptProtocolPattern.test(target)) {
    throw new TypeError(
      `Invalid location ref '${type}:${target}', target is a javascript: URL`
    );
  }
  return `${type}:${target}`;
}
function getEntitySourceLocation(entity) {
  const locationRef = entity.metadata?.annotations?.[ANNOTATION_SOURCE_LOCATION] ?? entity.metadata?.annotations?.[ANNOTATION_LOCATION];
  if (!locationRef) {
    throw new Error(
      `Entity '${stringifyEntityRef(entity)}' is missing location`
    );
  }
  return parseLocationRef(locationRef);
}

export { getEntitySourceLocation, parseLocationRef, stringifyLocationRef };
//# sourceMappingURL=helpers.esm.js.map
