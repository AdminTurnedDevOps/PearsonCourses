'use strict';

var Ajv = require('ajv');
var Entity_schema = require('../schema/Entity.schema.json.cjs.js');
var EntityEnvelope_schema = require('../schema/EntityEnvelope.schema.json.cjs.js');
var EntityMeta_schema = require('../schema/EntityMeta.schema.json.cjs.js');
var common_schema = require('../schema/shared/common.schema.json.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultCompat(Ajv);

const compiledSchemaCache = /* @__PURE__ */ new Map();
const refDependencyCandidates = [
  EntityEnvelope_schema.default,
  Entity_schema.default,
  EntityMeta_schema.default,
  common_schema.default
];
function throwAjvError(errors) {
  if (!errors?.length) {
    throw new TypeError("Unknown error");
  }
  const error = errors[0];
  throw new TypeError(
    `${error.instancePath || "<root>"} ${error.message}${error.params ? ` - ${Object.entries(error.params).map(([key, val]) => `${key}: ${val}`).join(", ")}` : ""}`
  );
}
function compileAjvSchema(schema, options = {}) {
  const disableCache = options?.disableCache ?? false;
  const cacheKey = disableCache ? "" : JSON.stringify(schema);
  if (!disableCache) {
    const cached = compiledSchemaCache.get(cacheKey);
    if (cached) {
      return cached;
    }
  }
  const extraSchemas = getExtraSchemas(schema);
  const ajv = new Ajv__default.default({
    allowUnionTypes: true,
    allErrors: true,
    validateSchema: true
  });
  if (extraSchemas.length) {
    ajv.addSchema(extraSchemas, void 0, void 0, true);
  }
  const compiled = ajv.compile(schema);
  if (!disableCache) {
    compiledSchemaCache.set(cacheKey, compiled);
  }
  return compiled;
}
function getExtraSchemas(schema) {
  if (typeof schema !== "object") {
    return [];
  }
  const seen = /* @__PURE__ */ new Set();
  if (schema.$id) {
    seen.add(schema.$id);
  }
  const selected = new Array();
  const todo = [schema];
  while (todo.length) {
    const current = todo.pop();
    for (const ref of getAllRefs(current)) {
      if (!seen.has(ref)) {
        seen.add(ref);
        const match = refDependencyCandidates.find((c) => c.$id === ref);
        if (match) {
          selected.push(match);
          todo.push(match);
        }
      }
    }
  }
  return selected;
}
function* getAllRefs(schema) {
  const todo = [schema];
  while (todo.length) {
    const current = todo.pop();
    if (typeof current === "object" && current) {
      for (const [key, value] of Object.entries(current)) {
        if (key === "$ref" && typeof value === "string") {
          yield value.split("#")[0];
        } else {
          todo.push(value);
        }
      }
    }
  }
}

exports.compileAjvSchema = compileAjvSchema;
exports.throwAjvError = throwAjvError;
//# sourceMappingURL=ajv.cjs.js.map
