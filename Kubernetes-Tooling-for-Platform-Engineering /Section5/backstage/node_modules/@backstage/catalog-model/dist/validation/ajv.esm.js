import Ajv from 'ajv';
import entitySchema from '../schema/Entity.schema.json.esm.js';
import entityEnvelopeSchema from '../schema/EntityEnvelope.schema.json.esm.js';
import entityMetaSchema from '../schema/EntityMeta.schema.json.esm.js';
import commonSchema from '../schema/shared/common.schema.json.esm.js';

const compiledSchemaCache = /* @__PURE__ */ new Map();
const refDependencyCandidates = [
  entityEnvelopeSchema,
  entitySchema,
  entityMetaSchema,
  commonSchema
];
function throwAjvError(errors) {
  if (!errors?.length) {
    throw new TypeError("Unknown error");
  }
  const error = errors[0];
  throw new TypeError(
    `${error.instancePath || "<root>"} ${error.message}${error.params ? ` - ${Object.entries(error.params).map(([key, val]) => `${key}: ${val}`).join(", ")}` : ""}`
  );
}
function compileAjvSchema(schema, options = {}) {
  const disableCache = options?.disableCache ?? false;
  const cacheKey = disableCache ? "" : JSON.stringify(schema);
  if (!disableCache) {
    const cached = compiledSchemaCache.get(cacheKey);
    if (cached) {
      return cached;
    }
  }
  const extraSchemas = getExtraSchemas(schema);
  const ajv = new Ajv({
    allowUnionTypes: true,
    allErrors: true,
    validateSchema: true
  });
  if (extraSchemas.length) {
    ajv.addSchema(extraSchemas, void 0, void 0, true);
  }
  const compiled = ajv.compile(schema);
  if (!disableCache) {
    compiledSchemaCache.set(cacheKey, compiled);
  }
  return compiled;
}
function getExtraSchemas(schema) {
  if (typeof schema !== "object") {
    return [];
  }
  const seen = /* @__PURE__ */ new Set();
  if (schema.$id) {
    seen.add(schema.$id);
  }
  const selected = new Array();
  const todo = [schema];
  while (todo.length) {
    const current = todo.pop();
    for (const ref of getAllRefs(current)) {
      if (!seen.has(ref)) {
        seen.add(ref);
        const match = refDependencyCandidates.find((c) => c.$id === ref);
        if (match) {
          selected.push(match);
          todo.push(match);
        }
      }
    }
  }
  return selected;
}
function* getAllRefs(schema) {
  const todo = [schema];
  while (todo.length) {
    const current = todo.pop();
    if (typeof current === "object" && current) {
      for (const [key, value] of Object.entries(current)) {
        if (key === "$ref" && typeof value === "string") {
          yield value.split("#")[0];
        } else {
          todo.push(value);
        }
      }
    }
  }
}

export { compileAjvSchema, throwAjvError };
//# sourceMappingURL=ajv.esm.js.map
