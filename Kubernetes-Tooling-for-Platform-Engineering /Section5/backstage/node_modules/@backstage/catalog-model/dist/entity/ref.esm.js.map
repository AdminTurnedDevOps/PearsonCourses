{"version":3,"file":"ref.esm.js","sources":["../../src/entity/ref.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DEFAULT_NAMESPACE } from './constants';\nimport { CompoundEntityRef } from '../types';\nimport { Entity } from './Entity';\n\nfunction parseRefString(ref: string): {\n  kind?: string;\n  namespace?: string;\n  name: string;\n} {\n  let colonI = ref.indexOf(':');\n  const slashI = ref.indexOf('/');\n\n  // If the / is ahead of the :, treat the rest as the name\n  if (slashI !== -1 && slashI < colonI) {\n    colonI = -1;\n  }\n\n  const kind = colonI === -1 ? undefined : ref.slice(0, colonI);\n  const namespace = slashI === -1 ? undefined : ref.slice(colonI + 1, slashI);\n  const name = ref.slice(Math.max(colonI + 1, slashI + 1));\n\n  if (kind === '' || namespace === '' || name === '') {\n    throw new TypeError(\n      `Entity reference \"${ref}\" was not on the form [<kind>:][<namespace>/]<name>`,\n    );\n  }\n\n  return { kind, namespace, name };\n}\n\n/**\n * Extracts the kind, namespace and name that form the compound entity ref\n * triplet of the given entity.\n *\n * @public\n * @param entity - An entity\n * @returns The compound entity ref\n */\nexport function getCompoundEntityRef(entity: Entity): CompoundEntityRef {\n  return {\n    kind: entity.kind,\n    namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,\n    name: entity.metadata.name,\n  };\n}\n\n/**\n * Parses an entity reference, either on string or compound form, and returns\n * a structure with a name, and optional kind and namespace.\n *\n * @remarks\n *\n * The context object can contain default values for the kind and namespace,\n * that will be used if the input reference did not specify any.\n *\n * @public\n * @param ref - The reference to parse\n * @param context - The context of defaults that the parsing happens within\n * @returns The compound form of the reference\n */\nexport function parseEntityRef(\n  ref: string | { kind?: string; namespace?: string; name: string },\n  context?: {\n    /** The default kind, if none is given in the reference */\n    defaultKind?: string;\n    /** The default namespace, if none is given in the reference */\n    defaultNamespace?: string;\n  },\n): CompoundEntityRef {\n  if (!ref) {\n    throw new Error(`Entity reference must not be empty`);\n  }\n\n  const defaultKind = context?.defaultKind;\n  const defaultNamespace = context?.defaultNamespace || DEFAULT_NAMESPACE;\n\n  let kind: string | undefined;\n  let namespace: string | undefined;\n  let name: string | undefined;\n\n  if (typeof ref === 'string') {\n    const parsed = parseRefString(ref);\n    kind = parsed.kind ?? defaultKind;\n    namespace = parsed.namespace ?? defaultNamespace;\n    name = parsed.name;\n  } else {\n    kind = ref.kind ?? defaultKind;\n    namespace = ref.namespace ?? defaultNamespace;\n    name = ref.name;\n  }\n\n  if (!kind) {\n    const textual = JSON.stringify(ref);\n    throw new Error(\n      `Entity reference ${textual} had missing or empty kind (e.g. did not start with \"component:\" or similar)`,\n    );\n  } else if (!namespace) {\n    const textual = JSON.stringify(ref);\n    throw new Error(\n      `Entity reference ${textual} had missing or empty namespace`,\n    );\n  } else if (!name) {\n    const textual = JSON.stringify(ref);\n    throw new Error(`Entity reference ${textual} had missing or empty name`);\n  }\n\n  return { kind, namespace, name };\n}\n\n/**\n * Takes an entity or entity name/reference, and returns the string form of an\n * entity ref.\n *\n * @remarks\n *\n * This function creates a canonical and unique reference to the entity, converting\n * all parts of the name to lowercase and inserts the default namespace if needed.\n * It is typically not the best way to represent the entity reference to the user.\n *\n * @public\n * @param ref - The reference to serialize\n * @returns The same reference on either string or compound form\n */\nexport function stringifyEntityRef(\n  ref: Entity | { kind: string; namespace?: string; name: string },\n): string {\n  let kind;\n  let namespace;\n  let name;\n\n  if ('metadata' in ref) {\n    kind = ref.kind;\n    namespace = ref.metadata.namespace ?? DEFAULT_NAMESPACE;\n    name = ref.metadata.name;\n  } else {\n    kind = ref.kind;\n    namespace = ref.namespace ?? DEFAULT_NAMESPACE;\n    name = ref.name;\n  }\n\n  return `${kind.toLocaleLowerCase('en-US')}:${namespace.toLocaleLowerCase(\n    'en-US',\n  )}/${name.toLocaleLowerCase('en-US')}`;\n}\n"],"names":[],"mappings":"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"}