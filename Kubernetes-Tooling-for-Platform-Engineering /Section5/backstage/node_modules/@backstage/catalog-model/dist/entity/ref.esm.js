import { DEFAULT_NAMESPACE } from './constants.esm.js';

function parseRefString(ref) {
  let colonI = ref.indexOf(":");
  const slashI = ref.indexOf("/");
  if (slashI !== -1 && slashI < colonI) {
    colonI = -1;
  }
  const kind = colonI === -1 ? void 0 : ref.slice(0, colonI);
  const namespace = slashI === -1 ? void 0 : ref.slice(colonI + 1, slashI);
  const name = ref.slice(Math.max(colonI + 1, slashI + 1));
  if (kind === "" || namespace === "" || name === "") {
    throw new TypeError(
      `Entity reference "${ref}" was not on the form [<kind>:][<namespace>/]<name>`
    );
  }
  return { kind, namespace, name };
}
function getCompoundEntityRef(entity) {
  return {
    kind: entity.kind,
    namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
    name: entity.metadata.name
  };
}
function parseEntityRef(ref, context) {
  if (!ref) {
    throw new Error(`Entity reference must not be empty`);
  }
  const defaultKind = context?.defaultKind;
  const defaultNamespace = context?.defaultNamespace || DEFAULT_NAMESPACE;
  let kind;
  let namespace;
  let name;
  if (typeof ref === "string") {
    const parsed = parseRefString(ref);
    kind = parsed.kind ?? defaultKind;
    namespace = parsed.namespace ?? defaultNamespace;
    name = parsed.name;
  } else {
    kind = ref.kind ?? defaultKind;
    namespace = ref.namespace ?? defaultNamespace;
    name = ref.name;
  }
  if (!kind) {
    const textual = JSON.stringify(ref);
    throw new Error(
      `Entity reference ${textual} had missing or empty kind (e.g. did not start with "component:" or similar)`
    );
  } else if (!namespace) {
    const textual = JSON.stringify(ref);
    throw new Error(
      `Entity reference ${textual} had missing or empty namespace`
    );
  } else if (!name) {
    const textual = JSON.stringify(ref);
    throw new Error(`Entity reference ${textual} had missing or empty name`);
  }
  return { kind, namespace, name };
}
function stringifyEntityRef(ref) {
  let kind;
  let namespace;
  let name;
  if ("metadata" in ref) {
    kind = ref.kind;
    namespace = ref.metadata.namespace ?? DEFAULT_NAMESPACE;
    name = ref.metadata.name;
  } else {
    kind = ref.kind;
    namespace = ref.namespace ?? DEFAULT_NAMESPACE;
    name = ref.name;
  }
  return `${kind.toLocaleLowerCase("en-US")}:${namespace.toLocaleLowerCase(
    "en-US"
  )}/${name.toLocaleLowerCase("en-US")}`;
}

export { getCompoundEntityRef, parseEntityRef, stringifyEntityRef };
//# sourceMappingURL=ref.esm.js.map
