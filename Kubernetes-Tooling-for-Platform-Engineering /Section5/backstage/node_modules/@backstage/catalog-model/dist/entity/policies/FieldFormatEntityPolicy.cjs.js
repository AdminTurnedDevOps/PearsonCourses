'use strict';

var CommonValidatorFunctions = require('../../validation/CommonValidatorFunctions.cjs.js');
require('ajv');
var KubernetesValidatorFunctions = require('../../validation/KubernetesValidatorFunctions.cjs.js');
var makeValidator = require('../../validation/makeValidator.cjs.js');

class FieldFormatEntityPolicy {
  validators;
  constructor(validators = makeValidator.makeValidator()) {
    this.validators = validators;
  }
  async enforce(entity) {
    function require(field, value, validator) {
      if (value === void 0 || value === null) {
        throw new Error(`${field} must have a value`);
      }
      let isValid;
      try {
        isValid = validator(value);
      } catch (e) {
        throw new Error(`${field} could not be validated, ${e}`);
      }
      if (!isValid) {
        let expectation;
        switch (validator.name) {
          case "isValidLabelValue":
          case "isValidObjectName":
            expectation = "a string that is sequences of [a-zA-Z0-9] separated by any of [-_.], at most 63 characters in total";
            break;
          case "isValidLabelKey":
          case "isValidApiVersion":
          case "isValidAnnotationKey":
            expectation = "a valid prefix and/or suffix";
            break;
          case "isValidNamespace":
          case "isValidDnsLabel":
            expectation = "a string that is sequences of [a-z0-9] separated by [-], at most 63 characters in total";
            break;
          case "isValidTag":
            expectation = "a string that is sequences of [a-z0-9+#] separated by [-], at most 63 characters in total";
            break;
          case "isValidAnnotationValue":
            expectation = "a string";
            break;
          case "isValidKind":
            expectation = "a string that is a sequence of [a-zA-Z][a-z0-9A-Z], at most 63 characters in total";
            break;
          case "isValidUrl":
            expectation = "a string that is a valid url";
            break;
          case "isValidString":
          case "isNonEmptyString":
            expectation = "a non empty string";
            break;
          default:
            expectation = void 0;
            break;
        }
        const message = expectation ? ` expected ${expectation} but found "${value}".` : "";
        throw new Error(
          `"${field}" is not valid;${message} To learn more about catalog file format, visit: https://github.com/backstage/backstage/blob/master/docs/architecture-decisions/adr002-default-catalog-file-format.md`
        );
      }
    }
    function optional(field, value, validator) {
      return value === void 0 || require(field, value, validator);
    }
    require("apiVersion", entity.apiVersion, this.validators.isValidApiVersion);
    require("kind", entity.kind, this.validators.isValidKind);
    require("metadata.name", entity.metadata.name, this.validators.isValidEntityName);
    optional(
      "metadata.namespace",
      entity.metadata.namespace,
      this.validators.isValidNamespace
    );
    for (const [k, v] of Object.entries(entity.metadata.labels ?? [])) {
      require(`labels.${k}`, k, this.validators.isValidLabelKey);
      require(`labels.${k}`, v, this.validators.isValidLabelValue);
    }
    for (const [k, v] of Object.entries(entity.metadata.annotations ?? [])) {
      require(`annotations.${k}`, k, this.validators.isValidAnnotationKey);
      require(`annotations.${k}`, v, this.validators.isValidAnnotationValue);
    }
    const tags = entity.metadata.tags ?? [];
    for (let i = 0; i < tags.length; ++i) {
      require(`tags.${i}`, tags[i], this.validators.isValidTag);
    }
    const links = entity.metadata.links ?? [];
    for (let i = 0; i < links.length; ++i) {
      require(`links.${i}.url`, links[i]?.url, CommonValidatorFunctions.CommonValidatorFunctions.isValidUrl);
      optional(
        `links.${i}.title`,
        links[i]?.title,
        CommonValidatorFunctions.CommonValidatorFunctions.isNonEmptyString
      );
      optional(
        `links.${i}.icon`,
        links[i]?.icon,
        KubernetesValidatorFunctions.KubernetesValidatorFunctions.isValidObjectName
      );
    }
    return entity;
  }
}

exports.FieldFormatEntityPolicy = FieldFormatEntityPolicy;
//# sourceMappingURL=FieldFormatEntityPolicy.cjs.js.map
