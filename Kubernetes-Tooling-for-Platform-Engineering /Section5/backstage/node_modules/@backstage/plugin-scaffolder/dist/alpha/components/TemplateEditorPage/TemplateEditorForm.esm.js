import { useApiHolder } from '@backstage/core-plugin-api';
import { makeStyles } from '@material-ui/core/styles';
import Paper from '@material-ui/core/Paper';
import Typography from '@material-ui/core/Typography';
import React, { useState, useMemo, Component } from 'react';
import useDebounce from 'react-use/esm/useDebounce';
import yaml from 'yaml';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { createAsyncValidators, Stepper } from '@backstage/plugin-scaffolder-react/alpha';
import { useDryRun } from './DryRunContext.esm.js';
import { useDirectoryEditor } from './DirectoryEditorContext.esm.js';
import { scaffolderTranslationRef } from '../../../translation.esm.js';

const useStyles = makeStyles({
  containerWrapper: {
    width: "100%"
  }
});
class ErrorBoundary extends Component {
  state = {
    shouldRender: true
  };
  componentDidUpdate(prevProps) {
    if (prevProps.invalidator !== this.props.invalidator) {
      this.setState({ shouldRender: true });
    }
  }
  componentDidCatch(error) {
    this.props.setErrorText(error.message);
    this.setState({ shouldRender: false });
  }
  render() {
    return this.state.shouldRender ? this.props.children : null;
  }
}
function isJsonObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function TemplateEditorForm(props) {
  const {
    content,
    contentIsSpec,
    onDryRun,
    setErrorText,
    fieldExtensions = [],
    layouts = []
  } = props;
  const classes = useStyles();
  const apiHolder = useApiHolder();
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const [steps, setSteps] = useState();
  const fields = useMemo(() => {
    return Object.fromEntries(
      fieldExtensions.map(({ name, component }) => [name, component])
    );
  }, [fieldExtensions]);
  useDebounce(
    () => {
      try {
        if (!content) {
          setSteps(void 0);
          return;
        }
        const parsed = yaml.parseAllDocuments(content).filter((c) => c).map((c) => c.toJSON())[0];
        if (!isJsonObject(parsed)) {
          setSteps(void 0);
          return;
        }
        let rootObj = parsed;
        if (!contentIsSpec) {
          const isTemplate = String(parsed.kind).toLocaleLowerCase("en-US") === "template";
          if (!isTemplate) {
            setSteps(void 0);
            return;
          }
          rootObj = isJsonObject(parsed.spec) ? parsed.spec : {};
        }
        const { parameters } = rootObj;
        if (!Array.isArray(parameters)) {
          setErrorText("Template parameters must be an array");
          setSteps(void 0);
          return;
        }
        const fieldValidators = Object.fromEntries(
          fieldExtensions.map(({ name, validation }) => [name, validation])
        );
        setErrorText();
        setSteps(
          parameters.flatMap(
            (param) => isJsonObject(param) ? [
              {
                title: String(param.title),
                schema: param,
                validate: createAsyncValidators(param, fieldValidators, {
                  apiHolder
                })
              }
            ] : []
          )
        );
      } catch (e) {
        setErrorText(e.message);
      }
    },
    250,
    [contentIsSpec, content, apiHolder]
  );
  return /* @__PURE__ */ React.createElement("div", { className: classes.containerWrapper }, steps ? /* @__PURE__ */ React.createElement(Paper, { variant: "outlined" }, /* @__PURE__ */ React.createElement(ErrorBoundary, { invalidator: steps, setErrorText }, /* @__PURE__ */ React.createElement(
    Stepper,
    {
      manifest: { steps, title: "Template Editor" },
      extensions: fieldExtensions,
      components: fields,
      onCreate: async (options) => {
        await onDryRun?.(options);
      },
      layouts,
      formProps: props.formProps
    }
  ))) : /* @__PURE__ */ React.createElement(Typography, { variant: "body1", color: "textSecondary" }, t("templateEditorForm.stepper.emptyText")));
}
function TemplateEditorFormDirectoryEditorDryRun(props) {
  const { setErrorText, fieldExtensions = [], layouts } = props;
  const dryRun = useDryRun();
  const directoryEditor = useDirectoryEditor();
  const { selectedFile } = directoryEditor ?? {};
  const handleDryRun = async (data) => {
    if (!selectedFile) {
      return;
    }
    try {
      await dryRun.execute({
        templateContent: selectedFile.content,
        values: data,
        files: directoryEditor?.files ?? []
      });
      setErrorText();
    } catch (e) {
      setErrorText(String(e.cause || e));
      throw e;
    }
  };
  const content = selectedFile && selectedFile.path.match(/\.ya?ml$/) ? selectedFile.content : void 0;
  if (!directoryEditor) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      onDryRun: handleDryRun,
      fieldExtensions,
      setErrorText,
      content,
      layouts,
      formProps: props.formProps
    }
  );
}
TemplateEditorForm.DirectoryEditorDryRun = TemplateEditorFormDirectoryEditorDryRun;

export { TemplateEditorForm, TemplateEditorFormDirectoryEditorDryRun };
//# sourceMappingURL=TemplateEditorForm.esm.js.map
