import { ErrorPanel } from '@backstage/core-components';
import { useAsync, useRerender } from '@react-hookz/web';
import React, { createContext, useEffect, useContext } from 'react';

const MAX_SIZE = 1024 * 1024;
const MAX_SIZE_MESSAGE = "This file is too large to be displayed";
class DirectoryEditorFileManager {
  #access;
  #signalUpdate;
  #content;
  #savedContent;
  constructor(access, signalUpdate) {
    this.#access = access;
    this.#signalUpdate = signalUpdate;
  }
  get path() {
    return this.#access.path;
  }
  get content() {
    return this.#content ?? MAX_SIZE_MESSAGE;
  }
  updateContent(content) {
    if (this.#content === void 0) {
      return;
    }
    this.#content = content;
    this.#signalUpdate();
  }
  get dirty() {
    return this.#content !== this.#savedContent;
  }
  async save() {
    if (this.#content !== void 0) {
      await this.#access.save(this.#content);
      this.#savedContent = this.#content;
      this.#signalUpdate();
    }
  }
  async reload() {
    const file = await this.#access.file();
    if (file.size > MAX_SIZE) {
      if (this.#content !== void 0) {
        this.#content = void 0;
        this.#savedContent = void 0;
        this.#signalUpdate();
      }
      return;
    }
    const content = await file.text();
    if (this.#content !== content) {
      this.#content = content;
      this.#savedContent = content;
      this.#signalUpdate();
    }
  }
}
class DirectoryEditorManager {
  #access;
  #listeners = /* @__PURE__ */ new Set();
  #files = [];
  #selectedFile;
  constructor(access) {
    this.#access = access;
  }
  get files() {
    return this.#files;
  }
  get selectedFile() {
    return this.#selectedFile;
  }
  setSelectedFile = (path) => {
    const prev = this.#selectedFile;
    const next = this.#files.find((file) => file.path === path);
    if (prev !== next) {
      this.#selectedFile = next;
      this.#signalUpdate();
    }
  };
  get dirty() {
    return this.#files.some((file) => file.dirty);
  }
  async save() {
    await Promise.all(this.#files.map((file) => file.save()));
  }
  async reload() {
    const selectedPath = this.#selectedFile?.path;
    const files = await this.#access.listFiles();
    const fileManagers = await Promise.all(
      files.map(async (file) => {
        const manager = new DirectoryEditorFileManager(
          file,
          this.#signalUpdate
        );
        await manager.reload();
        return manager;
      })
    );
    this.#files.length = 0;
    this.#files.push(...fileManagers);
    this.setSelectedFile(selectedPath);
    this.#signalUpdate();
  }
  subscribe(listener) {
    this.#listeners.add(listener);
    return () => {
      this.#listeners.delete(listener);
    };
  }
  #signalUpdate = () => {
    this.#listeners.forEach((listener) => listener());
  };
}
const DirectoryEditorContext = createContext(
  void 0
);
function useDirectoryEditor() {
  const value = useContext(DirectoryEditorContext);
  const rerender = useRerender();
  useEffect(() => value?.subscribe(rerender), [value, rerender]);
  return value;
}
function DirectoryEditorProvider(props) {
  const { directory } = props;
  const [{ result, error }, { execute }] = useAsync(
    async (dir) => {
      if (!dir) {
        return void 0;
      }
      const manager = new DirectoryEditorManager(dir);
      await manager.reload();
      const firstYaml = manager.files.find((file) => file.path.match(/\.ya?ml$/));
      if (firstYaml) {
        manager.setSelectedFile(firstYaml.path);
      }
      return manager;
    }
  );
  useEffect(() => {
    execute(directory);
  }, [execute, directory]);
  if (error) {
    return /* @__PURE__ */ React.createElement(ErrorPanel, { error });
  }
  return /* @__PURE__ */ React.createElement(DirectoryEditorContext.Provider, { value: result }, props.children);
}

export { DirectoryEditorProvider, useDirectoryEditor };
//# sourceMappingURL=DirectoryEditorContext.esm.js.map
