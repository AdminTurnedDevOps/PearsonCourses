import { parseEntityRef } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import { fetchEventSource } from '@microsoft/fetch-event-source';
import qs from 'qs';
import ObservableImpl from 'zen-observable';

class ScaffolderClient {
  discoveryApi;
  scmIntegrationsApi;
  fetchApi;
  identityApi;
  useLongPollingLogs;
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi ?? { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = options.useLongPollingLogs ?? false;
    this.identityApi = options.identityApi;
  }
  async listTasks(options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const query = qs.stringify({
      createdBy: options.filterByOwnership === "owned" ? userEntityRef : void 0,
      limit: options.limit,
      offset: options.offset
    });
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/tasks?${query}`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.gitea.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  async getTemplateParameterSchema(templateRef) {
    const { namespace, kind, name } = parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(options) {
    const { templateRef, values, secrets = {} } = options;
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        templateRef,
        values: { ...values },
        secrets
      })
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  async getTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs(options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(options);
    }
    return this.streamLogsEventStream(options);
  }
  async dryRun(options) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/dry-run`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        template: options.template,
        values: options.values,
        secrets: options.secrets,
        directoryContents: options.directoryContents
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  streamLogsEventStream({
    isTaskRecoverable,
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      this.discoveryApi.getBaseUrl("scaffolder").then(
        (baseUrl) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const ctrl = new AbortController();
          void fetchEventSource(url, {
            fetch: this.fetchApi.fetch,
            signal: ctrl.signal,
            onmessage(e) {
              if (e.event === "log") {
                processEvent(e);
                return;
              } else if (e.event === "completion" && !isTaskRecoverable) {
                processEvent(e);
                subscriber.complete();
                ctrl.abort();
                return;
              }
              processEvent(e);
            },
            onerror(err) {
              subscriber.error(err);
            }
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      this.discoveryApi.getBaseUrl("scaffolder").then(async (baseUrl) => {
        while (!subscriber.closed) {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/events?${qs.stringify({ after })}`;
          const response = await this.fetchApi.fetch(url);
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async cancelTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/cancel`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async retry(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/retry`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async autocomplete({
    token,
    resource,
    provider,
    context
  }) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/autocomplete/${provider}/${resource}`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        token,
        context: context ?? {}
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const { results } = await response.json();
    return { results };
  }
}

export { ScaffolderClient };
//# sourceMappingURL=api.esm.js.map
