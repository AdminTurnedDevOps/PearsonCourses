import { useApi } from '@backstage/core-plugin-api';
import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import { useTemplateSecrets } from '@backstage/plugin-scaffolder-react';
import Box from '@material-ui/core/Box';
import Divider from '@material-ui/core/Divider';
import Typography from '@material-ui/core/Typography';
import React, { useState, useMemo, useEffect, useCallback } from 'react';
import useDebounce from 'react-use/esm/useDebounce';
import { AzureRepoPicker } from './AzureRepoPicker.esm.js';
import { BitbucketRepoPicker } from './BitbucketRepoPicker.esm.js';
import { GerritRepoPicker } from './GerritRepoPicker.esm.js';
import { GiteaRepoPicker } from './GiteaRepoPicker.esm.js';
import { GithubRepoPicker } from './GithubRepoPicker.esm.js';
import { GitlabRepoPicker } from './GitlabRepoPicker.esm.js';
import { RepoUrlPickerHost } from './RepoUrlPickerHost.esm.js';
import { RepoUrlPickerRepoName } from './RepoUrlPickerRepoName.esm.js';
import { parseRepoPickerUrl, serializeRepoPickerUrl } from './utils.esm.js';
export { RepoUrlPickerSchema } from './schema.esm.js';

const RepoUrlPicker = (props) => {
  const { uiSchema, onChange, rawErrors, formData, schema } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const [credentialsHost, setCredentialsHost] = useState(
    void 0
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { secrets, setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => uiSchema?.["ui:options"]?.allowedHosts ?? [],
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => uiSchema?.["ui:options"]?.allowedOrganizations ?? [],
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => uiSchema?.["ui:options"]?.allowedOwners ?? [],
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => uiSchema?.["ui:options"]?.allowedProjects ?? [],
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => uiSchema?.["ui:options"]?.allowedRepos ?? [],
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      const { requestUserCredentials } = uiSchema?.["ui:options"] ?? {};
      if (!requestUserCredentials || !state.host) {
        return;
      }
      if (secrets[requestUserCredentials.secretsKey] && credentialsHost === state.host) {
        return;
      }
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${state.host}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
      setCredentialsHost(state.host);
    },
    500,
    [state, uiSchema]
  );
  const hostType = (state.host && integrationApi.byHost(state.host)?.type) ?? null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, schema.title && /* @__PURE__ */ React.createElement(Box, { my: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5" }, schema.title), /* @__PURE__ */ React.createElement(Divider, null)), schema.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, schema.description), /* @__PURE__ */ React.createElement(
    RepoUrlPickerHost,
    {
      host: state.host,
      hosts: allowedHosts,
      onChange: (host) => setState((prevState) => ({ ...prevState, host })),
      rawErrors
    }
  ), hostType === "github" && /* @__PURE__ */ React.createElement(
    GithubRepoPicker,
    {
      allowedOwners,
      onChange: updateLocalState,
      rawErrors,
      state
    }
  ), hostType === "gitea" && /* @__PURE__ */ React.createElement(
    GiteaRepoPicker,
    {
      allowedOwners,
      allowedRepos,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gitlab" && /* @__PURE__ */ React.createElement(
    GitlabRepoPicker,
    {
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState,
      accessToken: uiSchema?.["ui:options"]?.requestUserCredentials?.secretsKey && secrets[uiSchema["ui:options"].requestUserCredentials.secretsKey]
    }
  ), hostType === "bitbucket" && /* @__PURE__ */ React.createElement(
    BitbucketRepoPicker,
    {
      allowedOwners,
      allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState,
      accessToken: uiSchema?.["ui:options"]?.requestUserCredentials?.secretsKey && secrets[uiSchema["ui:options"].requestUserCredentials.secretsKey]
    }
  ), hostType === "azure" && /* @__PURE__ */ React.createElement(
    AzureRepoPicker,
    {
      allowedOrganizations,
      allowedProject: allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gerrit" && /* @__PURE__ */ React.createElement(
    GerritRepoPicker,
    {
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), /* @__PURE__ */ React.createElement(
    RepoUrlPickerRepoName,
    {
      repoName: state.repoName,
      allowedRepos,
      onChange: (repo) => setState((prevState) => ({
        ...prevState,
        repoName: repo.name,
        id: repo.id || ""
      })),
      rawErrors,
      availableRepos: state.availableRepos
    }
  ));
};

export { RepoUrlPicker };
//# sourceMappingURL=RepoUrlPicker.esm.js.map
