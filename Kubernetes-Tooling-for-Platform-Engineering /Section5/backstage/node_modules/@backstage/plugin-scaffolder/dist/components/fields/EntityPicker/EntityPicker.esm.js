import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef, entityPresentationApiRef, EntityDisplayName } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
import { VirtualizedListbox } from '../VirtualizedListbox.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../../translation.esm.js';
export { EntityPickerSchema } from './schema.esm.js';

const EntityPicker = (props) => {
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const {
    onChange,
    schema: {
      title = t("fields.entityPicker.title"),
      description = t("fields.entityPicker.description")
    },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = uiSchema["ui:options"]?.defaultKind;
  const defaultNamespace = uiSchema["ui:options"]?.defaultNamespace || void 0;
  const catalogApi = useApi(catalogApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const fields = [
      "metadata.name",
      "metadata.namespace",
      "metadata.title",
      "kind"
    ];
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter, fields } : { filter: void 0, fields }
    );
    const entityRefToPresentation = new Map(
      await Promise.all(
        items.map(async (item) => {
          const presentation = await entityPresentationApi.forEntity(item).promise;
          return [stringifyEntityRef(item), presentation];
        })
      )
    );
    return { catalogEntities: items, entityRefToPresentation };
  });
  const allowArbitraryValues = uiSchema["ui:options"]?.allowArbitraryValues ?? true;
  const getLabel = useCallback(
    (freeSoloValue) => {
      try {
        const parsedRef = parseEntityRef(freeSoloValue, {
          defaultKind,
          defaultNamespace
        });
        return stringifyEntityRef(parsedRef);
      } catch (err) {
        return freeSoloValue;
      }
    },
    [defaultKind, defaultNamespace]
  );
  const onSelect = useCallback(
    (_, ref, reason) => {
      if (typeof ref !== "string") {
        onChange(ref ? stringifyEntityRef(ref) : void 0);
      } else {
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData !== ref || allowArbitraryValues) {
            onChange(entityRef);
          }
        }
      }
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  const selectedEntity = entities?.catalogEntities.find((e) => stringifyEntityRef(e) === formData) ?? (allowArbitraryValues && formData ? getLabel(formData) : "");
  useEffect(() => {
    if (required && !allowArbitraryValues && entities?.catalogEntities.length === 1 && selectedEntity === "") {
      onChange(stringifyEntityRef(entities.catalogEntities[0]));
    }
  }, [entities, onChange, selectedEntity, required, allowArbitraryValues]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: rawErrors?.length > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: required && !allowArbitraryValues && entities?.catalogEntities.length === 1,
        id: idSchema?.$id,
        value: selectedEntity,
        loading,
        onChange: onSelect,
        options: entities?.catalogEntities || [],
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : entities?.entityRefToPresentation.get(stringifyEntityRef(option))?.entityRef
        ),
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        ),
        renderOption: (option) => /* @__PURE__ */ React.createElement(EntityDisplayName, { entityRef: option }),
        filterOptions: createFilterOptions({
          stringify: (option) => entities?.entityRefToPresentation.get(stringifyEntityRef(option))?.primaryTitle
        }),
        ListboxComponent: VirtualizedListbox
      }
    )
  );
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value?.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  const allowedKinds = uiSchema["ui:options"]?.allowedKinds;
  const catalogFilter = uiSchema["ui:options"]?.catalogFilter || allowedKinds && { kind: allowedKinds };
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

export { EntityPicker };
//# sourceMappingURL=EntityPicker.esm.js.map
