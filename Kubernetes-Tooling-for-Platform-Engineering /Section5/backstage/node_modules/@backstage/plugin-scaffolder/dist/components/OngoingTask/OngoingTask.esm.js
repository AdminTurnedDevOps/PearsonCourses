import React, { useMemo, useState, useEffect, useCallback } from 'react';
import { Page, Header, Content, ErrorPanel } from '@backstage/core-components';
import { useParams, useNavigate } from 'react-router-dom';
import Box from '@material-ui/core/Box';
import Button from '@material-ui/core/Button';
import Paper from '@material-ui/core/Paper';
import { makeStyles } from '@material-ui/core/styles';
import { ResizableBox } from 'react-resizable';
import { scaffolderApiRef, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { selectedTemplateRouteRef } from '../../routes.esm.js';
import { useRouteRef, useAnalytics, useApi } from '@backstage/core-plugin-api';
import qs from 'qs';
import { ContextMenu } from './ContextMenu.esm.js';
import { DefaultTemplateOutputs, TaskSteps, TaskLogStream } from '@backstage/plugin-scaffolder-react/alpha';
import { useAsync } from '@react-hookz/web';
import { usePermission } from '@backstage/plugin-permission-react';
import { taskCancelPermission, taskReadPermission, taskCreatePermission } from '@backstage/plugin-scaffolder-common/alpha';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../translation.esm.js';

const useStyles = makeStyles((theme) => ({
  contentWrapper: {
    display: "flex",
    flexDirection: "column"
  },
  buttonBar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "right"
  },
  cancelButton: {
    marginRight: theme.spacing(1)
  },
  retryButton: {
    marginRight: theme.spacing(1)
  },
  logsVisibilityButton: {
    marginRight: theme.spacing(1)
  }
}));
const OngoingTask = (props) => {
  const { taskId } = useParams();
  const templateRouteRef = useRouteRef(selectedTemplateRouteRef);
  const navigate = useNavigate();
  const analytics = useAnalytics();
  const scaffolderApi = useApi(scaffolderApiRef);
  const taskStream = useTaskEventStream(taskId);
  const classes = useStyles();
  const steps = useMemo(
    () => taskStream.task?.spec.steps.map((step) => ({
      ...step,
      ...taskStream?.steps?.[step.id]
    })) ?? [],
    [taskStream]
  );
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const [logsVisible, setLogVisibleState] = useState(false);
  const [buttonBarVisible, setButtonBarVisibleState] = useState(true);
  const { allowed: canCancelTask } = usePermission({
    permission: taskCancelPermission
  });
  const { allowed: canReadTask } = usePermission({
    permission: taskReadPermission
  });
  const { allowed: canCreateTask } = usePermission({
    permission: taskCreatePermission
  });
  const canStartOver = canReadTask && canCreateTask;
  useEffect(() => {
    if (taskStream.error) {
      setLogVisibleState(true);
    }
  }, [taskStream.error]);
  useEffect(() => {
    if (taskStream.completed && !taskStream.error) {
      setButtonBarVisibleState(false);
    }
  }, [taskStream.error, taskStream.completed]);
  const activeStep = useMemo(() => {
    for (let i = steps.length - 1; i >= 0; i--) {
      if (steps[i].status !== "open") {
        return i;
      }
    }
    return 0;
  }, [steps]);
  const isRetryableTask = taskStream.task?.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy === "startOver";
  const canRetry = canReadTask && canCreateTask && isRetryableTask;
  const startOver = useCallback(() => {
    const { namespace, name } = taskStream.task?.spec.templateInfo?.entity?.metadata ?? {};
    const formData = taskStream.task?.spec.parameters ?? {};
    if (!namespace || !name) {
      return;
    }
    analytics.captureEvent("click", `Task has been started over`);
    navigate({
      pathname: templateRouteRef({
        namespace,
        templateName: name
      }),
      search: `?${qs.stringify({ formData: JSON.stringify(formData) })}`
    });
  }, [
    analytics,
    navigate,
    taskStream.task?.spec.parameters,
    taskStream.task?.spec.templateInfo?.entity?.metadata,
    templateRouteRef
  ]);
  const [{ status: _ }, { execute: triggerRetry }] = useAsync(async () => {
    if (taskId) {
      analytics.captureEvent("retried", "Template has been retried");
      await scaffolderApi.retry?.(taskId);
    }
  });
  const [{ status: cancelStatus }, { execute: triggerCancel }] = useAsync(
    async () => {
      if (taskId) {
        analytics.captureEvent("cancelled", "Template has been cancelled");
        await scaffolderApi.cancelTask(taskId);
      }
    }
  );
  const Outputs = props.TemplateOutputsComponent ?? DefaultTemplateOutputs;
  const templateName = taskStream.task?.spec.templateInfo?.entity?.metadata.name || "";
  const cancelEnabled = !(taskStream.cancelled || taskStream.completed);
  return /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: templateName ? t("ongoingTask.pageTitle.hasTemplateName", { templateName }) : t("ongoingTask.pageTitle.noTemplateName"),
      title: /* @__PURE__ */ React.createElement("div", null, t("ongoingTask.title"), " ", /* @__PURE__ */ React.createElement("code", null, templateName)),
      subtitle: t("ongoingTask.subtitle", { taskId })
    },
    /* @__PURE__ */ React.createElement(
      ContextMenu,
      {
        cancelEnabled,
        canRetry,
        isRetryableTask,
        logsVisible,
        buttonBarVisible,
        onStartOver: startOver,
        onRetry: triggerRetry,
        onToggleLogs: setLogVisibleState,
        onToggleButtonBar: setButtonBarVisibleState,
        taskId
      }
    )
  ), /* @__PURE__ */ React.createElement(Content, { className: classes.contentWrapper }, taskStream.error ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      error: taskStream.error,
      titleFormat: "markdown",
      title: taskStream.error.message
    }
  )) : null, /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    TaskSteps,
    {
      steps,
      activeStep,
      isComplete: taskStream.completed,
      isError: Boolean(taskStream.error)
    }
  )), /* @__PURE__ */ React.createElement(Outputs, { output: taskStream.output }), buttonBarVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(Box, { padding: 2 }, /* @__PURE__ */ React.createElement("div", { className: classes.buttonBar }, /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.cancelButton,
      disabled: !cancelEnabled || cancelStatus !== "not-executed" && !isRetryableTask || !canCancelTask,
      onClick: triggerCancel,
      "data-testid": "cancel-button"
    },
    t("ongoingTask.cancelButtonTitle")
  ), isRetryableTask && /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.retryButton,
      disabled: cancelEnabled || !canRetry,
      onClick: triggerRetry,
      "data-testid": "retry-button"
    },
    t("ongoingTask.retryButtonTitle")
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.logsVisibilityButton,
      color: "primary",
      variant: "outlined",
      onClick: () => setLogVisibleState(!logsVisible)
    },
    logsVisible ? t("ongoingTask.hideLogsButtonTitle") : t("ongoingTask.showLogsButtonTitle")
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      disabled: cancelEnabled || !canStartOver,
      onClick: startOver,
      "data-testid": "start-over-button"
    },
    t("ongoingTask.startOverButtonTitle")
  ))))) : null, logsVisible ? /* @__PURE__ */ React.createElement(ResizableBox, { height: 240, minConstraints: [0, 160], axis: "y" }, /* @__PURE__ */ React.createElement(Paper, { style: { height: "100%" } }, /* @__PURE__ */ React.createElement(Box, { padding: 2, height: "100%" }, /* @__PURE__ */ React.createElement(TaskLogStream, { logs: taskStream.stepLogs })))) : null));
};

export { OngoingTask };
//# sourceMappingURL=OngoingTask.esm.js.map
