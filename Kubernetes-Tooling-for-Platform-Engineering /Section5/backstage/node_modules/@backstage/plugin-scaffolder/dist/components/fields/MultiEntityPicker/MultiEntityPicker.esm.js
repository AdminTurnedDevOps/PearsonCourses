import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef, entityPresentationApiRef, EntityDisplayName } from '@backstage/plugin-catalog-react';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useState, useCallback, useEffect } from 'react';
import useAsync from 'react-use/esm/useAsync';
import { VirtualizedListbox } from '../VirtualizedListbox.esm.js';
export { MultiEntityPickerSchema } from './schema.esm.js';

const MultiEntityPicker = (props) => {
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = uiSchema["ui:options"]?.defaultKind;
  const defaultNamespace = uiSchema["ui:options"]?.defaultNamespace || void 0;
  const [noOfItemsSelected, setNoOfItemsSelected] = useState(0);
  const catalogApi = useApi(catalogApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    const entityRefToPresentation = new Map(
      await Promise.all(
        items.map(async (item) => {
          const presentation = await entityPresentationApi.forEntity(item).promise;
          return [stringifyEntityRef(item), presentation];
        })
      )
    );
    return { entities: items, entityRefToPresentation };
  });
  const allowArbitraryValues = uiSchema["ui:options"]?.allowArbitraryValues ?? true;
  const maxItems = props.schema.maxItems;
  const onSelect = useCallback(
    (_, refs, reason) => {
      const values = refs.map((ref) => {
        if (typeof ref !== "string") {
          return ref ? stringifyEntityRef(ref) : void 0;
        }
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData?.includes(ref) || allowArbitraryValues) {
            return entityRef;
          }
        }
        return void 0;
      }).filter((ref) => ref !== void 0);
      setNoOfItemsSelected(values.length);
      onChange(values);
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  useEffect(() => {
    if (required && !allowArbitraryValues && entities?.entities?.length === 1) {
      onChange([stringifyEntityRef(entities?.entities[0])]);
    }
  }, [entities, onChange, required, allowArbitraryValues]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: rawErrors?.length > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        multiple: true,
        filterSelectedOptions: true,
        disabled: required && !allowArbitraryValues && entities?.entities?.length === 1,
        id: idSchema?.$id,
        defaultValue: formData,
        loading,
        onChange: onSelect,
        options: entities?.entities || [],
        renderOption: (option) => /* @__PURE__ */ React.createElement(EntityDisplayName, { entityRef: option }),
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : entities?.entityRefToPresentation.get(stringifyEntityRef(option))?.entityRef
        ),
        getOptionDisabled: (_options) => maxItems ? noOfItemsSelected >= maxItems : false,
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: {
              margin: "dense",
              style: { marginLeft: 0 }
            },
            variant: "outlined",
            required,
            InputProps: {
              ...params.InputProps,
              required: formData?.length === 0 && required
            }
          }
        ),
        ListboxComponent: VirtualizedListbox
      }
    )
  );
};
const validateMultiEntityPickerValidation = (values, validation) => {
  values.forEach((value) => {
    try {
      parseEntityRef(value);
    } catch {
      validation.addError(`${value} is not a valid entity ref`);
    }
  });
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value?.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  const catalogFilter = uiSchema["ui:options"]?.catalogFilter;
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

export { MultiEntityPicker, validateMultiEntityPickerValidation };
//# sourceMappingURL=MultiEntityPicker.esm.js.map
