import React, { useState } from 'react';
import useAsync from 'react-use/esm/useAsync';
import useEffectOnce from 'react-use/esm/useEffectOnce';
import { makeValidator } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import FormControl from '@material-ui/core/FormControl';
import TextField from '@material-ui/core/TextField';
import Autocomplete from '@material-ui/lab/Autocomplete';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../../translation.esm.js';
export { EntityTagsPickerSchema } from './schema.esm.js';

const EntityTagsPicker = (props) => {
  const { formData, onChange, uiSchema } = props;
  const catalogApi = useApi(catalogApiRef);
  const [tagOptions, setTagOptions] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [inputError, setInputError] = useState(false);
  const tagValidator = makeValidator().isValidTag;
  const kinds = uiSchema["ui:options"]?.kinds;
  const showCounts = uiSchema["ui:options"]?.showCounts;
  const helperText = uiSchema["ui:options"]?.helperText;
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const { loading, value: existingTags } = useAsync(async () => {
    const facet = "metadata.tags";
    const tagsRequest = { facets: [facet] };
    if (kinds) {
      tagsRequest.filter = { kind: kinds };
    }
    const { facets } = await catalogApi.getEntityFacets(tagsRequest);
    const tagFacets = Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
    setTagOptions(
      Object.keys(tagFacets).sort(
        (a, b) => showCounts ? tagFacets[b] - tagFacets[a] : a.localeCompare(b)
      )
    );
    return tagFacets;
  });
  const setTags = (_, values) => {
    let hasError = false;
    let addDuplicate = false;
    const currentTags = formData || [];
    if (values?.length && currentTags.length < values.length) {
      const newTag = values[values.length - 1] = values[values.length - 1].toLocaleLowerCase("en-US").trim();
      hasError = !tagValidator(newTag);
      addDuplicate = currentTags.indexOf(newTag) !== -1;
    }
    setInputError(hasError);
    setInputValue(!hasError ? "" : inputValue);
    if (!hasError && !addDuplicate) {
      onChange(values || []);
    }
  };
  useEffectOnce(() => onChange(formData || []));
  return /* @__PURE__ */ React.createElement(FormControl, { margin: "normal" }, /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      multiple: true,
      freeSolo: true,
      filterSelectedOptions: true,
      onChange: setTags,
      value: formData || [],
      inputValue,
      loading,
      options: tagOptions,
      ChipProps: { size: "small" },
      renderOption: (option) => showCounts ? `${option} (${existingTags?.[option]})` : option,
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          label: t("fields.entityTagsPicker.title"),
          onChange: (e) => setInputValue(e.target.value),
          error: inputError,
          helperText: helperText ?? t("fields.entityTagsPicker.description"),
          FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } }
        }
      )
    }
  ));
};

export { EntityTagsPicker };
//# sourceMappingURL=EntityTagsPicker.esm.js.map
