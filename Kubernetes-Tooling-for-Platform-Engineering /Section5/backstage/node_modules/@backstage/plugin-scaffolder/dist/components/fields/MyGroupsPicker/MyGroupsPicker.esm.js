import React, { useEffect } from 'react';
import { useApi, identityApiRef, errorApiRef } from '@backstage/core-plugin-api';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
export { MyGroupsPickerSchema } from './schema.esm.js';
import Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';
import { catalogApiRef, entityPresentationApiRef, EntityDisplayName } from '@backstage/plugin-catalog-react';
import { NotFoundError } from '@backstage/errors';
import useAsync from 'react-use/esm/useAsync';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { VirtualizedListbox } from '../VirtualizedListbox.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { scaffolderTranslationRef } from '../../../translation.esm.js';

const MyGroupsPicker = (props) => {
  const { t } = useTranslationRef(scaffolderTranslationRef);
  const {
    schema: {
      title = t("fields.myGroupsPicker.title"),
      description = t("fields.myGroupsPicker.description")
    },
    required,
    rawErrors,
    onChange,
    formData
  } = props;
  const identityApi = useApi(identityApiRef);
  const catalogApi = useApi(catalogApiRef);
  const errorApi = useApi(errorApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { value: groups, loading } = useAsync(async () => {
    const { userEntityRef } = await identityApi.getBackstageIdentity();
    if (!userEntityRef) {
      errorApi.post(new NotFoundError("No user entity ref found"));
      return { catalogEntities: [], entityRefToPresentation: /* @__PURE__ */ new Map() };
    }
    const { items } = await catalogApi.getEntities({
      filter: {
        kind: "Group",
        ["relations.hasMember"]: [userEntityRef]
      }
    });
    const entityRefToPresentation = new Map(
      await Promise.all(
        items.map(async (item) => {
          const presentation = await entityPresentationApi.forEntity(item).promise;
          return [stringifyEntityRef(item), presentation];
        })
      )
    );
    return { catalogEntities: items, entityRefToPresentation };
  });
  const updateChange = (_, value) => {
    onChange(value ? stringifyEntityRef(value) : "");
  };
  const selectedEntity = groups?.catalogEntities.find((e) => stringifyEntityRef(e) === formData) || null;
  useEffect(() => {
    if (required && groups?.catalogEntities.length === 1 && !selectedEntity) {
      onChange(stringifyEntityRef(groups.catalogEntities[0]));
    }
  }, [groups, onChange, selectedEntity, required]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: rawErrors?.length > 0
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: required && groups?.catalogEntities.length === 1,
        id: "OwnershipEntityRefPicker-dropdown",
        options: groups?.catalogEntities || [],
        value: selectedEntity,
        loading,
        onChange: updateChange,
        getOptionLabel: (option) => groups?.entityRefToPresentation.get(stringifyEntityRef(option))?.primaryTitle,
        autoSelect: true,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        ),
        renderOption: (option) => /* @__PURE__ */ React.createElement(EntityDisplayName, { entityRef: option }),
        filterOptions: createFilterOptions({
          stringify: (option) => groups?.entityRefToPresentation.get(stringifyEntityRef(option))?.primaryTitle
        }),
        ListboxComponent: VirtualizedListbox
      }
    )
  );
};

export { MyGroupsPicker };
//# sourceMappingURL=MyGroupsPicker.esm.js.map
