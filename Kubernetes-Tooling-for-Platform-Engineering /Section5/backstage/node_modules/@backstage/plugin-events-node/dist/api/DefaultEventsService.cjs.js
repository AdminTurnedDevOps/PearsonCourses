'use strict';

var EventsService = require('./EventsService.cjs.js');
var DefaultApi_client = require('../generated/apis/DefaultApi.client.cjs.js');
var errors = require('@backstage/errors');

const POLL_BACKOFF_START_MS = 1e3;
const POLL_BACKOFF_MAX_MS = 6e4;
const POLL_BACKOFF_FACTOR = 2;
const EVENT_BUS_MODES = ["never", "always", "auto"];
class LocalEventBus {
  #logger;
  #subscribers = /* @__PURE__ */ new Map();
  constructor(logger) {
    this.#logger = logger;
  }
  async publish(params) {
    this.#logger.debug(
      `Event received: topic=${params.topic}, metadata=${JSON.stringify(
        params.metadata
      )}, payload=${JSON.stringify(params.eventPayload)}`
    );
    if (!this.#subscribers.has(params.topic)) {
      return { notifiedSubscribers: [] };
    }
    const onEventPromises = [];
    this.#subscribers.get(params.topic)?.forEach((subscription) => {
      onEventPromises.push(
        (async () => {
          try {
            await subscription.onEvent(params);
          } catch (error) {
            this.#logger.warn(
              `Subscriber "${subscription.id}" failed to process event for topic "${params.topic}"`,
              error
            );
          }
          return subscription.id;
        })()
      );
    });
    return { notifiedSubscribers: await Promise.all(onEventPromises) };
  }
  async subscribe(options) {
    options.topics.forEach((topic) => {
      if (!this.#subscribers.has(topic)) {
        this.#subscribers.set(topic, []);
      }
      this.#subscribers.get(topic).push({
        id: options.id,
        onEvent: options.onEvent
      });
    });
  }
}
class PluginEventsService {
  constructor(pluginId, localBus, logger, mode, client, auth) {
    this.pluginId = pluginId;
    this.localBus = localBus;
    this.logger = logger;
    this.mode = mode;
    this.client = client;
    this.auth = auth;
  }
  async publish(params) {
    const lock = this.#getShutdownLock();
    if (!lock) {
      throw new Error("Service is shutting down");
    }
    try {
      const { notifiedSubscribers } = await this.localBus.publish(params);
      const client = this.client;
      if (!client) {
        return;
      }
      const token = await this.#getToken();
      if (!token) {
        return;
      }
      const res = await client.postEvent(
        {
          body: {
            event: { payload: params.eventPayload, topic: params.topic },
            notifiedSubscribers
          }
        },
        { token }
      );
      if (!res.ok) {
        if (res.status === 404 && this.mode !== "always") {
          this.logger.warn(
            `Event publish request failed with status 404, events backend not found. Future events will not be persisted.`
          );
          delete this.client;
          return;
        }
        throw await errors.ResponseError.fromResponse(res);
      }
    } finally {
      lock.release();
    }
  }
  async subscribe(options) {
    const subscriptionId = `${this.pluginId}.${options.id}`;
    await this.localBus.subscribe({
      id: subscriptionId,
      topics: options.topics,
      onEvent: options.onEvent
    });
    if (!this.client) {
      return;
    }
    this.#startPolling(subscriptionId, options.topics, options.onEvent);
  }
  #startPolling(subscriptionId, topics, onEvent) {
    let hasSubscription = false;
    let backoffMs = POLL_BACKOFF_START_MS;
    const poll = async () => {
      const client = this.client;
      if (!client) {
        return;
      }
      const lock = this.#getShutdownLock();
      if (!lock) {
        return;
      }
      try {
        const token = await this.#getToken();
        if (!token) {
          return;
        }
        if (hasSubscription) {
          const res = await client.getSubscriptionEvents(
            {
              path: { subscriptionId }
            },
            { token }
          );
          if (res.status === 202) {
            lock.release();
            const notifyTimeoutHeader = res.headers.get(
              EventsService.EVENTS_NOTIFY_TIMEOUT_HEADER
            );
            const notifyTimeoutMs = notifyTimeoutHeader && !isNaN(parseInt(notifyTimeoutHeader, 10)) ? Number(notifyTimeoutHeader) + 1e3 : null;
            await Promise.race(
              [
                // We don't actually expect any response body here, but waiting for
                // an empty body to be returned has been more reliable that waiting
                // for the response body stream to close.
                res.text(),
                notifyTimeoutMs ? new Promise((resolve) => setTimeout(resolve, notifyTimeoutMs)) : null
              ].filter(Boolean)
            );
          } else if (res.status === 200) {
            const data = await res.json();
            if (data) {
              for (const event of data.events ?? []) {
                try {
                  await onEvent({
                    topic: event.topic,
                    eventPayload: event.payload
                  });
                } catch (error) {
                  this.logger.warn(
                    `Subscriber "${subscriptionId}" failed to process event for topic "${event.topic}"`,
                    error
                  );
                }
              }
            }
          } else {
            if (res.status === 404) {
              this.logger.info(
                `Polling event subscription resulted in a 404, recreating subscription`
              );
              hasSubscription = false;
            } else {
              throw await errors.ResponseError.fromResponse(res);
            }
          }
        }
        if (!hasSubscription) {
          const res = await client.putSubscription(
            {
              path: { subscriptionId },
              body: { topics }
            },
            { token }
          );
          hasSubscription = true;
          if (!res.ok) {
            if (res.status === 404 && this.mode !== "always") {
              this.logger.warn(
                `Event subscribe request failed with status 404, events backend not found. Will only receive events that were sent locally on this process.`
              );
              delete this.client;
              return;
            }
            throw await errors.ResponseError.fromResponse(res);
          }
        }
        backoffMs = POLL_BACKOFF_START_MS;
        process.nextTick(poll);
      } catch (error) {
        this.logger.warn(
          `Poll failed for subscription "${subscriptionId}", retrying in ${backoffMs.toFixed(
            0
          )}ms`,
          error
        );
        setTimeout(poll, backoffMs);
        backoffMs = Math.min(
          backoffMs * POLL_BACKOFF_FACTOR,
          POLL_BACKOFF_MAX_MS
        );
      } finally {
        lock.release();
      }
    };
    poll();
  }
  async #getToken() {
    if (!this.auth) {
      throw new Error("Auth service not available");
    }
    try {
      const { token } = await this.auth.getPluginRequestToken({
        onBehalfOf: await this.auth.getOwnServiceCredentials(),
        targetPluginId: "events"
      });
      return token;
    } catch (error) {
      if (String(error).includes("Unable to generate legacy token") && this.mode !== "always") {
        this.logger.warn(
          `The events backend is not available and neither is legacy auth. Future events will not be persisted.`
        );
        delete this.client;
        return void 0;
      }
      throw error;
    }
  }
  async shutdown() {
    this.#isShuttingDown = true;
    await Promise.all(this.#shutdownLocks);
  }
  #isShuttingDown = false;
  #shutdownLocks = /* @__PURE__ */ new Set();
  // This locking mechanism helps ensure that we are either idle or waiting for
  // a blocked events call before shutting down. It increases out changes of
  // never dropping any events on shutdown.
  #getShutdownLock() {
    if (this.#isShuttingDown) {
      return void 0;
    }
    let release;
    const lock = new Promise((resolve) => {
      release = () => {
        resolve();
        this.#shutdownLocks.delete(lock);
      };
    });
    this.#shutdownLocks.add(lock);
    return { release };
  }
}
class DefaultEventsService {
  constructor(logger, localBus, mode) {
    this.logger = logger;
    this.localBus = localBus;
    this.mode = mode;
  }
  static create(options) {
    const eventBusMode = options.useEventBus ?? (options.config?.getOptionalString("events.useEventBus") ?? "auto");
    if (!EVENT_BUS_MODES.includes(eventBusMode)) {
      throw new Error(
        `Invalid events.useEventBus config, must be one of ${EVENT_BUS_MODES.join(
          ", "
        )}, got '${eventBusMode}'`
      );
    }
    return new DefaultEventsService(
      options.logger,
      new LocalEventBus(options.logger),
      eventBusMode
    );
  }
  /**
   * Returns a plugin-scoped context of the `EventService`
   * that ensures to prefix subscriber IDs with the plugin ID.
   *
   * @param pluginId - The plugin that the `EventService` should be created for.
   */
  forPlugin(pluginId, options) {
    const client = options && this.mode !== "never" ? new DefaultApi_client.DefaultApiClient({
      discoveryApi: options.discovery,
      fetchApi: { fetch }
      // use native node fetch
    }) : void 0;
    const logger = options?.logger ?? this.logger;
    const service = new PluginEventsService(
      pluginId,
      this.localBus,
      logger,
      this.mode,
      client,
      options?.auth
    );
    options?.lifecycle.addShutdownHook(async () => {
      await service.shutdown();
    });
    return service;
  }
  async publish(params) {
    await this.localBus.publish(params);
  }
  async subscribe(options) {
    this.localBus.subscribe(options);
  }
}

exports.DefaultEventsService = DefaultEventsService;
exports.LocalEventBus = LocalEventBus;
//# sourceMappingURL=DefaultEventsService.cjs.js.map
