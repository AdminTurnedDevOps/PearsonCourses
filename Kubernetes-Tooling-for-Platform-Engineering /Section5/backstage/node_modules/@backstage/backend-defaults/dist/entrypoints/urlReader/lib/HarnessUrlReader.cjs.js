'use strict';

var integration = require('@backstage/integration');
var fetch = require('node-fetch');
var ReadUrlResponseFactory = require('./ReadUrlResponseFactory.cjs.js');
var errors = require('@backstage/errors');
var stream = require('stream');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

class HarnessUrlReader {
  constructor(integration, deps) {
    this.integration = integration;
    this.deps = deps;
  }
  static factory = ({ config, treeResponseFactory }) => {
    return integration.ScmIntegrations.fromConfig(config).harness.list().map((integration) => {
      const reader = new HarnessUrlReader(integration, {
        treeResponseFactory
      });
      const predicate = (url) => {
        return url.host === integration.config.host;
      };
      return { reader, predicate };
    });
  };
  async read(url) {
    const response = await this.readUrl(url);
    return response.buffer();
  }
  async readUrl(url, options) {
    let response;
    const blobUrl = integration.getHarnessFileContentsUrl(this.integration.config, url);
    try {
      response = await fetch__default.default(blobUrl, {
        method: "GET",
        ...integration.getHarnessRequestOptions(this.integration.config),
        signal: options?.signal
      });
    } catch (e) {
      throw new Error(`Unable to read ${blobUrl}, ${e}`);
    }
    if (response.ok) {
      const jsonResponse = { data: response.body };
      if (jsonResponse) {
        return ReadUrlResponseFactory.ReadUrlResponseFactory.fromReadable(
          stream.Readable.from(jsonResponse.data),
          {
            etag: response.headers.get("ETag") ?? void 0
          }
        );
      }
      throw new Error(`Unknown json: ${jsonResponse}`);
    }
    const message = `${url} x ${blobUrl}, ${response.status} ${response.statusText}`;
    if (response.status === 404) {
      throw new errors.NotFoundError(message);
    }
    if (response.status === 304) {
      throw new errors.NotModifiedError();
    }
    if (response.status === 403) {
      throw new errors.AuthenticationError();
    }
    throw new Error(message);
  }
  async readTree(url, options) {
    const lastCommitHash = await this.getLastCommitHash(url);
    if (options?.etag && options.etag === lastCommitHash) {
      throw new errors.NotModifiedError();
    }
    const archiveUri = integration.getHarnessArchiveUrl(this.integration.config, url);
    let response;
    try {
      response = await fetch__default.default(archiveUri, {
        method: "GET",
        ...integration.getHarnessRequestOptions(this.integration.config),
        signal: options?.signal
      });
    } catch (e) {
      throw new Error(`Unable to read ${archiveUri}, ${e}`);
    }
    const parsedUri = integration.parseHarnessUrl(this.integration.config, url);
    return this.deps.treeResponseFactory.fromZipArchive({
      stream: stream.Readable.from(response.body),
      subpath: parsedUri.path,
      etag: lastCommitHash,
      filter: options?.filter
    });
  }
  search() {
    throw new Error("HarnessUrlReader search not implemented.");
  }
  toString() {
    const { host } = this.integration.config;
    return `harness{host=${host},authed=${Boolean(
      this.integration.config.token || this.integration.config.apiKey
    )}}`;
  }
  async getLastCommitHash(url) {
    const commitUri = integration.getHarnessLatestCommitUrl(this.integration.config, url);
    const response = await fetch__default.default(
      commitUri,
      integration.getHarnessRequestOptions(this.integration.config)
    );
    if (!response.ok) {
      const message = `Failed to retrieve latest commit information from ${commitUri}, ${response.status} ${response.statusText}`;
      if (response.status === 404) {
        throw new errors.NotFoundError(message);
      }
      throw new Error(message);
    }
    return (await response.json()).latest_commit.sha;
  }
}

exports.HarnessUrlReader = HarnessUrlReader;
//# sourceMappingURL=HarnessUrlReader.cjs.js.map
