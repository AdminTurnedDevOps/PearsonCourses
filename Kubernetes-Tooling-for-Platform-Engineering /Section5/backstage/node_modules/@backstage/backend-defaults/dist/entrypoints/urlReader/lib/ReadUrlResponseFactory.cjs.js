'use strict';

var errors = require('@backstage/errors');
var getRawBody = require('raw-body');
var stream = require('stream');
var util = require('./util.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var getRawBody__default = /*#__PURE__*/_interopDefaultCompat(getRawBody);

class ReadUrlResponseFactory {
  /**
   * Resolves a UrlReaderServiceReadUrlResponse from a Readable stream.
   */
  static async fromReadable(stream, options) {
    let buffer;
    const conflictError = new errors.ConflictError(
      "Cannot use buffer() and stream() from the same ReadUrlResponse"
    );
    let hasCalledStream = false;
    let hasCalledBuffer = false;
    return {
      buffer: () => {
        hasCalledBuffer = true;
        if (hasCalledStream) throw conflictError;
        if (buffer) return buffer;
        buffer = getRawBody__default.default(stream);
        return buffer;
      },
      stream: () => {
        hasCalledStream = true;
        if (hasCalledBuffer) throw conflictError;
        return stream;
      },
      etag: options?.etag,
      lastModifiedAt: options?.lastModifiedAt
    };
  }
  /**
   * Resolves a UrlReaderServiceReadUrlResponse from an old-style NodeJS.ReadableStream.
   */
  static async fromNodeJSReadable(oldStyleStream, options) {
    const readable = stream.Readable.from(oldStyleStream);
    return ReadUrlResponseFactory.fromReadable(readable, options);
  }
  /**
   * Resolves a UrlReaderServiceReadUrlResponse from a native fetch response body.
   */
  static async fromResponse(response) {
    const etag = response.headers.get("etag") || void 0;
    const lastModifiedAt = util.parseLastModified(
      response.headers.get("last-modified")
    );
    return ReadUrlResponseFactory.fromReadable(util.responseToReadable(response), {
      etag,
      lastModifiedAt
    });
  }
}

exports.ReadUrlResponseFactory = ReadUrlResponseFactory;
//# sourceMappingURL=ReadUrlResponseFactory.cjs.js.map
