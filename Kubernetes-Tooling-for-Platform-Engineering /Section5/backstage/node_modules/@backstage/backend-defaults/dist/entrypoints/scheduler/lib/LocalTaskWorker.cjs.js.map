{"version":3,"file":"LocalTaskWorker.cjs.js","sources":["../../../../src/entrypoints/scheduler/lib/LocalTaskWorker.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { SchedulerServiceTaskFunction } from '@backstage/backend-plugin-api';\nimport { ConflictError } from '@backstage/errors';\nimport { CronTime } from 'cron';\nimport { DateTime, Duration } from 'luxon';\nimport { TaskSettingsV2 } from './types';\nimport { delegateAbortController, sleep } from './util';\n\n/**\n * Implements tasks that run locally without cross-host collaboration.\n *\n * @private\n */\nexport class LocalTaskWorker {\n  private abortWait: AbortController | undefined;\n\n  constructor(\n    private readonly taskId: string,\n    private readonly fn: SchedulerServiceTaskFunction,\n    private readonly logger: LoggerService,\n  ) {}\n\n  start(settings: TaskSettingsV2, options: { signal: AbortSignal }) {\n    this.logger.info(\n      `Task worker starting: ${this.taskId}, ${JSON.stringify(settings)}`,\n    );\n\n    (async () => {\n      let attemptNum = 1;\n      for (;;) {\n        try {\n          if (settings.initialDelayDuration) {\n            await this.sleep(\n              Duration.fromISO(settings.initialDelayDuration),\n              options.signal,\n            );\n          }\n\n          while (!options.signal.aborted) {\n            const startTime = process.hrtime();\n            await this.runOnce(settings, options.signal);\n            const timeTaken = process.hrtime(startTime);\n            await this.waitUntilNext(\n              settings,\n              (timeTaken[0] + timeTaken[1] / 1e9) * 1000,\n              options.signal,\n            );\n          }\n\n          this.logger.info(`Task worker finished: ${this.taskId}`);\n          attemptNum = 0;\n          break;\n        } catch (e) {\n          attemptNum += 1;\n          this.logger.warn(\n            `Task worker failed unexpectedly, attempt number ${attemptNum}, ${e}`,\n          );\n          await sleep(Duration.fromObject({ seconds: 1 }));\n        }\n      }\n    })();\n  }\n\n  trigger(): void {\n    if (!this.abortWait) {\n      throw new ConflictError(`Task ${this.taskId} is currently running`);\n    }\n    this.abortWait.abort();\n  }\n\n  /**\n   * Makes a single attempt at running the task to completion.\n   */\n  private async runOnce(\n    settings: TaskSettingsV2,\n    signal: AbortSignal,\n  ): Promise<void> {\n    // Abort the task execution either if the worker is stopped, or if the\n    // task timeout is hit\n    const taskAbortController = delegateAbortController(signal);\n    const timeoutHandle = setTimeout(() => {\n      taskAbortController.abort();\n    }, Duration.fromISO(settings.timeoutAfterDuration).as('milliseconds'));\n\n    try {\n      await this.fn(taskAbortController.signal);\n    } catch (e) {\n      // ignore intentionally\n    }\n\n    // release resources\n    clearTimeout(timeoutHandle);\n    taskAbortController.abort();\n  }\n\n  /**\n   * Sleeps until it's time to run the task again.\n   */\n  private async waitUntilNext(\n    settings: TaskSettingsV2,\n    lastRunMillis: number,\n    signal: AbortSignal,\n  ) {\n    if (signal.aborted) {\n      return;\n    }\n\n    const isCron = !settings.cadence.startsWith('P');\n    let dt: number;\n\n    if (isCron) {\n      const nextRun = +new CronTime(settings.cadence).sendAt().toJSDate();\n      dt = nextRun - Date.now();\n    } else {\n      dt =\n        Duration.fromISO(settings.cadence).as('milliseconds') - lastRunMillis;\n    }\n\n    dt = Math.max(dt, 0);\n\n    this.logger.debug(\n      `task: ${this.taskId} will next occur around ${DateTime.now().plus(\n        Duration.fromMillis(dt),\n      )}`,\n    );\n\n    await this.sleep(Duration.fromMillis(dt), signal);\n  }\n\n  private async sleep(\n    duration: Duration,\n    abortSignal: AbortSignal,\n  ): Promise<void> {\n    this.abortWait = delegateAbortController(abortSignal);\n    await sleep(duration, this.abortWait.signal);\n    this.abortWait.abort(); // cleans up resources\n    this.abortWait = undefined;\n  }\n}\n"],"names":["Duration","sleep","ConflictError","delegateAbortController","CronTime","DateTime"],"mappings":"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"}