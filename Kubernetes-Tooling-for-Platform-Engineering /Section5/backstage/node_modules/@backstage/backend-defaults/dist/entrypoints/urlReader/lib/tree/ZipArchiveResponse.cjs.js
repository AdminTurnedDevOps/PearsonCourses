'use strict';

var archiver = require('archiver');
var yauzl = require('yauzl');
var fs = require('fs-extra');
var platformPath = require('path');
var util = require('./util.cjs.js');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var archiver__default = /*#__PURE__*/_interopDefaultCompat(archiver);
var yauzl__default = /*#__PURE__*/_interopDefaultCompat(yauzl);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);

class ZipArchiveResponse {
  constructor(stream, subPath, workDir, etag, filter) {
    this.stream = stream;
    this.subPath = subPath;
    this.workDir = workDir;
    this.etag = etag;
    this.filter = filter;
    if (subPath) {
      if (!subPath.endsWith("/")) {
        this.subPath += "/";
      }
      if (subPath.startsWith("/")) {
        throw new TypeError(
          `ZipArchiveResponse subPath must not start with a /, got '${subPath}'`
        );
      }
    }
    this.etag = etag;
  }
  read = false;
  // Make sure the input stream is only read once
  onlyOnce() {
    if (this.read) {
      throw new Error("Response has already been read");
    }
    this.read = true;
  }
  // File path relative to the root extracted directory or a sub directory if subpath is set.
  getInnerPath(path) {
    return path.slice(this.subPath.length);
  }
  shouldBeIncluded(entry) {
    if (this.subPath) {
      if (!entry.fileName.startsWith(this.subPath)) {
        return false;
      }
    }
    if (this.filter) {
      return this.filter(this.getInnerPath(entry.fileName), {
        size: entry.uncompressedSize
      });
    }
    return true;
  }
  async streamToTemporaryFile(stream) {
    const tmpDir = await fs__default.default.mkdtemp(
      platformPath__default.default.join(this.workDir, "backstage-tmp")
    );
    const tmpFile = platformPath__default.default.join(tmpDir, "tmp.zip");
    const writeStream = fs__default.default.createWriteStream(tmpFile);
    return new Promise((resolve, reject) => {
      writeStream.on("error", reject);
      writeStream.on("finish", () => {
        writeStream.end();
        resolve({
          fileName: tmpFile,
          cleanup: () => fs__default.default.rm(tmpDir, { recursive: true })
        });
      });
      stream.pipe(writeStream);
    });
  }
  forEveryZipEntry(zip, callback) {
    return new Promise((resolve, reject) => {
      yauzl__default.default.open(zip, { lazyEntries: true }, (err, zipfile) => {
        if (err || !zipfile) {
          reject(err || new Error(`Failed to open zip file ${zip}`));
          return;
        }
        zipfile.on("entry", async (entry) => {
          if (!entry.fileName.endsWith("/") && this.shouldBeIncluded(entry)) {
            zipfile.openReadStream(entry, async (openErr, readStream) => {
              if (openErr || !readStream) {
                reject(
                  openErr || new Error(`Failed to open zip entry ${entry.fileName}`)
                );
                return;
              }
              await callback(entry, readStream);
              zipfile.readEntry();
            });
          } else {
            zipfile.readEntry();
          }
        });
        zipfile.once("end", () => resolve());
        zipfile.on("error", (e) => reject(e));
        zipfile.readEntry();
      });
    });
  }
  async files() {
    this.onlyOnce();
    const files = Array();
    const temporary = await this.streamToTemporaryFile(this.stream);
    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {
      files.push({
        path: this.getInnerPath(entry.fileName),
        content: async () => await util.streamToBuffer(content),
        lastModifiedAt: entry.lastModFileTime ? new Date(entry.lastModFileTime) : void 0
      });
    });
    await temporary.cleanup();
    return files;
  }
  async archive() {
    this.onlyOnce();
    if (!this.subPath) {
      return this.stream;
    }
    const archive = archiver__default.default("zip");
    const temporary = await this.streamToTemporaryFile(this.stream);
    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {
      archive.append(await util.streamToBuffer(content), {
        name: this.getInnerPath(entry.fileName)
      });
    });
    archive.finalize();
    await temporary.cleanup();
    return archive;
  }
  async dir(options) {
    this.onlyOnce();
    const dir = options?.targetDir ?? await fs__default.default.mkdtemp(platformPath__default.default.join(this.workDir, "backstage-"));
    const temporary = await this.streamToTemporaryFile(this.stream);
    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {
      const entryPath = this.getInnerPath(entry.fileName);
      const dirname = platformPath__default.default.dirname(entryPath);
      if (dirname) {
        await fs__default.default.mkdirp(backendPluginApi.resolveSafeChildPath(dir, dirname));
      }
      return new Promise(async (resolve, reject) => {
        const file = fs__default.default.createWriteStream(backendPluginApi.resolveSafeChildPath(dir, entryPath));
        file.on("finish", resolve);
        content.on("error", reject);
        content.pipe(file);
      });
    });
    await temporary.cleanup();
    return dir;
  }
}

exports.ZipArchiveResponse = ZipArchiveResponse;
//# sourceMappingURL=ZipArchiveResponse.cjs.js.map
