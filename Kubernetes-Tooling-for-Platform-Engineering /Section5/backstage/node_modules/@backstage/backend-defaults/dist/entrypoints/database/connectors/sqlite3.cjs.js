'use strict';

var backendDevUtils = require('@backstage/backend-dev-utils');
var config = require('@backstage/config');
var fs = require('fs-extra');
var knexFactory = require('knex');
var lodash = require('lodash');
var platformPath = require('path');
var mergeDatabaseConfig = require('./mergeDatabaseConfig.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var knexFactory__default = /*#__PURE__*/_interopDefaultCompat(knexFactory);
var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);

function createSqliteDatabaseClient(pluginId, dbConfig, deps, overrides) {
  const knexConfig = buildSqliteDatabaseConfig(dbConfig, overrides);
  const connConfig = knexConfig.connection;
  const filename = connConfig.filename ?? ":memory:";
  if (filename !== ":memory:") {
    const directory = platformPath__default.default.dirname(filename);
    fs.ensureDirSync(directory);
  }
  let database;
  if (deps && filename === ":memory:") {
    const devStore = backendDevUtils.DevDataStore.get();
    if (devStore) {
      const dataKey = `sqlite3-db-${pluginId}`;
      const connectionLoader = async () => {
        const { data: seedData } = await devStore.load(dataKey);
        return {
          ...knexConfig.connection,
          filename: seedData ?? ":memory:"
        };
      };
      database = knexFactory__default.default({
        ...knexConfig,
        connection: Object.assign(connectionLoader, {
          // This is a workaround for the knex SQLite driver always warning when using a config loader
          filename: ":memory:"
        })
      });
      deps.lifecycle.addShutdownHook(async () => {
        const connection = await database.client.acquireConnection();
        const data = connection.serialize();
        await devStore.save(dataKey, data);
      });
    } else {
      database = knexFactory__default.default(knexConfig);
    }
  } else {
    database = knexFactory__default.default(knexConfig);
  }
  database.client.pool.on("createSuccess", (_eventId, resource) => {
    resource.run("PRAGMA foreign_keys = ON", () => {
    });
  });
  return database;
}
function buildSqliteDatabaseConfig(dbConfig, overrides) {
  const baseConfig = dbConfig.get();
  if (typeof baseConfig.connection === "string") {
    baseConfig.connection = { filename: baseConfig.connection };
  }
  if (overrides && typeof overrides.connection === "string") {
    overrides.connection = { filename: overrides.connection };
  }
  const config = mergeDatabaseConfig.mergeDatabaseConfig(
    {
      connection: {}
    },
    baseConfig,
    {
      useNullAsDefault: true
    },
    overrides
  );
  return config;
}
function createSqliteNameOverride(name) {
  return {
    connection: parseSqliteConnectionString(name)
  };
}
function parseSqliteConnectionString(name) {
  return {
    filename: name
  };
}
function pluginPath(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parseSqliteConnectionString(connection) : connection;
}
class Sqlite3Connector {
  constructor(config) {
    this.config = config;
  }
  async getClient(pluginId, deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const pluginDivisionMode = this.getPluginDivisionModeConfig();
    if (pluginDivisionMode !== "database") {
      throw new Error(
        `The SQLite driver does not support plugin division mode '${pluginDivisionMode}'`
      );
    }
    const databaseClientOverrides = mergeDatabaseConfig.mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId)
    );
    const client = createSqliteDatabaseClient(
      pluginId,
      pluginConfig,
      deps,
      databaseClientOverrides
    );
    return client;
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using global
   * and plugin specific database config. If no explicit database name is configured
   * and `pluginDivisionMode` is not `schema`, this method will provide a generated name
   * which is the pluginId prefixed with 'backstage_plugin_'. If `pluginDivisionMode` is
   * `schema`, it will fallback to using the default database for the knex instance.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const sqliteFilename = connection.filename;
    if (sqliteFilename === ":memory:") {
      return sqliteFilename;
    }
    const sqliteDirectory = connection.directory ?? ".";
    return platformPath__default.default.join(sqliteDirectory, sqliteFilename ?? `${pluginId}.sqlite`);
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted for
   * all supported databases excluding SQLite unless `pluginDivisionMode` is set
   * to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { client, overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection(this.config.get("connection"));
    if (client.includes("sqlite3") && "filename" in baseConnection && baseConnection.filename !== ":memory:") {
      throw new Error(
        "`connection.filename` is not supported for the base sqlite connection. Prefer `connection.directory` or provide a filename for the plugin connection instead."
      );
    }
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection(
      this.config.getOptional(`${pluginPath(pluginId)}.connection`)
    );
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`â€¢ database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? createSqliteNameOverride(databaseName) : {};
  }
}

exports.Sqlite3Connector = Sqlite3Connector;
exports.buildSqliteDatabaseConfig = buildSqliteDatabaseConfig;
exports.createSqliteDatabaseClient = createSqliteDatabaseClient;
exports.createSqliteNameOverride = createSqliteNameOverride;
exports.parseSqliteConnectionString = parseSqliteConnectionString;
//# sourceMappingURL=sqlite3.cjs.js.map
