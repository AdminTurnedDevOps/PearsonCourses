'use strict';

var config = require('@backstage/config');
var errors = require('@backstage/errors');
var knexFactory = require('knex');
var lodash = require('lodash');
var limiterFactory = require('p-limit');
var defaultNameOverride = require('./defaultNameOverride.cjs.js');
var defaultSchemaOverride = require('./defaultSchemaOverride.cjs.js');
var mergeDatabaseConfig = require('./mergeDatabaseConfig.cjs.js');
var format = require('pg-format');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var knexFactory__default = /*#__PURE__*/_interopDefaultCompat(knexFactory);
var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
var format__default = /*#__PURE__*/_interopDefaultCompat(format);

const ddlLimiter = limiterFactory__default.default(1);
async function createPgDatabaseClient(dbConfig, overrides) {
  const knexConfig = await buildPgDatabaseConfig(dbConfig, overrides);
  const database = knexFactory__default.default(knexConfig);
  const role = dbConfig.getOptionalString("role");
  if (role) {
    database.client.pool.on(
      "createSuccess",
      async (_event, pgClient) => {
        const query = format__default.default("SET ROLE %I", role);
        await pgClient.query(query);
      }
    );
  }
  return database;
}
async function buildPgDatabaseConfig(dbConfig, overrides) {
  const config = mergeDatabaseConfig.mergeDatabaseConfig(
    dbConfig.get(),
    {
      connection: getPgConnectionConfig(dbConfig, !!overrides),
      useNullAsDefault: true
    },
    overrides
  );
  const sanitizedConfig = JSON.parse(JSON.stringify(config));
  delete sanitizedConfig.connection.type;
  delete sanitizedConfig.connection.instance;
  if (config.connection.type === "default" || !config.connection.type) {
    return sanitizedConfig;
  }
  if (config.connection.type !== "cloudsql") {
    throw new Error(`Unknown connection type: ${config.connection.type}`);
  }
  if (config.client !== "pg") {
    throw new Error("Cloud SQL only supports the pg client");
  }
  if (!config.connection.instance) {
    throw new Error("Missing instance connection name for Cloud SQL");
  }
  const {
    Connector: CloudSqlConnector,
    IpAddressTypes,
    AuthTypes
  } = await import('@google-cloud/cloud-sql-connector');
  const connector = new CloudSqlConnector();
  const clientOpts = await connector.getOptions({
    instanceConnectionName: config.connection.instance,
    ipType: IpAddressTypes.PUBLIC,
    authType: AuthTypes.IAM
  });
  return {
    ...sanitizedConfig,
    client: "pg",
    connection: {
      ...sanitizedConfig.connection,
      ...clientOpts
    }
  };
}
function getPgConnectionConfig(dbConfig, parseConnectionString) {
  const connection = dbConfig.get("connection");
  const isConnectionString = typeof connection === "string" || connection instanceof String;
  const autoParse = typeof parseConnectionString !== "boolean";
  const shouldParseConnectionString = autoParse ? isConnectionString : parseConnectionString && isConnectionString;
  return shouldParseConnectionString ? parsePgConnectionString(connection) : connection;
}
function parsePgConnectionString(connectionString) {
  const parse = requirePgConnectionString();
  return parse(connectionString);
}
function requirePgConnectionString() {
  try {
    return require("pg-connection-string").parse;
  } catch (e) {
    throw new errors.ForwardedError("Postgres: Install 'pg-connection-string'", e);
  }
}
async function ensurePgDatabaseExists(dbConfig, ...databases) {
  const admin = await createPgDatabaseClient(dbConfig, {
    connection: {
      database: "postgres"
    },
    pool: {
      min: 0,
      acquireTimeoutMillis: 1e4
    }
  });
  try {
    const ensureDatabase = async (database) => {
      const result = await admin.from("pg_database").where("datname", database).count();
      if (parseInt(result[0].count, 10) > 0) {
        return;
      }
      await admin.raw(`CREATE DATABASE ??`, [database]);
    };
    await Promise.all(
      databases.map(async (database) => {
        let lastErr = void 0;
        for (let i = 0; i < 3; i++) {
          try {
            return await ddlLimiter(() => ensureDatabase(database));
          } catch (err) {
            lastErr = err;
          }
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        throw lastErr;
      })
    );
  } finally {
    await admin.destroy();
  }
}
async function ensurePgSchemaExists(dbConfig, ...schemas) {
  const admin = await createPgDatabaseClient(dbConfig);
  const role = dbConfig.getOptionalString("role");
  try {
    const ensureSchema = async (database) => {
      if (role) {
        await admin.raw(`CREATE SCHEMA IF NOT EXISTS ?? AUTHORIZATION ??`, [
          database,
          role
        ]);
      } else {
        await admin.raw(`CREATE SCHEMA IF NOT EXISTS ??`, [database]);
      }
    };
    await Promise.all(
      schemas.map((database) => ddlLimiter(() => ensureSchema(database)))
    );
  } finally {
    await admin.destroy();
  }
}
function pluginPath(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parsePgConnectionString(connection) : connection;
}
class PgConnector {
  constructor(config, prefix) {
    this.config = config;
    this.prefix = prefix;
  }
  async getClient(pluginId, _deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const databaseName = this.getDatabaseName(pluginId);
    if (databaseName && this.getEnsureExistsConfig(pluginId)) {
      try {
        await ensurePgDatabaseExists(pluginConfig, databaseName);
      } catch (error) {
        throw new Error(
          `Failed to connect to the database to make sure that '${databaseName}' exists, ${error}`
        );
      }
    }
    let schemaOverrides;
    if (this.getPluginDivisionModeConfig() === "schema") {
      schemaOverrides = defaultSchemaOverride.default(pluginId);
      if (this.getEnsureSchemaExistsConfig(pluginId) || this.getEnsureExistsConfig(pluginId)) {
        try {
          await ensurePgSchemaExists(pluginConfig, pluginId);
        } catch (error) {
          throw new Error(
            `Failed to connect to the database to make sure that schema for plugin '${pluginId}' exists, ${error}`
          );
        }
      }
    }
    const databaseClientOverrides = mergeDatabaseConfig.mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId),
      schemaOverrides
    );
    const client = createPgDatabaseClient(
      pluginConfig,
      databaseClientOverrides
    );
    return client;
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using global
   * and plugin specific database config. If no explicit database name is configured
   * and `pluginDivisionMode` is not `schema`, this method will provide a generated name
   * which is the pluginId prefixed with 'backstage_plugin_'. If `pluginDivisionMode` is
   * `schema`, it will fallback to using the default database for the knex instance.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const databaseName = connection?.database;
    if (this.getPluginDivisionModeConfig() === "schema") {
      return databaseName;
    }
    return databaseName ?? `${this.prefix}${pluginId}`;
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getEnsureExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureExists") ?? true;
    return this.config.getOptionalBoolean(`${pluginPath(pluginId)}.ensureExists`) ?? baseConfig;
  }
  getEnsureSchemaExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureSchemaExists") ?? false;
    return this.config.getOptionalBoolean(
      `${pluginPath(pluginId)}.getEnsureSchemaExistsConfig`
    ) ?? baseConfig;
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted
   * unless `pluginDivisionMode` is set to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection(this.config.get("connection"));
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection(
      this.config.getOptional(`${pluginPath(pluginId)}.connection`)
    );
    baseConnection.application_name ||= `backstage_plugin_${pluginId}`;
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`• database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? defaultNameOverride.default(databaseName) : {};
  }
}

exports.PgConnector = PgConnector;
exports.buildPgDatabaseConfig = buildPgDatabaseConfig;
exports.createPgDatabaseClient = createPgDatabaseClient;
exports.ensurePgDatabaseExists = ensurePgDatabaseExists;
exports.ensurePgSchemaExists = ensurePgSchemaExists;
exports.getPgConnectionConfig = getPgConnectionConfig;
exports.parsePgConnectionString = parsePgConnectionString;
//# sourceMappingURL=postgres.cjs.js.map
