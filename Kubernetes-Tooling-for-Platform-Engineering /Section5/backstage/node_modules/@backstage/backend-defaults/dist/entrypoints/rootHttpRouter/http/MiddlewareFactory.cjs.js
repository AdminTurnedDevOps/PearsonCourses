'use strict';

var cors = require('cors');
var helmet = require('helmet');
var compression = require('compression');
var readHelmetOptions = require('./readHelmetOptions.cjs.js');
var readCorsOptions = require('./readCorsOptions.cjs.js');
var errors = require('@backstage/errors');
var applyInternalErrorFilter = require('./applyInternalErrorFilter.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var cors__default = /*#__PURE__*/_interopDefaultCompat(cors);
var helmet__default = /*#__PURE__*/_interopDefaultCompat(helmet);
var compression__default = /*#__PURE__*/_interopDefaultCompat(compression);

function getLogMeta(req, res) {
  const referrer = req.headers.referer ?? req.headers.referrer;
  const userAgent = req.headers["user-agent"];
  const contentLength = Number(res.getHeader("content-length"));
  const meta = {
    date: (/* @__PURE__ */ new Date()).toISOString(),
    method: req.method,
    url: req.originalUrl ?? req.url,
    status: res.statusCode,
    httpVersion: `${req.httpVersionMajor}.${req.httpVersionMinor}`
  };
  if (userAgent) {
    meta.userAgent = userAgent;
  }
  if (isFinite(contentLength)) {
    meta.contentLength = contentLength;
  }
  if (referrer) {
    meta.referrer = Array.isArray(referrer) ? referrer.join(", ") : referrer;
  }
  return meta;
}
class MiddlewareFactory {
  #config;
  #logger;
  /**
   * Creates a new {@link MiddlewareFactory}.
   */
  static create(options) {
    return new MiddlewareFactory(options);
  }
  constructor(options) {
    this.#config = options.config;
    this.#logger = options.logger;
  }
  /**
   * Returns a middleware that unconditionally produces a 404 error response.
   *
   * @remarks
   *
   * Typically you want to place this middleware at the end of the chain, such
   * that it's the last one attempted after no other routes matched.
   *
   * @returns An Express request handler
   */
  notFound() {
    return (_req, res) => {
      res.status(404).end();
    };
  }
  /**
   * Returns the compression middleware.
   *
   * @remarks
   *
   * The middleware will attempt to compress response bodies for all requests
   * that traverse through the middleware.
   */
  compression() {
    return compression__default.default();
  }
  /**
   * Returns a request logging middleware.
   *
   * @remarks
   *
   * Typically you want to place this middleware at the start of the chain, such
   * that it always logs requests whether they are "caught" by handlers farther
   * down or not.
   *
   * @returns An Express request handler
   */
  logging() {
    const logger = this.#logger;
    return (req, res, next) => {
      res.on("finish", () => {
        const meta = getLogMeta(req, res);
        logger.info(
          `[${meta.date}] "${meta.method} ${meta.url} HTTP/${meta.httpVersion}" ${meta.status} ${meta.contentLength ?? 0} "${meta.referrer ?? "-"}" "${meta.userAgent ?? "-"}"`,
          {
            type: "incomingRequest",
            ...meta
          }
        );
      });
      next();
    };
  }
  /**
   * Returns a middleware that implements the helmet library.
   *
   * @remarks
   *
   * This middleware applies security policies to incoming requests and outgoing
   * responses. It is configured using config keys such as `backend.csp`.
   *
   * @see {@link https://helmetjs.github.io/}
   *
   * @returns An Express request handler
   */
  helmet() {
    return helmet__default.default(readHelmetOptions.readHelmetOptions(this.#config.getOptionalConfig("backend")));
  }
  /**
   * Returns a middleware that implements the cors library.
   *
   * @remarks
   *
   * This middleware handles CORS. It is configured using the config key
   * `backend.cors`.
   *
   * @see {@link https://github.com/expressjs/cors}
   *
   * @returns An Express request handler
   */
  cors() {
    return cors__default.default(readCorsOptions.readCorsOptions(this.#config.getOptionalConfig("backend")));
  }
  /**
   * Express middleware to handle errors during request processing.
   *
   * @remarks
   *
   * This is commonly the very last middleware in the chain.
   *
   * Its primary purpose is not to do translation of business logic exceptions,
   * but rather to be a global catch-all for uncaught "fatal" errors that are
   * expected to result in a 500 error. However, it also does handle some common
   * error types (such as http-error exceptions, and the well-known error types
   * in the `@backstage/errors` package) and returns the enclosed status code
   * accordingly.
   *
   * It will also produce a response body with a serialized form of the error,
   * unless a previous handler already did send a body. See
   * {@link @backstage/errors#ErrorResponseBody} for the response shape used.
   *
   * @returns An Express error request handler
   */
  error(options = {}) {
    const showStackTraces = options.showStackTraces ?? process.env.NODE_ENV === "development";
    const logger = this.#logger.child({
      type: "errorHandler"
    });
    return (rawError, req, res, next) => {
      const error = applyInternalErrorFilter.applyInternalErrorFilter(rawError, logger);
      const statusCode = getStatusCode(error);
      if (options.logAllErrors || statusCode >= 500) {
        logger.error(`Request failed with status ${statusCode}`, error);
      }
      if (res.headersSent) {
        next(error);
        return;
      }
      const body = {
        error: errors.serializeError(error, { includeStack: showStackTraces }),
        request: { method: req.method, url: req.url },
        response: { statusCode }
      };
      res.status(statusCode).json(body);
    };
  }
}
function getStatusCode(error) {
  const knownStatusCodeFields = ["statusCode", "status"];
  for (const field of knownStatusCodeFields) {
    const statusCode = error[field];
    if (typeof statusCode === "number" && (statusCode | 0) === statusCode && // is whole integer
    statusCode >= 100 && statusCode <= 599) {
      return statusCode;
    }
  }
  switch (error.name) {
    case errors.NotModifiedError.name:
      return 304;
    case errors.InputError.name:
      return 400;
    case errors.AuthenticationError.name:
      return 401;
    case errors.NotAllowedError.name:
      return 403;
    case errors.NotFoundError.name:
      return 404;
    case errors.ConflictError.name:
      return 409;
    case errors.NotImplementedError.name:
      return 501;
    case errors.ServiceUnavailableError.name:
      return 503;
  }
  return 500;
}

exports.MiddlewareFactory = MiddlewareFactory;
//# sourceMappingURL=MiddlewareFactory.cjs.js.map
