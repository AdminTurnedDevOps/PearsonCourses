'use strict';

var integration = require('@backstage/integration');
var ReadUrlResponseFactory = require('./ReadUrlResponseFactory.cjs.js');
var errors = require('@backstage/errors');
var stream = require('stream');
var util = require('./util.cjs.js');

class GiteaUrlReader {
  constructor(integration, deps) {
    this.integration = integration;
    this.deps = deps;
  }
  static factory = ({ config, treeResponseFactory }) => {
    return integration.ScmIntegrations.fromConfig(config).gitea.list().map((integration) => {
      const reader = new GiteaUrlReader(integration, { treeResponseFactory });
      const predicate = (url) => {
        return url.host === integration.config.host;
      };
      return { reader, predicate };
    });
  };
  async read(url) {
    const response = await this.readUrl(url);
    return response.buffer();
  }
  async readUrl(url, options) {
    let response;
    const blobUrl = integration.getGiteaFileContentsUrl(this.integration.config, url);
    try {
      response = await fetch(blobUrl, {
        method: "GET",
        ...integration.getGiteaRequestOptions(this.integration.config),
        signal: options?.signal
      });
    } catch (e) {
      throw new Error(`Unable to read ${blobUrl}, ${e}`);
    }
    if (response.ok) {
      const { encoding, content } = await response.json();
      if (encoding === "base64") {
        return ReadUrlResponseFactory.ReadUrlResponseFactory.fromReadable(
          stream.Readable.from(Buffer.from(content, "base64")),
          {
            etag: response.headers.get("ETag") ?? void 0,
            lastModifiedAt: util.parseLastModified(
              response.headers.get("Last-Modified")
            )
          }
        );
      }
      throw new Error(`Unknown encoding: ${encoding}`);
    }
    const message = `${url} could not be read as ${blobUrl}, ${response.status} ${response.statusText}`;
    if (response.status === 404) {
      throw new errors.NotFoundError(message);
    }
    if (response.status === 304) {
      throw new errors.NotModifiedError();
    }
    if (response.status === 403) {
      throw new errors.AuthenticationError();
    }
    throw new Error(message);
  }
  async readTree(url, options) {
    const lastCommitHash = await this.getLastCommitHash(url);
    if (options?.etag && options.etag === lastCommitHash) {
      throw new errors.NotModifiedError();
    }
    const archiveUri = integration.getGiteaArchiveUrl(this.integration.config, url);
    let response;
    try {
      response = await fetch(archiveUri, {
        method: "GET",
        ...integration.getGiteaRequestOptions(this.integration.config),
        signal: options?.signal
      });
    } catch (e) {
      throw new Error(`Unable to read ${archiveUri}, ${e}`);
    }
    const parsedUri = integration.parseGiteaUrl(this.integration.config, url);
    return this.deps.treeResponseFactory.fromTarArchive({
      response,
      subpath: parsedUri.path,
      etag: lastCommitHash,
      filter: options?.filter
    });
  }
  search() {
    throw new Error("GiteaUrlReader search not implemented.");
  }
  toString() {
    const { host } = this.integration.config;
    return `gitea{host=${host},authed=${Boolean(
      this.integration.config.password
    )}}`;
  }
  async getLastCommitHash(url) {
    const commitUri = integration.getGiteaLatestCommitUrl(this.integration.config, url);
    const response = await fetch(
      commitUri,
      integration.getGiteaRequestOptions(this.integration.config)
    );
    if (!response.ok) {
      const message = `Failed to retrieve latest commit information from ${commitUri}, ${response.status} ${response.statusText}`;
      if (response.status === 404) {
        throw new errors.NotFoundError(message);
      }
      throw new Error(message);
    }
    return (await response.json()).sha;
  }
}

exports.GiteaUrlReader = GiteaUrlReader;
//# sourceMappingURL=GiteaUrlReader.cjs.js.map
