'use strict';

var concatStream = require('concat-stream');
var fs = require('fs-extra');
var platformPath = require('path');
var stream = require('stream');
var tar = require('tar');
var util = require('util');
var util$1 = require('./util.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var concatStream__default = /*#__PURE__*/_interopDefaultCompat(concatStream);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);
var tar__default = /*#__PURE__*/_interopDefaultCompat(tar);

const TarParseStream = tar.Parse;
const pipeline = util.promisify(stream.pipeline);
class TarArchiveResponse {
  constructor(stream, subPath, workDir, etag, filter, stripFirstDirectory = true) {
    this.stream = stream;
    this.subPath = subPath;
    this.workDir = workDir;
    this.etag = etag;
    this.filter = filter;
    this.stripFirstDirectory = stripFirstDirectory;
    if (subPath) {
      if (!subPath.endsWith("/")) {
        this.subPath += "/";
      }
      if (subPath.startsWith("/")) {
        throw new TypeError(
          `TarArchiveResponse subPath must not start with a /, got '${subPath}'`
        );
      }
    }
    this.etag = etag;
  }
  read = false;
  // Make sure the input stream is only read once
  onlyOnce() {
    if (this.read) {
      throw new Error("Response has already been read");
    }
    this.read = true;
  }
  async files() {
    this.onlyOnce();
    const files = Array();
    const parser = new TarParseStream();
    parser.on("entry", (entry) => {
      if (entry.type === "Directory") {
        entry.resume();
        return;
      }
      const relativePath = this.stripFirstDirectory ? util$1.stripFirstDirectoryFromPath(entry.path) : entry.path;
      if (this.subPath) {
        if (!relativePath.startsWith(this.subPath)) {
          entry.resume();
          return;
        }
      }
      const path = relativePath.slice(this.subPath.length);
      if (this.filter) {
        if (!this.filter(path, { size: entry.remain })) {
          entry.resume();
          return;
        }
      }
      const content = new Promise(async (resolve) => {
        await pipeline(entry, concatStream__default.default(resolve));
      });
      files.push({
        path,
        content: () => content
      });
      entry.resume();
    });
    await pipeline(this.stream, parser);
    return files;
  }
  async archive() {
    if (!this.subPath) {
      this.onlyOnce();
      return this.stream;
    }
    const tmpDir = await this.dir();
    try {
      const data = await new Promise(async (resolve) => {
        await pipeline(
          tar__default.default.create({ cwd: tmpDir }, [""]),
          concatStream__default.default(resolve)
        );
      });
      return stream.Readable.from(data);
    } finally {
      await fs__default.default.remove(tmpDir);
    }
  }
  async dir(options) {
    this.onlyOnce();
    const dir = options?.targetDir ?? await fs__default.default.mkdtemp(platformPath__default.default.join(this.workDir, "backstage-"));
    let strip = this.subPath ? this.subPath.split("/").length : 1;
    if (!this.stripFirstDirectory) {
      strip--;
    }
    let filterError = void 0;
    await pipeline(
      this.stream,
      tar__default.default.extract({
        strip,
        cwd: dir,
        filter: (path, stat) => {
          if (filterError) {
            return false;
          }
          const relativePath = this.stripFirstDirectory ? util$1.stripFirstDirectoryFromPath(path) : path;
          if (this.subPath && !relativePath.startsWith(this.subPath)) {
            return false;
          }
          if (this.filter) {
            const innerPath = path.split("/").slice(strip).join("/");
            try {
              return this.filter(innerPath, { size: stat.size });
            } catch (error) {
              filterError = error;
              return false;
            }
          }
          return true;
        }
      })
    );
    if (filterError) {
      if (!options?.targetDir) {
        await fs__default.default.remove(dir).catch(() => {
        });
      }
      throw filterError;
    }
    return dir;
  }
}

exports.TarArchiveResponse = TarArchiveResponse;
//# sourceMappingURL=TarArchiveResponse.cjs.js.map
