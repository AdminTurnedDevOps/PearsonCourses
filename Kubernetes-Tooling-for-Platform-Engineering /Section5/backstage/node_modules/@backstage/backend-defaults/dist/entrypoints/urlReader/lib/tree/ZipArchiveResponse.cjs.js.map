{"version":3,"file":"ZipArchiveResponse.cjs.js","sources":["../../../../../src/entrypoints/urlReader/lib/tree/ZipArchiveResponse.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  UrlReaderServiceReadTreeResponse,\n  UrlReaderServiceReadTreeResponseDirOptions,\n  UrlReaderServiceReadTreeResponseFile,\n} from '@backstage/backend-plugin-api';\nimport archiver from 'archiver';\nimport yauzl, { Entry } from 'yauzl';\nimport fs from 'fs-extra';\nimport platformPath from 'path';\nimport { Readable } from 'stream';\nimport { streamToBuffer } from './util';\nimport { resolveSafeChildPath } from '@backstage/backend-plugin-api';\n\n/**\n * Wraps a zip archive stream into a tree response reader.\n */\nexport class ZipArchiveResponse implements UrlReaderServiceReadTreeResponse {\n  private read = false;\n\n  constructor(\n    private readonly stream: Readable,\n    private readonly subPath: string,\n    private readonly workDir: string,\n    public readonly etag: string,\n    private readonly filter?: (path: string, info: { size: number }) => boolean,\n  ) {\n    if (subPath) {\n      if (!subPath.endsWith('/')) {\n        this.subPath += '/';\n      }\n      if (subPath.startsWith('/')) {\n        throw new TypeError(\n          `ZipArchiveResponse subPath must not start with a /, got '${subPath}'`,\n        );\n      }\n    }\n\n    this.etag = etag;\n  }\n\n  // Make sure the input stream is only read once\n  private onlyOnce() {\n    if (this.read) {\n      throw new Error('Response has already been read');\n    }\n    this.read = true;\n  }\n\n  // File path relative to the root extracted directory or a sub directory if subpath is set.\n  private getInnerPath(path: string): string {\n    return path.slice(this.subPath.length);\n  }\n\n  private shouldBeIncluded(entry: Entry): boolean {\n    if (this.subPath) {\n      if (!entry.fileName.startsWith(this.subPath)) {\n        return false;\n      }\n    }\n    if (this.filter) {\n      return this.filter(this.getInnerPath(entry.fileName), {\n        size: entry.uncompressedSize,\n      });\n    }\n    return true;\n  }\n\n  private async streamToTemporaryFile(\n    stream: Readable,\n  ): Promise<{ fileName: string; cleanup: () => Promise<void> }> {\n    const tmpDir = await fs.mkdtemp(\n      platformPath.join(this.workDir, 'backstage-tmp'),\n    );\n    const tmpFile = platformPath.join(tmpDir, 'tmp.zip');\n\n    const writeStream = fs.createWriteStream(tmpFile);\n\n    return new Promise((resolve, reject) => {\n      writeStream.on('error', reject);\n      writeStream.on('finish', () => {\n        writeStream.end();\n        resolve({\n          fileName: tmpFile,\n          cleanup: () => fs.rm(tmpDir, { recursive: true }),\n        });\n      });\n      stream.pipe(writeStream);\n    });\n  }\n\n  private forEveryZipEntry(\n    zip: string,\n    callback: (entry: Entry, content: Readable) => Promise<void>,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      yauzl.open(zip, { lazyEntries: true }, (err, zipfile) => {\n        if (err || !zipfile) {\n          reject(err || new Error(`Failed to open zip file ${zip}`));\n          return;\n        }\n\n        zipfile.on('entry', async (entry: Entry) => {\n          // Check that the file is not a directory, and that is matches the filter.\n          if (!entry.fileName.endsWith('/') && this.shouldBeIncluded(entry)) {\n            zipfile.openReadStream(entry, async (openErr, readStream) => {\n              if (openErr || !readStream) {\n                reject(\n                  openErr ||\n                    new Error(`Failed to open zip entry ${entry.fileName}`),\n                );\n                return;\n              }\n\n              await callback(entry, readStream);\n              zipfile.readEntry();\n            });\n          } else {\n            zipfile.readEntry();\n          }\n        });\n        zipfile.once('end', () => resolve());\n        zipfile.on('error', e => reject(e));\n        zipfile.readEntry();\n      });\n    });\n  }\n\n  async files(): Promise<UrlReaderServiceReadTreeResponseFile[]> {\n    this.onlyOnce();\n    const files = Array<UrlReaderServiceReadTreeResponseFile>();\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      files.push({\n        path: this.getInnerPath(entry.fileName),\n        content: async () => await streamToBuffer(content),\n        lastModifiedAt: entry.lastModFileTime\n          ? new Date(entry.lastModFileTime)\n          : undefined,\n      });\n    });\n\n    await temporary.cleanup();\n\n    return files;\n  }\n\n  async archive(): Promise<Readable> {\n    this.onlyOnce();\n\n    if (!this.subPath) {\n      return this.stream;\n    }\n\n    const archive = archiver('zip');\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      archive.append(await streamToBuffer(content), {\n        name: this.getInnerPath(entry.fileName),\n      });\n    });\n\n    archive.finalize();\n\n    await temporary.cleanup();\n\n    return archive;\n  }\n\n  async dir(\n    options?: UrlReaderServiceReadTreeResponseDirOptions,\n  ): Promise<string> {\n    this.onlyOnce();\n    const dir =\n      options?.targetDir ??\n      (await fs.mkdtemp(platformPath.join(this.workDir, 'backstage-')));\n\n    const temporary = await this.streamToTemporaryFile(this.stream);\n\n    await this.forEveryZipEntry(temporary.fileName, async (entry, content) => {\n      const entryPath = this.getInnerPath(entry.fileName);\n      const dirname = platformPath.dirname(entryPath);\n\n      if (dirname) {\n        await fs.mkdirp(resolveSafeChildPath(dir, dirname));\n      }\n      return new Promise(async (resolve, reject) => {\n        const file = fs.createWriteStream(resolveSafeChildPath(dir, entryPath));\n        file.on('finish', resolve);\n\n        content.on('error', reject);\n        content.pipe(file);\n      });\n    });\n\n    await temporary.cleanup();\n\n    return dir;\n  }\n}\n"],"names":["fs","platformPath","yauzl","streamToBuffer","archiver","resolveSafeChildPath"],"mappings":";;;;;;;;;;;;;;;;AAgCO,MAAM,kBAA+D,CAAA;AAAA,EAG1E,WACmB,CAAA,MAAA,EACA,OACA,EAAA,OAAA,EACD,MACC,MACjB,EAAA;AALiB,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,OAAA,GAAA,OAAA;AACA,IAAA,IAAA,CAAA,OAAA,GAAA,OAAA;AACD,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AACC,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAEjB,IAAA,IAAI,OAAS,EAAA;AACX,MAAA,IAAI,CAAC,OAAA,CAAQ,QAAS,CAAA,GAAG,CAAG,EAAA;AAC1B,QAAA,IAAA,CAAK,OAAW,IAAA,GAAA;AAAA;AAElB,MAAI,IAAA,OAAA,CAAQ,UAAW,CAAA,GAAG,CAAG,EAAA;AAC3B,QAAA,MAAM,IAAI,SAAA;AAAA,UACR,4DAA4D,OAAO,CAAA,CAAA;AAAA,SACrE;AAAA;AACF;AAGF,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA;AAAA;AACd,EArBQ,IAAO,GAAA,KAAA;AAAA;AAAA,EAwBP,QAAW,GAAA;AACjB,IAAA,IAAI,KAAK,IAAM,EAAA;AACb,MAAM,MAAA,IAAI,MAAM,gCAAgC,CAAA;AAAA;AAElD,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA;AAAA;AACd;AAAA,EAGQ,aAAa,IAAsB,EAAA;AACzC,IAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,OAAA,CAAQ,MAAM,CAAA;AAAA;AACvC,EAEQ,iBAAiB,KAAuB,EAAA;AAC9C,IAAA,IAAI,KAAK,OAAS,EAAA;AAChB,MAAA,IAAI,CAAC,KAAM,CAAA,QAAA,CAAS,UAAW,CAAA,IAAA,CAAK,OAAO,CAAG,EAAA;AAC5C,QAAO,OAAA,KAAA;AAAA;AACT;AAEF,IAAA,IAAI,KAAK,MAAQ,EAAA;AACf,MAAA,OAAO,KAAK,MAAO,CAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,QAAQ,CAAG,EAAA;AAAA,QACpD,MAAM,KAAM,CAAA;AAAA,OACb,CAAA;AAAA;AAEH,IAAO,OAAA,IAAA;AAAA;AACT,EAEA,MAAc,sBACZ,MAC6D,EAAA;AAC7D,IAAM,MAAA,MAAA,GAAS,MAAMA,mBAAG,CAAA,OAAA;AAAA,MACtBC,6BAAa,CAAA,IAAA,CAAK,IAAK,CAAA,OAAA,EAAS,eAAe;AAAA,KACjD;AACA,IAAA,MAAM,OAAU,GAAAA,6BAAA,CAAa,IAAK,CAAA,MAAA,EAAQ,SAAS,CAAA;AAEnD,IAAM,MAAA,WAAA,GAAcD,mBAAG,CAAA,iBAAA,CAAkB,OAAO,CAAA;AAEhD,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAW,KAAA;AACtC,MAAY,WAAA,CAAA,EAAA,CAAG,SAAS,MAAM,CAAA;AAC9B,MAAY,WAAA,CAAA,EAAA,CAAG,UAAU,MAAM;AAC7B,QAAA,WAAA,CAAY,GAAI,EAAA;AAChB,QAAQ,OAAA,CAAA;AAAA,UACN,QAAU,EAAA,OAAA;AAAA,UACV,OAAA,EAAS,MAAMA,mBAAG,CAAA,EAAA,CAAG,QAAQ,EAAE,SAAA,EAAW,MAAM;AAAA,SACjD,CAAA;AAAA,OACF,CAAA;AACD,MAAA,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA,KACxB,CAAA;AAAA;AACH,EAEQ,gBAAA,CACN,KACA,QACe,EAAA;AACf,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAAW,KAAA;AACtC,MAAME,sBAAA,CAAA,IAAA,CAAK,KAAK,EAAE,WAAA,EAAa,MAAQ,EAAA,CAAC,KAAK,OAAY,KAAA;AACvD,QAAI,IAAA,GAAA,IAAO,CAAC,OAAS,EAAA;AACnB,UAAA,MAAA,CAAO,OAAO,IAAI,KAAA,CAAM,CAA2B,wBAAA,EAAA,GAAG,EAAE,CAAC,CAAA;AACzD,UAAA;AAAA;AAGF,QAAQ,OAAA,CAAA,EAAA,CAAG,OAAS,EAAA,OAAO,KAAiB,KAAA;AAE1C,UAAI,IAAA,CAAC,MAAM,QAAS,CAAA,QAAA,CAAS,GAAG,CAAK,IAAA,IAAA,CAAK,gBAAiB,CAAA,KAAK,CAAG,EAAA;AACjE,YAAA,OAAA,CAAQ,cAAe,CAAA,KAAA,EAAO,OAAO,OAAA,EAAS,UAAe,KAAA;AAC3D,cAAI,IAAA,OAAA,IAAW,CAAC,UAAY,EAAA;AAC1B,gBAAA,MAAA;AAAA,kBACE,WACE,IAAI,KAAA,CAAM,CAA4B,yBAAA,EAAA,KAAA,CAAM,QAAQ,CAAE,CAAA;AAAA,iBAC1D;AACA,gBAAA;AAAA;AAGF,cAAM,MAAA,QAAA,CAAS,OAAO,UAAU,CAAA;AAChC,cAAA,OAAA,CAAQ,SAAU,EAAA;AAAA,aACnB,CAAA;AAAA,WACI,MAAA;AACL,YAAA,OAAA,CAAQ,SAAU,EAAA;AAAA;AACpB,SACD,CAAA;AACD,QAAA,OAAA,CAAQ,IAAK,CAAA,KAAA,EAAO,MAAM,OAAA,EAAS,CAAA;AACnC,QAAA,OAAA,CAAQ,EAAG,CAAA,OAAA,EAAS,CAAK,CAAA,KAAA,MAAA,CAAO,CAAC,CAAC,CAAA;AAClC,QAAA,OAAA,CAAQ,SAAU,EAAA;AAAA,OACnB,CAAA;AAAA,KACF,CAAA;AAAA;AACH,EAEA,MAAM,KAAyD,GAAA;AAC7D,IAAA,IAAA,CAAK,QAAS,EAAA;AACd,IAAA,MAAM,QAAQ,KAA4C,EAAA;AAC1D,IAAA,MAAM,SAAY,GAAA,MAAM,IAAK,CAAA,qBAAA,CAAsB,KAAK,MAAM,CAAA;AAE9D,IAAA,MAAM,KAAK,gBAAiB,CAAA,SAAA,CAAU,QAAU,EAAA,OAAO,OAAO,OAAY,KAAA;AACxE,MAAA,KAAA,CAAM,IAAK,CAAA;AAAA,QACT,IAAM,EAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,QAAQ,CAAA;AAAA,QACtC,OAAS,EAAA,YAAY,MAAMC,mBAAA,CAAe,OAAO,CAAA;AAAA,QACjD,gBAAgB,KAAM,CAAA,eAAA,GAClB,IAAI,IAAK,CAAA,KAAA,CAAM,eAAe,CAC9B,GAAA,KAAA;AAAA,OACL,CAAA;AAAA,KACF,CAAA;AAED,IAAA,MAAM,UAAU,OAAQ,EAAA;AAExB,IAAO,OAAA,KAAA;AAAA;AACT,EAEA,MAAM,OAA6B,GAAA;AACjC,IAAA,IAAA,CAAK,QAAS,EAAA;AAEd,IAAI,IAAA,CAAC,KAAK,OAAS,EAAA;AACjB,MAAA,OAAO,IAAK,CAAA,MAAA;AAAA;AAGd,IAAM,MAAA,OAAA,GAAUC,0BAAS,KAAK,CAAA;AAC9B,IAAA,MAAM,SAAY,GAAA,MAAM,IAAK,CAAA,qBAAA,CAAsB,KAAK,MAAM,CAAA;AAE9D,IAAA,MAAM,KAAK,gBAAiB,CAAA,SAAA,CAAU,QAAU,EAAA,OAAO,OAAO,OAAY,KAAA;AACxE,MAAA,OAAA,CAAQ,MAAO,CAAA,MAAMD,mBAAe,CAAA,OAAO,CAAG,EAAA;AAAA,QAC5C,IAAM,EAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,QAAQ;AAAA,OACvC,CAAA;AAAA,KACF,CAAA;AAED,IAAA,OAAA,CAAQ,QAAS,EAAA;AAEjB,IAAA,MAAM,UAAU,OAAQ,EAAA;AAExB,IAAO,OAAA,OAAA;AAAA;AACT,EAEA,MAAM,IACJ,OACiB,EAAA;AACjB,IAAA,IAAA,CAAK,QAAS,EAAA;AACd,IAAM,MAAA,GAAA,GACJ,OAAS,EAAA,SAAA,IACR,MAAMH,mBAAA,CAAG,OAAQ,CAAAC,6BAAA,CAAa,IAAK,CAAA,IAAA,CAAK,OAAS,EAAA,YAAY,CAAC,CAAA;AAEjE,IAAA,MAAM,SAAY,GAAA,MAAM,IAAK,CAAA,qBAAA,CAAsB,KAAK,MAAM,CAAA;AAE9D,IAAA,MAAM,KAAK,gBAAiB,CAAA,SAAA,CAAU,QAAU,EAAA,OAAO,OAAO,OAAY,KAAA;AACxE,MAAA,MAAM,SAAY,GAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAM,QAAQ,CAAA;AAClD,MAAM,MAAA,OAAA,GAAUA,6BAAa,CAAA,OAAA,CAAQ,SAAS,CAAA;AAE9C,MAAA,IAAI,OAAS,EAAA;AACX,QAAA,MAAMD,mBAAG,CAAA,MAAA,CAAOK,qCAAqB,CAAA,GAAA,EAAK,OAAO,CAAC,CAAA;AAAA;AAEpD,MAAA,OAAO,IAAI,OAAA,CAAQ,OAAO,OAAA,EAAS,MAAW,KAAA;AAC5C,QAAA,MAAM,OAAOL,mBAAG,CAAA,iBAAA,CAAkBK,qCAAqB,CAAA,GAAA,EAAK,SAAS,CAAC,CAAA;AACtE,QAAK,IAAA,CAAA,EAAA,CAAG,UAAU,OAAO,CAAA;AAEzB,QAAQ,OAAA,CAAA,EAAA,CAAG,SAAS,MAAM,CAAA;AAC1B,QAAA,OAAA,CAAQ,KAAK,IAAI,CAAA;AAAA,OAClB,CAAA;AAAA,KACF,CAAA;AAED,IAAA,MAAM,UAAU,OAAQ,EAAA;AAExB,IAAO,OAAA,GAAA;AAAA;AAEX;;;;"}