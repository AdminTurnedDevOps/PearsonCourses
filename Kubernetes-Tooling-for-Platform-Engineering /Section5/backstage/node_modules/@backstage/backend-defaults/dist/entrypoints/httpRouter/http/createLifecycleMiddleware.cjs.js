'use strict';

var config = require('@backstage/config');
var errors = require('@backstage/errors');
var types = require('@backstage/types');

const DEFAULT_TIMEOUT = { seconds: 5 };
function createLifecycleMiddleware(options) {
  const { config: config$1, lifecycle } = options;
  let state = "init";
  const waiting = /* @__PURE__ */ new Set();
  lifecycle.addStartupHook(async () => {
    if (state === "init") {
      state = "up";
      for (const item of waiting) {
        clearTimeout(item.timeout);
        item.next();
      }
      waiting.clear();
    }
  });
  lifecycle.addShutdownHook(async () => {
    state = "down";
    for (const item of waiting) {
      clearTimeout(item.timeout);
      item.next(new errors.ServiceUnavailableError("Service is shutting down"));
    }
    waiting.clear();
  });
  let startupRequestPauseTimeout = DEFAULT_TIMEOUT;
  if (config$1.has("backend.lifecycle.startupRequestPauseTimeout")) {
    startupRequestPauseTimeout = config.readDurationFromConfig(config$1, {
      key: "backend.lifecycle.startupRequestPauseTimeout"
    });
  }
  const timeoutMs = types.durationToMilliseconds(startupRequestPauseTimeout);
  return (_req, _res, next) => {
    if (state === "up") {
      next();
      return;
    } else if (state === "down") {
      next(new errors.ServiceUnavailableError("Service is shutting down"));
      return;
    }
    const item = {
      next,
      timeout: setTimeout(() => {
        if (waiting.delete(item)) {
          next(new errors.ServiceUnavailableError("Service has not started up yet"));
        }
      }, timeoutMs)
    };
    waiting.add(item);
  };
}

exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
exports.createLifecycleMiddleware = createLifecycleMiddleware;
//# sourceMappingURL=createLifecycleMiddleware.cjs.js.map
