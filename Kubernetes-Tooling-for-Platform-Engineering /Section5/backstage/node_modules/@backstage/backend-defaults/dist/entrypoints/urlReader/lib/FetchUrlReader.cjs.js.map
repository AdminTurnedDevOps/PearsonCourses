{"version":3,"file":"FetchUrlReader.cjs.js","sources":["../../../../src/entrypoints/urlReader/lib/FetchUrlReader.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  UrlReaderService,\n  UrlReaderServiceReadTreeResponse,\n  UrlReaderServiceReadUrlOptions,\n  UrlReaderServiceReadUrlResponse,\n  UrlReaderServiceSearchResponse,\n} from '@backstage/backend-plugin-api';\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport { ReaderFactory } from './types';\nimport path from 'path';\nimport { ReadUrlResponseFactory } from './ReadUrlResponseFactory';\n\nconst isInRange = (num: number, [start, end]: [number, number]) => {\n  return num >= start && num <= end;\n};\n\nconst parsePortRange = (port: string): [number, number] => {\n  const isRange = port.includes('-');\n  if (isRange) {\n    const range = port\n      .split('-')\n      .map(v => parseInt(v, 10))\n      .filter(Boolean) as [number, number];\n    if (range.length !== 2) throw new Error(`Port range is not valid: ${port}`);\n    const [start, end] = range;\n    if (start <= 0 || end <= 0 || start > end)\n      throw new Error(`Port range is not valid: [${start}, ${end}]`);\n    return range;\n  }\n  const parsedPort = parseInt(port, 10);\n  return [parsedPort, parsedPort];\n};\n\nconst parsePortPredicate = (port: string | undefined) => {\n  if (port) {\n    const range = parsePortRange(port);\n    return (url: URL) => {\n      if (url.port) return isInRange(parseInt(url.port, 10), range);\n\n      if (url.protocol === 'http:') return isInRange(80, range);\n      if (url.protocol === 'https:') return isInRange(443, range);\n      return false;\n    };\n  }\n  return (url: URL) => !url.port;\n};\n\n/**\n * A {@link @backstage/backend-plugin-api#UrlReaderService} that does a plain fetch of the URL.\n *\n * @public\n */\nexport class FetchUrlReader implements UrlReaderService {\n  /**\n   * The factory creates a single reader that will be used for reading any URL that's listed\n   * in configuration at `backend.reading.allow`. The allow list contains a list of objects describing\n   * targets to allow, containing the following fields:\n   *\n   * `host`:\n   *   Either full hostnames to match, or subdomain wildcard matchers with a leading '*'.\n   *   For example 'example.com' and '*.example.com' are valid values, 'prod.*.example.com' is not.\n   *\n   * `paths`:\n   *   An optional list of paths which are allowed. If the list is omitted all paths are allowed.\n   */\n  static factory: ReaderFactory = ({ config }) => {\n    const predicates =\n      config\n        .getOptionalConfigArray('backend.reading.allow')\n        ?.map(allowConfig => {\n          const paths = allowConfig.getOptionalStringArray('paths');\n          const checkPath = paths\n            ? (url: URL) => {\n                const targetPath = path.posix.normalize(url.pathname);\n                return paths.some(allowedPath =>\n                  targetPath.startsWith(allowedPath),\n                );\n              }\n            : (_url: URL) => true;\n          const host = allowConfig.getString('host');\n          const [hostname, port] = host.split(':');\n\n          const checkPort = parsePortPredicate(port);\n\n          if (hostname.startsWith('*.')) {\n            const suffix = hostname.slice(1);\n            return (url: URL) =>\n              url.hostname.endsWith(suffix) && checkPath(url) && checkPort(url);\n          }\n          return (url: URL) =>\n            url.hostname === hostname && checkPath(url) && checkPort(url);\n        }) ?? [];\n\n    const reader = new FetchUrlReader();\n    const predicate = (url: URL) => predicates.some(p => p(url));\n    return [{ reader, predicate }];\n  };\n\n  async read(url: string): Promise<Buffer> {\n    const response = await this.readUrl(url);\n    return response.buffer();\n  }\n\n  async readUrl(\n    url: string,\n    options?: UrlReaderServiceReadUrlOptions,\n  ): Promise<UrlReaderServiceReadUrlResponse> {\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          ...(options?.etag && { 'If-None-Match': options.etag }),\n          ...(options?.lastModifiedAfter && {\n            'If-Modified-Since': options.lastModifiedAfter.toUTCString(),\n          }),\n          ...(options?.token && { Authorization: `Bearer ${options.token}` }),\n        },\n        // TODO(freben): The signal cast is there because pre-3.x versions of\n        // node-fetch have a very slightly deviating AbortSignal type signature.\n        // The difference does not affect us in practice however. The cast can\n        // be removed after we support ESM for CLI dependencies and migrate to\n        // version 3 of node-fetch.\n        // https://github.com/backstage/backstage/issues/8242\n        signal: options?.signal as any,\n      });\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    if (response.status === 304) {\n      throw new NotModifiedError();\n    }\n\n    if (response.ok) {\n      return ReadUrlResponseFactory.fromResponse(response);\n    }\n\n    const message = `could not read ${url}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readTree(): Promise<UrlReaderServiceReadTreeResponse> {\n    throw new Error('FetchUrlReader does not implement readTree');\n  }\n\n  async search(): Promise<UrlReaderServiceSearchResponse> {\n    throw new Error('FetchUrlReader does not implement search');\n  }\n\n  toString() {\n    return 'fetch{}';\n  }\n}\n"],"names":["path","NotModifiedError","ReadUrlResponseFactory","NotFoundError"],"mappings":"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"}