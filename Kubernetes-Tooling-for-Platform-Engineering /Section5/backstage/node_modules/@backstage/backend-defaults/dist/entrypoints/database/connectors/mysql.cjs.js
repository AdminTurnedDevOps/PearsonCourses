'use strict';

var config = require('@backstage/config');
var errors = require('@backstage/errors');
var knexFactory = require('knex');
var lodash = require('lodash');
var limiterFactory = require('p-limit');
var yn = require('yn');
var defaultNameOverride = require('./defaultNameOverride.cjs.js');
var mergeDatabaseConfig = require('./mergeDatabaseConfig.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var knexFactory__default = /*#__PURE__*/_interopDefaultCompat(knexFactory);
var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);

const ddlLimiter = limiterFactory__default.default(1);
function createMysqlDatabaseClient(dbConfig, overrides) {
  const knexConfig = buildMysqlDatabaseConfig(dbConfig, overrides);
  const database = knexFactory__default.default(knexConfig);
  return database;
}
function buildMysqlDatabaseConfig(dbConfig, overrides) {
  return mergeDatabaseConfig.mergeDatabaseConfig(
    dbConfig.get(),
    {
      connection: getMysqlConnectionConfig(dbConfig, !!overrides),
      useNullAsDefault: true
    },
    overrides
  );
}
function getMysqlConnectionConfig(dbConfig, parseConnectionString) {
  const connection = dbConfig.get("connection");
  const isConnectionString = typeof connection === "string" || connection instanceof String;
  const autoParse = typeof parseConnectionString !== "boolean";
  const shouldParseConnectionString = autoParse ? isConnectionString : parseConnectionString && isConnectionString;
  return shouldParseConnectionString ? parseMysqlConnectionString(connection) : connection;
}
function parseMysqlConnectionString(connectionString) {
  try {
    const {
      protocol,
      username,
      password,
      port,
      hostname,
      pathname,
      searchParams
    } = new URL(connectionString);
    if (protocol !== "mysql:") {
      throw new Error(`Unknown protocol ${protocol}`);
    } else if (!username || !password) {
      throw new Error(`Missing username/password`);
    } else if (!pathname.match(/^\/[^/]+$/)) {
      throw new Error(`Expected single path segment`);
    }
    const result = {
      user: username,
      password,
      host: hostname,
      port: Number(port || 3306),
      database: decodeURIComponent(pathname.substring(1))
    };
    const ssl = searchParams.get("ssl");
    if (ssl) {
      result.ssl = ssl;
    }
    const debug = searchParams.get("debug");
    if (debug) {
      result.debug = yn__default.default(debug);
    }
    return result;
  } catch (e) {
    throw new errors.InputError(
      `Error while parsing MySQL connection string, ${e}`,
      e
    );
  }
}
async function ensureMysqlDatabaseExists(dbConfig, ...databases) {
  const admin = createMysqlDatabaseClient(dbConfig, {
    connection: {
      database: null
    },
    pool: {
      min: 0,
      acquireTimeoutMillis: 1e4
    }
  });
  try {
    const ensureDatabase = async (database) => {
      await admin.raw(`CREATE DATABASE IF NOT EXISTS ??`, [database]);
    };
    await Promise.all(
      databases.map(async (database) => {
        let lastErr = void 0;
        for (let i = 0; i < 3; i++) {
          try {
            return await ddlLimiter(() => ensureDatabase(database));
          } catch (err) {
            lastErr = err;
          }
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        throw lastErr;
      })
    );
  } finally {
    await admin.destroy();
  }
}
function pluginPath(pluginId) {
  return `plugin.${pluginId}`;
}
function normalizeConnection(connection) {
  if (typeof connection === "undefined" || connection === null) {
    return {};
  }
  return typeof connection === "string" || connection instanceof String ? parseMysqlConnectionString(connection) : connection;
}
class MysqlConnector {
  constructor(config, prefix) {
    this.config = config;
    this.prefix = prefix;
  }
  async getClient(pluginId, _deps) {
    const pluginConfig = new config.ConfigReader(
      this.getConfigForPlugin(pluginId)
    );
    const databaseName = this.getDatabaseName(pluginId);
    if (databaseName && this.getEnsureExistsConfig(pluginId)) {
      try {
        await ensureMysqlDatabaseExists(pluginConfig, databaseName);
      } catch (error) {
        throw new Error(
          `Failed to connect to the database to make sure that '${databaseName}' exists, ${error}`
        );
      }
    }
    const pluginDivisionMode = this.getPluginDivisionModeConfig();
    if (pluginDivisionMode !== "database") {
      throw new Error(
        `The MySQL driver does not support plugin division mode '${pluginDivisionMode}'`
      );
    }
    const databaseClientOverrides = mergeDatabaseConfig.mergeDatabaseConfig(
      {},
      this.getDatabaseOverrides(pluginId)
    );
    const client = createMysqlDatabaseClient(
      pluginConfig,
      databaseClientOverrides
    );
    return client;
  }
  /**
   * Provides the canonical database name for a given plugin.
   *
   * This method provides the effective database name which is determined using
   * global and plugin specific database config. If no explicit database name,
   * this method will provide a generated name which is the pluginId prefixed
   * with 'backstage_plugin_'.
   *
   * @param pluginId - Lookup the database name for given plugin
   * @returns String representing the plugin's database name
   */
  getDatabaseName(pluginId) {
    const connection = this.getConnectionConfig(pluginId);
    const databaseName = connection?.database;
    return databaseName ?? `${this.prefix}${pluginId}`;
  }
  /**
   * Provides the client type which should be used for a given plugin.
   *
   * The client type is determined by plugin specific config if present.
   * Otherwise the base client is used as the fallback.
   *
   * @param pluginId - Plugin to get the client type for
   * @returns Object with client type returned as `client` and boolean
   *          representing whether or not the client was overridden as
   *          `overridden`
   */
  getClientType(pluginId) {
    const pluginClient = this.config.getOptionalString(
      `${pluginPath(pluginId)}.client`
    );
    const baseClient = this.config.getString("client");
    const client = pluginClient ?? baseClient;
    return {
      client,
      overridden: client !== baseClient
    };
  }
  getRoleConfig(pluginId) {
    return this.config.getOptionalString(`${pluginPath(pluginId)}.role`) ?? this.config.getOptionalString("role");
  }
  /**
   * Provides the knexConfig which should be used for a given plugin.
   *
   * @param pluginId - Plugin to get the knexConfig for
   * @returns The merged knexConfig value or undefined if it isn't specified
   */
  getAdditionalKnexConfig(pluginId) {
    const pluginConfig = this.config.getOptionalConfig(`${pluginPath(pluginId)}.knexConfig`)?.get();
    const baseConfig = this.config.getOptionalConfig("knexConfig")?.get();
    return lodash.merge(baseConfig, pluginConfig);
  }
  getEnsureExistsConfig(pluginId) {
    const baseConfig = this.config.getOptionalBoolean("ensureExists") ?? true;
    return this.config.getOptionalBoolean(`${pluginPath(pluginId)}.ensureExists`) ?? baseConfig;
  }
  getPluginDivisionModeConfig() {
    return this.config.getOptionalString("pluginDivisionMode") ?? "database";
  }
  /**
   * Provides a Knex connection plugin config by combining base and plugin
   * config.
   *
   * This method provides a baseConfig for a plugin database connector. If the
   * client type has not been overridden, the global connection config will be
   * included with plugin specific config as the base. Values from the plugin
   * connection take precedence over the base. Base database name is omitted
   * unless `pluginDivisionMode` is set to `schema`.
   */
  getConnectionConfig(pluginId) {
    const { overridden } = this.getClientType(pluginId);
    let baseConnection = normalizeConnection(this.config.get("connection"));
    if (this.getPluginDivisionModeConfig() !== "schema") {
      baseConnection = lodash.omit(baseConnection, "database");
    }
    const connection = normalizeConnection(
      this.config.getOptional(`${pluginPath(pluginId)}.connection`)
    );
    return {
      // include base connection if client type has not been overridden
      ...overridden ? {} : baseConnection,
      ...connection
    };
  }
  /**
   * Provides a Knex database config for a given plugin.
   *
   * This method provides a Knex configuration object along with the plugin's
   * client type.
   *
   * @param pluginId - The plugin that the database config should correspond with
   */
  getConfigForPlugin(pluginId) {
    const { client } = this.getClientType(pluginId);
    const role = this.getRoleConfig(pluginId);
    return {
      ...this.getAdditionalKnexConfig(pluginId),
      client,
      connection: this.getConnectionConfig(pluginId),
      ...role && { role }
    };
  }
  /**
   * Provides a partial `Knex.Config`â€¢ database name override for a given plugin.
   *
   * @param pluginId - Target plugin to get database name override
   * @returns Partial `Knex.Config` with database name override
   */
  getDatabaseOverrides(pluginId) {
    const databaseName = this.getDatabaseName(pluginId);
    return databaseName ? defaultNameOverride.default(databaseName) : {};
  }
}

exports.MysqlConnector = MysqlConnector;
exports.buildMysqlDatabaseConfig = buildMysqlDatabaseConfig;
exports.createMysqlDatabaseClient = createMysqlDatabaseClient;
exports.ensureMysqlDatabaseExists = ensureMysqlDatabaseExists;
exports.getMysqlConnectionConfig = getMysqlConnectionConfig;
exports.parseMysqlConnectionString = parseMysqlConnectionString;
//# sourceMappingURL=mysql.cjs.js.map
