'use strict';

var concatStream = require('concat-stream');
var platformPath = require('path');
var getRawBody = require('raw-body');
var fs = require('fs-extra');
var util = require('util');
var tar = require('tar');
var stream = require('stream');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var concatStream__default = /*#__PURE__*/_interopDefaultCompat(concatStream);
var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);
var getRawBody__default = /*#__PURE__*/_interopDefaultCompat(getRawBody);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var tar__default = /*#__PURE__*/_interopDefaultCompat(tar);

const pipeline = util.promisify(stream.pipeline);
class ReadableArrayResponse {
  constructor(stream, workDir, etag) {
    this.stream = stream;
    this.workDir = workDir;
    this.etag = etag;
    this.etag = etag;
  }
  read = false;
  // Make sure the input stream is only read once
  onlyOnce() {
    if (this.read) {
      throw new Error("Response has already been read");
    }
    this.read = true;
  }
  async files() {
    this.onlyOnce();
    const files = Array();
    for (let i = 0; i < this.stream.length; i++) {
      if (!this.stream[i].path.endsWith("/")) {
        files.push({
          path: this.stream[i].path,
          content: () => getRawBody__default.default(this.stream[i].data),
          lastModifiedAt: this.stream[i]?.lastModifiedAt
        });
      }
    }
    return files;
  }
  async archive() {
    const tmpDir = await this.dir();
    try {
      const data = await new Promise(async (resolve) => {
        await pipeline(
          tar__default.default.create({ cwd: tmpDir }, [""]),
          concatStream__default.default(resolve)
        );
      });
      return stream.Readable.from(data);
    } finally {
      await fs__default.default.remove(tmpDir);
    }
  }
  async dir(options) {
    this.onlyOnce();
    const dir = options?.targetDir ?? await fs__default.default.mkdtemp(platformPath__default.default.join(this.workDir, "backstage-"));
    for (let i = 0; i < this.stream.length; i++) {
      if (!this.stream[i].path.endsWith("/")) {
        const filePath = platformPath__default.default.join(dir, this.stream[i].path);
        await fs__default.default.mkdir(platformPath.dirname(filePath), { recursive: true });
        await pipeline(this.stream[i].data, fs__default.default.createWriteStream(filePath));
      }
    }
    return dir;
  }
}

exports.ReadableArrayResponse = ReadableArrayResponse;
//# sourceMappingURL=ReadableArrayResponse.cjs.js.map
