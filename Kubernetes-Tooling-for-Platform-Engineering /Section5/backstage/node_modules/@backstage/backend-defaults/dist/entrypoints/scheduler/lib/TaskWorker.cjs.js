'use strict';

var errors = require('@backstage/errors');
var cron = require('cron');
var luxon = require('luxon');
var uuid = require('uuid');
var tables = require('../database/tables.cjs.js');
var types = require('./types.cjs.js');
var util = require('./util.cjs.js');

const DEFAULT_WORK_CHECK_FREQUENCY = luxon.Duration.fromObject({ seconds: 5 });
class TaskWorker {
  constructor(taskId, fn, knex, logger, workCheckFrequency = DEFAULT_WORK_CHECK_FREQUENCY) {
    this.taskId = taskId;
    this.fn = fn;
    this.knex = knex;
    this.logger = logger;
    this.workCheckFrequency = workCheckFrequency;
  }
  async start(settings, options) {
    try {
      await this.persistTask(settings);
    } catch (e) {
      throw new Error(`Failed to persist task, ${e}`);
    }
    this.logger.info(
      `Task worker starting: ${this.taskId}, ${JSON.stringify(settings)}`
    );
    let workCheckFrequency = this.workCheckFrequency;
    const isDuration = settings?.cadence.startsWith("P");
    if (isDuration) {
      const cadence = luxon.Duration.fromISO(settings.cadence);
      if (cadence < workCheckFrequency) {
        workCheckFrequency = cadence;
      }
    }
    let attemptNum = 1;
    (async () => {
      for (; ; ) {
        try {
          if (settings.initialDelayDuration) {
            await util.sleep(
              luxon.Duration.fromISO(settings.initialDelayDuration),
              options.signal
            );
          }
          while (!options.signal.aborted) {
            const runResult = await this.runOnce(options.signal);
            if (runResult.result === "abort") {
              break;
            }
            await util.sleep(workCheckFrequency, options.signal);
          }
          this.logger.info(`Task worker finished: ${this.taskId}`);
          attemptNum = 0;
          break;
        } catch (e) {
          attemptNum += 1;
          this.logger.warn(
            `Task worker failed unexpectedly, attempt number ${attemptNum}, ${e}`
          );
          await util.sleep(luxon.Duration.fromObject({ seconds: 1 }));
        }
      }
    })();
  }
  static async trigger(knex, taskId) {
    const rows = await knex(tables.DB_TASKS_TABLE).select(knex.raw(1)).where("id", "=", taskId);
    if (rows.length !== 1) {
      throw new errors.NotFoundError(`Task ${taskId} does not exist`);
    }
    const updatedRows = await knex(tables.DB_TASKS_TABLE).where("id", "=", taskId).whereNull("current_run_ticket").update({
      next_run_start_at: knex.fn.now()
    });
    if (updatedRows < 1) {
      throw new errors.ConflictError(`Task ${taskId} is currently running`);
    }
  }
  /**
   * Makes a single attempt at running the task to completion, if ready.
   *
   * @returns The outcome of the attempt
   */
  async runOnce(signal) {
    const findResult = await this.findReadyTask();
    if (findResult.result === "not-ready-yet" || findResult.result === "abort") {
      return findResult;
    }
    const taskSettings = findResult.settings;
    const ticket = uuid.v4();
    const claimed = await this.tryClaimTask(ticket, taskSettings);
    if (!claimed) {
      return { result: "not-ready-yet" };
    }
    const taskAbortController = util.delegateAbortController(signal);
    const timeoutHandle = setTimeout(() => {
      taskAbortController.abort();
    }, luxon.Duration.fromISO(taskSettings.timeoutAfterDuration).as("milliseconds"));
    try {
      await this.fn(taskAbortController.signal);
      taskAbortController.abort();
    } catch (e) {
      this.logger.error(e);
      await this.tryReleaseTask(ticket, taskSettings);
      return { result: "failed" };
    } finally {
      clearTimeout(timeoutHandle);
    }
    await this.tryReleaseTask(ticket, taskSettings);
    return { result: "completed" };
  }
  /**
   * Perform the initial store of the task info
   */
  async persistTask(settings) {
    types.taskSettingsV2Schema.parse(settings);
    const isManual = settings?.cadence === "manual";
    const isDuration = settings?.cadence.startsWith("P");
    const isCron = !isManual && !isDuration;
    let startAt;
    let nextStartAt;
    if (settings.initialDelayDuration) {
      startAt = util.nowPlus(
        luxon.Duration.fromISO(settings.initialDelayDuration),
        this.knex
      );
    }
    if (isCron) {
      const time = new cron.CronTime(settings.cadence).sendAt().minus({ seconds: 1 }).toUTC();
      nextStartAt = this.nextRunAtRaw(time);
      startAt ||= nextStartAt;
    } else if (isManual) {
      nextStartAt = this.knex.raw("null");
      startAt ||= nextStartAt;
    } else {
      startAt ||= this.knex.fn.now();
      nextStartAt = util.nowPlus(luxon.Duration.fromISO(settings.cadence), this.knex);
    }
    this.logger.debug(`task: ${this.taskId} configured to run at: ${startAt}`);
    const settingsJson = JSON.stringify(settings);
    await this.knex(tables.DB_TASKS_TABLE).insert({
      id: this.taskId,
      settings_json: settingsJson,
      next_run_start_at: startAt
    }).onConflict("id").merge(
      this.knex.client.config.client.includes("mysql") ? {
        settings_json: settingsJson,
        next_run_start_at: this.knex.raw(
          `CASE WHEN ?? < ?? THEN ?? ELSE ?? END`,
          [
            nextStartAt,
            "next_run_start_at",
            nextStartAt,
            "next_run_start_at"
          ]
        )
      } : {
        settings_json: this.knex.ref("excluded.settings_json"),
        next_run_start_at: this.knex.raw(
          `CASE WHEN ?? < ?? THEN ?? ELSE ?? END`,
          [
            nextStartAt,
            `${tables.DB_TASKS_TABLE}.next_run_start_at`,
            nextStartAt,
            `${tables.DB_TASKS_TABLE}.next_run_start_at`
          ]
        )
      }
    );
  }
  /**
   * Check if the task is ready to run
   */
  async findReadyTask() {
    const [row] = await this.knex(tables.DB_TASKS_TABLE).where("id", "=", this.taskId).select({
      settingsJson: "settings_json",
      ready: this.knex.raw(
        `CASE
            WHEN next_run_start_at <= ? AND current_run_ticket IS NULL THEN TRUE
            ELSE FALSE
          END`,
        [this.knex.fn.now()]
      )
    });
    if (!row) {
      this.logger.info(
        "No longer able to find task; aborting and assuming that it has been unregistered or expired"
      );
      return { result: "abort" };
    } else if (!row.ready) {
      return { result: "not-ready-yet" };
    }
    try {
      const obj = JSON.parse(row.settingsJson);
      const settings = types.taskSettingsV2Schema.parse(obj);
      return { result: "ready", settings };
    } catch (e) {
      this.logger.info(
        `Task "${this.taskId}" is no longer able to parse task settings; aborting and assuming that a newer version of the task has been issued and being handled by other workers, ${e}`
      );
      return { result: "abort" };
    }
  }
  /**
   * Attempts to claim a task that's ready for execution, on this worker's
   * behalf. We should not attempt to perform the work unless the claim really
   * goes through.
   *
   * @param ticket - A globally unique string that changes for each invocation
   * @param settings - The settings of the task to claim
   * @returns True if it was successfully claimed
   */
  async tryClaimTask(ticket, settings) {
    const startedAt = this.knex.fn.now();
    const expiresAt = settings.timeoutAfterDuration ? util.nowPlus(luxon.Duration.fromISO(settings.timeoutAfterDuration), this.knex) : this.knex.raw("null");
    const rows = await this.knex(tables.DB_TASKS_TABLE).where("id", "=", this.taskId).whereNull("current_run_ticket").update({
      current_run_ticket: ticket,
      current_run_started_at: startedAt,
      current_run_expires_at: expiresAt
    });
    return rows === 1;
  }
  async tryReleaseTask(ticket, settings) {
    const isManual = settings?.cadence === "manual";
    const isDuration = settings?.cadence.startsWith("P");
    const isCron = !isManual && !isDuration;
    let nextRun;
    if (isCron) {
      const time = new cron.CronTime(settings.cadence).sendAt().toUTC();
      this.logger.debug(`task: ${this.taskId} will next occur around ${time}`);
      nextRun = this.nextRunAtRaw(time);
    } else if (isManual) {
      nextRun = this.knex.raw("null");
    } else {
      const dt = luxon.Duration.fromISO(settings.cadence).as("seconds");
      this.logger.debug(
        `task: ${this.taskId} will next occur around ${luxon.DateTime.now().plus({
          seconds: dt
        })}`
      );
      if (this.knex.client.config.client.includes("sqlite3")) {
        nextRun = this.knex.raw(
          `max(datetime(next_run_start_at, ?), datetime('now'))`,
          [`+${dt} seconds`]
        );
      } else if (this.knex.client.config.client.includes("mysql")) {
        nextRun = this.knex.raw(
          `greatest(next_run_start_at + interval ${dt} second, now())`
        );
      } else {
        nextRun = this.knex.raw(
          `greatest(next_run_start_at + interval '${dt} seconds', now())`
        );
      }
    }
    const rows = await this.knex(tables.DB_TASKS_TABLE).where("id", "=", this.taskId).where("current_run_ticket", "=", ticket).update({
      next_run_start_at: nextRun,
      current_run_ticket: this.knex.raw("null"),
      current_run_started_at: this.knex.raw("null"),
      current_run_expires_at: this.knex.raw("null")
    });
    return rows === 1;
  }
  nextRunAtRaw(time) {
    if (this.knex.client.config.client.includes("sqlite3")) {
      return this.knex.raw("datetime(?)", [time.toISO()]);
    } else if (this.knex.client.config.client.includes("mysql")) {
      return this.knex.raw(`?`, [time.toSQL({ includeOffset: false })]);
    }
    return this.knex.raw(`?`, [time.toISO()]);
  }
}

exports.TaskWorker = TaskWorker;
//# sourceMappingURL=TaskWorker.cjs.js.map
