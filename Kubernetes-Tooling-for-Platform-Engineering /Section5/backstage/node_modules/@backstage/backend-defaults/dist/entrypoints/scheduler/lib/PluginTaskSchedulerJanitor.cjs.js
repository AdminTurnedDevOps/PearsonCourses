'use strict';

var tables = require('../database/tables.cjs.js');
var util = require('./util.cjs.js');

class PluginTaskSchedulerJanitor {
  knex;
  waitBetweenRuns;
  logger;
  constructor(options) {
    this.knex = options.knex;
    this.waitBetweenRuns = options.waitBetweenRuns;
    this.logger = options.logger;
  }
  async start(abortSignal) {
    while (!abortSignal?.aborted) {
      try {
        await this.runOnce();
      } catch (e) {
        this.logger.warn(`Error while performing janitorial tasks, ${e}`);
      }
      await util.sleep(this.waitBetweenRuns, abortSignal);
    }
  }
  async runOnce() {
    const dbNull = this.knex.raw("null");
    const configClient = this.knex.client.config.client;
    let tasks;
    if (configClient.includes("sqlite3") || configClient.includes("mysql")) {
      tasks = await this.knex(tables.DB_TASKS_TABLE).select("id").where("current_run_expires_at", "<", this.knex.fn.now());
      await this.knex(tables.DB_TASKS_TABLE).whereIn(
        "id",
        tasks.map((t) => t.id)
      ).update({
        current_run_ticket: dbNull,
        current_run_started_at: dbNull,
        current_run_expires_at: dbNull
      });
    } else {
      tasks = await this.knex(tables.DB_TASKS_TABLE).where("current_run_expires_at", "<", this.knex.fn.now()).update({
        current_run_ticket: dbNull,
        current_run_started_at: dbNull,
        current_run_expires_at: dbNull
      }).returning(["id"]);
    }
    if (typeof tasks === "number") {
      if (tasks > 0) {
        this.logger.warn(`${tasks} tasks timed out and were lost`);
      }
    } else {
      for (const { id } of tasks) {
        this.logger.warn(`Task timed out and was lost: ${id}`);
      }
    }
  }
}

exports.PluginTaskSchedulerJanitor = PluginTaskSchedulerJanitor;
//# sourceMappingURL=PluginTaskSchedulerJanitor.cjs.js.map
