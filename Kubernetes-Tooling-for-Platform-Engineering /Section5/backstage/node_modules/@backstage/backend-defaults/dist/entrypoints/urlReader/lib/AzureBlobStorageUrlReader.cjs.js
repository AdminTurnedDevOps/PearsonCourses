'use strict';

var storageBlob = require('@azure/storage-blob');
var errors = require('@backstage/errors');
var stream = require('stream');
var posix = require('path/posix');
var ReadUrlResponseFactory = require('./ReadUrlResponseFactory.cjs.js');
var integration = require('@backstage/integration');

function parseUrl(url) {
  const parsedUrl = new URL(url);
  const pathSegments = parsedUrl.pathname.split("/").filter(Boolean);
  if (pathSegments.length < 1) {
    throw new Error(`Invalid Azure Blob Storage URL format: ${url}`);
  }
  const container = pathSegments[0];
  const path = pathSegments.slice(1).join("/");
  return { path, container };
}
class AzureBlobStorageUrlReader {
  // private readonly blobServiceClient: BlobServiceClient;
  constructor(credsManager, integration, deps) {
    this.credsManager = credsManager;
    this.integration = integration;
    this.deps = deps;
  }
  static factory = ({ config, treeResponseFactory }) => {
    const integrations = integration.ScmIntegrations.fromConfig(config);
    const credsManager = integration.DefaultAzureCredentialsManager.fromIntegrations(integrations);
    return integrations.azureBlobStorage.list().map((integrationConfig) => {
      const reader = new AzureBlobStorageUrlReader(
        credsManager,
        integrationConfig,
        {
          treeResponseFactory
        }
      );
      const predicate = (url) => url.host.endsWith(
        `${integrationConfig.config.accountName}.${integrationConfig.config.host}`
      );
      return { reader, predicate };
    });
  };
  async createContainerClient(containerName) {
    const accountName = this.integration.config.accountName;
    const accountKey = this.integration.config.accountKey;
    if (accountKey && accountName) {
      const creds = new storageBlob.StorageSharedKeyCredential(accountName, accountKey);
      const blobServiceClient2 = new storageBlob.BlobServiceClient(
        `https://${accountName}.${this.integration.config.host}`,
        creds
      );
      return blobServiceClient2.getContainerClient(containerName);
    }
    const credential = await this.credsManager.getCredentials(
      accountName
    );
    let blobServiceClientUrl;
    if (this.integration.config.endpoint) {
      if (this.integration.config.sasToken) {
        blobServiceClientUrl = `${this.integration.config.endpoint}?${this.integration.config.sasToken}`;
      } else {
        blobServiceClientUrl = `${this.integration.config.endpoint}`;
      }
    } else {
      blobServiceClientUrl = `https://${this.integration.config.accountName}.${this.integration.config.host}`;
    }
    const blobServiceClient = new storageBlob.BlobServiceClient(
      blobServiceClientUrl,
      credential
    );
    return blobServiceClient.getContainerClient(containerName);
  }
  async read(url) {
    const response = await this.readUrl(url);
    return response.buffer();
  }
  async readUrl(url, options) {
    const { etag, lastModifiedAfter } = options ?? {};
    try {
      const { path, container } = parseUrl(url);
      const containerClient = await this.createContainerClient(container);
      const blobClient = containerClient.getBlobClient(path);
      const getBlobOptions = {
        abortSignal: options?.signal,
        conditions: {
          ...etag && { ifNoneMatch: etag },
          ...lastModifiedAfter && { ifModifiedSince: lastModifiedAfter }
        }
      };
      const downloadBlockBlobResponse = await blobClient.download(
        0,
        void 0,
        getBlobOptions
      );
      return ReadUrlResponseFactory.ReadUrlResponseFactory.fromReadable(
        downloadBlockBlobResponse.readableStreamBody,
        {
          etag: downloadBlockBlobResponse.etag,
          lastModifiedAt: downloadBlockBlobResponse.lastModified
        }
      );
    } catch (e) {
      if (e.statusCode === 304) {
        throw new errors.NotModifiedError();
      }
      throw new errors.ForwardedError(
        "Could not retrieve file from Azure Blob Storage",
        e
      );
    }
  }
  async readTree(url, options) {
    try {
      const { path, container } = parseUrl(url);
      const containerClient = await this.createContainerClient(container);
      const blobs = containerClient.listBlobsFlat({ prefix: path });
      const responses = [];
      for await (const blob of blobs) {
        const blobClient = containerClient.getBlobClient(blob.name);
        const downloadBlockBlobResponse = await blobClient.download(
          void 0,
          void 0,
          { abortSignal: options?.signal }
        );
        responses.push({
          data: stream.Readable.from(
            downloadBlockBlobResponse.readableStreamBody
          ),
          path: posix.relative(path, blob.name),
          lastModifiedAt: blob.properties.lastModified
        });
      }
      return this.deps.treeResponseFactory.fromReadableArray(responses);
    } catch (e) {
      throw new errors.ForwardedError(
        "Could not retrieve file tree from Azure Blob Storage",
        e
      );
    }
  }
  async search() {
    throw new Error("AzureBlobStorageUrlReader does not implement search");
  }
  toString() {
    const accountName = this.integration.config.accountName;
    const accountKey = this.integration.config.accountKey;
    return `azureBlobStorage{accountName=${accountName},authed=${Boolean(
      accountKey
    )}}`;
  }
}

exports.AzureBlobStorageUrlReader = AzureBlobStorageUrlReader;
exports.parseUrl = parseUrl;
//# sourceMappingURL=AzureBlobStorageUrlReader.cjs.js.map
