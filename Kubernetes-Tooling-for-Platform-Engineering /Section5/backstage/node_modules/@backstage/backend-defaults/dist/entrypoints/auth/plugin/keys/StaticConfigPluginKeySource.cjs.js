'use strict';

var types = require('@backstage/types');
var fs = require('fs');
var jose = require('jose');

const DEFAULT_ALGORITHM = "ES256";
const SECONDS_IN_MS = 1e3;
class StaticConfigPluginKeySource {
  constructor(keyPairs, keyDurationSeconds) {
    this.keyPairs = keyPairs;
    this.keyDurationSeconds = keyDurationSeconds;
  }
  static async create(options) {
    const keyConfigs = options.sourceConfig.getConfigArray("static.keys").map((c) => {
      const staticKeyConfig = {
        publicKeyFile: c.getString("publicKeyFile"),
        privateKeyFile: c.getOptionalString("privateKeyFile"),
        keyId: c.getString("keyId"),
        algorithm: c.getOptionalString("algorithm") ?? DEFAULT_ALGORITHM
      };
      return staticKeyConfig;
    });
    const keyPairs = await Promise.all(
      keyConfigs.map(async (k) => await this.loadKeyPair(k))
    );
    if (keyPairs.length < 1) {
      throw new Error(
        "At least one key pair must be provided in static.keys, when the static key store type is used"
      );
    } else if (!keyPairs[0].privateKey) {
      throw new Error(
        "Private key for signing must be provided in the first key pair in static.keys, when the static key store type is used"
      );
    }
    return new StaticConfigPluginKeySource(
      keyPairs,
      types.durationToMilliseconds(options.keyDuration) / SECONDS_IN_MS
    );
  }
  async getPrivateSigningKey() {
    return this.keyPairs[0].privateKey;
  }
  async listKeys() {
    const keys = this.keyPairs.map((k) => this.keyPairToStoredKey(k));
    return { keys };
  }
  static async loadKeyPair(options) {
    const algorithm = options.algorithm;
    const keyId = options.keyId;
    const publicKey = await this.loadPublicKeyFromFile(
      options.publicKeyFile,
      keyId,
      algorithm
    );
    const privateKey = options.privateKeyFile ? await this.loadPrivateKeyFromFile(
      options.privateKeyFile,
      keyId,
      algorithm
    ) : void 0;
    return { publicKey, privateKey, keyId };
  }
  static async loadPublicKeyFromFile(path, keyId, algorithm) {
    return this.loadKeyFromFile(path, keyId, algorithm, jose.importSPKI);
  }
  static async loadPrivateKeyFromFile(path, keyId, algorithm) {
    return this.loadKeyFromFile(path, keyId, algorithm, jose.importPKCS8);
  }
  static async loadKeyFromFile(path, keyId, algorithm, importer) {
    const content = await fs.promises.readFile(path, { encoding: "utf8", flag: "r" });
    const key = await importer(content, algorithm);
    const jwk = await jose.exportJWK(key);
    jwk.kid = keyId;
    jwk.alg = algorithm;
    return jwk;
  }
  keyPairToStoredKey(keyPair) {
    const publicKey = {
      ...keyPair.publicKey,
      kid: keyPair.keyId
    };
    return {
      key: publicKey,
      id: keyPair.keyId,
      expiresAt: new Date(Date.now() + this.keyDurationSeconds * SECONDS_IN_MS)
    };
  }
}

exports.StaticConfigPluginKeySource = StaticConfigPluginKeySource;
//# sourceMappingURL=StaticConfigPluginKeySource.cjs.js.map
