import EventEmitter from 'node:events';
import { RedisClientType, RedisClusterType, RedisModules, RedisFunctions, RedisScripts, RedisClientOptions, RedisClusterOptions } from 'redis';
export { RedisClientOptions, RedisClientType, RedisClusterOptions, RedisClusterType, createClient, createCluster } from 'redis';
import { KeyvStoreAdapter, Keyv } from 'keyv';
export { Keyv } from 'keyv';

type KeyvRedisOptions = {
    /**
     * Namespace for the current instance.
     */
    namespace?: string;
    /**
     * Separator to use between namespace and key.
     */
    keyPrefixSeparator?: string;
    /**
     * Number of keys to delete in a single batch.
     */
    clearBatchSize?: number;
    /**
     * Enable Unlink instead of using Del for clearing keys. This is more performant but may not be supported by all Redis versions.
     */
    useUnlink?: boolean;
    /**
     * Whether to allow clearing all keys when no namespace is set.
     * If set to true and no namespace is set, iterate() will return all keys.
     * Defaults to `false`.
     */
    noNamespaceAffectsAll?: boolean;
};
type KeyvRedisPropertyOptions = KeyvRedisOptions & {
    /**
     * Dialect used by the adapter. This is legacy so Keyv knows what is iteratable.
     */
    dialect: 'redis';
    /**
     * URL used to connect to the Redis server. This is legacy so Keyv knows what is iteratable.
     */
    url: string;
};
type KeyvRedisEntry<T> = {
    /**
     * Key to set.
     */
    key: string;
    /**
     * Value to set.
     */
    value: T;
    /**
     * Time to live in milliseconds.
     */
    ttl?: number;
};
type RedisClientConnectionType = RedisClientType | RedisClusterType<RedisModules, RedisFunctions, RedisScripts>;
declare class KeyvRedis extends EventEmitter implements KeyvStoreAdapter {
    private _client;
    private _namespace;
    private _keyPrefixSeparator;
    private _clearBatchSize;
    private _useUnlink;
    private _noNamespaceAffectsAll;
    /**
     * KeyvRedis constructor.
     * @param {string | RedisClientOptions | RedisClientType} [connect] How to connect to the Redis server. If string pass in the url, if object pass in the options, if RedisClient pass in the client.
     * @param {KeyvRedisOptions} [options] Options for the adapter such as namespace, keyPrefixSeparator, and clearBatchSize.
     */
    constructor(connect?: string | RedisClientOptions | RedisClusterOptions | RedisClientConnectionType, options?: KeyvRedisOptions);
    /**
     * Get the Redis client.
     */
    get client(): RedisClientConnectionType;
    /**
     * Set the Redis client.
     */
    set client(value: RedisClientConnectionType);
    /**
     * Get the options for the adapter.
     */
    get opts(): KeyvRedisPropertyOptions;
    /**
     * Set the options for the adapter.
     */
    set opts(options: KeyvRedisOptions);
    /**
     * Get the namespace for the adapter. If undefined, it will not use a namespace including keyPrefixing.
     * @default undefined
     */
    get namespace(): string | undefined;
    /**
     * Set the namespace for the adapter. If undefined, it will not use a namespace including keyPrefixing.
     */
    set namespace(value: string | undefined);
    /**
     * Get the separator between the namespace and key.
     * @default '::'
     */
    get keyPrefixSeparator(): string;
    /**
     * Set the separator between the namespace and key.
     */
    set keyPrefixSeparator(value: string);
    /**
     * Get the number of keys to delete in a single batch.
     * @default 1000
     */
    get clearBatchSize(): number;
    /**
     * Set the number of keys to delete in a single batch.
     */
    set clearBatchSize(value: number);
    /**
     * Get if Unlink is used instead of Del for clearing keys. This is more performant but may not be supported by all Redis versions.
     * @default true
     */
    get useUnlink(): boolean;
    /**
     * Set if Unlink is used instead of Del for clearing keys. This is more performant but may not be supported by all Redis versions.
     */
    set useUnlink(value: boolean);
    /**
     * Get if no namespace affects all keys.
     * Whether to allow clearing all keys when no namespace is set.
     * If set to true and no namespace is set, iterate() will return all keys.
     * @default false
     */
    get noNamespaceAffectsAll(): boolean;
    /**
     * Set if not namespace affects all keys.
     */
    set noNamespaceAffectsAll(value: boolean);
    /**
     * Get the Redis URL used to connect to the server. This is used to get a connected client.
     */
    getClient(): Promise<RedisClientConnectionType>;
    /**
     * Set a key value pair in the store. TTL is in milliseconds.
     * @param {string} key - the key to set
     * @param {string} value - the value to set
     * @param {number} [ttl] - the time to live in milliseconds
     */
    set(key: string, value: string, ttl?: number): Promise<void>;
    /**
     * Will set many key value pairs in the store. TTL is in milliseconds. This will be done as a single transaction.
     * @param {Array<KeyvRedisEntry<string>>} entries - the key value pairs to set with optional ttl
     */
    setMany(entries: Array<KeyvRedisEntry<string>>): Promise<void>;
    /**
     * Check if a key exists in the store.
     * @param {string} key - the key to check
     * @returns {Promise<boolean>} - true if the key exists, false if not
     */
    has(key: string): Promise<boolean>;
    /**
     * Check if many keys exist in the store. This will be done as a single transaction.
     * @param {Array<string>} keys - the keys to check
     * @returns {Promise<Array<boolean>>} - array of booleans for each key if it exists
     */
    hasMany(keys: string[]): Promise<boolean[]>;
    /**
     * Get a value from the store. If the key does not exist, it will return undefined.
     * @param {string} key - the key to get
     * @returns {Promise<string | undefined>} - the value or undefined if the key does not exist
     */
    get<T>(key: string): Promise<T | undefined>;
    /**
     * Get many values from the store. If a key does not exist, it will return undefined.
     * @param {Array<string>} keys - the keys to get
     * @returns {Promise<Array<string | undefined>>} - array of values or undefined if the key does not exist
     */
    getMany<T>(keys: string[]): Promise<Array<T | undefined>>;
    /**
     * Delete a key from the store.
     * @param {string} key - the key to delete
     * @returns {Promise<boolean>} - true if the key was deleted, false if not
     */
    delete(key: string): Promise<boolean>;
    /**
     * Delete many keys from the store. This will be done as a single transaction.
     * @param {Array<string>} keys - the keys to delete
     * @returns {Promise<boolean>} - true if any key was deleted, false if not
     */
    deleteMany(keys: string[]): Promise<boolean>;
    /**
     * Disconnect from the Redis server.
     * @returns {Promise<void>}
     */
    disconnect(): Promise<void>;
    /**
     * Helper function to create a key with a namespace.
     * @param {string} key - the key to prefix
     * @param {string} namespace - the namespace to prefix the key with
     * @returns {string} - the key with the namespace such as 'namespace::key'
     */
    createKeyPrefix(key: string, namespace?: string): string;
    /**
     * Helper function to get a key without the namespace.
     * @param {string} key - the key to remove the namespace from
     * @param {string} namespace - the namespace to remove from the key
     * @returns {string} - the key without the namespace such as 'key'
     */
    getKeyWithoutPrefix(key: string, namespace?: string): string;
    /**
     * Is the client a cluster.
     * @returns {boolean} - true if the client is a cluster, false if not
     */
    isCluster(): boolean;
    /**
     * Get the master nodes in the cluster. If not a cluster, it will return the single client.
     *
     * @returns {Promise<RedisClientType[]>} - array of master nodes
     */
    getMasterNodes(): Promise<RedisClientType[]>;
    /**
     * Get an async iterator for the keys and values in the store. If a namespace is provided, it will only iterate over keys with that namespace.
     * @param {string} [namespace] - the namespace to iterate over
     * @returns {AsyncGenerator<[string, T | undefined], void, unknown>} - async iterator with key value pairs
     */
    iterator<Value>(namespace?: string): AsyncGenerator<[string, Value | undefined], void, unknown>;
    /**
     * Clear all keys in the store.
     * IMPORTANT: this can cause performance issues if there are a large number of keys in the store and worse with clusters. Use with caution as not recommended for production.
     * If a namespace is not set it will clear all keys with no prefix.
     * If a namespace is set it will clear all keys with that namespace.
     * @returns {Promise<void>}
     */
    clear(): Promise<void>;
    /**
     * Get many keys. If the instance is a cluster, it will do multiple MGET calls
     * by separating the keys by slot to solve the CROSS-SLOT restriction.
     */
    private mget;
    /**
     * Clear all keys in the store with a specific namespace. If the instance is a cluster, it will clear all keys
     * by separating the keys by slot to solve the CROSS-SLOT restriction.
     */
    private clearWithClusterSupport;
    /**
     * Returns the master node client for a given slot or the instance's client if it's not a cluster.
     */
    private getSlotMaster;
    /**
     * Group keys by their slot.
     *
     * @param {string[]} keys - the keys to group
     * @returns {Map<number, string[]>} - map of slot to keys
     */
    private getSlotMap;
    private isClientCluster;
    private setOptions;
    private initClient;
}
/**
 * Will create a Keyv instance with the Redis adapter. This will also set the namespace and useKeyPrefix to false.
 * @param connect
 * @param options
 * @returns {Keyv} - Keyv instance with the Redis adapter
 */
declare function createKeyv(connect?: string | RedisClientOptions | RedisClientType, options?: KeyvRedisOptions): Keyv;

export { type KeyvRedisEntry, type KeyvRedisOptions, type KeyvRedisPropertyOptions, type RedisClientConnectionType, createKeyv, KeyvRedis as default };
