// src/index.ts
import EventEmitter from "node:events";
import memcache from "memjs";
import { defaultDeserialize } from "@keyv/serialize";
var KeyvMemcache = class extends EventEmitter {
  ttlSupport = true;
  namespace;
  client;
  opts;
  constructor(uri, options) {
    super();
    options = {
      ...typeof uri === "string" ? { uri } : uri,
      ...options
    };
    if (options.uri && options.url === void 0) {
      options.url = options.uri;
    }
    if (uri === void 0) {
      uri = "localhost:11211";
      options.url = options.uri = uri;
    }
    this.opts = options;
    this.client = memcache.Client.create(uri, options);
  }
  _getNamespace() {
    return `namespace:${this.namespace}`;
  }
  async get(key) {
    return new Promise((resolve, reject) => {
      this.client.get(this.formatKey(key), (error, value) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          let value_;
          if (value === null) {
            value_ = {
              value: void 0,
              expires: 0
            };
          } else {
            value_ = this.opts.deserialize ? this.opts.deserialize(value) : defaultDeserialize(value);
          }
          resolve(value_);
        }
      });
    });
  }
  async getMany(keys) {
    const promises = [];
    for (const key of keys) {
      promises.push(this.get(key));
    }
    return Promise.allSettled(promises).then((values) => {
      const data = [];
      for (const value of values) {
        data.push(value.value);
      }
      return data;
    });
  }
  async set(key, value, ttl) {
    const options = {};
    if (ttl !== void 0) {
      options.expires = options.ttl = Math.floor(ttl / 1e3);
    }
    await this.client.set(this.formatKey(key), value, options);
  }
  async delete(key) {
    return new Promise((resolve, reject) => {
      this.client.delete(this.formatKey(key), (error, success) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          resolve(Boolean(success));
        }
      });
    });
  }
  async deleteMany(keys) {
    const promises = keys.map(async (key) => this.delete(key));
    const results = await Promise.allSettled(promises);
    return results.every((x) => x.value === true);
  }
  async clear() {
    return new Promise((resolve, reject) => {
      this.client.flush((error) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          resolve(void 0);
        }
      });
    });
  }
  formatKey(key) {
    let result = key;
    if (this.namespace) {
      result = this.namespace.trim() + ":" + key.trim();
    }
    return result;
  }
  async has(key) {
    return new Promise((resolve) => {
      this.client.get(this.formatKey(key), (error, value) => {
        if (error) {
          resolve(false);
        } else {
          resolve(value !== null);
        }
      });
    });
  }
};
var src_default = KeyvMemcache;
export {
  KeyvMemcache,
  src_default as default
};
