"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KeyvMemcache: () => KeyvMemcache,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_node_events = __toESM(require("events"), 1);
var import_memjs = __toESM(require("memjs"), 1);
var import_serialize = require("@keyv/serialize");
var KeyvMemcache = class extends import_node_events.default {
  ttlSupport = true;
  namespace;
  client;
  opts;
  constructor(uri, options) {
    super();
    options = {
      ...typeof uri === "string" ? { uri } : uri,
      ...options
    };
    if (options.uri && options.url === void 0) {
      options.url = options.uri;
    }
    if (uri === void 0) {
      uri = "localhost:11211";
      options.url = options.uri = uri;
    }
    this.opts = options;
    this.client = import_memjs.default.Client.create(uri, options);
  }
  _getNamespace() {
    return `namespace:${this.namespace}`;
  }
  async get(key) {
    return new Promise((resolve, reject) => {
      this.client.get(this.formatKey(key), (error, value) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          let value_;
          if (value === null) {
            value_ = {
              value: void 0,
              expires: 0
            };
          } else {
            value_ = this.opts.deserialize ? this.opts.deserialize(value) : (0, import_serialize.defaultDeserialize)(value);
          }
          resolve(value_);
        }
      });
    });
  }
  async getMany(keys) {
    const promises = [];
    for (const key of keys) {
      promises.push(this.get(key));
    }
    return Promise.allSettled(promises).then((values) => {
      const data = [];
      for (const value of values) {
        data.push(value.value);
      }
      return data;
    });
  }
  async set(key, value, ttl) {
    const options = {};
    if (ttl !== void 0) {
      options.expires = options.ttl = Math.floor(ttl / 1e3);
    }
    await this.client.set(this.formatKey(key), value, options);
  }
  async delete(key) {
    return new Promise((resolve, reject) => {
      this.client.delete(this.formatKey(key), (error, success) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          resolve(Boolean(success));
        }
      });
    });
  }
  async deleteMany(keys) {
    const promises = keys.map(async (key) => this.delete(key));
    const results = await Promise.allSettled(promises);
    return results.every((x) => x.value === true);
  }
  async clear() {
    return new Promise((resolve, reject) => {
      this.client.flush((error) => {
        if (error) {
          this.emit("error", error);
          reject(error);
        } else {
          resolve(void 0);
        }
      });
    });
  }
  formatKey(key) {
    let result = key;
    if (this.namespace) {
      result = this.namespace.trim() + ":" + key.trim();
    }
    return result;
  }
  async has(key) {
    return new Promise((resolve) => {
      this.client.get(this.formatKey(key), (error, value) => {
        if (error) {
          resolve(false);
        } else {
          resolve(value !== null);
        }
      });
    });
  }
};
var src_default = KeyvMemcache;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KeyvMemcache
});
