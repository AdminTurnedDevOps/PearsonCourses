import { WebStorage } from '@backstage/core-app-api';
import { ResponseError } from '@backstage/errors';
import ObservableImpl from 'zen-observable';

const JSON_HEADERS = {
  "Content-Type": "application/json; charset=utf-8",
  Accept: "application/json"
};
const buckets = /* @__PURE__ */ new Map();
class UserSettingsStorage {
  constructor(namespace, fetchApi, discoveryApi, errorApi, identityApi, fallback, signalApi) {
    this.namespace = namespace;
    this.fetchApi = fetchApi;
    this.discoveryApi = discoveryApi;
    this.errorApi = errorApi;
    this.identityApi = identityApi;
    this.fallback = fallback;
    this.signalApi = signalApi;
  }
  subscribers = /* @__PURE__ */ new Set();
  observables = /* @__PURE__ */ new Map();
  static create(options) {
    return new UserSettingsStorage(
      options.namespace ?? "default",
      options.fetchApi,
      options.discoveryApi,
      options.errorApi,
      options.identityApi,
      WebStorage.create({
        namespace: options.namespace,
        errorApi: options.errorApi
      }),
      options.signalApi
    );
  }
  forBucket(name) {
    const bucketPath = `${this.namespace}.${name}`;
    if (!buckets.has(bucketPath)) {
      buckets.set(
        bucketPath,
        new UserSettingsStorage(
          bucketPath,
          this.fetchApi,
          this.discoveryApi,
          this.errorApi,
          this.identityApi,
          this.fallback
        )
      );
    }
    return buckets.get(bucketPath);
  }
  async remove(key) {
    const fetchUrl = await this.getFetchUrl(key);
    const response = await this.fetchApi.fetch(fetchUrl, {
      method: "DELETE"
    });
    if (!response.ok && response.status !== 404) {
      throw await ResponseError.fromResponse(response);
    }
    this.notifyChanges({ key, presence: "absent" });
  }
  async set(key, data) {
    if (!await this.isSignedIn()) {
      await this.fallback.set(key, data);
      this.notifyChanges({ key, presence: "present", value: data });
      return;
    }
    const fetchUrl = await this.getFetchUrl(key);
    const response = await this.fetchApi.fetch(fetchUrl, {
      method: "PUT",
      headers: JSON_HEADERS,
      body: JSON.stringify({ value: data })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const { value } = await response.json();
    this.notifyChanges({ key, value, presence: "present" });
  }
  observe$(key) {
    if (!this.observables.has(key)) {
      this.observables.set(
        key,
        new ObservableImpl((subscriber) => {
          let signalSubscription;
          this.subscribers.add(subscriber);
          const updateSnapshot = () => {
            Promise.resolve().then(() => this.get(key)).then((snapshot) => subscriber.next(snapshot)).catch((error) => this.errorApi.post(error));
          };
          if (this.signalApi) {
            signalSubscription = this.signalApi.subscribe(
              `user-settings`,
              (msg) => {
                if (msg.key === key) {
                  updateSnapshot();
                }
              }
            );
          }
          updateSnapshot();
          return () => {
            if (signalSubscription) {
              signalSubscription.unsubscribe();
            }
            this.subscribers.delete(subscriber);
          };
        }).filter(({ key: messageKey }) => messageKey === key)
      );
    }
    return this.observables.get(key);
  }
  snapshot(key) {
    return { key, presence: "unknown" };
  }
  async get(key) {
    if (!await this.isSignedIn()) {
      return this.fallback.snapshot(key);
    }
    const fetchUrl = await this.getFetchUrl(key);
    const response = await this.fetchApi.fetch(fetchUrl);
    if (response.status === 404) {
      return { key, presence: "absent" };
    }
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    try {
      const { value: rawValue } = await response.json();
      const value = JSON.parse(JSON.stringify(rawValue), (_key, val) => {
        if (typeof val === "object" && val !== null) {
          Object.freeze(val);
        }
        return val;
      });
      return { key, presence: "present", value };
    } catch {
      return { key, presence: "absent" };
    }
  }
  async getFetchUrl(key) {
    const baseUrl = await this.discoveryApi.getBaseUrl("user-settings");
    const encodedNamespace = encodeURIComponent(this.namespace);
    const encodedKey = encodeURIComponent(key);
    return `${baseUrl}/buckets/${encodedNamespace}/keys/${encodedKey}`;
  }
  async notifyChanges(snapshot) {
    for (const subscription of this.subscribers) {
      try {
        subscription.next(snapshot);
      } catch {
      }
    }
  }
  async isSignedIn() {
    try {
      const credentials = await this.identityApi.getCredentials();
      return credentials?.token ? true : false;
    } catch {
      return false;
    }
  }
}

export { UserSettingsStorage };
//# sourceMappingURL=UserSettingsStorage.esm.js.map
