'use strict';

var zod = require('zod');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var errors = require('@backstage/errors');

const responseSchema = zod.z.object({
  items: zod.z.array(
    zod.z.object({
      id: zod.z.string(),
      result: zod.z.literal(pluginPermissionCommon.AuthorizeResult.ALLOW).or(zod.z.literal(pluginPermissionCommon.AuthorizeResult.DENY))
    })
  )
});
class PermissionIntegrationClient {
  discovery;
  auth;
  constructor(options) {
    this.discovery = options.discovery;
    this.auth = options.auth;
  }
  async applyConditions(pluginId, credentials, decisions) {
    const baseUrl = await this.discovery.getBaseUrl(pluginId);
    const endpoint = `${baseUrl}/.well-known/backstage/permissions/apply-conditions`;
    const token = this.auth.isPrincipal(credentials, "none") ? void 0 : await this.auth.getPluginRequestToken({
      onBehalfOf: credentials,
      targetPluginId: pluginId
    }).then((t) => t.token);
    const response = await fetch(endpoint, {
      method: "POST",
      body: JSON.stringify({
        items: decisions.map(
          ({ id, resourceRef, resourceType, conditions }) => ({
            id,
            resourceRef,
            resourceType,
            conditions
          })
        )
      }),
      headers: {
        ...token ? { authorization: `Bearer ${token}` } : {},
        "content-type": "application/json"
      }
    });
    if (!response.ok) {
      throw await errors.ResponseError.fromResponse(response);
    }
    const result = responseSchema.parse(await response.json());
    return result.items;
  }
}

exports.PermissionIntegrationClient = PermissionIntegrationClient;
//# sourceMappingURL=PermissionIntegrationClient.cjs.js.map
