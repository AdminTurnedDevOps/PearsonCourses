'use strict';

var zod = require('zod');
var express = require('express');
var Router = require('express-promise-router');
var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var PermissionIntegrationClient = require('./PermissionIntegrationClient.cjs.js');
var lodash = require('lodash');
var DataLoader = require('dataloader');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);
var DataLoader__default = /*#__PURE__*/_interopDefaultCompat(DataLoader);

const attributesSchema = zod.z.object({
  action: zod.z.union([
    zod.z.literal("create"),
    zod.z.literal("read"),
    zod.z.literal("update"),
    zod.z.literal("delete")
  ]).optional()
});
const permissionSchema = zod.z.union([
  zod.z.object({
    type: zod.z.literal("basic"),
    name: zod.z.string(),
    attributes: attributesSchema
  }),
  zod.z.object({
    type: zod.z.literal("resource"),
    name: zod.z.string(),
    attributes: attributesSchema,
    resourceType: zod.z.string()
  })
]);
const evaluatePermissionRequestSchema = zod.z.object({
  id: zod.z.string(),
  resourceRef: zod.z.string().optional(),
  permission: permissionSchema
});
const evaluatePermissionRequestBatchSchema = zod.z.object({
  items: zod.z.array(evaluatePermissionRequestSchema)
});
const handleRequest = async (requests, policy, permissionIntegrationClient, credentials, auth, userInfo) => {
  const applyConditionsLoaderFor = lodash.memoize((pluginId) => {
    return new DataLoader__default.default(
      (batch) => permissionIntegrationClient.applyConditions(pluginId, credentials, batch)
    );
  });
  let user;
  if (auth.isPrincipal(credentials, "user")) {
    const info = await userInfo.getUserInfo(credentials);
    const { token } = await auth.getPluginRequestToken({
      onBehalfOf: credentials,
      targetPluginId: "catalog"
      // TODO: unknown at this point
    });
    user = {
      identity: {
        type: "user",
        userEntityRef: credentials.principal.userEntityRef,
        ownershipEntityRefs: info.ownershipEntityRefs
      },
      token,
      credentials,
      info
    };
  }
  return Promise.all(
    requests.map(
      ({ id, resourceRef, ...request }) => policy.handle(request, user).then((decision) => {
        if (decision.result !== pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
          return {
            id,
            ...decision
          };
        }
        if (!pluginPermissionCommon.isResourcePermission(request.permission)) {
          throw new Error(
            `Conditional decision returned from permission policy for non-resource permission ${request.permission.name}`
          );
        }
        if (decision.resourceType !== request.permission.resourceType) {
          throw new Error(
            `Invalid resource conditions returned from permission policy for permission ${request.permission.name}`
          );
        }
        if (!resourceRef) {
          return {
            id,
            ...decision
          };
        }
        return applyConditionsLoaderFor(decision.pluginId).load({
          id,
          resourceRef,
          ...decision
        });
      })
    )
  );
};
async function createRouter(options) {
  const { policy, discovery, config, logger } = options;
  const { auth, httpAuth, userInfo } = backendCommon.createLegacyAuthAdapters(options);
  if (!config.getOptionalBoolean("permission.enabled")) {
    logger.warn(
      "Permission backend started with permissions disabled. Enable permissions by setting permission.enabled=true."
    );
  }
  const permissionIntegrationClient = new PermissionIntegrationClient.PermissionIntegrationClient({
    discovery,
    auth
  });
  const router = Router__default.default();
  router.use(express__default.default.json());
  router.get("/health", (_, response) => {
    response.json({ status: "ok" });
  });
  router.post(
    "/authorize",
    async (req, res) => {
      const credentials = await httpAuth.credentials(req, {
        allow: ["user", "none"]
      });
      const parseResult = evaluatePermissionRequestBatchSchema.safeParse(
        req.body
      );
      if (!parseResult.success) {
        throw new errors.InputError(parseResult.error.toString());
      }
      const body = parseResult.data;
      res.json({
        items: await handleRequest(
          body.items,
          policy,
          permissionIntegrationClient,
          credentials,
          auth,
          userInfo
        )
      });
    }
  );
  router.use(backendCommon.errorHandler());
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.cjs.js.map
