'use strict';

var passportGithub2 = require('passport-github2');
var pluginAuthNode = require('@backstage/plugin-auth-node');

const ACCESS_TOKEN_PREFIX = "access-token.";
const githubAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  defaultProfileTransform: pluginAuthNode.PassportOAuthAuthenticatorHelper.defaultProfileTransform,
  scopes: {
    persist: true,
    required: ["read:user"]
  },
  initialize({ callbackUrl, config }) {
    const clientId = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const enterpriseInstanceUrl = config.getOptionalString("enterpriseInstanceUrl")?.replace(/\/$/, "");
    const authorizationUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/authorize` : void 0;
    const tokenUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/access_token` : void 0;
    const userProfileUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/api/v3/user` : void 0;
    return pluginAuthNode.PassportOAuthAuthenticatorHelper.from(
      new passportGithub2.Strategy(
        {
          clientID: clientId,
          clientSecret,
          callbackURL: callbackUrl,
          tokenURL: tokenUrl,
          userProfileURL: userProfileUrl,
          authorizationURL: authorizationUrl
        },
        (accessToken, refreshToken, params, fullProfile, done) => {
          done(
            void 0,
            { fullProfile, params, accessToken },
            { refreshToken }
          );
        }
      )
    );
  },
  async start(input, helper) {
    return helper.start(input, {
      accessType: "offline",
      prompt: "consent"
    });
  },
  async authenticate(input, helper) {
    const { fullProfile, session } = await helper.authenticate(input);
    if (!session.refreshToken && !session.expiresInSeconds) {
      session.refreshToken = ACCESS_TOKEN_PREFIX + session.accessToken;
    }
    return { fullProfile, session };
  },
  async refresh(input, helper) {
    if (input.refreshToken?.startsWith(ACCESS_TOKEN_PREFIX)) {
      const accessToken = input.refreshToken.slice(ACCESS_TOKEN_PREFIX.length);
      const fullProfile = await helper.fetchProfile(accessToken).catch((error) => {
        if (error.oauthError?.statusCode === 401) {
          throw new Error("Invalid access token");
        }
        throw error;
      });
      return {
        fullProfile,
        session: {
          accessToken,
          tokenType: "bearer",
          scope: input.scope,
          refreshToken: input.refreshToken
          // No expiration
        }
      };
    }
    return helper.refresh(input);
  }
});

exports.githubAuthenticator = githubAuthenticator;
//# sourceMappingURL=authenticator.cjs.js.map
