import { useMemo, useCallback, useEffect } from 'react';
import { useApi, fetchApiRef, discoveryApiRef } from '@backstage/core-plugin-api';
import { useAsync, useMountEffect } from '@react-hookz/web';
import { ResponseError } from '@backstage/errors';

const COOKIE_PATH = "/.backstage/auth/v1/cookie";
const ONE_YEAR_MS = 365 * 24 * 36e5;
function useCookieAuthRefresh(options) {
  const { pluginId } = options ?? {};
  const fetchApi = useApi(fetchApiRef);
  const discoveryApi = useApi(discoveryApiRef);
  const channel = useMemo(() => {
    return "BroadcastChannel" in window ? new BroadcastChannel(`${pluginId}-auth-cookie-expires-at`) : null;
  }, [pluginId]);
  const [state, actions] = useAsync(async () => {
    const apiOrigin = await discoveryApi.getBaseUrl(pluginId);
    const requestUrl = `${apiOrigin}${COOKIE_PATH}`;
    const response = await fetchApi.fetch(`${requestUrl}`, {
      credentials: "include"
    });
    if (!response.ok) {
      if (response.status === 404) {
        return { expiresAt: new Date(Date.now() + ONE_YEAR_MS) };
      }
      throw await ResponseError.fromResponse(response);
    }
    const data = await response.json();
    if (!data.expiresAt) {
      throw new Error("No expiration date found in response");
    }
    return data;
  });
  useMountEffect(actions.execute);
  const retry = useCallback(() => {
    actions.execute();
  }, [actions]);
  const refresh = useCallback(
    (params) => {
      const margin = (1 + 3 * Math.random()) * 6e4;
      const delay = Date.parse(params.expiresAt) - Date.now() - margin;
      const timeout = setTimeout(retry, delay);
      return () => clearTimeout(timeout);
    },
    [retry]
  );
  useEffect(() => {
    if (state.status !== "success" || !state.result) {
      return () => {
      };
    }
    channel?.postMessage({
      action: "COOKIE_REFRESH_SUCCESS",
      payload: state.result
    });
    let cancel = refresh(state.result);
    const listener = (event) => {
      const { action, payload } = event.data;
      if (action === "COOKIE_REFRESH_SUCCESS") {
        cancel();
        cancel = refresh(payload);
      }
    };
    channel?.addEventListener("message", listener);
    return () => {
      cancel();
      channel?.removeEventListener("message", listener);
    };
  }, [state, refresh, channel]);
  if (state.status === "not-executed") {
    return { status: "loading" };
  }
  if (state.status === "loading" && !state.result) {
    return { status: "loading" };
  }
  if (state.status === "loading" && state.error) {
    return { status: "loading" };
  }
  if (state.status === "error" && state.error) {
    return { status: "error", error: state.error, retry };
  }
  return { status: "success", data: state.result };
}

export { useCookieAuthRefresh };
//# sourceMappingURL=useCookieAuthRefresh.esm.js.map
