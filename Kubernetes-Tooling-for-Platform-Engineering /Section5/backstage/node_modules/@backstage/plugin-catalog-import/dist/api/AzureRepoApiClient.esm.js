const apiVersions = "6.0";
class RepoApiClient {
  constructor(_options) {
    this._options = _options;
  }
  createEndpoint = (path, version, queryParams = void 0) => {
    const url = new URL(
      `${this._options.tenantUrl}/${this._options.project}/_apis/git/repositories`
    );
    url.pathname += path;
    url.searchParams.set("api-version", version);
    Object.entries(queryParams ?? {}).forEach(
      ([key, value]) => url.searchParams.set(key, value)
    );
    return url.toString();
  };
  async get(path, version, queryParams = void 0, token) {
    const endpoint = this.createEndpoint(path, version, queryParams);
    const result = await fetch(endpoint, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    if (!result.ok) {
      return result.json().then((it) => Promise.reject(new Error(it.message)));
    }
    return await result.json();
  }
  async post(path, version, payload, token) {
    const endpoint = this.createEndpoint(path, version);
    const result = await fetch(endpoint, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    });
    if (!result.ok) {
      return result.json().then((it) => Promise.reject(new Error(it.message)));
    }
    return await result.json();
  }
  async getRepository(repositoryName, token) {
    return this.get(`/${repositoryName}`, apiVersions, void 0, token);
  }
  async getDefaultBranch(repo, token) {
    const filter = repo.defaultBranch.replace("refs/", "");
    const result = await this.get(
      `/${repo.name}/refs`,
      apiVersions,
      { filter },
      token
    );
    if (!result.value?.length) {
      return Promise.reject(
        new Error(`The requested ref '${filter}' was not found`)
      );
    }
    return result.value[0];
  }
  async pushNewBranch(options, token) {
    const { sourceBranch, repoName } = options;
    const push = {
      refUpdates: [
        {
          name: `refs/heads/${options.branchName}`,
          oldObjectId: sourceBranch.objectId
        }
      ],
      commits: [
        {
          comment: options.title,
          changes: [
            {
              changeType: "add",
              item: {
                path: `/${options.fileName}`
              },
              newContent: {
                content: options.fileContent,
                contentType: "rawtext"
              }
            }
          ]
        }
      ]
    };
    const result = await this.post(
      `/${repoName}/pushes`,
      apiVersions,
      push,
      token
    );
    return result.refUpdates[0];
  }
  async createPullRequest(options, token) {
    const { repoName, sourceName, targetName } = options;
    const payload = {
      title: options.title,
      description: options.description,
      sourceRefName: sourceName,
      targetRefName: targetName
    };
    return await this.post(
      `/${repoName}/pullrequests`,
      apiVersions,
      payload,
      token
    );
  }
}
async function createAzurePullRequest(options, client = void 0) {
  const {
    title,
    repository,
    token,
    fileContent,
    fileName,
    branchName,
    description
  } = options;
  const actualClient = client ?? new RepoApiClient(options);
  const repo = await actualClient.getRepository(repository, token);
  const defaultBranch = await actualClient.getDefaultBranch(repo, token);
  const branchOptions = {
    title,
    repoName: repo.name,
    sourceBranch: defaultBranch,
    branchName,
    fileContent,
    fileName
  };
  const refUpdate = await actualClient.pushNewBranch(branchOptions, token);
  const prOptions = {
    title,
    description,
    repoName: repo.name,
    sourceName: refUpdate.name,
    targetName: defaultBranch.name
  };
  return actualClient.createPullRequest(prOptions, token);
}

export { RepoApiClient, createAzurePullRequest };
//# sourceMappingURL=AzureRepoApiClient.esm.js.map
