import YAML from 'yaml';
import { submitGitHubPrToRepo } from './GitHub.esm.js';
import { getCatalogFilename } from '../components/helpers.esm.js';
import parseGitUrl from 'git-url-parse';
import { submitAzurePrToRepo } from './AzureDevops.esm.js';

class CatalogImportClient {
  discoveryApi;
  fetchApi;
  scmAuthApi;
  scmIntegrationsApi;
  catalogApi;
  configApi;
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.scmAuthApi = options.scmAuthApi;
    this.fetchApi = options.fetchApi;
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.catalogApi = options.catalogApi;
    this.configApi = options.configApi;
  }
  async analyzeUrl(url) {
    if (new URL(url).pathname.match(/\.ya?ml$/) || new URL(url).searchParams.get("path")?.match(/.ya?ml$/)) {
      const location = await this.catalogApi.addLocation({
        type: "url",
        target: url,
        dryRun: true
      });
      return {
        type: "locations",
        locations: [
          {
            exists: location.exists,
            target: location.location.target,
            entities: location.entities.map((e) => ({
              kind: e.kind,
              namespace: e.metadata.namespace ?? "default",
              name: e.metadata.name
            }))
          }
        ]
      };
    }
    const supportedIntegrations = ["github", "azure"];
    const foundIntegration = this.scmIntegrationsApi.byUrl(url);
    const iSupported = !!foundIntegration && supportedIntegrations.find((it) => it === foundIntegration.type);
    if (!iSupported) {
      const catalogFilename = getCatalogFilename(this.configApi);
      if (foundIntegration) {
        throw new Error(
          `The ${foundIntegration.title} integration only supports full URLs to ${catalogFilename} files. Did you try to pass in the URL of a directory instead?`
        );
      }
      throw new Error(
        `This URL was not recognized as a valid git URL because there was no configured integration that matched the given host name. Currently GitHub and Azure DevOps are supported. You could try to paste the full URL to a ${catalogFilename} file instead.`
      );
    }
    const analyzation = await this.analyzeLocation({
      repo: url
    });
    if (analyzation.existingEntityFiles.length > 0) {
      const locations = analyzation.existingEntityFiles.reduce((state, curr) => {
        state[curr.location.target] = {
          target: curr.location.target,
          exists: curr.isRegistered,
          entities: [
            ...curr.location.target in state ? state[curr.location.target].entities : [],
            {
              name: curr.entity.metadata.name,
              namespace: curr.entity.metadata.namespace ?? "default",
              kind: curr.entity.kind
            }
          ]
        };
        return state;
      }, {});
      return {
        type: "locations",
        locations: Object.values(locations)
      };
    }
    return {
      type: "repository",
      integrationType: foundIntegration.type,
      url,
      generatedEntities: analyzation.generateEntities.map((x) => x.entity)
    };
  }
  async preparePullRequest() {
    const appTitle = this.configApi.getOptionalString("app.title") ?? "Backstage";
    const appBaseUrl = this.configApi.getString("app.baseUrl");
    const catalogFilename = getCatalogFilename(this.configApi);
    return {
      title: `Add ${catalogFilename} config file`,
      body: `This pull request adds a **Backstage entity metadata file** to this repository so that the component can be added to the [${appTitle} software catalog](${appBaseUrl}).

After this pull request is merged, the component will become available.

For more information, read an [overview of the Backstage software catalog](https://backstage.io/docs/features/software-catalog/).`
    };
  }
  async submitPullRequest(options) {
    const { repositoryUrl, fileContent, title, body } = options;
    const parseData = YAML.parseAllDocuments(fileContent);
    for (const document of parseData) {
      const validationResponse = await this.catalogApi.validateEntity(
        document.toJS(),
        `url:${repositoryUrl}`
      );
      if (!validationResponse.valid) {
        throw new Error(validationResponse.errors[0].message);
      }
    }
    const provider = this.scmIntegrationsApi.byUrl(repositoryUrl);
    switch (provider?.type) {
      case "github": {
        const { config } = provider;
        const { name, owner } = parseGitUrl(repositoryUrl);
        const options2 = {
          githubIntegrationConfig: config,
          repo: name,
          owner,
          repositoryUrl,
          fileContent,
          title,
          body
        };
        return submitGitHubPrToRepo(options2, this.scmAuthApi, this.configApi);
      }
      case "azure": {
        return submitAzurePrToRepo(
          {
            repositoryUrl,
            fileContent,
            title,
            body
          },
          this.scmAuthApi,
          this.configApi
        );
      }
      default: {
        throw new Error("unimplemented!");
      }
    }
  }
  // TODO: this could be part of the catalog api
  async analyzeLocation(options) {
    const response = await this.fetchApi.fetch(
      `${await this.discoveryApi.getBaseUrl("catalog")}/analyze-location`,
      {
        headers: {
          "Content-Type": "application/json"
        },
        method: "POST",
        body: JSON.stringify({
          location: { type: "url", target: options.repo },
          ...this.configApi.getOptionalString(
            "catalog.import.entityFilename"
          ) && {
            catalogFilename: this.configApi.getOptionalString(
              "catalog.import.entityFilename"
            )
          }
        })
      }
    ).catch((e) => {
      throw new Error(`Failed to generate entity definitions, ${e.message}`);
    });
    if (!response.ok) {
      throw new Error(
        `Failed to generate entity definitions. Received http response ${response.status}: ${response.statusText}`
      );
    }
    const payload = await response.json();
    return payload;
  }
}

export { CatalogImportClient };
//# sourceMappingURL=CatalogImportClient.esm.js.map
