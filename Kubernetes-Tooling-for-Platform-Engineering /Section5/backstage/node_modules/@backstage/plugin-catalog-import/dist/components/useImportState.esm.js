import { useReducer } from 'react';

function init(initialUrl) {
  return {
    activeFlow: "unknown",
    activeState: "analyze",
    analysisUrl: initialUrl,
    previousStates: []
  };
}
function reducer(state, action) {
  switch (action.type) {
    case "onAnalysis": {
      if (state.activeState !== "analyze") {
        return state;
      }
      const { activeState, previousStates } = state;
      const [activeFlow, analysisUrl, analyzeResult, opts] = action.args;
      return {
        ...state,
        analysisUrl,
        activeFlow,
        analyzeResult,
        prepareResult: opts?.prepareResult,
        activeState: opts?.prepareResult === void 0 ? "prepare" : "review",
        previousStates: previousStates.concat(activeState)
      };
    }
    case "onPrepare": {
      if (state.activeState !== "prepare") {
        return state;
      }
      const { activeState, previousStates } = state;
      const [prepareResult, opts] = action.args;
      return {
        ...state,
        prepareResult,
        activeState: "review",
        previousStates: opts?.notRepeatable ? [] : previousStates.concat(activeState)
      };
    }
    case "onReview": {
      if (state.activeState !== "review") {
        return state;
      }
      const { activeState, previousStates } = state;
      const [reviewResult] = action.args;
      return {
        ...state,
        reviewResult,
        activeState: "finish",
        previousStates: previousStates.concat(activeState)
      };
    }
    case "onGoBack": {
      const { activeState, previousStates } = state;
      return {
        ...state,
        activeState: previousStates.length > 0 ? previousStates[previousStates.length - 1] : activeState,
        previousStates: previousStates.slice(0, previousStates.length - 1)
      };
    }
    case "onReset":
      return {
        ...init(action.initialUrl),
        // we keep the old prepareResult since the form is animated and an
        // undefined value might crash the last step.
        prepareResult: state.prepareResult
      };
    default:
      throw new Error();
  }
}
const useImportState = (options) => {
  const [state, dispatch] = useReducer(reducer, options?.initialUrl, init);
  const { activeFlow, activeState, analysisUrl, previousStates } = state;
  return {
    activeFlow,
    activeState,
    activeStepNumber: ["analyze", "prepare", "review", "finish"].indexOf(
      activeState
    ),
    analysisUrl,
    analyzeResult: state.analyzeResult,
    prepareResult: state.prepareResult,
    reviewResult: state.reviewResult,
    onAnalysis: (flow, url, result, opts) => dispatch({
      type: "onAnalysis",
      args: [flow, url, result, opts]
    }),
    onPrepare: (result, opts) => dispatch({
      type: "onPrepare",
      args: [result, opts]
    }),
    onReview: (result) => dispatch({ type: "onReview", args: [result] }),
    onGoBack: previousStates.length > 0 ? () => dispatch({ type: "onGoBack" }) : void 0,
    onReset: () => dispatch({ type: "onReset", initialUrl: options?.initialUrl })
  };
};

export { useImportState };
//# sourceMappingURL=useImportState.esm.js.map
