{"version":3,"file":"readDeclarativeSignInResolver.cjs.js","sources":["../../src/sign-in/readDeclarativeSignInResolver.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { JsonObject } from '@backstage/types';\nimport { SignInResolver } from '../types';\nimport { SignInResolverFactory } from './createSignInResolverFactory';\n\n/** @public */\nexport interface ReadDeclarativeSignInResolverOptions<TAuthResult> {\n  config: Config;\n  signInResolverFactories: {\n    [name in string]: SignInResolverFactory<TAuthResult, unknown>;\n  };\n}\n\n/** @public */\nexport function readDeclarativeSignInResolver<TAuthResult>(\n  options: ReadDeclarativeSignInResolverOptions<TAuthResult>,\n): SignInResolver<TAuthResult> | undefined {\n  const resolvers =\n    options.config\n      .getOptionalConfigArray('signIn.resolvers')\n      ?.map(resolverConfig => {\n        const resolverName = resolverConfig.getString('resolver');\n        if (!Object.hasOwn(options.signInResolverFactories, resolverName)) {\n          throw new Error(\n            `Sign-in resolver '${resolverName}' is not available`,\n          );\n        }\n        const resolver = options.signInResolverFactories[resolverName];\n        const { resolver: _ignored, ...resolverOptions } =\n          resolverConfig.get<JsonObject>();\n\n        return resolver(\n          Object.keys(resolverOptions).length > 0 ? resolverOptions : undefined,\n        );\n      }) ?? [];\n\n  if (resolvers.length === 0) {\n    return undefined;\n  }\n\n  return async (profile, context) => {\n    for (const resolver of resolvers) {\n      try {\n        return await resolver(profile, context);\n      } catch (error) {\n        if (error?.name === 'NotFoundError') {\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    throw new Error(\n      'Failed to sign-in, unable to resolve user identity. Please verify that your catalog contains the expected User entities that would match your configured sign-in resolver.',\n    );\n  };\n}\n"],"names":[],"mappings":";;AA8BO,SAAS,8BACd,OACyC,EAAA;AACzC,EAAA,MAAM,YACJ,OAAQ,CAAA,MAAA,CACL,uBAAuB,kBAAkB,CAAA,EACxC,IAAI,CAAkB,cAAA,KAAA;AACtB,IAAM,MAAA,YAAA,GAAe,cAAe,CAAA,SAAA,CAAU,UAAU,CAAA;AACxD,IAAA,IAAI,CAAC,MAAO,CAAA,MAAA,CAAO,OAAQ,CAAA,uBAAA,EAAyB,YAAY,CAAG,EAAA;AACjE,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,YAAY,CAAA,kBAAA;AAAA,OACnC;AAAA;AAEF,IAAM,MAAA,QAAA,GAAW,OAAQ,CAAA,uBAAA,CAAwB,YAAY,CAAA;AAC7D,IAAA,MAAM,EAAE,QAAU,EAAA,QAAA,EAAU,GAAG,eAAgB,EAAA,GAC7C,eAAe,GAAgB,EAAA;AAEjC,IAAO,OAAA,QAAA;AAAA,MACL,OAAO,IAAK,CAAA,eAAe,CAAE,CAAA,MAAA,GAAS,IAAI,eAAkB,GAAA,KAAA;AAAA,KAC9D;AAAA,GACD,KAAK,EAAC;AAEX,EAAI,IAAA,SAAA,CAAU,WAAW,CAAG,EAAA;AAC1B,IAAO,OAAA,KAAA,CAAA;AAAA;AAGT,EAAO,OAAA,OAAO,SAAS,OAAY,KAAA;AACjC,IAAA,KAAA,MAAW,YAAY,SAAW,EAAA;AAChC,MAAI,IAAA;AACF,QAAO,OAAA,MAAM,QAAS,CAAA,OAAA,EAAS,OAAO,CAAA;AAAA,eAC/B,KAAO,EAAA;AACd,QAAI,IAAA,KAAA,EAAO,SAAS,eAAiB,EAAA;AACnC,UAAA;AAAA;AAEF,QAAM,MAAA,KAAA;AAAA;AACR;AAGF,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,GACF;AACF;;;;"}