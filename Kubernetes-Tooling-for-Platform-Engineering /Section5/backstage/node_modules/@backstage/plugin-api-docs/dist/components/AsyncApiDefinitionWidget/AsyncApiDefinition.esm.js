import AsyncApi from '@asyncapi/react-component';
import '@asyncapi/react-component/styles/default.css';
import { makeStyles, alpha, darken, useTheme } from '@material-ui/core/styles';
import React from 'react';

const useStyles = makeStyles((theme) => ({
  root: {
    fontFamily: "inherit",
    "& .bg-white": {
      background: "none"
    },
    "& .text-4xl": {
      ...theme.typography.h3
    },
    " & h2": {
      ...theme.typography.h4
    },
    "& .border": {
      borderColor: alpha(theme.palette.border, 0.1)
    },
    "& .min-w-min": {
      minWidth: "fit-content"
    },
    "& .examples": {
      padding: "1rem"
    },
    "& .bg-teal-500": {
      backgroundColor: theme.palette.status.ok
    },
    "& .bg-blue-500": {
      backgroundColor: theme.palette.info.main
    },
    "& .bg-blue-400": {
      backgroundColor: theme.palette.info.light
    },
    "& .bg-indigo-400": {
      backgroundColor: theme.palette.warning.main
    },
    "& .text-teal-50": {
      color: theme.palette.status.ok
    },
    "& .text-red-600": {
      color: theme.palette.error.main
    },
    "& .text-orange-600": {
      color: theme.palette.warning.main
    },
    "& .text-teal-500": {
      color: theme.palette.status.ok
    },
    "& .text-blue-500": {
      color: theme.palette.info.main
    },
    "& .-rotate-90": {
      "--tw-rotate": "0deg"
    },
    "& button": {
      ...theme.typography.button,
      borderRadius: theme.shape.borderRadius,
      color: theme.palette.primary.main,
      // override whatever may be in the theme's typography to ensure consistency with asyncapi
      textTransform: "inherit"
    },
    "& a": {
      color: theme.palette.link
    },
    "& a.no-underline": {
      ...theme.typography.button,
      background: "none",
      boxSizing: "border-box",
      minWidth: 64,
      borderRadius: theme.shape.borderRadius,
      transition: theme.transitions.create(
        ["background-color", "box-shadow", "border"],
        {
          duration: theme.transitions.duration.short
        }
      ),
      padding: "5px 15px",
      color: theme.palette.primary.main,
      border: `1px solid ${alpha(theme.palette.primary.main, 0.5)}`,
      "&:hover": {
        textDecoration: "none",
        border: `1px solid ${theme.palette.primary.main}`,
        backgroundColor: alpha(
          theme.palette.primary.main,
          theme.palette.action.hoverOpacity
        )
      }
    },
    "& li.no-underline": {
      "& a": {
        textDecoration: "none",
        color: theme.palette.getContrastText(theme.palette.primary.main)
      }
    }
  },
  dark: {
    "& svg": {
      fill: theme.palette.text.primary
    },
    "& .prose": {
      color: theme.palette.text.secondary,
      "& h3": {
        color: theme.palette.text.primary
      }
    },
    "& .bg-gray-100, .bg-gray-200": {
      backgroundColor: theme.palette.background.default
    },
    "& .text-gray-600": {
      color: theme.palette.grey["50"]
    },
    "& .text-gray-700": {
      color: theme.palette.grey["100"]
    },
    "& .panel--right": {
      background: darken(theme.palette.navigation.background, 0.1)
    },
    "& .examples": {
      backgroundColor: darken(theme.palette.navigation.background, 0.1),
      "& pre": {
        backgroundColor: darken(theme.palette.background.default, 0.2)
      }
    }
  }
}));
const httpsFetchResolver = {
  schema: "https",
  order: 1,
  canRead: true,
  async read(uri) {
    const response = await fetch(uri.toString());
    return response.text();
  }
};
const httpFetchResolver = {
  schema: "http",
  order: 1,
  canRead: true,
  async read(uri) {
    const response = await fetch(uri.toString());
    return response.text();
  }
};
const AsyncApiDefinition = ({
  definition,
  resolvers
}) => {
  const classes = useStyles();
  const theme = useTheme();
  const classNames = `${classes.root} ${theme.palette.type === "dark" ? classes.dark : ""}`;
  const config = {
    parserOptions: {
      __unstable: {
        resolver: {
          resolvers: [httpsFetchResolver, httpFetchResolver]
        }
      }
    }
  };
  if (resolvers) {
    config.parserOptions.__unstable.resolver.resolvers = resolvers;
  }
  return /* @__PURE__ */ React.createElement("div", { className: classNames }, /* @__PURE__ */ React.createElement(AsyncApi, { schema: definition, config }));
};

export { AsyncApiDefinition };
//# sourceMappingURL=AsyncApiDefinition.esm.js.map
