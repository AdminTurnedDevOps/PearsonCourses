{"version":3,"file":"helpers.cjs.js","sources":["../src/helpers.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AuthenticationError } from '@backstage/errors';\nimport { OAuth2Client } from 'google-auth-library';\nimport { GcpIapTokenInfo } from './types';\n\nexport function createTokenValidator(\n  audience: string,\n  providedClient?: OAuth2Client,\n): (token: string) => Promise<GcpIapTokenInfo> {\n  const client = providedClient ?? new OAuth2Client();\n\n  return async function tokenValidator(token) {\n    // TODO(freben): Rate limit the public key reads. It may be sensible to\n    // cache these for some reasonable time rather than asking for the public\n    // keys on every single sign-in. But since the rate of events here is so\n    // slow, I decided to keep it simple for now.\n    const response = await client.getIapPublicKeys().catch(error => {\n      throw new AuthenticationError(\n        `Unable to list Google IAP token verification keys, ${error}`,\n      );\n    });\n    const ticket = await client\n      .verifySignedJwtWithCertsAsync(token, response.pubkeys, audience, [\n        'https://cloud.google.com/iap',\n      ])\n      .catch(error => {\n        throw new AuthenticationError(\n          `Google IAP token verification failed, ${error}`,\n        );\n      });\n\n    const payload = ticket.getPayload();\n    if (!payload) {\n      throw new AuthenticationError(\n        'Google IAP token verification failed, token had no payload',\n      );\n    }\n\n    if (!payload.sub) {\n      throw new AuthenticationError(\n        'Google IAP token payload is missing subject claim',\n      );\n    }\n    if (!payload.email) {\n      throw new AuthenticationError(\n        'Google IAP token payload is missing email claim',\n      );\n    }\n\n    return payload as unknown as GcpIapTokenInfo;\n  };\n}\n"],"names":["OAuth2Client","AuthenticationError"],"mappings":";;;;;AAoBgB,SAAA,oBAAA,CACd,UACA,cAC6C,EAAA;AAC7C,EAAM,MAAA,MAAA,GAA2B,IAAIA,8BAAa,EAAA;AAElD,EAAO,OAAA,eAAe,eAAe,KAAO,EAAA;AAK1C,IAAA,MAAM,WAAW,MAAM,MAAA,CAAO,gBAAiB,EAAA,CAAE,MAAM,CAAS,KAAA,KAAA;AAC9D,MAAA,MAAM,IAAIC,0BAAA;AAAA,QACR,sDAAsD,KAAK,CAAA;AAAA,OAC7D;AAAA,KACD,CAAA;AACD,IAAA,MAAM,SAAS,MAAM,MAAA,CAClB,8BAA8B,KAAO,EAAA,QAAA,CAAS,SAAS,QAAU,EAAA;AAAA,MAChE;AAAA,KACD,CACA,CAAA,KAAA,CAAM,CAAS,KAAA,KAAA;AACd,MAAA,MAAM,IAAIA,0BAAA;AAAA,QACR,yCAAyC,KAAK,CAAA;AAAA,OAChD;AAAA,KACD,CAAA;AAEH,IAAM,MAAA,OAAA,GAAU,OAAO,UAAW,EAAA;AAClC,IAAA,IAAI,CAAC,OAAS,EAAA;AACZ,MAAA,MAAM,IAAIA,0BAAA;AAAA,QACR;AAAA,OACF;AAAA;AAGF,IAAI,IAAA,CAAC,QAAQ,GAAK,EAAA;AAChB,MAAA,MAAM,IAAIA,0BAAA;AAAA,QACR;AAAA,OACF;AAAA;AAEF,IAAI,IAAA,CAAC,QAAQ,KAAO,EAAA;AAClB,MAAA,MAAM,IAAIA,0BAAA;AAAA,QACR;AAAA,OACF;AAAA;AAGF,IAAO,OAAA,OAAA;AAAA,GACT;AACF;;;;"}