'use strict';

var crypto = require('crypto');
var jose = require('jose');
var errors = require('@backstage/errors');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var crypto__namespace = /*#__PURE__*/_interopNamespaceCompat(crypto);

const makeProfileInfo = (profile, idToken) => {
  let email = void 0;
  if (profile.emails && profile.emails.length > 0) {
    const [firstEmail] = profile.emails;
    email = firstEmail.value;
  }
  let picture = void 0;
  if (profile.avatarUrl) {
    picture = profile.avatarUrl;
  } else if (profile.photos && profile.photos.length > 0) {
    const [firstPhoto] = profile.photos;
    picture = firstPhoto.value;
  }
  let displayName = profile.displayName ?? profile.username ?? profile.id;
  if ((!email || !picture || !displayName) && idToken) {
    try {
      const decoded = jose.decodeJwt(idToken);
      if (!email && decoded.email) {
        email = decoded.email;
      }
      if (!picture && decoded.picture) {
        picture = decoded.picture;
      }
      if (!displayName && decoded.name) {
        displayName = decoded.name;
      }
    } catch (e) {
      throw new Error(`Failed to parse id token and get profile info, ${e}`);
    }
  }
  return {
    email,
    picture,
    displayName
  };
};
const getPublicKeyEndpoint = (region) => {
  if (region.startsWith("us-gov")) {
    return `https://s3-${encodeURIComponent(
      region
    )}.amazonaws.com/aws-elb-public-keys-prod-${encodeURIComponent(region)}`;
  }
  return `https://public-keys.auth.elb.${encodeURIComponent(
    region
  )}.amazonaws.com`;
};
const provisionKeyCache = (region, keyCache) => {
  return async (header) => {
    if (!header.kid) {
      throw new errors.AuthenticationError("No key id was specified in header");
    }
    const optionalCacheKey = keyCache.get(header.kid);
    if (optionalCacheKey) {
      return crypto__namespace.createPublicKey(optionalCacheKey);
    }
    const keyText = await fetch(
      `${getPublicKeyEndpoint(region)}/${encodeURIComponent(header.kid)}`
    ).then((response) => response.text());
    const keyValue = crypto__namespace.createPublicKey(keyText);
    keyCache.set(header.kid, keyValue.export({ format: "pem", type: "spki" }));
    return keyValue;
  };
};

exports.makeProfileInfo = makeProfileInfo;
exports.provisionKeyCache = provisionKeyCache;
//# sourceMappingURL=helpers.cjs.js.map
