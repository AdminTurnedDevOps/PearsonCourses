'use strict';

var router = require('express-promise-router');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var router__default = /*#__PURE__*/_interopDefaultCompat(router);

const createCacheMiddleware = ({
  cache
}) => {
  const cacheMiddleware = router__default.default();
  cacheMiddleware.use(async (req, res, next) => {
    const socket = res.socket;
    const isCacheable = req.path.startsWith("/static/docs/");
    const isGetRequest = req.method === "GET";
    if (!isCacheable || !socket) {
      next();
      return;
    }
    const reqPath = decodeURI(req.path.match(/\/static\/docs\/(.*)$/)[1]);
    const realEnd = socket.end.bind(socket);
    const realWrite = socket.write.bind(socket);
    let writeToCache = true;
    const chunks = [];
    socket.write = (data, encoding, callback) => {
      chunks.push(Buffer.from(data));
      if (typeof encoding === "function") {
        return realWrite(data, encoding);
      }
      return realWrite(data, encoding, callback);
    };
    socket.on("close", async (hadError) => {
      const content = Buffer.concat(chunks);
      const head = content.toString("utf8", 0, 12);
      if (isGetRequest && writeToCache && !hadError && head.match(/HTTP\/\d\.\d 200/)) {
        await cache.set(reqPath, content);
      }
    });
    const cached = await cache.get(reqPath);
    if (cached) {
      writeToCache = false;
      realEnd(cached);
      return;
    }
    next();
  });
  return cacheMiddleware;
};

exports.createCacheMiddleware = createCacheMiddleware;
//# sourceMappingURL=cacheMiddleware.cjs.js.map
