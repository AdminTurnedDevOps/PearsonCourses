'use strict';

var errors = require('@backstage/errors');

class CacheInvalidationError extends errors.CustomErrorBase {
}
class TechDocsCache {
  cache;
  logger;
  readTimeout;
  constructor({
    cache,
    logger,
    readTimeout
  }) {
    this.cache = cache;
    this.logger = logger;
    this.readTimeout = readTimeout;
  }
  static fromConfig(config, { cache, logger }) {
    const timeout = config.getOptionalNumber("techdocs.cache.readTimeout");
    const readTimeout = timeout === void 0 ? 1e3 : timeout;
    return new TechDocsCache({ cache, logger, readTimeout });
  }
  async get(path) {
    try {
      const response = await Promise.race([
        this.cache.get(path),
        new Promise((cancelAfter) => setTimeout(cancelAfter, this.readTimeout))
      ]);
      if (response !== void 0) {
        this.logger.debug(`Cache hit: ${path}`);
        return Buffer.from(response, "base64");
      }
      this.logger.debug(`Cache miss: ${path}`);
      return response;
    } catch (e) {
      errors.assertError(e);
      this.logger.warn(`Error getting cache entry ${path}: ${e.message}`);
      this.logger.debug(e.message, e);
      return void 0;
    }
  }
  async set(path, data) {
    this.logger.debug(`Writing cache entry for ${path}`);
    this.cache.set(path, data.toString("base64")).catch((e) => this.logger.error("write error", e));
  }
  async invalidate(path) {
    return this.cache.delete(path);
  }
  async invalidateMultiple(paths) {
    const settled = await Promise.allSettled(
      paths.map((path) => this.cache.delete(path))
    );
    const rejected = settled.filter(
      (s) => s.status === "rejected"
    );
    if (rejected.length) {
      throw new CacheInvalidationError(
        "TechDocs cache invalidation error",
        rejected
      );
    }
    return settled;
  }
}

exports.CacheInvalidationError = CacheInvalidationError;
exports.TechDocsCache = TechDocsCache;
//# sourceMappingURL=TechDocsCache.cjs.js.map
