import { SessionScopeHelper } from './common.esm.js';
import { SessionStateTracker } from './SessionStateTracker.esm.js';

class StaticAuthSessionManager {
  connector;
  helper;
  stateTracker = new SessionStateTracker();
  currentSession;
  constructor(options) {
    const { connector, defaultScopes = /* @__PURE__ */ new Set(), sessionScopes } = options;
    this.connector = connector;
    this.helper = new SessionScopeHelper({ sessionScopes, defaultScopes });
  }
  setSession(session) {
    this.currentSession = session;
    this.stateTracker.setIsSignedIn(Boolean(session));
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      return this.currentSession;
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  /**
   * We don't call this.connector.removeSession here, since this session manager
   * is intended to be static. As such there's no need to hit the remote logout
   * endpoint - simply discarding the local session state when signing out is
   * enough.
   */
  async removeSession() {
    this.currentSession = void 0;
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
}

export { StaticAuthSessionManager };
//# sourceMappingURL=StaticAuthSessionManager.esm.js.map
