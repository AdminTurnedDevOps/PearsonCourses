{"version":3,"file":"ApiFactoryRegistry.esm.js","sources":["../../../src/apis/system/ApiFactoryRegistry.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiFactoryHolder } from './types';\nimport {\n  ApiRef,\n  ApiFactory,\n  AnyApiRef,\n  AnyApiFactory,\n} from '@backstage/core-plugin-api';\n\n/**\n * Scope type when registering API factories.\n * @public\n */\nexport type ApiFactoryScope =\n  | 'default' // Default factories registered by core and plugins\n  | 'app' // Factories registered in the app, overriding default ones\n  | 'static'; // APIs that can't be overridden, e.g. config\n\nenum ScopePriority {\n  default = 10,\n  app = 50,\n  static = 100,\n}\n\ntype FactoryTuple = {\n  priority: number;\n  factory: AnyApiFactory;\n};\n\n/**\n * ApiFactoryRegistry is an ApiFactoryHolder implementation that enables\n * registration of API Factories with different scope.\n *\n * Each scope has an assigned priority, where factories registered with\n * higher priority scopes override ones with lower priority.\n *\n * @public\n */\nexport class ApiFactoryRegistry implements ApiFactoryHolder {\n  private readonly factories = new Map<string, FactoryTuple>();\n\n  /**\n   * Register a new API factory. Returns true if the factory was added\n   * to the registry.\n   *\n   * A factory will not be added to the registry if there is already\n   * an existing factory with the same or higher priority.\n   */\n  register<Api, Impl extends Api, Deps extends { [name in string]: unknown }>(\n    scope: ApiFactoryScope,\n    factory: ApiFactory<Api, Impl, Deps>,\n  ) {\n    const priority = ScopePriority[scope];\n    const existing = this.factories.get(factory.api.id);\n    if (existing && existing.priority >= priority) {\n      return false;\n    }\n\n    this.factories.set(factory.api.id, { priority, factory });\n    return true;\n  }\n\n  get<T>(\n    api: ApiRef<T>,\n  ): ApiFactory<T, T, { [x: string]: unknown }> | undefined {\n    const tuple = this.factories.get(api.id);\n    if (!tuple) {\n      return undefined;\n    }\n    return tuple.factory as ApiFactory<T, T, { [x: string]: unknown }>;\n  }\n\n  getAllApis(): Set<AnyApiRef> {\n    const refs = new Set<AnyApiRef>();\n    for (const { factory } of this.factories.values()) {\n      refs.add(factory.api);\n    }\n    return refs;\n  }\n}\n"],"names":["ScopePriority"],"mappings":"AAiCA,IAAK,aAAA,qBAAAA,cAAL,KAAA;AACE,EAAAA,cAAAA,CAAAA,cAAAA,CAAA,aAAU,EAAV,CAAA,GAAA,SAAA;AACA,EAAAA,cAAAA,CAAAA,cAAAA,CAAA,SAAM,EAAN,CAAA,GAAA,KAAA;AACA,EAAAA,cAAAA,CAAAA,cAAAA,CAAA,YAAS,GAAT,CAAA,GAAA,QAAA;AAHG,EAAAA,OAAAA,cAAAA;AAAA,CAAA,EAAA,aAAA,IAAA,EAAA,CAAA;AAoBE,MAAM,kBAA+C,CAAA;AAAA,EACzC,SAAA,uBAAgB,GAA0B,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS3D,QAAA,CACE,OACA,OACA,EAAA;AACA,IAAM,MAAA,QAAA,GAAW,cAAc,KAAK,CAAA;AACpC,IAAA,MAAM,WAAW,IAAK,CAAA,SAAA,CAAU,GAAI,CAAA,OAAA,CAAQ,IAAI,EAAE,CAAA;AAClD,IAAI,IAAA,QAAA,IAAY,QAAS,CAAA,QAAA,IAAY,QAAU,EAAA;AAC7C,MAAO,OAAA,KAAA;AAAA;AAGT,IAAK,IAAA,CAAA,SAAA,CAAU,IAAI,OAAQ,CAAA,GAAA,CAAI,IAAI,EAAE,QAAA,EAAU,SAAS,CAAA;AACxD,IAAO,OAAA,IAAA;AAAA;AACT,EAEA,IACE,GACwD,EAAA;AACxD,IAAA,MAAM,KAAQ,GAAA,IAAA,CAAK,SAAU,CAAA,GAAA,CAAI,IAAI,EAAE,CAAA;AACvC,IAAA,IAAI,CAAC,KAAO,EAAA;AACV,MAAO,OAAA,KAAA,CAAA;AAAA;AAET,IAAA,OAAO,KAAM,CAAA,OAAA;AAAA;AACf,EAEA,UAA6B,GAAA;AAC3B,IAAM,MAAA,IAAA,uBAAW,GAAe,EAAA;AAChC,IAAA,KAAA,MAAW,EAAE,OAAQ,EAAA,IAAK,IAAK,CAAA,SAAA,CAAU,QAAU,EAAA;AACjD,MAAK,IAAA,CAAA,GAAA,CAAI,QAAQ,GAAG,CAAA;AAAA;AAEtB,IAAO,OAAA,IAAA;AAAA;AAEX;;;;"}