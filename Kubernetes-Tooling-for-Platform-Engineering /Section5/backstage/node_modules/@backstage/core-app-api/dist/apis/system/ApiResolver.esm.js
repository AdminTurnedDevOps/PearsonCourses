class ApiResolver {
  constructor(factories) {
    this.factories = factories;
  }
  /**
   * Validate factories by making sure that each of the apis can be created
   * without hitting any circular dependencies.
   */
  static validateFactories(factories, apis) {
    for (const api of apis) {
      const heap = [api];
      const allDeps = /* @__PURE__ */ new Set();
      while (heap.length) {
        const apiRef = heap.shift();
        const factory = factories.get(apiRef);
        if (!factory) {
          continue;
        }
        for (const dep of Object.values(factory.deps)) {
          if (dep.id === api.id) {
            throw new Error(`Circular dependency of api factory for ${api}`);
          }
          if (!allDeps.has(dep)) {
            allDeps.add(dep);
            heap.push(dep);
          }
        }
      }
    }
  }
  apis = /* @__PURE__ */ new Map();
  get(ref) {
    return this.load(ref);
  }
  load(ref, loading = []) {
    const impl = this.apis.get(ref.id);
    if (impl) {
      return impl;
    }
    const factory = this.factories.get(ref);
    if (!factory) {
      return void 0;
    }
    if (loading.includes(factory.api)) {
      throw new Error(`Circular dependency of api factory for ${factory.api}`);
    }
    const deps = this.loadDeps(ref, factory.deps, [...loading, factory.api]);
    const api = factory.factory(deps);
    this.apis.set(ref.id, api);
    return api;
  }
  loadDeps(dependent, apis, loading) {
    const impls = {};
    for (const key in apis) {
      if (apis.hasOwnProperty(key)) {
        const ref = apis[key];
        const api = this.load(ref, loading);
        if (!api) {
          throw new Error(
            `No API factory available for dependency ${ref} of dependent ${dependent}`
          );
        }
        impls[key] = api;
      }
    }
    return impls;
  }
}

export { ApiResolver };
//# sourceMappingURL=ApiResolver.esm.js.map
