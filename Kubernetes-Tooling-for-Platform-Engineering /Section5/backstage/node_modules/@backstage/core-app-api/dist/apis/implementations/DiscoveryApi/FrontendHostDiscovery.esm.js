import { UrlPatternDiscovery } from './UrlPatternDiscovery.esm.js';

class FrontendHostDiscovery {
  constructor(endpoints, defaultEndpoint) {
    this.endpoints = endpoints;
    this.defaultEndpoint = defaultEndpoint;
  }
  /**
   * Creates a new FrontendHostDiscovery discovery instance by reading
   * the external target URL from the `discovery.endpoints` config section.
   *
   * eg.
   * ```yaml
   * discovery:
   *  endpoints:
   *    - target: https://internal.example.com/internal-catalog
   *      plugins: [catalog]
   *    - target: https://internal.example.com/secure/api/{{pluginId}}
   *      plugins: [auth, permissions]
   *    - target:
   *        internal: https://internal.example.com/search
   *        external: https://example.com/search
   *      plugins: [search]
   * ```
   *
   * If a plugin is not declared in the config, the discovery will fall back to using the baseUrl with
   * the provided `pathPattern` appended. The default path pattern is `"/api/{{ pluginId }}"`.
   */
  static fromConfig(config, options) {
    const path = options?.pathPattern ?? "/api/{{ pluginId }}";
    const baseUrl = config.getString("backend.baseUrl");
    const endpoints = config.getOptionalConfigArray("discovery.endpoints")?.flatMap((e) => {
      const target = typeof e.get("target") === "object" ? e.getString("target.external") : e.getString("target");
      const discovery = UrlPatternDiscovery.compile(target);
      return e.getStringArray("plugins").map((pluginId) => [pluginId, discovery]);
    });
    return new FrontendHostDiscovery(
      new Map(endpoints),
      UrlPatternDiscovery.compile(`${baseUrl}${path}`)
    );
  }
  async getBaseUrl(pluginId) {
    const endpoint = this.endpoints.get(pluginId);
    if (endpoint) {
      return endpoint.getBaseUrl(pluginId);
    }
    return this.defaultEndpoint.getBaseUrl(pluginId);
  }
}

export { FrontendHostDiscovery };
//# sourceMappingURL=FrontendHostDiscovery.esm.js.map
