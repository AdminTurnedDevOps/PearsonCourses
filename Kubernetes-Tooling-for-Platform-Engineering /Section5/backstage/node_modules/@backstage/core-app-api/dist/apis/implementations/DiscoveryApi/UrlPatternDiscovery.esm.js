const ERROR_PREFIX = "Invalid discovery URL pattern,";
class UrlPatternDiscovery {
  constructor(parts) {
    this.parts = parts;
  }
  /**
   * Creates a new UrlPatternDiscovery given a template. The only
   * interpolation done for the template is to replace instances of `{{pluginId}}`
   * with the ID of the plugin being requested.
   *
   * Example pattern: `http://localhost:7007/api/{{ pluginId }}`
   */
  static compile(pattern) {
    const parts = pattern.split(/\{\{\s*pluginId\s*\}\}/);
    const urlStr = parts.join("pluginId");
    let url;
    try {
      url = new URL(urlStr);
    } catch {
      throw new Error(`${ERROR_PREFIX} URL '${urlStr}' is invalid`);
    }
    if (url.hash) {
      throw new Error(`${ERROR_PREFIX} URL must not have a hash`);
    }
    if (url.search) {
      throw new Error(`${ERROR_PREFIX} URL must not have a query`);
    }
    if (urlStr.endsWith("/")) {
      throw new Error(`${ERROR_PREFIX} URL must not end with a slash`);
    }
    return new UrlPatternDiscovery(parts);
  }
  async getBaseUrl(pluginId) {
    return this.parts.join(encodeURIComponent(pluginId));
  }
}

export { UrlPatternDiscovery };
//# sourceMappingURL=UrlPatternDiscovery.esm.js.map
