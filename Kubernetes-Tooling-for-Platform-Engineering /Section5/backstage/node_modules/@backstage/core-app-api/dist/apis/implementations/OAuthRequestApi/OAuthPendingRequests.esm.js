import { BehaviorSubject } from '../../../lib/subjects.esm.js';

function hasScopes(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
function joinScopes(scopes, ...moreScopess) {
  const result = new Set(scopes);
  for (const moreScopes of moreScopess) {
    for (const scope of moreScopes) {
      result.add(scope);
    }
  }
  return result;
}
class OAuthPendingRequests {
  requests = [];
  subject = new BehaviorSubject(
    this.getCurrentPending()
  );
  request(scopes) {
    return new Promise((resolve, reject) => {
      this.requests.push({ scopes, resolve, reject });
      this.subject.next(this.getCurrentPending());
    });
  }
  resolve(scopes, result) {
    this.requests = this.requests.filter((request) => {
      if (hasScopes(scopes, request.scopes)) {
        request.resolve(result);
        return false;
      }
      return true;
    });
    this.subject.next(this.getCurrentPending());
  }
  reject(error) {
    this.requests.forEach((request) => request.reject(error));
    this.requests = [];
    this.subject.next(this.getCurrentPending());
  }
  pending() {
    return this.subject;
  }
  getCurrentPending() {
    const currentScopes = this.requests.length === 0 ? void 0 : this.requests.slice(1).reduce(
      (acc, current) => joinScopes(acc, current.scopes),
      this.requests[0].scopes
    );
    return {
      scopes: currentScopes,
      resolve: (value) => {
        if (currentScopes) {
          this.resolve(currentScopes, value);
        }
      },
      reject: (reason) => {
        if (currentScopes) {
          this.reject(reason);
        }
      }
    };
  }
}

export { OAuthPendingRequests, hasScopes, joinScopes };
//# sourceMappingURL=OAuthPendingRequests.esm.js.map
