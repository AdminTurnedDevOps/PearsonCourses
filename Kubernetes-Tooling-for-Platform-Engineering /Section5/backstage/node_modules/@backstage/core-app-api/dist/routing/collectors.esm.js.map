{"version":3,"file":"collectors.esm.js","sources":["../../src/routing/collectors.tsx"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  RouteRef,\n  getComponentData,\n  BackstagePlugin,\n} from '@backstage/core-plugin-api';\nimport { isValidElement, ReactNode, Children } from 'react';\nimport { BackstageRouteObject } from './types';\nimport { createCollector } from '../extensions/traversal';\nimport { FeatureFlagged, FeatureFlaggedProps } from './FeatureFlagged';\n\n// We always add a child that matches all subroutes but without any route refs. This makes\n// sure that we're always able to match each route no matter how deep the navigation goes.\n// The route resolver then takes care of selecting the most specific match in order to find\n// mount points that are as deep in the routing tree as possible.\nexport const MATCH_ALL_ROUTE: BackstageRouteObject = {\n  caseSensitive: false,\n  path: '*',\n  element: 'match-all', // These elements aren't used, so we add in a bit of debug information\n  routeRefs: new Set(),\n  plugins: new Set(),\n};\n\nfunction stringifyNode(node: ReactNode): string {\n  const anyNode = node as { type?: { displayName?: string; name?: string } };\n  if (anyNode?.type) {\n    return (\n      anyNode.type.displayName ?? anyNode.type.name ?? String(anyNode.type)\n    );\n  }\n  return String(anyNode);\n}\n\nconst pluginSet = (\n  plugin: BackstagePlugin | undefined,\n): Set<BackstagePlugin> => {\n  const set = new Set<BackstagePlugin>();\n  if (plugin) {\n    set.add(plugin);\n  }\n  return set;\n};\n\ninterface RoutingV2CollectorContext {\n  routeRef?: RouteRef;\n  gatherPath?: string;\n  gatherRouteRef?: RouteRef;\n  obj?: BackstageRouteObject;\n  isElementAncestor?: boolean;\n}\n\n// This collects all the mount points and their plugins within an element tree.\n// Unlike regular traversal this ignores all other things, like path props and mount point gatherers.\nfunction collectSubTree(\n  node: ReactNode,\n  entries = new Array<{ routeRef: RouteRef; plugin?: BackstagePlugin }>(),\n) {\n  Children.forEach(node, element => {\n    if (!isValidElement(element)) {\n      return;\n    }\n\n    const routeRef = getComponentData<RouteRef>(element, 'core.mountPoint');\n    if (routeRef) {\n      const plugin = getComponentData<BackstagePlugin>(element, 'core.plugin');\n      entries.push({ routeRef, plugin });\n    }\n\n    collectSubTree(element.props.children, entries);\n  });\n\n  return entries;\n}\n\nexport const routingV2Collector = createCollector(\n  () => ({\n    paths: new Map<RouteRef, string>(),\n    parents: new Map<RouteRef, RouteRef | undefined>(),\n    objects: new Array<BackstageRouteObject>(),\n  }),\n  (acc, node, parent, ctx?: RoutingV2CollectorContext) => {\n    // If we're in an element prop, ignore everything\n    if (ctx?.isElementAncestor) {\n      return ctx;\n    }\n\n    // Start ignoring everything if we enter an element prop\n    if (parent?.props.element === node) {\n      return { ...ctx, isElementAncestor: true };\n    }\n\n    const pathProp: unknown = node.props?.path;\n\n    const mountPoint = getComponentData<RouteRef>(node, 'core.mountPoint');\n    if (mountPoint && pathProp) {\n      throw new Error(\n        `Path property may not be set directly on a routable extension \"${stringifyNode(\n          node,\n        )}\"`,\n      );\n    }\n\n    const parentChildren = ctx?.obj?.children ?? acc.objects;\n\n    if (pathProp !== undefined) {\n      if (typeof pathProp !== 'string') {\n        throw new Error(\n          `Element path must be a string at \"${stringifyNode(node)}\"`,\n        );\n      }\n\n      const path = pathProp.startsWith('/') ? pathProp.slice(1) : pathProp;\n\n      const elementProp = node.props.element;\n\n      if (getComponentData<boolean>(node, 'core.gatherMountPoints')) {\n        if (elementProp) {\n          throw new Error(\n            `Mount point gatherers may not have an element prop \"${stringifyNode(\n              node,\n            )}\"`,\n          );\n        }\n\n        const newObj = {\n          path,\n          element: 'gathered',\n          routeRefs: new Set<RouteRef>(),\n          caseSensitive: Boolean(node.props?.caseSensitive),\n          children: [MATCH_ALL_ROUTE],\n          plugins: new Set<BackstagePlugin>(),\n        };\n        parentChildren.push(newObj);\n\n        return {\n          obj: newObj,\n          gatherPath: path,\n          routeRef: ctx?.routeRef,\n          gatherRouteRef: ctx?.routeRef,\n        };\n      }\n\n      if (elementProp) {\n        const [extension, ...others] = collectSubTree(elementProp);\n        if (others.length > 0) {\n          throw new Error(\n            `Route element with path \"${pathProp}\" may not contain multiple routable extensions`,\n          );\n        }\n        if (!extension) {\n          return ctx;\n        }\n        const { routeRef, plugin } = extension;\n\n        const newObj = {\n          path,\n          element: 'mounted',\n          routeRefs: new Set([routeRef]),\n          caseSensitive: Boolean(node.props?.caseSensitive),\n          children: [MATCH_ALL_ROUTE],\n          plugins: pluginSet(plugin),\n        };\n        parentChildren.push(newObj);\n        acc.paths.set(routeRef, path);\n        acc.parents.set(routeRef, ctx?.routeRef);\n\n        return {\n          obj: newObj,\n          routeRef: routeRef ?? ctx?.routeRef,\n          gatherPath: path,\n          gatherRouteRef: ctx?.gatherRouteRef,\n        };\n      }\n    }\n\n    if (mountPoint) {\n      if (ctx?.gatherPath === undefined) {\n        throw new Error(\n          `Routable extension \"${stringifyNode(\n            node,\n          )}\" with mount point \"${mountPoint}\" must be assigned a path`,\n        );\n      }\n\n      ctx?.obj?.routeRefs.add(mountPoint);\n\n      const mountPointPlugin = getComponentData<BackstagePlugin>(\n        node,\n        'core.plugin',\n      );\n      if (mountPointPlugin) {\n        ctx?.obj?.plugins.add(mountPointPlugin);\n      }\n\n      acc.paths.set(mountPoint, ctx.gatherPath);\n      acc.parents.set(mountPoint, ctx?.gatherRouteRef);\n\n      return {\n        ...ctx,\n        routeRef: mountPoint,\n      };\n    }\n\n    return ctx;\n  },\n);\n\ninterface RoutingV1CollectorContext {\n  path?: string;\n  routeRef?: RouteRef;\n  obj?: BackstageRouteObject;\n  sticky?: boolean;\n}\n\n/**\n * This is the old V1 logic for collecting the routing model.\n * It is being replaced by a new collector because this collection\n * logic does not work well beyond react-router v6 beta.\n *\n * The breaking change is that react-router now requires route\n * elements to be `Route` components, and directly renders the\n * element prop rather than the `Route` itself. This means it is\n * no longer possible to create utility route components. In order\n * to fill this gap and in general simplify the route collection\n * logic, a new route collection logic is created.\n *\n * @internal\n */\nexport const routingV1Collector = createCollector(\n  () => ({\n    paths: new Map<RouteRef, string>(),\n    parents: new Map<RouteRef, RouteRef | undefined>(),\n    objects: new Array<BackstageRouteObject>(),\n  }),\n  (acc, node, parent, ctx?: RoutingV1CollectorContext) => {\n    // Ignore the top-level element within element props, since it's already been collected.\n    if (parent?.props.element === node) {\n      return ctx;\n    }\n\n    let currentObj = ctx?.obj;\n    let currentParentRouteRef = ctx?.routeRef;\n    let sticky = ctx?.sticky;\n\n    const path: string | undefined = node.props?.path;\n    const parentChildren = currentObj?.children ?? acc.objects;\n    const caseSensitive: boolean = Boolean(node.props?.caseSensitive);\n\n    // The context path is used during mount point gathering to assign the same path\n    // to all discovered mount points\n    let currentCtxPath = ctx?.path;\n\n    // Start gathering mount points when we encounter a mount point gathering flag\n    if (getComponentData<boolean>(node, 'core.gatherMountPoints')) {\n      if (!path) {\n        throw new Error('Mount point gatherer must have a path');\n      }\n      currentCtxPath = path;\n    }\n\n    // Route refs are discovered on the element itself, and on the top-level\n    // element within the element prop if it exists.\n    const element = node.props?.element;\n    let routeRef = getComponentData<RouteRef>(node, 'core.mountPoint');\n    if (!routeRef && isValidElement(element)) {\n      routeRef = getComponentData<RouteRef>(element, 'core.mountPoint');\n    }\n\n    if (routeRef) {\n      // First the path gathering\n\n      let routePath: string | undefined = path;\n      // If we're gathering mount points we use the context path as out path, unless\n      // the element has its own path, in which case we use that instead and stop gathering\n      if (currentCtxPath) {\n        if (routePath) {\n          currentCtxPath = undefined;\n        } else {\n          routePath = currentCtxPath;\n        }\n      }\n      if (!routePath) {\n        throw new Error('Mounted routable extension must have a path');\n      }\n      acc.paths.set(routeRef, routePath);\n\n      // Then the parent gathering\n\n      // \"sticky\" route ref is when we've encountered a mount point gatherer, and we want a\n      // mount points beneath it to have the same parent, regardless of internal structure\n      if (currentParentRouteRef && sticky) {\n        acc.parents.set(routeRef, currentParentRouteRef);\n\n        // When we encounter a mount point with an explicit path, we stop gathering\n        // mount points within the children and remove the sticky state\n        if (path) {\n          currentParentRouteRef = routeRef;\n          sticky = false;\n        }\n      } else {\n        acc.parents.set(routeRef, currentParentRouteRef);\n        currentParentRouteRef = routeRef;\n      }\n\n      // Then construct the objects\n\n      if (path) {\n        currentObj = {\n          caseSensitive,\n          path,\n          element: 'mounted',\n          routeRefs: new Set([routeRef]),\n          children: [MATCH_ALL_ROUTE],\n          plugins: pluginSet(\n            getComponentData<BackstagePlugin>(\n              node.props.element,\n              'core.plugin',\n            ),\n          ),\n        };\n        parentChildren.push(currentObj);\n      } else {\n        currentObj?.routeRefs.add(routeRef);\n      }\n    }\n\n    if (getComponentData<boolean>(node, 'core.gatherMountPoints')) {\n      sticky = true;\n    }\n\n    const isGatherer = getComponentData<boolean>(\n      node,\n      'core.gatherMountPoints',\n    );\n    if (isGatherer) {\n      if (!path) {\n        throw new Error('Mount point gatherer must have a path');\n      }\n      if (!routeRef) {\n        currentObj = {\n          caseSensitive,\n          path,\n          element: 'gathered',\n          routeRefs: new Set(),\n          children: [MATCH_ALL_ROUTE],\n          plugins: ctx?.obj?.plugins || new Set(),\n        };\n        parentChildren.push(currentObj);\n      }\n    }\n\n    return {\n      obj: currentObj,\n      path: currentCtxPath,\n      routeRef: currentParentRouteRef,\n      sticky,\n    };\n  },\n);\n\nexport const featureFlagCollector = createCollector(\n  () => new Set<string>(),\n  (acc, node) => {\n    if (node.type === FeatureFlagged) {\n      const props = node.props as FeatureFlaggedProps;\n      acc.add('with' in props ? props.with : props.without);\n    }\n  },\n);\n"],"names":[],"mappings":"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"}