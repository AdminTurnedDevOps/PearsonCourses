import { matchRoutes, generatePath } from 'react-router-dom';
import { isRouteRef, isSubRouteRef, isExternalRouteRef, routeRefType } from './types.esm.js';
import { joinPaths } from './helpers.esm.js';
import mapValues from 'lodash/mapValues';

function resolveTargetRef(anyRouteRef, routePaths, routeBindings) {
  let targetRef;
  let subRoutePath = "";
  if (isRouteRef(anyRouteRef)) {
    targetRef = anyRouteRef;
  } else if (isSubRouteRef(anyRouteRef)) {
    targetRef = anyRouteRef.parent;
    subRoutePath = anyRouteRef.path;
  } else if (isExternalRouteRef(anyRouteRef)) {
    const resolvedRoute = routeBindings.get(anyRouteRef);
    if (!resolvedRoute) {
      return [void 0, ""];
    }
    if (isRouteRef(resolvedRoute)) {
      targetRef = resolvedRoute;
    } else if (isSubRouteRef(resolvedRoute)) {
      targetRef = resolvedRoute.parent;
      subRoutePath = resolvedRoute.path;
    } else {
      throw new Error(
        `ExternalRouteRef was bound to invalid target, ${resolvedRoute}`
      );
    }
  } else if (anyRouteRef[routeRefType]) {
    throw new Error(
      `Unknown or invalid route ref type, ${anyRouteRef[routeRefType]}`
    );
  } else {
    throw new Error(`Unknown object passed to useRouteRef, got ${anyRouteRef}`);
  }
  if (!targetRef) {
    return [void 0, ""];
  }
  const resolvedPath = routePaths.get(targetRef);
  if (resolvedPath === void 0) {
    return [void 0, ""];
  }
  const targetPath = joinPaths(resolvedPath, subRoutePath);
  return [targetRef, targetPath];
}
function resolveBasePath(targetRef, sourceLocation, routePaths, routeParents, routeObjects) {
  const match = matchRoutes(routeObjects, sourceLocation) ?? [];
  const refDiffList = Array();
  let matchIndex = -1;
  for (let targetSearchRef = targetRef; targetSearchRef; targetSearchRef = routeParents.get(targetSearchRef)) {
    matchIndex = match.findIndex(
      (m) => m.route.routeRefs.has(targetSearchRef)
    );
    if (matchIndex !== -1) {
      break;
    }
    refDiffList.unshift(targetSearchRef);
  }
  if (refDiffList.length === 0) {
    matchIndex -= 1;
  }
  const parentPath = matchIndex === -1 ? "" : match[matchIndex].pathname;
  const diffPaths = refDiffList.slice(0, -1).map((ref) => {
    const path = routePaths.get(ref);
    if (path === void 0) {
      throw new Error(`No path for ${ref}`);
    }
    if (path.includes(":")) {
      throw new Error(
        `Cannot route to ${targetRef} with parent ${ref} as it has parameters`
      );
    }
    return path;
  });
  return `${joinPaths(parentPath, ...diffPaths)}/`;
}
class RouteResolver {
  constructor(routePaths, routeParents, routeObjects, routeBindings, appBasePath) {
    this.routePaths = routePaths;
    this.routeParents = routeParents;
    this.routeObjects = routeObjects;
    this.routeBindings = routeBindings;
    this.appBasePath = appBasePath;
  }
  resolve(anyRouteRef, sourceLocation) {
    const [targetRef, targetPath] = resolveTargetRef(
      anyRouteRef,
      this.routePaths,
      this.routeBindings
    );
    if (!targetRef) {
      return void 0;
    }
    let relativeSourceLocation;
    if (typeof sourceLocation === "string") {
      relativeSourceLocation = this.trimPath(sourceLocation);
    } else if (sourceLocation.pathname) {
      relativeSourceLocation = {
        ...sourceLocation,
        pathname: this.trimPath(sourceLocation.pathname)
      };
    } else {
      relativeSourceLocation = sourceLocation;
    }
    const basePath = this.appBasePath + resolveBasePath(
      targetRef,
      relativeSourceLocation,
      this.routePaths,
      this.routeParents,
      this.routeObjects
    );
    const routeFunc = (...[params]) => {
      const encodedParams = params && mapValues(params, (value) => {
        if (typeof value === "string") {
          return value.replaceAll(/[&?#;\/]/g, (c) => encodeURIComponent(c));
        }
        return value;
      });
      return joinPaths(basePath, generatePath(targetPath, encodedParams));
    };
    return routeFunc;
  }
  trimPath(targetPath) {
    if (!targetPath) {
      return targetPath;
    }
    if (targetPath.startsWith(this.appBasePath)) {
      return targetPath.slice(this.appBasePath.length);
    }
    return targetPath;
  }
}

export { RouteResolver };
//# sourceMappingURL=RouteResolver.esm.js.map
