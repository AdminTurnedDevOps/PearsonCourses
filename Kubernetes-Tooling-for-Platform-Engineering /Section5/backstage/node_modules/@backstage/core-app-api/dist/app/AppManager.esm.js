import React, { useRef, useMemo, Suspense } from 'react';
import useAsync from 'react-use/esm/useAsync';
import { ApiProvider } from '../apis/system/ApiProvider.esm.js';
import { ApiResolver } from '../apis/system/ApiResolver.esm.js';
import { ApiFactoryRegistry } from '../apis/system/ApiFactoryRegistry.esm.js';
import 'zen-observable';
import { appThemeApiRef, configApiRef, identityApiRef, featureFlagsApiRef, errorApiRef, fetchApiRef, discoveryApiRef } from '@backstage/core-plugin-api';
import '../apis/implementations/auth/saml/types.esm.js';
import { AppThemeSelector } from '../apis/implementations/AppThemeApi/AppThemeSelector.esm.js';
import { ConfigReader } from '@backstage/config';
import { LocalStorageFeatureFlags } from '../apis/implementations/FeatureFlagsApi/LocalStorageFeatureFlags.esm.js';
import { appLanguageApiRef, translationApiRef } from '@backstage/core-plugin-api/alpha';
import { traverseElementTree, childDiscoverer, routeElementDiscoverer } from '../extensions/traversal.esm.js';
import { pluginCollector } from '../plugins/collectors.esm.js';
import { routingV1Collector, routingV2Collector, featureFlagCollector } from '../routing/collectors.esm.js';
import { RoutingProvider } from '../routing/RoutingProvider.esm.js';
import { validateRouteParameters, validateRouteBindings } from '../routing/validation.esm.js';
import { AppContextProvider } from './AppContext.esm.js';
import { AppIdentityProxy } from '../apis/implementations/IdentityApi/AppIdentityProxy.esm.js';
import { AppThemeProvider } from './AppThemeProvider.esm.js';
import { defaultConfigLoader } from './defaultConfigLoader.esm.js';
import { ApiRegistry } from '../apis/system/ApiRegistry.esm.js';
import { resolveRouteBindings } from './resolveRouteBindings.esm.js';
import { isReactRouterBeta } from './isReactRouterBeta.esm.js';
import { InternalAppContext } from './InternalAppContext.esm.js';
import { AppRouter, getBasePath } from './AppRouter.esm.js';
import { AppLanguageSelector } from '../apis/implementations/AppLanguageApi/AppLanguageSelector.esm.js';
import { I18nextTranslationApi } from '../apis/implementations/TranslationApi/I18nextTranslationApi.esm.js';
import { overrideBaseUrlConfigs } from './overrideBaseUrlConfigs.esm.js';
import { isProtectedApp } from './isProtectedApp.esm.js';

function useConfigLoader(configLoader, components, appThemeApi) {
  const hasConfig = Boolean(configLoader);
  const config = useAsync(configLoader || (() => Promise.resolve([])));
  let noConfigNode = void 0;
  if (hasConfig && config.loading) {
    const { Progress } = components;
    noConfigNode = /* @__PURE__ */ React.createElement(Progress, null);
  } else if (config.error) {
    const { BootErrorPage } = components;
    noConfigNode = /* @__PURE__ */ React.createElement(BootErrorPage, { step: "load-config", error: config.error });
  }
  const { ThemeProvider = AppThemeProvider } = components;
  if (noConfigNode) {
    return {
      node: /* @__PURE__ */ React.createElement(ApiProvider, { apis: ApiRegistry.with(appThemeApiRef, appThemeApi) }, /* @__PURE__ */ React.createElement(ThemeProvider, null, noConfigNode))
    };
  }
  const configReader = ConfigReader.fromConfigs(
    config.value?.length ? overrideBaseUrlConfigs(config.value) : []
  );
  return { api: configReader };
}
class AppContextImpl {
  constructor(app) {
    this.app = app;
  }
  getPlugins() {
    return this.app.getPlugins();
  }
  getSystemIcon(key) {
    return this.app.getSystemIcon(key);
  }
  getSystemIcons() {
    return this.app.getSystemIcons();
  }
  getComponents() {
    return this.app.getComponents();
  }
}
class AppManager {
  apiHolder;
  configApi;
  apis;
  icons;
  plugins;
  featureFlags;
  components;
  themes;
  configLoader;
  defaultApis;
  bindRoutes;
  appLanguageApi;
  translationResources;
  appIdentityProxy = new AppIdentityProxy();
  apiFactoryRegistry;
  constructor(options) {
    this.apis = options.apis ?? [];
    this.icons = options.icons;
    this.plugins = new Set(options.plugins ?? []);
    this.featureFlags = options.featureFlags ?? [];
    this.components = options.components;
    this.themes = options.themes;
    this.configLoader = options.configLoader ?? defaultConfigLoader;
    this.defaultApis = options.defaultApis ?? [];
    this.bindRoutes = options.bindRoutes;
    this.apiFactoryRegistry = new ApiFactoryRegistry();
    this.appLanguageApi = AppLanguageSelector.createWithStorage({
      defaultLanguage: options.__experimentalTranslations?.defaultLanguage,
      availableLanguages: options.__experimentalTranslations?.availableLanguages
    });
    this.translationResources = options.__experimentalTranslations?.resources ?? [];
  }
  getPlugins() {
    return Array.from(this.plugins);
  }
  getSystemIcon(key) {
    return this.icons[key];
  }
  getSystemIcons() {
    return this.icons;
  }
  getComponents() {
    return this.components;
  }
  createRoot(element) {
    const AppProvider = this.getProvider();
    const AppRoot = () => {
      return /* @__PURE__ */ React.createElement(AppProvider, null, element);
    };
    return AppRoot;
  }
  #getProviderCalled = false;
  getProvider() {
    if (this.#getProviderCalled) {
      throw new Error(
        "app.getProvider() or app.createRoot() has already been called, and can only be called once"
      );
    }
    this.#getProviderCalled = true;
    const appContext = new AppContextImpl(this);
    let routeBindings;
    let routeValidationError = void 0;
    const Provider = ({ children }) => {
      const needsFeatureFlagRegistrationRef = useRef(true);
      const appThemeApi = useMemo(
        () => AppThemeSelector.createWithStorage(this.themes),
        []
      );
      const { routing, featureFlags } = useMemo(() => {
        const usesReactRouterBeta = isReactRouterBeta();
        if (usesReactRouterBeta) {
          console.warn(`
DEPRECATION WARNING: React Router Beta is deprecated and support for it will be removed in a future release.
                     Please migrate to use React Router v6 stable.
                     See https://backstage.io/docs/tutorials/react-router-stable-migration
`);
        }
        const result = traverseElementTree({
          root: children,
          discoverers: [childDiscoverer, routeElementDiscoverer],
          collectors: {
            routing: usesReactRouterBeta ? routingV1Collector : routingV2Collector,
            collectedPlugins: pluginCollector,
            featureFlags: featureFlagCollector
          }
        });
        result.collectedPlugins.forEach((plugin) => this.plugins.add(plugin));
        this.verifyPlugins(this.plugins);
        this.getApiHolder();
        return result;
      }, [children]);
      const loadedConfig = useConfigLoader(
        this.configLoader,
        this.components,
        appThemeApi
      );
      const hasConfigApi = "api" in loadedConfig;
      if (hasConfigApi) {
        const { api } = loadedConfig;
        this.configApi = api;
      }
      if ("node" in loadedConfig) {
        return loadedConfig.node;
      }
      if (routeValidationError) {
        throw routeValidationError;
      } else if (!routeBindings) {
        try {
          routeBindings = resolveRouteBindings(
            this.bindRoutes,
            loadedConfig.api,
            this.plugins
          );
          validateRouteParameters(routing.paths, routing.parents);
          validateRouteBindings(routeBindings, this.plugins);
        } catch (error) {
          routeValidationError = error;
          throw error;
        }
      }
      if (hasConfigApi && needsFeatureFlagRegistrationRef.current) {
        needsFeatureFlagRegistrationRef.current = false;
        const featureFlagsApi = this.getApiHolder().get(featureFlagsApiRef);
        if (featureFlagsApi) {
          for (const flag of this.featureFlags) {
            featureFlagsApi.registerFlag({
              ...flag,
              pluginId: ""
            });
          }
          for (const plugin of this.plugins.values()) {
            if ("getFeatureFlags" in plugin) {
              for (const flag of plugin.getFeatureFlags()) {
                featureFlagsApi.registerFlag({
                  name: flag.name,
                  pluginId: plugin.getId()
                });
              }
            } else {
              for (const output of plugin.output()) {
                if (output.type === "feature-flag") {
                  featureFlagsApi.registerFlag({
                    name: output.name,
                    pluginId: plugin.getId()
                  });
                }
              }
            }
          }
          const registeredFlags = featureFlagsApi.getRegisteredFlags();
          const flagNames = new Set(registeredFlags.map((f) => f.name));
          for (const name of featureFlags) {
            if (!flagNames.has(name)) {
              featureFlagsApi.registerFlag({ name, pluginId: "" });
            }
          }
        }
      }
      const { ThemeProvider = AppThemeProvider, Progress } = this.components;
      const apis = this.getApiHolder();
      if (isProtectedApp()) {
        const errorApi = apis.get(errorApiRef);
        const fetchApi = apis.get(fetchApiRef);
        const discoveryApi = apis.get(discoveryApiRef);
        if (!errorApi || !fetchApi || !discoveryApi) {
          throw new Error(
            "App is running in protected mode but missing required APIs"
          );
        }
        this.appIdentityProxy.enableCookieAuth({
          errorApi,
          fetchApi,
          discoveryApi
        });
      }
      return /* @__PURE__ */ React.createElement(ApiProvider, { apis }, /* @__PURE__ */ React.createElement(AppContextProvider, { appContext }, /* @__PURE__ */ React.createElement(ThemeProvider, null, /* @__PURE__ */ React.createElement(
        RoutingProvider,
        {
          routePaths: routing.paths,
          routeParents: routing.parents,
          routeObjects: routing.objects,
          routeBindings,
          basePath: getBasePath(loadedConfig.api)
        },
        /* @__PURE__ */ React.createElement(
          InternalAppContext.Provider,
          {
            value: {
              routeObjects: routing.objects,
              appIdentityProxy: this.appIdentityProxy
            }
          },
          /* @__PURE__ */ React.createElement(Suspense, { fallback: /* @__PURE__ */ React.createElement(Progress, null) }, children)
        )
      ))));
    };
    return Provider;
  }
  getRouter() {
    return AppRouter;
  }
  getApiHolder() {
    if (this.apiHolder) {
      for (const plugin of this.plugins) {
        for (const factory of plugin.getApis()) {
          if (!this.apiFactoryRegistry.get(factory.api)) {
            this.apiFactoryRegistry.register("default", factory);
          }
        }
      }
      ApiResolver.validateFactories(
        this.apiFactoryRegistry,
        this.apiFactoryRegistry.getAllApis()
      );
      return this.apiHolder;
    }
    this.apiFactoryRegistry.register("static", {
      api: appThemeApiRef,
      deps: {},
      factory: () => AppThemeSelector.createWithStorage(this.themes)
    });
    this.apiFactoryRegistry.register("static", {
      api: configApiRef,
      deps: {},
      factory: () => {
        if (!this.configApi) {
          throw new Error(
            "Tried to access config API before config was loaded"
          );
        }
        return this.configApi;
      }
    });
    this.apiFactoryRegistry.register("static", {
      api: identityApiRef,
      deps: {},
      factory: () => this.appIdentityProxy
    });
    this.apiFactoryRegistry.register("static", {
      api: appLanguageApiRef,
      deps: {},
      factory: () => this.appLanguageApi
    });
    this.apiFactoryRegistry.register("default", {
      api: translationApiRef,
      deps: { languageApi: appLanguageApiRef },
      factory: ({ languageApi }) => I18nextTranslationApi.create({
        languageApi,
        resources: this.translationResources
      })
    });
    this.apiFactoryRegistry.register("default", {
      api: featureFlagsApiRef,
      deps: {},
      factory: () => new LocalStorageFeatureFlags()
    });
    for (const factory of this.defaultApis) {
      this.apiFactoryRegistry.register("default", factory);
    }
    for (const plugin of this.plugins) {
      for (const factory of plugin.getApis()) {
        if (!this.apiFactoryRegistry.register("default", factory)) {
          throw new Error(
            `Plugin ${plugin.getId()} tried to register duplicate or forbidden API factory for ${factory.api}`
          );
        }
      }
    }
    for (const factory of this.apis) {
      if (!this.apiFactoryRegistry.register("app", factory)) {
        throw new Error(
          `Duplicate or forbidden API factory for ${factory.api} in app`
        );
      }
    }
    ApiResolver.validateFactories(
      this.apiFactoryRegistry,
      this.apiFactoryRegistry.getAllApis()
    );
    this.apiHolder = new ApiResolver(this.apiFactoryRegistry);
    return this.apiHolder;
  }
  verifyPlugins(plugins) {
    const pluginIds = /* @__PURE__ */ new Set();
    for (const plugin of plugins) {
      const id = plugin.getId();
      if (pluginIds.has(id)) {
        throw new Error(`Duplicate plugin found '${id}'`);
      }
      pluginIds.add(id);
    }
  }
}

export { AppManager };
//# sourceMappingURL=AppManager.esm.js.map
