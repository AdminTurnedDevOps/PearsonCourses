function collectRouteIds(plugins) {
  const routesById = /* @__PURE__ */ new Map();
  const externalRoutesById = /* @__PURE__ */ new Map();
  for (const plugin of plugins) {
    for (const [name, ref] of Object.entries(plugin.routes ?? {})) {
      const refId = `${plugin.getId()}.${name}`;
      if (routesById.has(refId)) {
        throw new Error(`Unexpected duplicate route '${refId}'`);
      }
      routesById.set(refId, ref);
    }
    for (const [name, ref] of Object.entries(plugin.externalRoutes ?? {})) {
      const refId = `${plugin.getId()}.${name}`;
      if (externalRoutesById.has(refId)) {
        throw new Error(`Unexpected duplicate external route '${refId}'`);
      }
      externalRoutesById.set(refId, ref);
    }
  }
  return { routes: routesById, externalRoutes: externalRoutesById };
}
function resolveRouteBindings(bindRoutes, config, plugins) {
  const routesById = collectRouteIds(plugins);
  const result = /* @__PURE__ */ new Map();
  const disabledExternalRefs = /* @__PURE__ */ new Set();
  if (bindRoutes) {
    const bind = (externalRoutes, targetRoutes) => {
      for (const [key, value] of Object.entries(targetRoutes)) {
        const externalRoute = externalRoutes[key];
        if (!externalRoute) {
          throw new Error(`Key ${key} is not an existing external route`);
        }
        if (!value && !externalRoute.optional) {
          throw new Error(
            `External route ${key} is required but was ${value === false ? "disabled" : "not provided"}`
          );
        }
        if (value) {
          result.set(externalRoute, value);
        } else if (value === false) {
          disabledExternalRefs.add(externalRoute);
        }
      }
    };
    bindRoutes({ bind });
  }
  const bindings = config.getOptionalConfig("app.routes.bindings")?.get();
  if (bindings) {
    for (const [externalRefId, targetRefId] of Object.entries(bindings)) {
      if (!isValidTargetRefId(targetRefId)) {
        throw new Error(
          `Invalid config at app.routes.bindings['${externalRefId}'], value must be a non-empty string or false`
        );
      }
      const externalRef = routesById.externalRoutes.get(externalRefId);
      if (!externalRef) {
        throw new Error(
          `Invalid config at app.routes.bindings, '${externalRefId}' is not a valid external route`
        );
      }
      if (result.has(externalRef) || disabledExternalRefs.has(externalRef)) {
        continue;
      }
      if (targetRefId === false) {
        disabledExternalRefs.add(externalRef);
      } else {
        const targetRef = routesById.routes.get(targetRefId);
        if (!targetRef) {
          throw new Error(
            `Invalid config at app.routes.bindings['${externalRefId}'], '${targetRefId}' is not a valid route`
          );
        }
        result.set(externalRef, targetRef);
      }
    }
  }
  for (const externalRef of routesById.externalRoutes.values()) {
    if (!result.has(externalRef) && !disabledExternalRefs.has(externalRef)) {
      const defaultRefId = "getDefaultTarget" in externalRef ? externalRef.getDefaultTarget() : void 0;
      if (defaultRefId) {
        const defaultRef = routesById.routes.get(defaultRefId);
        if (defaultRef) {
          result.set(externalRef, defaultRef);
        }
      }
    }
  }
  return result;
}
function isValidTargetRefId(value) {
  if (value === false) {
    return true;
  }
  if (typeof value === "string" && value) {
    return true;
  }
  return false;
}

export { collectRouteIds, resolveRouteBindings };
//# sourceMappingURL=resolveRouteBindings.esm.js.map
