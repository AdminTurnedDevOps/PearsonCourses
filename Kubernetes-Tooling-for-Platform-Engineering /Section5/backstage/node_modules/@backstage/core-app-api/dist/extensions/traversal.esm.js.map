{"version":3,"file":"traversal.esm.js","sources":["../../src/extensions/traversal.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidElement, ReactNode, ReactElement, Children } from 'react';\n\nexport type Discoverer = (element: ReactElement) => ReactNode;\n\nexport type Collector<Result, Context> = () => {\n  accumulator: Result;\n  visit(\n    accumulator: Result,\n    element: ReactElement,\n    parent: ReactElement | undefined,\n    context: Context,\n  ): Context;\n};\n\n/**\n * A function that allows you to traverse a tree of React elements using\n * varying methods to discover child nodes and collect data along the way.\n */\nexport function traverseElementTree<Results>(options: {\n  root: ReactNode;\n  discoverers: Discoverer[];\n  collectors: { [name in keyof Results]: Collector<Results[name], any> };\n}): Results {\n  const collectors: {\n    [name in string]: ReturnType<Collector<any, any>>;\n  } = {};\n\n  // Bootstrap all collectors, initializing the accumulators and providing the visitor function\n  for (const name in options.collectors) {\n    if (options.collectors.hasOwnProperty(name)) {\n      collectors[name] = options.collectors[name]();\n    }\n  }\n\n  // Internal representation of an element in the tree that we're iterating over\n  type QueueItem = {\n    node: ReactNode;\n    parent: ReactElement | undefined;\n    contexts: { [name in string]: unknown };\n  };\n\n  const queue = [\n    {\n      node: Children.toArray(options.root),\n      parent: undefined,\n      contexts: {},\n    } as QueueItem,\n  ];\n\n  while (queue.length !== 0) {\n    const { node, parent, contexts } = queue.shift()!;\n\n    // While the parent and the element we pass on to collectors and discoverers\n    // have been validated and are known to be React elements, the child nodes\n    // emitted by the discoverers are not.\n    Children.forEach(node, element => {\n      if (!isValidElement(element)) {\n        return;\n      }\n\n      const nextContexts: QueueItem['contexts'] = {};\n\n      // Collectors populate their result data using the current node, and compute\n      // context for the next iteration\n      for (const name in collectors) {\n        if (collectors.hasOwnProperty(name)) {\n          const collector = collectors[name];\n\n          nextContexts[name] = collector.visit(\n            collector.accumulator,\n            element,\n            parent,\n            contexts[name],\n          );\n        }\n      }\n\n      // Discoverers provide ways to continue the traversal from the current element\n      for (const discoverer of options.discoverers) {\n        const children = discoverer(element);\n        if (children) {\n          queue.push({\n            node: children,\n            parent: element,\n            contexts: nextContexts,\n          });\n        }\n      }\n    });\n  }\n\n  return Object.fromEntries(\n    Object.entries(collectors).map(([name, c]) => [name, c.accumulator]),\n  ) as Results;\n}\n\nexport function createCollector<Result, Context>(\n  accumulatorFactory: () => Result,\n  visit: ReturnType<Collector<Result, Context>>['visit'],\n): Collector<Result, Context> {\n  return () => ({ accumulator: accumulatorFactory(), visit });\n}\n\nexport function childDiscoverer(element: ReactElement): ReactNode {\n  return element.props?.children;\n}\n\nexport function routeElementDiscoverer(element: ReactElement): ReactNode {\n  if (element.props?.path && element.props?.element) {\n    return element.props?.element;\n  }\n  return undefined;\n}\n"],"names":[],"mappings":";;AAkCO,SAAS,oBAA6B,OAIjC,EAAA;AACV,EAAA,MAAM,aAEF,EAAC;AAGL,EAAW,KAAA,MAAA,IAAA,IAAQ,QAAQ,UAAY,EAAA;AACrC,IAAA,IAAI,OAAQ,CAAA,UAAA,CAAW,cAAe,CAAA,IAAI,CAAG,EAAA;AAC3C,MAAA,UAAA,CAAW,IAAI,CAAA,GAAI,OAAQ,CAAA,UAAA,CAAW,IAAI,CAAE,EAAA;AAAA;AAC9C;AAUF,EAAA,MAAM,KAAQ,GAAA;AAAA,IACZ;AAAA,MACE,IAAM,EAAA,QAAA,CAAS,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA;AAAA,MACnC,MAAQ,EAAA,KAAA,CAAA;AAAA,MACR,UAAU;AAAC;AACb,GACF;AAEA,EAAO,OAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AACzB,IAAA,MAAM,EAAE,IAAM,EAAA,MAAA,EAAQ,QAAS,EAAA,GAAI,MAAM,KAAM,EAAA;AAK/C,IAAS,QAAA,CAAA,OAAA,CAAQ,MAAM,CAAW,OAAA,KAAA;AAChC,MAAI,IAAA,CAAC,cAAe,CAAA,OAAO,CAAG,EAAA;AAC5B,QAAA;AAAA;AAGF,MAAA,MAAM,eAAsC,EAAC;AAI7C,MAAA,KAAA,MAAW,QAAQ,UAAY,EAAA;AAC7B,QAAI,IAAA,UAAA,CAAW,cAAe,CAAA,IAAI,CAAG,EAAA;AACnC,UAAM,MAAA,SAAA,GAAY,WAAW,IAAI,CAAA;AAEjC,UAAa,YAAA,CAAA,IAAI,IAAI,SAAU,CAAA,KAAA;AAAA,YAC7B,SAAU,CAAA,WAAA;AAAA,YACV,OAAA;AAAA,YACA,MAAA;AAAA,YACA,SAAS,IAAI;AAAA,WACf;AAAA;AACF;AAIF,MAAW,KAAA,MAAA,UAAA,IAAc,QAAQ,WAAa,EAAA;AAC5C,QAAM,MAAA,QAAA,GAAW,WAAW,OAAO,CAAA;AACnC,QAAA,IAAI,QAAU,EAAA;AACZ,UAAA,KAAA,CAAM,IAAK,CAAA;AAAA,YACT,IAAM,EAAA,QAAA;AAAA,YACN,MAAQ,EAAA,OAAA;AAAA,YACR,QAAU,EAAA;AAAA,WACX,CAAA;AAAA;AACH;AACF,KACD,CAAA;AAAA;AAGH,EAAA,OAAO,MAAO,CAAA,WAAA;AAAA,IACZ,MAAO,CAAA,OAAA,CAAQ,UAAU,CAAA,CAAE,IAAI,CAAC,CAAC,IAAM,EAAA,CAAC,CAAM,KAAA,CAAC,IAAM,EAAA,CAAA,CAAE,WAAW,CAAC;AAAA,GACrE;AACF;AAEgB,SAAA,eAAA,CACd,oBACA,KAC4B,EAAA;AAC5B,EAAA,OAAO,OAAO,EAAE,WAAa,EAAA,kBAAA,IAAsB,KAAM,EAAA,CAAA;AAC3D;AAEO,SAAS,gBAAgB,OAAkC,EAAA;AAChE,EAAA,OAAO,QAAQ,KAAO,EAAA,QAAA;AACxB;AAEO,SAAS,uBAAuB,OAAkC,EAAA;AACvE,EAAA,IAAI,OAAQ,CAAA,KAAA,EAAO,IAAQ,IAAA,OAAA,CAAQ,OAAO,OAAS,EAAA;AACjD,IAAA,OAAO,QAAQ,KAAO,EAAA,OAAA;AAAA;AAExB,EAAO,OAAA,KAAA,CAAA;AACT;;;;"}