'use strict';

var errors = require('@backstage/errors');
var jose = require('jose');
var types = require('./types.cjs.js');

class AuthHelper {
  constructor(teamName, serviceTokens, jwtHeaderName, authorizationCookieName, keySet, cache) {
    this.teamName = teamName;
    this.serviceTokens = serviceTokens;
    this.jwtHeaderName = jwtHeaderName;
    this.authorizationCookieName = authorizationCookieName;
    this.keySet = keySet;
    this.cache = cache;
  }
  static fromConfig(config, options) {
    const teamName = config.getString("teamName");
    const jwtHeaderName = config.getOptionalString("jwtHeaderName") ?? types.CF_JWT_HEADER;
    const authorizationCookieName = config.getOptionalString("authorizationCookieName") ?? types.COOKIE_AUTH_NAME;
    const serviceTokens = (config.getOptionalConfigArray("serviceTokens") ?? [])?.map((cfg) => {
      return {
        token: cfg.getString("token"),
        subject: cfg.getString("subject")
      };
    });
    const keySet = jose.createRemoteJWKSet(
      new URL(`https://${teamName}.cloudflareaccess.com/cdn-cgi/access/certs`)
    );
    return new AuthHelper(
      teamName,
      serviceTokens,
      jwtHeaderName,
      authorizationCookieName,
      keySet,
      options?.cache
    );
  }
  async authenticate(req) {
    let jwt = req.header(this.jwtHeaderName);
    if (!jwt) {
      jwt = req.cookies[this.authorizationCookieName];
    }
    if (!jwt) {
      throw new errors.AuthenticationError(
        `Missing ${this.jwtHeaderName} and ${this.authorizationCookieName} from Cloudflare Access`
      );
    }
    const verifyResult = await jose.jwtVerify(jwt, this.keySet, {
      issuer: `https://${this.teamName}.cloudflareaccess.com`
    });
    const isServiceToken = !verifyResult.payload.sub;
    const subject = isServiceToken ? verifyResult.payload.common_name : verifyResult.payload.sub;
    if (!subject) {
      throw new errors.AuthenticationError(
        `Missing both sub and common_name from Cloudflare Access JWT`
      );
    }
    const serviceToken = this.serviceTokens.find((st) => st.token === subject);
    if (isServiceToken && !serviceToken) {
      throw new errors.AuthenticationError(
        `${subject} is not a permitted Service Token.`
      );
    }
    const cacheKey = `${types.CACHE_PREFIX}/${subject}`;
    const cfAccessResultStr = await this.cache?.get(cacheKey);
    if (typeof cfAccessResultStr === "string") {
      const result = JSON.parse(cfAccessResultStr);
      return {
        ...result,
        token: jwt
      };
    }
    const claims = verifyResult.payload;
    try {
      let cfIdentity;
      if (serviceToken) {
        cfIdentity = {
          id: subject,
          name: "Bot",
          email: serviceToken.subject,
          groups: []
        };
      } else {
        cfIdentity = await this.getIdentityProfile(jwt);
      }
      const cfAccessResult = {
        claims,
        cfIdentity,
        expiresInSeconds: claims.exp - claims.iat
      };
      this.cache?.set(cacheKey, JSON.stringify(cfAccessResult));
      return {
        ...cfAccessResult,
        token: jwt
      };
    } catch (err) {
      throw new errors.ForwardedError(
        "Failed to populate access identity information",
        err
      );
    }
  }
  async getIdentityProfile(jwt) {
    const headers = new Headers();
    headers.set(this.jwtHeaderName, jwt);
    headers.set("cookie", `${this.authorizationCookieName}=${jwt}`);
    try {
      const res = await fetch(
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/get-identity`,
        { headers }
      );
      if (!res.ok) {
        throw await errors.ResponseError.fromResponse(res);
      }
      const cfIdentity = await res.json();
      return cfIdentity;
    } catch (err) {
      throw new errors.ForwardedError("getIdentityProfile failed", err);
    }
  }
}

exports.AuthHelper = AuthHelper;
//# sourceMappingURL=helpers.cjs.js.map
