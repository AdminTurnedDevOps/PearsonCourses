/// <reference types="react" />
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { z } from 'zod';
import { FieldExtensionComponentProps, CustomFieldValidator, FieldSchema, TemplateParameterSchema, FieldExtensionOptions, FormProps, ReviewStepProps, LayoutOptions, TemplateGroupFilter, ScaffolderTaskOutput, ScaffolderRJSFFormProps, ScaffolderStep } from '@backstage/plugin-scaffolder-react';
import { JsonObject, JsonValue } from '@backstage/types';
import * as React from 'react';
import React__default, { ComponentType, ReactNode, PropsWithChildren, ReactElement } from 'react';
import { TemplatePresentationV1beta3, TemplateEntityV1beta3, TaskStep } from '@backstage/plugin-scaffolder-common';
import { UiSchema, FieldValidation, WidgetProps } from '@rjsf/utils';
import { ApiHolder, IconComponent, AnyApiRef } from '@backstage/core-plugin-api';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';

/*
 * Copyright 2024 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/** @alpha */
interface FormField {
  readonly $$type: '@backstage/scaffolder/FormField';
}

/** @alpha */
declare const formFieldsApi: _backstage_frontend_plugin_api.ExtensionDefinition<{
    config: {};
    configInput: {};
    output: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<_backstage_frontend_plugin_api.AnyApiFactory, "core.api.factory", {}>;
    inputs: {
        formFields: _backstage_frontend_plugin_api.ExtensionInput<_backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>, {
            singleton: false;
            optional: false;
        }>;
    };
    kind: "api";
    name: "form-fields";
    params: {
        factory: _backstage_frontend_plugin_api.AnyApiFactory;
    };
}>;

/** @alpha */
type FormFieldExtensionData<TReturnValue extends z.ZodType = z.ZodType, TUiOptions extends z.ZodType = z.ZodType> = {
    name: string;
    component: (props: FieldExtensionComponentProps<z.output<TReturnValue>, z.output<TUiOptions>>) => JSX.Element | null;
    validation?: CustomFieldValidator<z.output<TReturnValue>, z.output<TUiOptions>>;
    schema?: FieldSchema<z.output<TReturnValue>, z.output<TUiOptions>>;
};

/**
 * @alpha
 * Creates extensions that are Field Extensions for the Scaffolder
 * */
declare const FormFieldBlueprint: _backstage_frontend_plugin_api.ExtensionBlueprint<{
    kind: "scaffolder-form-field";
    name: undefined;
    params: {
        field: () => Promise<FormField>;
    };
    output: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        formFieldLoader: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<() => Promise<FormField>, "scaffolder.form-field-loader", {}>;
    };
}>;
/**
 * @alpha
 * Used to create a form field binding with typechecking for compliance
 */
declare function createFormField<TReturnValue extends z.ZodType, TUiOptions extends z.ZodType>(opts: FormFieldExtensionData<TReturnValue, TUiOptions>): FormField;

/** @alpha */
interface ScaffolderFormFieldsApi {
    getFormFields(): Promise<FormFieldExtensionData[]>;
}

/** @alpha */
declare const formFieldsApiRef: _backstage_frontend_plugin_api.ApiRef<ScaffolderFormFieldsApi>;

/**
 * This is the parsed template schema that is returned from the {@link useTemplateSchema} hook.
 * @alpha
 */
interface ParsedTemplateSchema {
    uiSchema: UiSchema;
    mergedSchema: JsonObject;
    schema: JsonObject;
    title: string;
    description?: string;
}
/**
 * This hook will parse the template schema and return the steps with the
 * parsed schema and uiSchema. Filtering out any steps or properties that
 * are not enabled with feature flags.
 * @alpha
 */
declare const useTemplateSchema: (manifest: TemplateParameterSchema) => {
    steps: ParsedTemplateSchema[];
    presentation?: TemplatePresentationV1beta3 | undefined;
};

/**
 * The props for the {@link ReviewState} component.
 * @alpha
 */
type ReviewStateProps = {
    schemas: ParsedTemplateSchema[];
    formState: JsonObject;
};
/**
 * The component used by the {@link Stepper} to render the review step.
 * @alpha
 */
declare const ReviewState: (props: ReviewStateProps) => React__default.JSX.Element;

/** @alpha */
type BackstageTemplateStepperClassKey = 'backButton' | 'footer' | 'formWrapper';
/**
 * The Props for {@link Stepper} component
 * @alpha
 */
type StepperProps = {
    manifest: TemplateParameterSchema;
    extensions: FieldExtensionOptions<any, any>[];
    /**
     * @deprecated This was only ever used for analytics tracking purposes, which
     * is now handled in the `<Workflow />` component. Passing it in will have no
     * effect.
     */
    templateName?: string;
    formProps?: FormProps;
    initialState?: Record<string, JsonValue>;
    onCreate: (values: Record<string, JsonValue>) => Promise<void>;
    components?: {
        ReviewStepComponent?: ComponentType<ReviewStepProps>;
        ReviewStateComponent?: (props: ReviewStateProps) => JSX.Element;
        backButtonText?: ReactNode;
        createButtonText?: ReactNode;
        reviewButtonText?: ReactNode;
    };
    layouts?: LayoutOptions[];
};
/**
 * The `Stepper` component is the Wizard that is rendered when a user selects a template
 * @alpha
 */
declare const Stepper: (stepperProps: StepperProps) => React__default.JSX.Element;

/** @alpha */
type FormValidation = {
    [name: string]: FieldValidation | FormValidation;
};
/** @alpha */
declare const createAsyncValidators: (rootSchema: JsonObject, validators: Record<string, undefined | CustomFieldValidator<unknown, unknown>>, context: {
    apiHolder: ApiHolder;
}) => (formData: JsonObject) => Promise<FormValidation>;

/**
 * The Props for the {@link TemplateCard} component
 * @alpha
 */
interface TemplateCardProps {
    template: TemplateEntityV1beta3;
    additionalLinks?: {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
    onSelected?: (template: TemplateEntityV1beta3) => void;
}
/**
 * The `TemplateCard` component that is rendered in a list for each template
 * @alpha
 */
declare const TemplateCard: (props: TemplateCardProps) => React__default.JSX.Element;

/**
 * The props for the {@link TemplateGroup} component.
 * @alpha
 */
interface TemplateGroupProps {
    templates: {
        template: TemplateEntityV1beta3;
        additionalLinks?: {
            icon: IconComponent;
            text: string;
            url: string;
        }[];
    }[];
    onSelected: (template: TemplateEntityV1beta3) => void;
    title: React__default.ReactNode;
    components?: {
        CardComponent?: React__default.ComponentType<TemplateCardProps>;
    };
}
/**
 * The `TemplateGroup` component is used to display a group of templates with a title.
 * @alpha
 */
declare const TemplateGroup: (props: TemplateGroupProps) => React__default.JSX.Element | null;

/**
 * @alpha
 */
interface TemplateGroupsProps {
    groups: TemplateGroupFilter[];
    templateFilter?: (entity: TemplateEntityV1beta3) => boolean;
    TemplateCardComponent?: React__default.ComponentType<{
        template: TemplateEntityV1beta3;
    }>;
    onTemplateSelected?: (template: TemplateEntityV1beta3) => void;
    additionalLinksForEntity?: (template: TemplateEntityV1beta3) => {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
}
/**
 * @alpha
 */
declare const TemplateGroups: (props: TemplateGroupsProps) => React__default.JSX.Element | null;

/**
 * @alpha
 */
type WorkflowProps = {
    title?: string;
    description?: string;
    namespace: string;
    templateName: string;
    components?: {
        ReviewStepComponent?: React__default.ComponentType<ReviewStepProps>;
    };
    onError(error: Error | undefined): JSX.Element | null;
} & Pick<StepperProps, 'extensions' | 'formProps' | 'components' | 'onCreate' | 'initialState' | 'layouts'>;
/**
 * @alpha
 */
declare const Workflow: (workflowProps: WorkflowProps) => JSX.Element | null;
/**
 * @alpha
 */
declare const EmbeddableWorkflow: (props: WorkflowProps) => React__default.JSX.Element;

/**
 * The DefaultOutputs renderer for the scaffolder task output
 *
 * @alpha
 */
declare const DefaultTemplateOutputs: (props: {
    output?: ScaffolderTaskOutput;
}) => React__default.JSX.Element | null;

/**
 * The Form component
 * @alpha
 */
declare const Form: (props: PropsWithChildren<ScaffolderRJSFFormProps>) => React__default.JSX.Element;

/**
 * Props for the TaskSteps component
 *
 * @alpha
 */
interface TaskStepsProps {
    steps: (TaskStep & ScaffolderStep)[];
    activeStep?: number;
    isComplete?: boolean;
    isError?: boolean;
}
/**
 * The visual stepper of the task event stream
 *
 * @alpha
 */
declare const TaskSteps: (props: TaskStepsProps) => React__default.JSX.Element;

/**
 * The text of the event stream
 *
 * @alpha
 */
declare const TaskLogStream: (props: {
    logs: {
        [k: string]: string[];
    };
}) => React__default.JSX.Element;

/** @alpha */
type ScaffolderReactTemplateCategoryPickerClassKey = 'root' | 'label';
/**
 * The Category Picker that is rendered on the left side for picking
 * categories and filtering the template list.
 * @alpha
 */
declare const TemplateCategoryPicker: () => React__default.JSX.Element | null;

/**
 * @alpha
 */
type ScaffolderPageContextMenuProps = {
    onEditorClicked?: () => void;
    onActionsClicked?: () => void;
    onTasksClicked?: () => void;
    onCreateClicked?: () => void;
};
/**
 * @alpha
 */
declare function ScaffolderPageContextMenu(props: ScaffolderPageContextMenuProps): React__default.JSX.Element | null;

/**
 * Props for the {@link ScaffolderField} component
 * @alpha
 */
interface ScaffolderFieldProps {
    rawDescription?: string;
    errors?: ReactElement;
    rawErrors?: string[];
    help?: ReactElement;
    rawHelp?: string;
    required?: boolean;
    disabled?: boolean;
    displayLabel?: boolean;
}
/**
 * A component to wrap up a input field which helps with formatting and supporting markdown
 * on the field types
 * @alpha
 */
declare const ScaffolderField: (props: PropsWithChildren<ScaffolderFieldProps>) => React__default.JSX.Element;

/**
 * Secret Widget for overriding the default password input widget
 * @alpha
 */
declare const SecretWidget: (props: Pick<WidgetProps, 'name' | 'onChange' | 'schema' | 'required' | 'disabled'>) => React__default.JSX.Element;

/**
 * Takes a step from a Backstage Template Manifest and converts it to a JSON Schema and UI Schema for rjsf
 * @alpha
 */
declare const extractSchemaFromStep: (inputStep: JsonObject) => {
    uiSchema: UiSchema;
    schema: JsonObject;
};
/**
 * Creates a field validation object for use in react jsonschema form
 * @alpha
 */
declare const createFieldValidation: () => FieldValidation;

/**
 * This hook is used to get the formData from the query string.
 * @alpha
 */
declare const useFormDataFromQuery: (initialState?: Record<string, JsonValue>) => [Record<string, any>, React.Dispatch<React.SetStateAction<Record<string, any>>>];

/**
 * @alpha
 */
declare const useTemplateParameterSchema: (templateRef: string) => {
    manifest?: TemplateParameterSchema | undefined;
    loading: boolean;
    error?: Error | undefined;
};

/**
 * Returns manifest of software templates with steps without a featureFlag tag.
 * @alpha
 */
declare const useFilteredSchemaProperties: (manifest: TemplateParameterSchema | undefined) => TemplateParameterSchema | undefined;

/** @alpha */
type ScaffolderReactComponentsNameToClassKey = {
    ScaffolderReactTemplateCategoryPicker: ScaffolderReactTemplateCategoryPickerClassKey;
    BackstageTemplateStepper: BackstageTemplateStepperClassKey;
};
/** @alpha */
type BackstageOverrides = Overrides & {
    [Name in keyof ScaffolderReactComponentsNameToClassKey]?: Partial<StyleRules<ScaffolderReactComponentsNameToClassKey[Name]>>;
};
declare module '@backstage/theme' {
    interface OverrideComponentNameToClassKeys extends ScaffolderReactComponentsNameToClassKey {
    }
}

/** @alpha */
type ScaffolderFormDecoratorContext<TInput extends JsonObject = JsonObject> = {
    input: TInput;
    formState: Record<string, JsonValue>;
    setFormState: (fn: (currentState: Record<string, JsonValue>) => Record<string, JsonValue>) => void;
    setSecrets: (fn: (currentState: Record<string, string>) => Record<string, string>) => void;
};
/** @alpha */
type ScaffolderFormDecorator<TInput extends JsonObject = JsonObject> = {
    readonly $$type: '@backstage/scaffolder/FormDecorator';
    readonly id: string;
    readonly TInput: TInput;
};
/**
 * Method for creating decorators which can be used to collect
 * secrets from the user before submitting to the backend.
 * @alpha
 */
declare function createScaffolderFormDecorator<TInputSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
} = {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, TDeps extends {
    [key in string]: AnyApiRef;
} = {
    [key in string]: AnyApiRef;
}, TInput extends JsonObject = {
    [key in keyof TInputSchema]: z.infer<ReturnType<TInputSchema[key]>>;
}>(options: {
    id: string;
    schema?: {
        input?: TInputSchema;
    };
    deps?: TDeps;
    decorator: (ctx: ScaffolderFormDecoratorContext<TInput>, deps: TDeps extends {
        [key in string]: AnyApiRef;
    } ? {
        [key in keyof TDeps]: TDeps[key]['T'];
    } : never) => Promise<void>;
}): ScaffolderFormDecorator<TInput>;

export { type BackstageOverrides, type BackstageTemplateStepperClassKey, DefaultTemplateOutputs, EmbeddableWorkflow, Form, FormFieldBlueprint, type FormFieldExtensionData, type FormValidation, type ParsedTemplateSchema, ReviewState, type ReviewStateProps, ScaffolderField, type ScaffolderFieldProps, type ScaffolderFormDecorator, type ScaffolderFormDecoratorContext, type ScaffolderFormFieldsApi, ScaffolderPageContextMenu, type ScaffolderPageContextMenuProps, type ScaffolderReactComponentsNameToClassKey, type ScaffolderReactTemplateCategoryPickerClassKey, SecretWidget, Stepper, type StepperProps, TaskLogStream, TaskSteps, type TaskStepsProps, TemplateCard, type TemplateCardProps, TemplateCategoryPicker, TemplateGroup, type TemplateGroupProps, TemplateGroups, type TemplateGroupsProps, Workflow, type WorkflowProps, createAsyncValidators, createFieldValidation, createFormField, createScaffolderFormDecorator, extractSchemaFromStep, formFieldsApi, formFieldsApiRef, useFilteredSchemaProperties, useFormDataFromQuery, useTemplateParameterSchema, useTemplateSchema };
