import { Draft07 } from 'json-schema-library';
import { extractSchemaFromStep, createFieldValidation } from '../../lib/schema.esm.js';
import { isObject } from './utils.esm.js';

const isJsonError = (value) => "type" in value && value.type === "error";
const createAsyncValidators = (rootSchema, validators, context) => {
  async function validate(formData, pathPrefix = "#", current = formData) {
    const parsedSchema = new Draft07(rootSchema);
    const formValidation = {};
    const validateForm = async (validatorName, key, value, schema, uiSchema) => {
      const validator = validators[validatorName];
      if (validator) {
        const fieldValidation = createFieldValidation();
        try {
          await validator(value, fieldValidation, {
            ...context,
            formData,
            schema,
            uiSchema
          });
        } catch (ex) {
          fieldValidation.addError(ex.message);
        }
        formValidation[key] = fieldValidation;
      }
    };
    for (const [key, value] of Object.entries(current)) {
      const pointer = `${pathPrefix}/${key}`;
      const definitionInSchema = parsedSchema.getSchema({
        pointer,
        data: formData
      });
      if (!definitionInSchema) {
        continue;
      }
      if (isJsonError(definitionInSchema)) {
        throw new Error(definitionInSchema.message);
      }
      const { schema, uiSchema } = extractSchemaFromStep(
        definitionInSchema
      );
      const hasItems = definitionInSchema && definitionInSchema.items;
      const doValidateItem = async (propValue, itemSchema, itemUiSchema) => {
        await validateForm(
          propValue["ui:field"],
          key,
          value,
          itemSchema,
          itemUiSchema
        );
      };
      const doValidate = async (propValue) => {
        if ("ui:field" in propValue) {
          const { schema: itemsSchema, uiSchema: itemsUiSchema } = extractSchemaFromStep(definitionInSchema.items);
          await doValidateItem(propValue, itemsSchema, itemsUiSchema);
        }
      };
      if ("ui:field" in definitionInSchema) {
        await doValidateItem(definitionInSchema, schema, uiSchema);
      } else if (hasItems && "ui:field" in definitionInSchema.items) {
        await doValidate(definitionInSchema.items);
      } else if (hasItems && definitionInSchema.items.type === "object") {
        const properties = definitionInSchema.items?.properties ?? [];
        for (const [, propValue] of Object.entries(properties)) {
          await doValidate(propValue);
        }
      } else if (isObject(value)) {
        formValidation[key] = await validate(formData, pointer, value);
      }
    }
    return formValidation;
  }
  return async (formData) => {
    return await validate(formData);
  };
};

export { createAsyncValidators };
//# sourceMappingURL=createAsyncValidators.esm.js.map
