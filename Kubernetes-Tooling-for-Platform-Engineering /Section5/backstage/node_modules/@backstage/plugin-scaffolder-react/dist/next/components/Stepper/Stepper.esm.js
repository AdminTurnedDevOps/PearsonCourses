import { useAnalytics, useApiHolder } from '@backstage/core-plugin-api';
import MuiStepper from '@material-ui/core/Stepper';
import MuiStep from '@material-ui/core/Step';
import MuiStepLabel from '@material-ui/core/StepLabel';
import Button from '@material-ui/core/Button';
import LinearProgress from '@material-ui/core/LinearProgress';
import React, { useState, useMemo, useCallback } from 'react';
import { createAsyncValidators } from './createAsyncValidators.esm.js';
import { ReviewState } from '../ReviewState/ReviewState.esm.js';
import { useFormDataFromQuery } from '../../hooks/useFormDataFromQuery.esm.js';
import { useTemplateSchema } from '../../hooks/useTemplateSchema.esm.js';
import 'react-use/esm/useAsync';
import '../../../api/ref.esm.js';
import 'lodash/cloneDeep';
import { customizeValidator } from '@rjsf/validator-ajv8';
import { useTransformSchemaToProps } from '../../hooks/useTransformSchemaToProps.esm.js';
import { hasErrors } from './utils.esm.js';
import * as index from './FieldOverrides/index.esm.js';
import { Form } from '../Form/Form.esm.js';
import { ErrorListTemplate } from './ErrorListTemplate/errorListTemplate.esm.js';
import { makeStyles } from '@material-ui/core/styles';
import { PasswordWidget } from '../PasswordWidget/PasswordWidget.esm.js';
import ajvErrors from 'ajv-errors';
import { merge } from 'lodash';

const validator = customizeValidator();
ajvErrors(validator.ajv);
const useStyles = makeStyles(
  (theme) => ({
    backButton: {
      marginRight: theme.spacing(1)
    },
    footer: {
      display: "flex",
      flexDirection: "row",
      justifyContent: "right",
      marginTop: theme.spacing(2)
    },
    formWrapper: {
      padding: theme.spacing(2)
    }
  }),
  { name: "BackstageTemplateStepper" }
);
const Stepper = (stepperProps) => {
  const { layouts = [], components = {}, ...props } = stepperProps;
  const {
    ReviewStateComponent = ReviewState,
    ReviewStepComponent,
    backButtonText = "Back",
    createButtonText = "Create",
    reviewButtonText = "Review"
  } = components;
  const analytics = useAnalytics();
  const { presentation, steps } = useTemplateSchema(props.manifest);
  const apiHolder = useApiHolder();
  const [activeStep, setActiveStep] = useState(0);
  const [isValidating, setIsValidating] = useState(false);
  const [initialState] = useFormDataFromQuery(props.initialState);
  const [stepsState, setStepsState] = useState(initialState);
  const [errors, setErrors] = useState();
  const styles = useStyles();
  const backLabel = presentation?.buttonLabels?.backButtonText ?? backButtonText;
  const createLabel = presentation?.buttonLabels?.createButtonText ?? createButtonText;
  const reviewLabel = presentation?.buttonLabels?.reviewButtonText ?? reviewButtonText;
  const extensions = useMemo(() => {
    return Object.fromEntries(
      props.extensions.map(({ name, component }) => [name, component])
    );
  }, [props.extensions]);
  const fields = useMemo(
    () => ({ ...index, ...extensions }),
    [extensions]
  );
  const validators = useMemo(() => {
    return Object.fromEntries(
      props.extensions.map(({ name, validation: validation2 }) => [name, validation2])
    );
  }, [props.extensions]);
  const validation = useMemo(() => {
    return createAsyncValidators(steps[activeStep]?.mergedSchema, validators, {
      apiHolder
    });
  }, [steps, activeStep, validators, apiHolder]);
  const handleBack = useCallback(() => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  }, [setActiveStep]);
  const currentStep = useTransformSchemaToProps(steps[activeStep], { layouts });
  const {
    formContext: propFormContext,
    uiSchema: propUiSchema,
    liveOmit: _shouldLiveOmit,
    omitExtraData: _shouldOmitExtraData,
    ...restFormProps
  } = props.formProps ?? {};
  const handleChange = useCallback(
    (e) => {
      setStepsState((current) => {
        return { ...current, ...e.formData };
      });
    },
    [setStepsState]
  );
  const handleNext = useCallback(
    async ({ formData = {} }) => {
      setErrors(void 0);
      setIsValidating(true);
      const returnedValidation = await validation(formData);
      setStepsState((current) => ({
        ...current,
        ...formData
      }));
      setIsValidating(false);
      if (hasErrors(returnedValidation)) {
        setErrors(returnedValidation);
      } else {
        setErrors(void 0);
        setActiveStep((prevActiveStep) => {
          const stepNum = prevActiveStep + 1;
          analytics.captureEvent("click", `Next Step (${stepNum})`);
          return stepNum;
        });
      }
    },
    [validation, analytics]
  );
  const mergedUiSchema = merge({}, propUiSchema, currentStep?.uiSchema);
  const handleCreate = useCallback(() => {
    props.onCreate(stepsState);
    analytics.captureEvent("click", `${createLabel}`);
  }, [props, stepsState, analytics, createLabel]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, isValidating && /* @__PURE__ */ React.createElement(LinearProgress, { variant: "indeterminate" }), /* @__PURE__ */ React.createElement(
    MuiStepper,
    {
      activeStep,
      alternativeLabel: true,
      variant: "elevation",
      style: { overflowX: "auto" }
    },
    steps.map((step, index) => {
      const isAllowedLabelClick = activeStep > index;
      return /* @__PURE__ */ React.createElement(MuiStep, { key: index }, /* @__PURE__ */ React.createElement(
        MuiStepLabel,
        {
          "aria-label": `Step ${index + 1}`,
          style: { cursor: isAllowedLabelClick ? "pointer" : "default" },
          onClick: () => {
            if (isAllowedLabelClick) setActiveStep(index);
          }
        },
        step.title
      ));
    }),
    /* @__PURE__ */ React.createElement(MuiStep, null, /* @__PURE__ */ React.createElement(MuiStepLabel, null, reviewLabel))
  ), /* @__PURE__ */ React.createElement("div", { className: styles.formWrapper }, activeStep < steps.length ? /* @__PURE__ */ React.createElement(
    Form,
    {
      key: activeStep,
      validator,
      extraErrors: errors,
      formData: stepsState,
      formContext: { ...propFormContext, formData: stepsState },
      schema: currentStep.schema,
      uiSchema: mergedUiSchema,
      onSubmit: handleNext,
      fields,
      showErrorList: "top",
      templates: { ErrorListTemplate },
      onChange: handleChange,
      widgets: { password: PasswordWidget },
      experimental_defaultFormStateBehavior: {
        allOf: "populateDefaults"
      },
      ...restFormProps
    },
    /* @__PURE__ */ React.createElement("div", { className: styles.footer }, /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: handleBack,
        className: styles.backButton,
        disabled: activeStep < 1 || isValidating
      },
      backLabel
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "primary",
        type: "submit",
        disabled: isValidating
      },
      activeStep === steps.length - 1 ? reviewLabel : "Next"
    ))
  ) : (
    // TODO: potentially move away from this pattern, deprecate?
    ReviewStepComponent ? /* @__PURE__ */ React.createElement(
      ReviewStepComponent,
      {
        disableButtons: isValidating,
        formData: stepsState,
        handleBack,
        handleReset: () => {
        },
        steps,
        handleCreate
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ReviewStateComponent, { formState: stepsState, schemas: steps }), /* @__PURE__ */ React.createElement("div", { className: styles.footer }, /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: handleBack,
        className: styles.backButton,
        disabled: activeStep < 1
      },
      backLabel
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "primary",
        onClick: handleCreate
      },
      createLabel
    )))
  )));
};

export { Stepper };
//# sourceMappingURL=Stepper.esm.js.map
