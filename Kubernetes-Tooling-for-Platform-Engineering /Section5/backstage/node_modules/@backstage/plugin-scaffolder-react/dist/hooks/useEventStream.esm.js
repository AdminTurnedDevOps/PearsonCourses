import { useImmerReducer } from 'use-immer';
import { useEffect } from 'react';
import { useApi } from '@backstage/core-plugin-api';
import { scaffolderApiRef } from '../api/ref.esm.js';

function reducer(draft, action) {
  switch (action.type) {
    case "INIT": {
      draft.steps = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = { status: "open", id: next.id };
        return current;
      }, {});
      draft.stepLogs = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = [];
        return current;
      }, {});
      draft.loading = false;
      draft.error = void 0;
      draft.completed = false;
      draft.task = action.data;
      return;
    }
    case "LOGS": {
      const entries = action.data;
      for (const entry of entries) {
        const logLine = `${entry.createdAt} ${entry.body.message}`;
        if (!entry.body.stepId || !draft.steps?.[entry.body.stepId]) {
          continue;
        }
        const currentStepLog = draft.stepLogs?.[entry.body.stepId];
        const currentStep = draft.steps?.[entry.body.stepId];
        if (currentStep) {
          if (entry.body.status && entry.body.status !== currentStep.status) {
            currentStep.status = entry.body.status;
            if (currentStep.status === "processing") {
              currentStep.startedAt = entry.createdAt;
            }
            if (["cancelled", "completed", "failed"].includes(currentStep.status)) {
              currentStep.endedAt = entry.createdAt;
            }
          }
        }
        currentStepLog?.push(logLine);
      }
      return;
    }
    case "COMPLETED": {
      draft.completed = true;
      draft.output = action.data.body.output;
      draft.error = action.data.body.error;
      return;
    }
    case "CANCELLED": {
      draft.cancelled = true;
      return;
    }
    case "RECOVERED": {
      draft.cancelled = false;
      draft.completed = false;
      draft.output = void 0;
      draft.error = void 0;
      for (const stepId in draft.steps) {
        if (draft.steps.hasOwnProperty(stepId)) {
          draft.steps[stepId].startedAt = void 0;
          draft.steps[stepId].endedAt = void 0;
          draft.steps[stepId].status = "open";
        }
      }
      return;
    }
    case "ERROR": {
      draft.error = action.data;
      draft.loading = false;
      draft.completed = true;
      return;
    }
    default:
      return;
  }
}
const useTaskEventStream = (taskId) => {
  const scaffolderApi = useApi(scaffolderApiRef);
  const [state, dispatch] = useImmerReducer(reducer, {
    cancelled: false,
    loading: true,
    completed: false,
    stepLogs: {},
    steps: {}
  });
  useEffect(() => {
    let didCancel = false;
    let subscription;
    let logPusher;
    let retryCount = 1;
    let isTaskRecoverable = false;
    const startStreamLogProcess = () => scaffolderApi.getTask(taskId).then(
      (task) => {
        if (didCancel) {
          return;
        }
        isTaskRecoverable = task.spec.EXPERIMENTAL_recovery?.EXPERIMENTAL_strategy === "startOver";
        dispatch({ type: "INIT", data: task });
        const observable = scaffolderApi.streamLogs({
          isTaskRecoverable,
          taskId
        });
        const collectedLogEvents = new Array();
        function emitLogs() {
          if (collectedLogEvents.length) {
            const logs = collectedLogEvents.splice(
              0,
              collectedLogEvents.length
            );
            dispatch({ type: "LOGS", data: logs });
          }
        }
        logPusher = setInterval(emitLogs, 500);
        subscription = observable.subscribe({
          next: (event) => {
            retryCount = 1;
            switch (event.type) {
              case "log":
                return collectedLogEvents.push(event);
              case "cancelled":
                dispatch({ type: "CANCELLED" });
                return void 0;
              case "completion":
                emitLogs();
                dispatch({ type: "COMPLETED", data: event });
                return void 0;
              case "recovered":
                dispatch({ type: "RECOVERED", data: event });
                return void 0;
              default:
                throw new Error(
                  `Unhandled event type ${event.type} in observer`
                );
            }
          },
          error: (error) => {
            emitLogs();
            const maxRetries = 3;
            if (!error.message) {
              error.message = `We cannot connect at the moment, trying again in some seconds... Retrying (${retryCount > maxRetries ? maxRetries : retryCount}/${maxRetries} retries)`;
            }
            setTimeout(() => {
              retryCount += 1;
              void startStreamLogProcess();
            }, 15e3);
            dispatch({ type: "ERROR", data: error });
          }
        });
      },
      (error) => {
        if (!didCancel) {
          dispatch({ type: "ERROR", data: error });
        }
      }
    );
    void startStreamLogProcess();
    return () => {
      if (!isTaskRecoverable) {
        didCancel = true;
        if (subscription) {
          subscription.unsubscribe();
        }
        if (logPusher) {
          clearInterval(logPusher);
        }
      }
    };
  }, [scaffolderApi, dispatch, taskId]);
  return state;
};

export { useTaskEventStream };
//# sourceMappingURL=useEventStream.esm.js.map
