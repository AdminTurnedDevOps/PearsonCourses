'use strict';

var Ajv = require('ajv');
var mergeAllOf = require('json-schema-merge-allof');
var traverse = require('json-schema-traverse');
var config = require('@backstage/config');
var types = require('./types.cjs.js');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultCompat(Ajv);
var mergeAllOf__default = /*#__PURE__*/_interopDefaultCompat(mergeAllOf);
var traverse__default = /*#__PURE__*/_interopDefaultCompat(traverse);

const inheritedVisibility = Symbol("inherited-visibility");
function compileConfigSchemas(schemas, options) {
  const visibilityByDataPath = /* @__PURE__ */ new Map();
  const deepVisibilityByDataPath = /* @__PURE__ */ new Map();
  const deprecationByDataPath = /* @__PURE__ */ new Map();
  const ajv = new Ajv__default.default({
    allErrors: true,
    allowUnionTypes: true,
    coerceTypes: true,
    schemas: {
      "https://backstage.io/schema/config-v1": true
    }
  }).addKeyword({
    keyword: "visibility",
    metaSchema: {
      type: "string",
      enum: types.CONFIG_VISIBILITIES
    },
    compile(visibility) {
      return (_data, context) => {
        if (context?.instancePath === void 0) {
          return false;
        }
        if (visibility && visibility !== "backend") {
          const normalizedPath = utils.normalizeAjvPath(context.instancePath);
          visibilityByDataPath.set(normalizedPath, visibility);
        }
        return true;
      };
    }
  }).addKeyword({
    keyword: "deepVisibility",
    metaSchema: {
      type: "string",
      /**
       * Disallow 'backend' deepVisibility to prevent cases of permission escaping.
       *
       * Something like:
       * - deepVisibility secret -> backend -> frontend.
       * - deepVisibility secret -> backend -> visibility frontend.
       */
      enum: ["frontend", "secret"]
    },
    compile(visibility) {
      return (_data, context) => {
        if (context?.instancePath === void 0) {
          return false;
        }
        if (visibility) {
          const normalizedPath = utils.normalizeAjvPath(context.instancePath);
          deepVisibilityByDataPath.set(normalizedPath, visibility);
        }
        return true;
      };
    }
  }).removeKeyword("deprecated").addKeyword({
    keyword: "deprecated",
    metaSchema: { type: "string" },
    compile(deprecationDescription) {
      return (_data, context) => {
        if (context?.instancePath === void 0) {
          return false;
        }
        const normalizedPath = utils.normalizeAjvPath(context.instancePath);
        deprecationByDataPath.set(normalizedPath, deprecationDescription);
        return true;
      };
    }
  });
  for (const schema of schemas) {
    try {
      ajv.compile(schema.value);
    } catch (error) {
      throw new Error(`Schema at ${schema.path} is invalid, ${error}`);
    }
  }
  const merged = mergeConfigSchemas(schemas.map((_) => _.value));
  traverse__default.default(
    merged,
    (schema, jsonPtr, _1, _2, _3, parentSchema) => {
      schema[inheritedVisibility] ??= schema?.deepVisibility ?? parentSchema?.[inheritedVisibility];
      if (schema[inheritedVisibility]) {
        const values = [
          schema.visibility,
          schema[inheritedVisibility],
          parentSchema?.[inheritedVisibility]
        ];
        const hasFrontend = values.some((e) => e === "frontend");
        const hasSecret = values.some((e) => e === "secret");
        if (hasFrontend && hasSecret) {
          throw new Error(
            `Config schema visibility is both 'frontend' and 'secret' for ${jsonPtr}`
          );
        }
      }
      if (options?.noUndeclaredProperties) {
        if (schema?.type === "object") {
          schema.additionalProperties ||= false;
        }
      }
    }
  );
  const validate = ajv.compile(merged);
  const visibilityBySchemaPath = /* @__PURE__ */ new Map();
  traverse__default.default(merged, (schema, path) => {
    if (schema.visibility && schema.visibility !== "backend") {
      visibilityBySchemaPath.set(utils.normalizeAjvPath(path), schema.visibility);
    }
    if (schema.deepVisibility) {
      visibilityBySchemaPath.set(utils.normalizeAjvPath(path), schema.deepVisibility);
    }
  });
  return (configs) => {
    const config$1 = config.ConfigReader.fromConfigs(configs).getOptional();
    visibilityByDataPath.clear();
    deepVisibilityByDataPath.clear();
    const valid = validate(config$1);
    if (!valid) {
      return {
        errors: validate.errors ?? [],
        visibilityByDataPath: new Map(visibilityByDataPath),
        deepVisibilityByDataPath: new Map(deepVisibilityByDataPath),
        visibilityBySchemaPath,
        deprecationByDataPath
      };
    }
    return {
      visibilityByDataPath: new Map(visibilityByDataPath),
      deepVisibilityByDataPath: new Map(deepVisibilityByDataPath),
      visibilityBySchemaPath,
      deprecationByDataPath
    };
  };
}
function mergeConfigSchemas(schemas) {
  const merged = mergeAllOf__default.default(
    { allOf: schemas },
    {
      // JSONSchema is typically subtractive, as in it always reduces the set of allowed
      // inputs through constraints. This changes the object property merging to be additive
      // rather than subtractive.
      ignoreAdditionalProperties: true,
      resolvers: {
        // This ensures that the visibilities across different schemas are sound, and
        // selects the most specific visibility for each path.
        visibility(values, path) {
          const hasFrontend = values.some((_) => _ === "frontend");
          const hasSecret = values.some((_) => _ === "secret");
          if (hasFrontend && hasSecret) {
            throw new Error(
              `Config schema visibility is both 'frontend' and 'secret' for ${path.join(
                "/"
              )}`
            );
          } else if (hasFrontend) {
            return "frontend";
          } else if (hasSecret) {
            return "secret";
          }
          return "backend";
        }
      }
    }
  );
  return merged;
}

exports.compileConfigSchemas = compileConfigSchemas;
exports.mergeConfigSchemas = mergeConfigSchemas;
//# sourceMappingURL=compile.cjs.js.map
