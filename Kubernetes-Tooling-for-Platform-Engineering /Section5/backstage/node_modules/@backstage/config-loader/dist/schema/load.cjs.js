'use strict';

var compile = require('./compile.cjs.js');
var collect = require('./collect.cjs.js');
var filtering = require('./filtering.cjs.js');
var types = require('./types.cjs.js');
var utils = require('./utils.cjs.js');

function errorsToError(errors) {
  const messages = errors.map(({ instancePath, message, params }) => {
    const paramStr = Object.entries(params).map(([name, value]) => `${name}=${value}`).join(" ");
    return `Config ${message || ""} { ${paramStr} } at ${utils.normalizeAjvPath(
      instancePath
    )}`;
  });
  const error = new Error(`Config validation failed, ${messages.join("; ")}`);
  error.messages = messages;
  return error;
}
async function loadConfigSchema(options) {
  let schemas;
  if ("dependencies" in options) {
    schemas = await collect.collectConfigSchemas(
      options.dependencies,
      options.packagePaths ?? []
    );
  } else {
    const { serialized } = options;
    if (serialized?.backstageConfigSchemaVersion !== 1) {
      throw new Error(
        "Serialized configuration schema is invalid or has an invalid version number"
      );
    }
    schemas = serialized.schemas;
  }
  const validate = compile.compileConfigSchemas(schemas, {
    noUndeclaredProperties: options.noUndeclaredProperties
  });
  return {
    process(configs, {
      visibility,
      valueTransform,
      withFilteredKeys,
      withDeprecatedKeys,
      ignoreSchemaErrors
    } = {}) {
      const result = validate(configs);
      if (!ignoreSchemaErrors) {
        const visibleErrors = filtering.filterErrorsByVisibility(
          result.errors,
          visibility,
          result.visibilityByDataPath,
          result.visibilityBySchemaPath
        );
        if (visibleErrors.length > 0) {
          throw errorsToError(visibleErrors);
        }
      }
      let processedConfigs = configs;
      if (visibility) {
        processedConfigs = processedConfigs.map(({ data, context }) => ({
          context,
          ...filtering.filterByVisibility(
            data,
            visibility,
            result.visibilityByDataPath,
            result.deepVisibilityByDataPath,
            result.deprecationByDataPath,
            valueTransform,
            withFilteredKeys,
            withDeprecatedKeys
          )
        }));
      } else if (valueTransform) {
        processedConfigs = processedConfigs.map(({ data, context }) => ({
          context,
          ...filtering.filterByVisibility(
            data,
            Array.from(types.CONFIG_VISIBILITIES),
            result.visibilityByDataPath,
            result.deepVisibilityByDataPath,
            result.deprecationByDataPath,
            valueTransform,
            withFilteredKeys,
            withDeprecatedKeys
          )
        }));
      }
      return processedConfigs;
    },
    serialize() {
      return {
        schemas,
        backstageConfigSchemaVersion: 1
      };
    }
  };
}

exports.loadConfigSchema = loadConfigSchema;
//# sourceMappingURL=load.cjs.js.map
