{"version":3,"file":"filtering.cjs.js","sources":["../../src/schema/filtering.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject, JsonValue } from '@backstage/types';\nimport {\n  ConfigVisibility,\n  DEFAULT_CONFIG_VISIBILITY,\n  TransformFunc,\n  ValidationError,\n} from './types';\nimport { normalizeAjvPath } from './utils';\n\n/**\n * This filters data by visibility by discovering the visibility of each\n * value, and then only keeping the ones that are specified in `includeVisibilities`.\n */\nexport function filterByVisibility(\n  data: JsonObject,\n  includeVisibilities: ConfigVisibility[],\n  visibilityByDataPath: Map<string, ConfigVisibility>,\n  deepVisibilityByDataPath: Map<string, ConfigVisibility>,\n  deprecationByDataPath: Map<string, string>,\n  transformFunc?: TransformFunc<number | string | boolean>,\n  withFilteredKeys?: boolean,\n  withDeprecatedKeys?: boolean,\n): {\n  data: JsonObject;\n  filteredKeys?: string[];\n  deprecatedKeys?: { key: string; description: string }[];\n} {\n  const filteredKeys = new Array<string>();\n  const deprecatedKeys = new Array<{ key: string; description: string }>();\n\n  function transform(\n    jsonVal: JsonValue,\n    visibilityPath: string, // Matches the format we get from ajv\n    filterPath: string, // Matches the format of the ConfigReader\n    inheritedVisibility: ConfigVisibility,\n  ): JsonValue | undefined {\n    const visibility =\n      visibilityByDataPath.get(visibilityPath) ?? inheritedVisibility;\n    const isVisible = includeVisibilities.includes(visibility);\n\n    // If a deep visibility is set for our current path, then we that as our\n    // default visibility for all children until we encounter a different deep visibility\n    const newInheritedVisibility =\n      deepVisibilityByDataPath.get(visibilityPath) ?? inheritedVisibility;\n\n    // deprecated keys are added regardless of visibility indicator\n    const deprecation = deprecationByDataPath.get(visibilityPath);\n    if (deprecation) {\n      deprecatedKeys.push({ key: filterPath, description: deprecation });\n    }\n\n    if (typeof jsonVal !== 'object') {\n      if (isVisible) {\n        if (transformFunc) {\n          return transformFunc(jsonVal, { visibility, path: filterPath });\n        }\n        return jsonVal;\n      }\n      if (withFilteredKeys) {\n        filteredKeys.push(filterPath);\n      }\n      return undefined;\n    } else if (jsonVal === null) {\n      return undefined;\n    } else if (Array.isArray(jsonVal)) {\n      const arr = new Array<JsonValue>();\n\n      for (const [index, value] of jsonVal.entries()) {\n        let path = visibilityPath;\n        const hasVisibilityInIndex = visibilityByDataPath.get(\n          `${visibilityPath}/${index}`,\n        );\n\n        if (hasVisibilityInIndex || typeof value === 'object') {\n          path = `${visibilityPath}/${index}`;\n        }\n\n        const out = transform(\n          value,\n          path,\n          `${filterPath}[${index}]`,\n          newInheritedVisibility,\n        );\n\n        if (out !== undefined) {\n          arr.push(out);\n        }\n      }\n\n      if (arr.length > 0 || isVisible) {\n        return arr;\n      }\n      return undefined;\n    }\n\n    const outObj: JsonObject = {};\n    let hasOutput = false;\n\n    for (const [key, value] of Object.entries(jsonVal)) {\n      if (value === undefined) {\n        continue;\n      }\n      const out = transform(\n        value,\n        `${visibilityPath}/${key}`,\n        filterPath ? `${filterPath}.${key}` : key,\n        newInheritedVisibility,\n      );\n      if (out !== undefined) {\n        outObj[key] = out;\n        hasOutput = true;\n      }\n    }\n\n    if (hasOutput || isVisible) {\n      return outObj;\n    }\n    return undefined;\n  }\n\n  return {\n    filteredKeys: withFilteredKeys ? filteredKeys : undefined,\n    deprecatedKeys: withDeprecatedKeys ? deprecatedKeys : undefined,\n    data:\n      (transform(data, '', '', DEFAULT_CONFIG_VISIBILITY) as JsonObject) ?? {},\n  };\n}\n\nexport function filterErrorsByVisibility(\n  errors: ValidationError[] | undefined,\n  includeVisibilities: ConfigVisibility[] | undefined,\n  visibilityByDataPath: Map<string, ConfigVisibility>,\n  visibilityBySchemaPath: Map<string, ConfigVisibility>,\n): ValidationError[] {\n  if (!errors) {\n    return [];\n  }\n  if (!includeVisibilities) {\n    return errors;\n  }\n\n  const visibleSchemaPaths = Array.from(visibilityBySchemaPath)\n    .filter(([, v]) => includeVisibilities.includes(v))\n    .map(([k]) => k);\n\n  // If we're filtering by visibility we only care about the errors that happened\n  // in a visible path.\n  return errors.filter(error => {\n    // We always include structural errors as we don't know whether there are\n    // any visible paths within the structures.\n    if (\n      error.keyword === 'type' &&\n      ['object', 'array'].includes(error.params.type)\n    ) {\n      return true;\n    }\n\n    // For fields that were required we use the schema path to determine whether\n    // it was visible in addition to the data path. This is because the data path\n    // visibilities are only populated for values that we reached, which we won't\n    // if the value is missing.\n    // We don't use this method for all the errors as the data path is more robust\n    // and doesn't require us to properly trim the schema path.\n    if (error.keyword === 'required') {\n      const trimmedPath = normalizeAjvPath(error.schemaPath).slice(\n        1,\n        -'/required'.length,\n      );\n      const fullPath = `${trimmedPath}/properties/${error.params.missingProperty}`;\n      if (\n        visibleSchemaPaths.some(visiblePath => visiblePath.startsWith(fullPath))\n      ) {\n        return true;\n      }\n    }\n\n    const vis =\n      visibilityByDataPath.get(normalizeAjvPath(error.instancePath)) ??\n      DEFAULT_CONFIG_VISIBILITY;\n    return vis && includeVisibilities.includes(vis);\n  });\n}\n"],"names":["DEFAULT_CONFIG_VISIBILITY","normalizeAjvPath"],"mappings":";;;;;AA6BgB,SAAA,kBAAA,CACd,MACA,mBACA,EAAA,oBAAA,EACA,0BACA,qBACA,EAAA,aAAA,EACA,kBACA,kBAKA,EAAA;AACA,EAAM,MAAA,YAAA,GAAe,IAAI,KAAc,EAAA;AACvC,EAAM,MAAA,cAAA,GAAiB,IAAI,KAA4C,EAAA;AAEvE,EAAA,SAAS,SACP,CAAA,OAAA,EACA,cACA,EAAA,UAAA,EACA,mBACuB,EAAA;AACvB,IAAA,MAAM,UACJ,GAAA,oBAAA,CAAqB,GAAI,CAAA,cAAc,CAAK,IAAA,mBAAA;AAC9C,IAAM,MAAA,SAAA,GAAY,mBAAoB,CAAA,QAAA,CAAS,UAAU,CAAA;AAIzD,IAAA,MAAM,sBACJ,GAAA,wBAAA,CAAyB,GAAI,CAAA,cAAc,CAAK,IAAA,mBAAA;AAGlD,IAAM,MAAA,WAAA,GAAc,qBAAsB,CAAA,GAAA,CAAI,cAAc,CAAA;AAC5D,IAAA,IAAI,WAAa,EAAA;AACf,MAAA,cAAA,CAAe,KAAK,EAAE,GAAA,EAAK,UAAY,EAAA,WAAA,EAAa,aAAa,CAAA;AAAA;AAGnE,IAAI,IAAA,OAAO,YAAY,QAAU,EAAA;AAC/B,MAAA,IAAI,SAAW,EAAA;AACb,QAAA,IAAI,aAAe,EAAA;AACjB,UAAA,OAAO,cAAc,OAAS,EAAA,EAAE,UAAY,EAAA,IAAA,EAAM,YAAY,CAAA;AAAA;AAEhE,QAAO,OAAA,OAAA;AAAA;AAET,MAAA,IAAI,gBAAkB,EAAA;AACpB,QAAA,YAAA,CAAa,KAAK,UAAU,CAAA;AAAA;AAE9B,MAAO,OAAA,KAAA,CAAA;AAAA,KACT,MAAA,IAAW,YAAY,IAAM,EAAA;AAC3B,MAAO,OAAA,KAAA,CAAA;AAAA,KACE,MAAA,IAAA,KAAA,CAAM,OAAQ,CAAA,OAAO,CAAG,EAAA;AACjC,MAAM,MAAA,GAAA,GAAM,IAAI,KAAiB,EAAA;AAEjC,MAAA,KAAA,MAAW,CAAC,KAAO,EAAA,KAAK,CAAK,IAAA,OAAA,CAAQ,SAAW,EAAA;AAC9C,QAAA,IAAI,IAAO,GAAA,cAAA;AACX,QAAA,MAAM,uBAAuB,oBAAqB,CAAA,GAAA;AAAA,UAChD,CAAA,EAAG,cAAc,CAAA,CAAA,EAAI,KAAK,CAAA;AAAA,SAC5B;AAEA,QAAI,IAAA,oBAAA,IAAwB,OAAO,KAAA,KAAU,QAAU,EAAA;AACrD,UAAO,IAAA,GAAA,CAAA,EAAG,cAAc,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA;AAAA;AAGnC,QAAA,MAAM,GAAM,GAAA,SAAA;AAAA,UACV,KAAA;AAAA,UACA,IAAA;AAAA,UACA,CAAA,EAAG,UAAU,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAA;AAAA,UACtB;AAAA,SACF;AAEA,QAAA,IAAI,QAAQ,KAAW,CAAA,EAAA;AACrB,UAAA,GAAA,CAAI,KAAK,GAAG,CAAA;AAAA;AACd;AAGF,MAAI,IAAA,GAAA,CAAI,MAAS,GAAA,CAAA,IAAK,SAAW,EAAA;AAC/B,QAAO,OAAA,GAAA;AAAA;AAET,MAAO,OAAA,KAAA,CAAA;AAAA;AAGT,IAAA,MAAM,SAAqB,EAAC;AAC5B,IAAA,IAAI,SAAY,GAAA,KAAA;AAEhB,IAAA,KAAA,MAAW,CAAC,GAAK,EAAA,KAAK,KAAK,MAAO,CAAA,OAAA,CAAQ,OAAO,CAAG,EAAA;AAClD,MAAA,IAAI,UAAU,KAAW,CAAA,EAAA;AACvB,QAAA;AAAA;AAEF,MAAA,MAAM,GAAM,GAAA,SAAA;AAAA,QACV,KAAA;AAAA,QACA,CAAA,EAAG,cAAc,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA;AAAA,QACxB,UAAa,GAAA,CAAA,EAAG,UAAU,CAAA,CAAA,EAAI,GAAG,CAAK,CAAA,GAAA,GAAA;AAAA,QACtC;AAAA,OACF;AACA,MAAA,IAAI,QAAQ,KAAW,CAAA,EAAA;AACrB,QAAA,MAAA,CAAO,GAAG,CAAI,GAAA,GAAA;AACd,QAAY,SAAA,GAAA,IAAA;AAAA;AACd;AAGF,IAAA,IAAI,aAAa,SAAW,EAAA;AAC1B,MAAO,OAAA,MAAA;AAAA;AAET,IAAO,OAAA,KAAA,CAAA;AAAA;AAGT,EAAO,OAAA;AAAA,IACL,YAAA,EAAc,mBAAmB,YAAe,GAAA,KAAA,CAAA;AAAA,IAChD,cAAA,EAAgB,qBAAqB,cAAiB,GAAA,KAAA,CAAA;AAAA,IACtD,MACG,SAAU,CAAA,IAAA,EAAM,IAAI,EAAI,EAAAA,+BAAyB,KAAoB;AAAC,GAC3E;AACF;AAEO,SAAS,wBACd,CAAA,MAAA,EACA,mBACA,EAAA,oBAAA,EACA,sBACmB,EAAA;AACnB,EAAA,IAAI,CAAC,MAAQ,EAAA;AACX,IAAA,OAAO,EAAC;AAAA;AAEV,EAAA,IAAI,CAAC,mBAAqB,EAAA;AACxB,IAAO,OAAA,MAAA;AAAA;AAGT,EAAM,MAAA,kBAAA,GAAqB,MAAM,IAAK,CAAA,sBAAsB,EACzD,MAAO,CAAA,CAAC,GAAG,CAAC,MAAM,mBAAoB,CAAA,QAAA,CAAS,CAAC,CAAC,CAAA,CACjD,IAAI,CAAC,CAAC,CAAC,CAAA,KAAM,CAAC,CAAA;AAIjB,EAAO,OAAA,MAAA,CAAO,OAAO,CAAS,KAAA,KAAA;AAG5B,IACE,IAAA,KAAA,CAAM,OAAY,KAAA,MAAA,IAClB,CAAC,QAAA,EAAU,OAAO,CAAA,CAAE,QAAS,CAAA,KAAA,CAAM,MAAO,CAAA,IAAI,CAC9C,EAAA;AACA,MAAO,OAAA,IAAA;AAAA;AAST,IAAI,IAAA,KAAA,CAAM,YAAY,UAAY,EAAA;AAChC,MAAA,MAAM,WAAc,GAAAC,sBAAA,CAAiB,KAAM,CAAA,UAAU,CAAE,CAAA,KAAA;AAAA,QACrD,CAAA;AAAA,QACA,CAAC,WAAY,CAAA;AAAA,OACf;AACA,MAAA,MAAM,WAAW,CAAG,EAAA,WAAW,CAAe,YAAA,EAAA,KAAA,CAAM,OAAO,eAAe,CAAA,CAAA;AAC1E,MAAA,IACE,mBAAmB,IAAK,CAAA,CAAA,WAAA,KAAe,YAAY,UAAW,CAAA,QAAQ,CAAC,CACvE,EAAA;AACA,QAAO,OAAA,IAAA;AAAA;AACT;AAGF,IAAA,MAAM,MACJ,oBAAqB,CAAA,GAAA,CAAIA,uBAAiB,KAAM,CAAA,YAAY,CAAC,CAC7D,IAAAD,+BAAA;AACF,IAAO,OAAA,GAAA,IAAO,mBAAoB,CAAA,QAAA,CAAS,GAAG,CAAA;AAAA,GAC/C,CAAA;AACH;;;;;"}