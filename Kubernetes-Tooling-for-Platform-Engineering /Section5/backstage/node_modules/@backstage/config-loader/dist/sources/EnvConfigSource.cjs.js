'use strict';

var errors = require('@backstage/errors');

class EnvConfigSource {
  constructor(env) {
    this.env = env;
  }
  /**
   * Creates a new config source that reads from the environment.
   *
   * @param options - Options for the config source.
   * @returns A new config source that reads from the environment.
   */
  static create(options) {
    return new EnvConfigSource(options?.env ?? process.env);
  }
  async *readConfigData() {
    const configs = readEnvConfig(this.env);
    yield { configs };
    return;
  }
  toString() {
    const keys = Object.keys(this.env).filter(
      (key) => key.startsWith("APP_CONFIG_")
    );
    return `EnvConfigSource{count=${keys.length}}`;
  }
}
const ENV_PREFIX = "APP_CONFIG_";
const CONFIG_KEY_PART_PATTERN = /^[a-z][a-z0-9]*(?:[-_][a-z][a-z0-9]*)*$/i;
function readEnvConfig(env) {
  let data = void 0;
  for (const [name, value] of Object.entries(env)) {
    if (!value) {
      continue;
    }
    if (name.startsWith(ENV_PREFIX)) {
      const key = name.replace(ENV_PREFIX, "");
      const keyParts = key.split("_");
      let obj = data = data ?? {};
      for (const [index, part] of keyParts.entries()) {
        if (!CONFIG_KEY_PART_PATTERN.test(part)) {
          throw new TypeError(`Invalid env config key '${key}'`);
        }
        if (index < keyParts.length - 1) {
          obj = obj[part] = obj[part] ?? {};
          if (typeof obj !== "object" || Array.isArray(obj)) {
            const subKey = keyParts.slice(0, index + 1).join("_");
            throw new TypeError(
              `Could not nest config for key '${key}' under existing value '${subKey}'`
            );
          }
        } else {
          if (part in obj) {
            throw new TypeError(
              `Refusing to override existing config at key '${key}'`
            );
          }
          try {
            const [, parsedValue] = safeJsonParse(value);
            if (parsedValue === null) {
              throw new Error("value may not be null");
            }
            obj[part] = parsedValue;
          } catch (error) {
            throw new TypeError(
              `Failed to parse JSON-serialized config value for key '${key}', ${error}`
            );
          }
        }
      }
    }
  }
  return data ? [{ data, context: "env" }] : [];
}
function safeJsonParse(str) {
  try {
    return [null, JSON.parse(str)];
  } catch (err) {
    errors.assertError(err);
    return [err, str];
  }
}

exports.EnvConfigSource = EnvConfigSource;
exports.readEnvConfig = readEnvConfig;
//# sourceMappingURL=EnvConfigSource.cjs.js.map
