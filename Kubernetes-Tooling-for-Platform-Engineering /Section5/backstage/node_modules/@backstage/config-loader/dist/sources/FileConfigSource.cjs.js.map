{"version":3,"file":"FileConfigSource.cjs.js","sources":["../../src/sources/FileConfigSource.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport chokidar, { FSWatcher } from 'chokidar';\nimport fs from 'fs-extra';\nimport { basename, dirname, isAbsolute, resolve as resolvePath } from 'path';\nimport {\n  AsyncConfigSourceGenerator,\n  ConfigSource,\n  ConfigSourceData,\n  SubstitutionFunc,\n  Parser,\n  ReadConfigDataOptions,\n} from './types';\nimport { createConfigTransformer } from './transform';\nimport { NotFoundError } from '@backstage/errors';\nimport { parseYamlContent } from './utils';\n\n/**\n * Options for {@link FileConfigSource.create}.\n *\n * @public\n */\nexport interface FileConfigSourceOptions {\n  /**\n   * The path to the config file that should be loaded.\n   */\n  path: string;\n\n  /**\n   * Set to `false` to disable file watching, defaults to `true`.\n   */\n  watch?: boolean;\n\n  /**\n   * A substitution function to use instead of the default environment substitution.\n   */\n  substitutionFunc?: SubstitutionFunc;\n\n  /**\n   * A content parsing function to transform string content to configuration values.\n   */\n  parser?: Parser;\n}\n\nasync function readFile(path: string): Promise<string | undefined> {\n  try {\n    const content = await fs.readFile(path, 'utf8');\n    // During watching we may sometimes read files too early before the file content has been written.\n    // We never expect the writing to take a long time, but if we encounter an empty file then check\n    // again after a short delay for safety.\n    if (content === '') {\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return await fs.readFile(path, 'utf8');\n    }\n    return content;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return undefined;\n    }\n    throw error;\n  }\n}\n\n/**\n * A config source that loads configuration from a local file.\n *\n * @public\n */\nexport class FileConfigSource implements ConfigSource {\n  /**\n   * Creates a new config source that loads configuration from the given path.\n   *\n   * @remarks\n   *\n   * The source will watch the file for changes, as well as any referenced files.\n   *\n   * @param options - Options for the config source.\n   * @returns A new config source that loads from the given path.\n   */\n  static create(options: FileConfigSourceOptions): ConfigSource {\n    if (!isAbsolute(options.path)) {\n      throw new Error(`Config load path is not absolute: \"${options.path}\"`);\n    }\n    return new FileConfigSource(options);\n  }\n\n  readonly #path: string;\n  readonly #substitutionFunc?: SubstitutionFunc;\n  readonly #watch?: boolean;\n  readonly #parser: Parser;\n\n  private constructor(options: FileConfigSourceOptions) {\n    this.#path = options.path;\n    this.#substitutionFunc = options.substitutionFunc;\n    this.#watch = options.watch ?? true;\n    this.#parser = options.parser ?? parseYamlContent;\n  }\n\n  // Work is duplicated across each read, in practice that should not\n  // have any impact since there won't be multiple consumers. If that\n  // changes it might be worth refactoring this to avoid duplicate work.\n  async *readConfigData(\n    options?: ReadConfigDataOptions,\n  ): AsyncConfigSourceGenerator {\n    const signal = options?.signal;\n    const configFileName = basename(this.#path);\n\n    let watchedPaths: Array<string> | null = null;\n    let watcher: FSWatcher | null = null;\n\n    if (this.#watch) {\n      // Keep track of watched paths, since this is simpler than resetting the watcher\n      watchedPaths = new Array<string>();\n      watcher = chokidar.watch(this.#path, {\n        usePolling: process.env.NODE_ENV === 'test',\n      });\n    }\n\n    const dir = dirname(this.#path);\n    const transformer = createConfigTransformer({\n      substitutionFunc: this.#substitutionFunc,\n      readFile: async path => {\n        const fullPath = resolvePath(dir, path);\n        if (watcher && watchedPaths) {\n          // Any files discovered while reading this config should be watched too\n          watcher.add(fullPath);\n          watchedPaths.push(fullPath);\n        }\n\n        const data = await readFile(fullPath);\n        if (data === undefined) {\n          throw new NotFoundError(\n            `failed to include \"${fullPath}\", file does not exist`,\n          );\n        }\n        return data;\n      },\n    });\n\n    // This is the entry point for reading the file, called initially and on change\n    const readConfigFile = async (): Promise<ConfigSourceData[]> => {\n      if (watcher && watchedPaths) {\n        // We clear the watched files every time we initiate a new read\n        watcher.unwatch(watchedPaths);\n        watchedPaths.length = 0;\n\n        watcher.add(this.#path);\n        watchedPaths.push(this.#path);\n      }\n\n      const contents = await readFile(this.#path);\n      if (contents === undefined) {\n        throw new NotFoundError(`Config file \"${this.#path}\" does not exist`);\n      }\n      const { result: parsed } = await this.#parser({ contents });\n      if (parsed === undefined) {\n        return [];\n      }\n      try {\n        const data = await transformer(parsed, { dir });\n        return [{ data, context: configFileName, path: this.#path }];\n      } catch (error) {\n        throw new Error(\n          `Failed to read config file at \"${this.#path}\", ${error.message}`,\n        );\n      }\n    };\n\n    const onAbort = () => {\n      signal?.removeEventListener('abort', onAbort);\n      if (watcher) watcher.close();\n    };\n    signal?.addEventListener('abort', onAbort);\n\n    yield { configs: await readConfigFile() };\n\n    if (watcher) {\n      for (;;) {\n        const event = await this.#waitForEvent(watcher, signal);\n        if (event === 'abort') {\n          return;\n        }\n        yield { configs: await readConfigFile() };\n      }\n    }\n  }\n\n  toString() {\n    return `FileConfigSource{path=\"${this.#path}\"}`;\n  }\n\n  #waitForEvent(\n    watcher: FSWatcher,\n    signal?: AbortSignal,\n  ): Promise<'change' | 'abort'> {\n    return new Promise(resolve => {\n      function onChange() {\n        resolve('change');\n        onDone();\n      }\n      function onAbort() {\n        resolve('abort');\n        onDone();\n      }\n      function onDone() {\n        watcher.removeListener('change', onChange);\n        signal?.removeEventListener('abort', onAbort);\n      }\n      watcher.addListener('change', onChange);\n      signal?.addEventListener('abort', onAbort);\n    });\n  }\n}\n"],"names":["fs","isAbsolute","parseYamlContent","basename","chokidar","dirname","createConfigTransformer","path","resolvePath","NotFoundError"],"mappings":"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"}