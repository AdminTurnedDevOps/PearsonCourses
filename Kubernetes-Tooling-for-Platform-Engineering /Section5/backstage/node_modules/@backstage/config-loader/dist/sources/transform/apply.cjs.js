'use strict';

var errors = require('@backstage/errors');
var utils = require('./utils.cjs.js');
var substitution = require('./substitution.cjs.js');
var include = require('./include.cjs.js');

async function applyConfigTransforms(input, context, transforms) {
  async function transform(inputObj, path, baseDir) {
    let obj = inputObj;
    let dir = baseDir;
    for (const tf of transforms) {
      try {
        const result = await tf(inputObj, { dir });
        if (result.applied) {
          if (result.value === void 0) {
            return void 0;
          }
          obj = result.value;
          dir = result?.newDir ?? dir;
          break;
        }
      } catch (error) {
        errors.assertError(error);
        throw new Error(`error at ${path}, ${error.message}`);
      }
    }
    if (typeof obj !== "object") {
      return obj;
    } else if (obj === null) {
      return null;
    } else if (Array.isArray(obj)) {
      const arr = new Array();
      for (const [index, value] of obj.entries()) {
        const out2 = await transform(value, `${path}[${index}]`, dir);
        if (out2 !== void 0) {
          arr.push(out2);
        }
      }
      return arr;
    }
    const out = {};
    for (const [key, value] of Object.entries(obj)) {
      if (value !== void 0) {
        const result = await transform(value, `${path}.${key}`, dir);
        if (result !== void 0) {
          out[key] = result;
        }
      }
    }
    return out;
  }
  const finalData = await transform(input, "", context?.dir);
  if (!utils.isObject(finalData)) {
    throw new TypeError("expected object at config root");
  }
  return finalData;
}
function createConfigTransformer(options) {
  const {
    substitutionFunc = async (name) => process.env[name]?.trim(),
    readFile
  } = options;
  const substitutionTransform = substitution.createSubstitutionTransform(substitutionFunc);
  const transforms = [substitutionTransform];
  if (readFile) {
    const includeTransform = include.createIncludeTransform(
      substitutionFunc,
      readFile,
      substitutionTransform
    );
    transforms.push(includeTransform);
  }
  return async (input, ctx) => applyConfigTransforms(input, ctx ?? {}, transforms);
}

exports.applyConfigTransforms = applyConfigTransforms;
exports.createConfigTransformer = createConfigTransformer;
//# sourceMappingURL=apply.cjs.js.map
