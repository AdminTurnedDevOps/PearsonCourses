'use strict';

var types = require('@backstage/types');
var utils = require('./utils.cjs.js');

class MutableConfigSource {
  /**
   * Creates a new mutable config source.
   *
   * @param options - Options for the config source.
   * @returns A new mutable config source.
   */
  static create(options) {
    return new MutableConfigSource(
      options?.context ?? "mutable-config",
      options?.data
    );
  }
  #currentData;
  #deferred;
  #context;
  #abortController = new AbortController();
  constructor(context, initialData) {
    this.#currentData = initialData;
    this.#context = context;
    this.#deferred = types.createDeferred();
  }
  async *readConfigData(options) {
    let deferredPromise = this.#deferred;
    if (this.#currentData !== void 0) {
      yield { configs: [{ data: this.#currentData, context: this.#context }] };
    }
    for (; ; ) {
      const [ok] = await utils.waitOrAbort(deferredPromise, [
        options?.signal,
        this.#abortController.signal
      ]);
      if (!ok) {
        return;
      }
      deferredPromise = this.#deferred;
      if (this.#currentData !== void 0) {
        yield {
          configs: [{ data: this.#currentData, context: this.#context }]
        };
      }
    }
  }
  /**
   * Set the data of the config source.
   *
   * @param data - The new data to set
   */
  setData(data) {
    if (!this.#abortController.signal.aborted) {
      this.#currentData = data;
      const oldDeferred = this.#deferred;
      this.#deferred = types.createDeferred();
      oldDeferred.resolve();
    }
  }
  /**
   * Close the config source, preventing any further updates.
   */
  close() {
    this.#currentData = void 0;
    this.#abortController.abort();
  }
  toString() {
    return `MutableConfigSource{}`;
  }
}

exports.MutableConfigSource = MutableConfigSource;
//# sourceMappingURL=MutableConfigSource.cjs.js.map
