'use strict';

var chokidar = require('chokidar');
var fs = require('fs-extra');
var path = require('path');
var apply = require('./transform/apply.cjs.js');
var errors = require('@backstage/errors');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

async function readFile(path) {
  try {
    const content = await fs__default.default.readFile(path, "utf8");
    if (content === "") {
      await new Promise((resolve) => setTimeout(resolve, 10));
      return await fs__default.default.readFile(path, "utf8");
    }
    return content;
  } catch (error) {
    if (error.code === "ENOENT") {
      return void 0;
    }
    throw error;
  }
}
class FileConfigSource {
  /**
   * Creates a new config source that loads configuration from the given path.
   *
   * @remarks
   *
   * The source will watch the file for changes, as well as any referenced files.
   *
   * @param options - Options for the config source.
   * @returns A new config source that loads from the given path.
   */
  static create(options) {
    if (!path.isAbsolute(options.path)) {
      throw new Error(`Config load path is not absolute: "${options.path}"`);
    }
    return new FileConfigSource(options);
  }
  #path;
  #substitutionFunc;
  #watch;
  #parser;
  constructor(options) {
    this.#path = options.path;
    this.#substitutionFunc = options.substitutionFunc;
    this.#watch = options.watch ?? true;
    this.#parser = options.parser ?? utils.parseYamlContent;
  }
  // Work is duplicated across each read, in practice that should not
  // have any impact since there won't be multiple consumers. If that
  // changes it might be worth refactoring this to avoid duplicate work.
  async *readConfigData(options) {
    const signal = options?.signal;
    const configFileName = path.basename(this.#path);
    let watchedPaths = null;
    let watcher = null;
    if (this.#watch) {
      watchedPaths = new Array();
      watcher = chokidar__default.default.watch(this.#path, {
        usePolling: process.env.NODE_ENV === "test"
      });
    }
    const dir = path.dirname(this.#path);
    const transformer = apply.createConfigTransformer({
      substitutionFunc: this.#substitutionFunc,
      readFile: async (path$1) => {
        const fullPath = path.resolve(dir, path$1);
        if (watcher && watchedPaths) {
          watcher.add(fullPath);
          watchedPaths.push(fullPath);
        }
        const data = await readFile(fullPath);
        if (data === void 0) {
          throw new errors.NotFoundError(
            `failed to include "${fullPath}", file does not exist`
          );
        }
        return data;
      }
    });
    const readConfigFile = async () => {
      if (watcher && watchedPaths) {
        watcher.unwatch(watchedPaths);
        watchedPaths.length = 0;
        watcher.add(this.#path);
        watchedPaths.push(this.#path);
      }
      const contents = await readFile(this.#path);
      if (contents === void 0) {
        throw new errors.NotFoundError(`Config file "${this.#path}" does not exist`);
      }
      const { result: parsed } = await this.#parser({ contents });
      if (parsed === void 0) {
        return [];
      }
      try {
        const data = await transformer(parsed, { dir });
        return [{ data, context: configFileName, path: this.#path }];
      } catch (error) {
        throw new Error(
          `Failed to read config file at "${this.#path}", ${error.message}`
        );
      }
    };
    const onAbort = () => {
      signal?.removeEventListener("abort", onAbort);
      if (watcher) watcher.close();
    };
    signal?.addEventListener("abort", onAbort);
    yield { configs: await readConfigFile() };
    if (watcher) {
      for (; ; ) {
        const event = await this.#waitForEvent(watcher, signal);
        if (event === "abort") {
          return;
        }
        yield { configs: await readConfigFile() };
      }
    }
  }
  toString() {
    return `FileConfigSource{path="${this.#path}"}`;
  }
  #waitForEvent(watcher, signal) {
    return new Promise((resolve) => {
      function onChange() {
        resolve("change");
        onDone();
      }
      function onAbort() {
        resolve("abort");
        onDone();
      }
      function onDone() {
        watcher.removeListener("change", onChange);
        signal?.removeEventListener("abort", onAbort);
      }
      watcher.addListener("change", onChange);
      signal?.addEventListener("abort", onAbort);
    });
  }
}

exports.FileConfigSource = FileConfigSource;
//# sourceMappingURL=FileConfigSource.cjs.js.map
