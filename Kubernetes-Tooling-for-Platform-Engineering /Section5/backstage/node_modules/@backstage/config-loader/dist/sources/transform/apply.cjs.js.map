{"version":3,"file":"apply.cjs.js","sources":["../../../src/sources/transform/apply.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject, JsonValue } from '@backstage/types';\nimport { assertError } from '@backstage/errors';\nimport { TransformContext, TransformFunc } from './types';\nimport { isObject } from './utils';\nimport { createSubstitutionTransform } from './substitution';\nimport { createIncludeTransform } from './include';\nimport { SubstitutionFunc } from '../types';\n\n/**\n * Applies a set of transforms to raw configuration data.\n */\nexport async function applyConfigTransforms(\n  input: JsonValue,\n  context: { dir?: string },\n  transforms: TransformFunc[],\n): Promise<JsonObject> {\n  async function transform(\n    inputObj: JsonValue,\n    path: string,\n    baseDir?: string,\n  ): Promise<JsonValue | undefined> {\n    let obj = inputObj;\n    let dir = baseDir;\n\n    for (const tf of transforms) {\n      try {\n        const result = await tf(inputObj, { dir });\n        if (result.applied) {\n          if (result.value === undefined) {\n            return undefined;\n          }\n          obj = result.value;\n          dir = result?.newDir ?? dir;\n          break;\n        }\n      } catch (error) {\n        assertError(error);\n        throw new Error(`error at ${path}, ${error.message}`);\n      }\n    }\n\n    if (typeof obj !== 'object') {\n      return obj;\n    } else if (obj === null) {\n      return null;\n    } else if (Array.isArray(obj)) {\n      const arr = new Array<JsonValue>();\n\n      for (const [index, value] of obj.entries()) {\n        const out = await transform(value, `${path}[${index}]`, dir);\n        if (out !== undefined) {\n          arr.push(out);\n        }\n      }\n\n      return arr;\n    }\n\n    const out: JsonObject = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      // undefined covers optional fields\n      if (value !== undefined) {\n        const result = await transform(value, `${path}.${key}`, dir);\n        if (result !== undefined) {\n          out[key] = result;\n        }\n      }\n    }\n\n    return out;\n  }\n\n  const finalData = await transform(input, '', context?.dir);\n  if (!isObject(finalData)) {\n    throw new TypeError('expected object at config root');\n  }\n  return finalData;\n}\n\n/** @internal */\nexport type ConfigTransformer = (\n  input: JsonObject,\n  context?: TransformContext,\n) => Promise<JsonObject>;\n\n/** @internal */\nexport function createConfigTransformer(options: {\n  substitutionFunc?: SubstitutionFunc;\n  readFile?(path: string): Promise<string>;\n}): ConfigTransformer {\n  const {\n    substitutionFunc = async name => process.env[name]?.trim(),\n    readFile,\n  } = options;\n  const substitutionTransform = createSubstitutionTransform(substitutionFunc);\n  const transforms = [substitutionTransform];\n  if (readFile) {\n    const includeTransform = createIncludeTransform(\n      substitutionFunc,\n      readFile,\n      substitutionTransform,\n    );\n    transforms.push(includeTransform);\n  }\n\n  return async (input, ctx) =>\n    applyConfigTransforms(input, ctx ?? {}, transforms);\n}\n"],"names":["assertError","out","isObject","createSubstitutionTransform","createIncludeTransform"],"mappings":"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"}