{"version":3,"file":"substitution.cjs.js","sources":["../../../src/sources/transform/substitution.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue } from '@backstage/types';\nimport { TransformFunc } from './types';\nimport { SubstitutionFunc } from '../types';\n\n/**\n * A environment variable substitution transform that transforms e.g. 'token ${MY_TOKEN}'\n * to 'token abc' if MY_TOKEN is 'abc'. If any of the substituted variables are undefined,\n * the entire expression ends up undefined. Additionally, supports parameter substitution\n * syntax to provide a default or fallback value for a given environment variable if it is\n * unset; e.g. 'token ${MY_TOKEN:-xyz}' transforms to 'token xyz' if MY_TOKEN is unset.\n */\nexport function createSubstitutionTransform(\n  env: SubstitutionFunc,\n): TransformFunc {\n  return async (input: JsonValue) => {\n    if (typeof input !== 'string') {\n      return { applied: false };\n    }\n\n    const parts: (string | undefined)[] = input.split(/(\\$?\\$\\{[^{}]*\\})/);\n    for (let i = 1; i < parts.length; i += 2) {\n      const part = parts[i]!;\n      if (part.startsWith('$$')) {\n        parts[i] = part.slice(1);\n      } else {\n        const indexOfFallbackSeparator = part.indexOf(':-');\n\n        if (indexOfFallbackSeparator > -1) {\n          const envVarValue = await env(\n            part.slice(2, indexOfFallbackSeparator).trim(),\n          );\n          const fallbackValue = part\n            .slice(indexOfFallbackSeparator + ':-'.length, -1)\n            .trim();\n\n          parts[i] = envVarValue || fallbackValue || undefined;\n        } else {\n          parts[i] = await env(part.slice(2, -1).trim());\n        }\n      }\n    }\n\n    if (parts.some(part => part === undefined)) {\n      return { applied: true, value: undefined };\n    }\n    return { applied: true, value: parts.join('') };\n  };\n}\n"],"names":[],"mappings":";;AA2BO,SAAS,4BACd,GACe,EAAA;AACf,EAAA,OAAO,OAAO,KAAqB,KAAA;AACjC,IAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,MAAO,OAAA,EAAE,SAAS,KAAM,EAAA;AAAA;AAG1B,IAAM,MAAA,KAAA,GAAgC,KAAM,CAAA,KAAA,CAAM,mBAAmB,CAAA;AACrE,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,MAAA,EAAQ,KAAK,CAAG,EAAA;AACxC,MAAM,MAAA,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,MAAI,IAAA,IAAA,CAAK,UAAW,CAAA,IAAI,CAAG,EAAA;AACzB,QAAA,KAAA,CAAM,CAAC,CAAA,GAAI,IAAK,CAAA,KAAA,CAAM,CAAC,CAAA;AAAA,OAClB,MAAA;AACL,QAAM,MAAA,wBAAA,GAA2B,IAAK,CAAA,OAAA,CAAQ,IAAI,CAAA;AAElD,QAAA,IAAI,2BAA2B,CAAI,CAAA,EAAA;AACjC,UAAA,MAAM,cAAc,MAAM,GAAA;AAAA,YACxB,IAAK,CAAA,KAAA,CAAM,CAAG,EAAA,wBAAwB,EAAE,IAAK;AAAA,WAC/C;AACA,UAAM,MAAA,aAAA,GAAgB,KACnB,KAAM,CAAA,wBAAA,GAA2B,KAAK,MAAQ,EAAA,CAAA,CAAE,EAChD,IAAK,EAAA;AAER,UAAM,KAAA,CAAA,CAAC,CAAI,GAAA,WAAA,IAAe,aAAiB,IAAA,KAAA,CAAA;AAAA,SACtC,MAAA;AACL,UAAM,KAAA,CAAA,CAAC,CAAI,GAAA,MAAM,GAAI,CAAA,IAAA,CAAK,MAAM,CAAG,EAAA,CAAA,CAAE,CAAE,CAAA,IAAA,EAAM,CAAA;AAAA;AAC/C;AACF;AAGF,IAAA,IAAI,KAAM,CAAA,IAAA,CAAK,CAAQ,IAAA,KAAA,IAAA,KAAS,MAAS,CAAG,EAAA;AAC1C,MAAA,OAAO,EAAE,OAAA,EAAS,IAAM,EAAA,KAAA,EAAO,KAAU,CAAA,EAAA;AAAA;AAE3C,IAAA,OAAO,EAAE,OAAS,EAAA,IAAA,EAAM,OAAO,KAAM,CAAA,IAAA,CAAK,EAAE,CAAE,EAAA;AAAA,GAChD;AACF;;;;"}