'use strict';

var yaml = require('yaml');
var path = require('path');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);

const includeFileParser = {
  ".json": async (content) => JSON.parse(content),
  ".yaml": async (content) => yaml__default.default.parse(content),
  ".yml": async (content) => yaml__default.default.parse(content)
};
function createIncludeTransform(env, readFile, substitute) {
  return async (input, context) => {
    const { dir } = context;
    if (!dir) {
      throw new Error("Include transform requires a base directory");
    }
    if (!utils.isObject(input)) {
      return { applied: false };
    }
    const [includeKey] = Object.keys(input).filter((key) => key.startsWith("$"));
    if (includeKey) {
      if (Object.keys(input).length !== 1) {
        throw new Error(
          `include key ${includeKey} should not have adjacent keys`
        );
      }
    } else {
      return { applied: false };
    }
    const rawIncludedValue = input[includeKey];
    if (typeof rawIncludedValue !== "string") {
      throw new Error(`${includeKey} include value is not a string`);
    }
    const substituteResults = await substitute(rawIncludedValue, { dir });
    const includeValue = substituteResults.applied ? substituteResults.value : rawIncludedValue;
    if (includeValue === void 0 || typeof includeValue !== "string") {
      throw new Error(`${includeKey} substitution value was undefined`);
    }
    switch (includeKey) {
      case "$file":
        try {
          const value = await readFile(path.resolve(dir, includeValue));
          return { applied: true, value: value.trimEnd() };
        } catch (error) {
          throw new Error(`failed to read file ${includeValue}, ${error}`);
        }
      case "$env":
        try {
          return { applied: true, value: await env(includeValue) };
        } catch (error) {
          throw new Error(`failed to read env ${includeValue}, ${error}`);
        }
      case "$include": {
        const [filePath, dataPath] = includeValue.split(/#(.*)/);
        const ext = path.extname(filePath);
        const parser = includeFileParser[ext];
        if (!parser) {
          throw new Error(
            `no configuration parser available for included file ${filePath}`
          );
        }
        const path$1 = path.resolve(dir, filePath);
        const content = await readFile(path$1);
        const newDir = path.dirname(path$1);
        const parts = dataPath ? dataPath.split(".") : [];
        let value;
        try {
          value = await parser(content);
        } catch (error) {
          throw new Error(
            `failed to parse included file ${filePath}, ${error}`
          );
        }
        for (const [index, part] of parts.entries()) {
          if (!utils.isObject(value)) {
            const errPath = parts.slice(0, index).join(".");
            throw new Error(
              `value at '${errPath}' in included file ${filePath} is not an object`
            );
          }
          value = value[part];
        }
        if (typeof value === "string") {
          const substituted = await substitute(value, { dir: newDir });
          if (substituted.applied) {
            value = substituted.value;
          }
        }
        return {
          applied: true,
          value,
          newDir: newDir !== dir ? newDir : void 0
        };
      }
      default:
        throw new Error(`unknown include ${includeKey}`);
    }
  };
}

exports.createIncludeTransform = createIncludeTransform;
//# sourceMappingURL=include.cjs.js.map
