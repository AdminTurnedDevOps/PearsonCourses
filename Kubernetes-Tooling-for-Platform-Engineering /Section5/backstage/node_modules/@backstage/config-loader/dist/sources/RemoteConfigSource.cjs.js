'use strict';

var errors = require('@backstage/errors');
var types = require('@backstage/types');
var isEqual = require('lodash/isEqual');
var apply = require('./transform/apply.cjs.js');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);

const DEFAULT_RELOAD_INTERVAL = { seconds: 60 };
class RemoteConfigSource {
  /**
   * Creates a new {@link RemoteConfigSource}.
   *
   * @param options - Options for the source.
   * @returns A new remote config source.
   */
  static create(options) {
    try {
      new URL(options.url);
    } catch (error) {
      throw new Error(
        `Invalid URL provided to remote config source, '${options.url}', ${error}`
      );
    }
    return new RemoteConfigSource(options);
  }
  #url;
  #reloadIntervalMs;
  #transformer;
  #parser;
  constructor(options) {
    this.#url = options.url;
    this.#reloadIntervalMs = types.durationToMilliseconds(
      options.reloadInterval ?? DEFAULT_RELOAD_INTERVAL
    );
    this.#transformer = apply.createConfigTransformer({
      substitutionFunc: options.substitutionFunc
    });
    this.#parser = options.parser ?? utils.parseYamlContent;
  }
  async *readConfigData(options) {
    let data = await this.#load();
    yield { configs: [{ data, context: this.#url }] };
    for (; ; ) {
      await this.#wait(options?.signal);
      if (options?.signal?.aborted) {
        return;
      }
      try {
        const newData = await this.#load(options?.signal);
        if (newData && !isEqual__default.default(data, newData)) {
          data = newData;
          yield { configs: [{ data, context: this.#url }] };
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error(`Failed to read config from ${this.#url}, ${error}`);
        }
      }
    }
  }
  toString() {
    return `RemoteConfigSource{path="${this.#url}"}`;
  }
  async #load(signal) {
    const res = await fetch(this.#url, {
      signal
    });
    if (!res.ok) {
      throw await errors.ResponseError.fromResponse(res);
    }
    const contents = await res.text();
    const { result: rawData } = await this.#parser({ contents });
    if (rawData === void 0) {
      throw new Error("configuration data is null");
    }
    const data = await this.#transformer(rawData);
    if (typeof data !== "object") {
      throw new Error("configuration data is not an object");
    } else if (Array.isArray(data)) {
      throw new Error(
        "configuration data is an array, expected an object instead"
      );
    }
    return data;
  }
  async #wait(signal) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(onDone, this.#reloadIntervalMs);
      signal?.addEventListener("abort", onDone);
      function onDone() {
        clearTimeout(timeoutId);
        signal?.removeEventListener("abort", onDone);
        resolve();
      }
    });
  }
}

exports.RemoteConfigSource = RemoteConfigSource;
//# sourceMappingURL=RemoteConfigSource.cjs.js.map
