'use strict';

var path = require('path');
var fs = require('fs-extra');
var config = require('@backstage/config');
var parseArgs = require('minimist');
var EnvConfigSource = require('./EnvConfigSource.cjs.js');
var FileConfigSource = require('./FileConfigSource.cjs.js');
var MergedConfigSource = require('./MergedConfigSource.cjs.js');
var RemoteConfigSource = require('./RemoteConfigSource.cjs.js');
var ObservableConfigProxy = require('./ObservableConfigProxy.cjs.js');
var cliCommon = require('@backstage/cli-common');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var parseArgs__default = /*#__PURE__*/_interopDefaultCompat(parseArgs);

class ConfigSources {
  /**
   * Parses command line arguments and returns the config targets.
   *
   * @param argv - The command line arguments to parse. Defaults to `process.argv`
   * @returns A list of config targets
   */
  static parseArgs(argv = process.argv) {
    const args = [parseArgs__default.default(argv).config].flat().filter(Boolean);
    return args.map((target) => {
      try {
        const url = new URL(target);
        if (!url.host) {
          return { type: "path", target };
        }
        return { type: "url", target };
      } catch {
        return { type: "path", target };
      }
    });
  }
  /**
   * Creates the default config sources for the provided targets.
   *
   * @remarks
   *
   * This will create {@link FileConfigSource}s and {@link RemoteConfigSource}s
   * for the provided targets, and merge them together to a single source.
   * If no targets are provided it will fall back to `app-config.yaml` and
   * `app-config.local.yaml`.
   *
   * URL targets are only supported if the `remote` option is provided.
   *
   * @param options - Options
   * @returns A config source for the provided targets
   */
  static defaultForTargets(options) {
    const rootDir = options.rootDir ?? cliCommon.findPaths(process.cwd()).targetRoot;
    const argSources = options.targets.map((arg) => {
      if (arg.type === "url") {
        if (!options.remote) {
          throw new Error(
            `Config argument "${arg.target}" looks like a URL but remote configuration is not enabled. Enable it by passing the \`remote\` option`
          );
        }
        return RemoteConfigSource.RemoteConfigSource.create({
          url: arg.target,
          substitutionFunc: options.substitutionFunc,
          reloadInterval: options.remote.reloadInterval
        });
      }
      return FileConfigSource.FileConfigSource.create({
        watch: options.watch,
        path: path.resolve(arg.target),
        substitutionFunc: options.substitutionFunc
      });
    });
    if (argSources.length === 0) {
      const defaultPath = path.resolve(rootDir, "app-config.yaml");
      const localPath = path.resolve(rootDir, "app-config.local.yaml");
      const alwaysIncludeDefaultConfigSource = !options.allowMissingDefaultConfig;
      if (alwaysIncludeDefaultConfigSource || fs__default.default.pathExistsSync(defaultPath)) {
        argSources.push(
          FileConfigSource.FileConfigSource.create({
            watch: options.watch,
            path: defaultPath,
            substitutionFunc: options.substitutionFunc
          })
        );
      }
      if (fs__default.default.pathExistsSync(localPath)) {
        argSources.push(
          FileConfigSource.FileConfigSource.create({
            watch: options.watch,
            path: localPath,
            substitutionFunc: options.substitutionFunc
          })
        );
      }
    }
    return this.merge(argSources);
  }
  /**
   * Creates the default config source for Backstage.
   *
   * @remarks
   *
   * This will read from `app-config.yaml` and `app-config.local.yaml` by
   * default, as well as environment variables prefixed with `APP_CONFIG_`.
   * If `--config <path|url>` command line arguments are passed, these will
   * override the default configuration file paths. URLs are only supported
   * if the `remote` option is provided.
   *
   * @param options - Options
   * @returns The default Backstage config source
   */
  static default(options) {
    const argSource = this.defaultForTargets({
      ...options,
      targets: this.parseArgs(options.argv)
    });
    const envSource = EnvConfigSource.EnvConfigSource.create({
      env: options.env
    });
    return this.merge([argSource, envSource]);
  }
  /**
   * Merges multiple config sources into a single source that reads from all
   * sources and concatenates the result.
   *
   * @param sources - The config sources to merge
   * @returns A single config source that concatenates the data from the given sources
   */
  static merge(sources) {
    return MergedConfigSource.MergedConfigSource.from(sources);
  }
  /**
   * Creates an observable {@link @backstage/config#Config} implementation from a {@link ConfigSource}.
   *
   * @remarks
   *
   * If you only want to read the config once you can close the returned config immediately.
   *
   * @example
   *
   * ```ts
   * const sources = ConfigSources.default(...)
   * const config = await ConfigSources.toConfig(source)
   * config.close()
   * const example = config.getString(...)
   * ```
   *
   * @param source - The config source to read from
   * @returns A promise that resolves to a closable config
   */
  static toConfig(source) {
    return new Promise(async (resolve, reject) => {
      let config$1 = void 0;
      try {
        const abortController = new AbortController();
        for await (const { configs } of source.readConfigData({
          signal: abortController.signal
        })) {
          if (config$1) {
            config$1.setConfig(config.ConfigReader.fromConfigs(configs));
          } else {
            config$1 = ObservableConfigProxy.ObservableConfigProxy.create(abortController);
            config$1.setConfig(config.ConfigReader.fromConfigs(configs));
            resolve(config$1);
          }
        }
      } catch (error) {
        reject(error);
      }
    });
  }
}

exports.ConfigSources = ConfigSources;
//# sourceMappingURL=ConfigSources.cjs.js.map
