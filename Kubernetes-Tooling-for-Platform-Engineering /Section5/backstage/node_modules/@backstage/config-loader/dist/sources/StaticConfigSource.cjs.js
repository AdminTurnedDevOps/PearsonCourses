'use strict';

var types = require('@backstage/types');

class StaticObservableConfigSource {
  constructor(data, context) {
    this.data = data;
    this.context = context;
  }
  async *readConfigData(options) {
    const queue = new Array();
    let deferred = types.createDeferred();
    const sub = this.data.subscribe({
      next(value) {
        queue.push(value);
        deferred.resolve();
        deferred = types.createDeferred();
      },
      complete() {
        deferred.resolve();
      }
    });
    const signal = options?.signal;
    if (signal) {
      const onAbort = () => {
        sub.unsubscribe();
        queue.length = 0;
        deferred.resolve();
        signal.removeEventListener("abort", onAbort);
      };
      signal.addEventListener("abort", onAbort);
    }
    for (; ; ) {
      await deferred;
      if (queue.length === 0) {
        return;
      }
      while (queue.length > 0) {
        yield { configs: [{ data: queue.shift(), context: this.context }] };
      }
    }
  }
}
function isObservable(value) {
  return "subscribe" in value && typeof value.subscribe === "function";
}
function isAsyncIterable(value) {
  return Symbol.asyncIterator in value;
}
class StaticConfigSource {
  constructor(promise, context) {
    this.promise = promise;
    this.context = context;
  }
  /**
   * Creates a new {@link StaticConfigSource}.
   *
   * @param options - Options for the config source
   * @returns A new static config source
   */
  static create(options) {
    const { data, context = "static-config" } = options;
    if (!data) {
      return {
        async *readConfigData() {
          yield { configs: [] };
          return;
        }
      };
    }
    if (isObservable(data)) {
      return new StaticObservableConfigSource(data, context);
    }
    if (isAsyncIterable(data)) {
      return {
        async *readConfigData() {
          for await (const value of data) {
            yield { configs: [{ data: value, context }] };
          }
        }
      };
    }
    return new StaticConfigSource(data, context);
  }
  async *readConfigData() {
    yield { configs: [{ data: await this.promise, context: this.context }] };
    return;
  }
  toString() {
    return `StaticConfigSource{}`;
  }
}

exports.StaticConfigSource = StaticConfigSource;
//# sourceMappingURL=StaticConfigSource.cjs.js.map
