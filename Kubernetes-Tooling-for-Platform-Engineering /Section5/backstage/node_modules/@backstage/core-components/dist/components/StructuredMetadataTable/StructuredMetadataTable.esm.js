import React__default, { Fragment } from 'react';
import { createStyles, withStyles } from '@material-ui/core/styles';
import startCase from 'lodash/startCase';
import Typography from '@material-ui/core/Typography';
import { MetadataList, MetadataTable, MetadataTableItem, MetadataListItem } from './MetadataTable.esm.js';

const listStyle = createStyles({
  root: {
    margin: "0 0",
    listStyleType: "none"
  }
});
const nestedListStyle = (theme) => createStyles({
  root: {
    ...listStyle.root,
    paddingLeft: theme.spacing(1)
  }
});
const StyledList = withStyles(listStyle, {
  name: "BackstageStructuredMetadataTableList"
})(({ classes, children }) => /* @__PURE__ */ React__default.createElement(MetadataList, { classes }, children));
const StyledNestedList = withStyles(nestedListStyle, {
  name: "BackstageStructuredMetadataTableNestedList"
})(({ classes, children }) => /* @__PURE__ */ React__default.createElement(MetadataList, { classes }, children));
function renderList(list, options, nested) {
  const values = list.map((item, index) => /* @__PURE__ */ React__default.createElement(MetadataListItem, { key: index }, toValue(item, options, nested)));
  return nested ? /* @__PURE__ */ React__default.createElement(StyledNestedList, null, values) : /* @__PURE__ */ React__default.createElement(StyledList, null, values);
}
function renderMap(map, options, nested) {
  const values = Object.keys(map).map((key) => {
    const value = toValue(map[key], options, true);
    return /* @__PURE__ */ React__default.createElement(MetadataListItem, { key }, /* @__PURE__ */ React__default.createElement(Typography, { variant: "body2", component: "span" }, `${options.titleFormat(key)}: `), value);
  });
  return nested ? /* @__PURE__ */ React__default.createElement(StyledNestedList, null, values) : /* @__PURE__ */ React__default.createElement(StyledList, null, values);
}
function toValue(value, options, nested) {
  if (React__default.isValidElement(value)) {
    return /* @__PURE__ */ React__default.createElement(Fragment, null, value);
  }
  if (value !== null && typeof value === "object" && !Array.isArray(value)) {
    return renderMap(value, options, nested);
  }
  if (Array.isArray(value)) {
    return renderList(value, options, nested);
  }
  if (typeof value === "boolean") {
    return /* @__PURE__ */ React__default.createElement(Fragment, null, value ? "\u2705" : "\u274C");
  }
  return /* @__PURE__ */ React__default.createElement(Typography, { variant: "body2", component: "span" }, value);
}
const ItemValue = ({ value, options }) => /* @__PURE__ */ React__default.createElement(Fragment, null, toValue(value, options, false));
const TableItem = ({
  title,
  value,
  options
}) => {
  return /* @__PURE__ */ React__default.createElement(MetadataTableItem, { title: options.titleFormat(title) }, /* @__PURE__ */ React__default.createElement(ItemValue, { value, options }));
};
function mapToItems(info, options) {
  return Object.keys(info).map((key) => /* @__PURE__ */ React__default.createElement(TableItem, { key, title: key, value: info[key], options }));
}
function StructuredMetadataTable(props) {
  const { metadata, dense = true, options = {} } = props;
  const metadataItems = mapToItems(metadata, {
    titleFormat: startCase,
    ...options
  });
  return /* @__PURE__ */ React__default.createElement(MetadataTable, { dense }, metadataItems);
}

export { StructuredMetadataTable };
//# sourceMappingURL=StructuredMetadataTable.esm.js.map
