{"version":3,"file":"AnsiProcessor.esm.js","sources":["../../../src/components/LogViewer/AnsiProcessor.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ansiRegexMaker from 'ansi-regex';\n\nconst ansiRegex = ansiRegexMaker();\nconst newlineRegex = /\\n\\r?/g;\n\n// A mapping of how each escape code changes the modifiers\nconst codeModifiers = Object.fromEntries(\n  Object.entries({\n    1: m => ({ ...m, bold: true }),\n    3: m => ({ ...m, italic: true }),\n    4: m => ({ ...m, underline: true }),\n    22: ({ bold: _, ...m }) => m,\n    23: ({ italic: _, ...m }) => m,\n    24: ({ underline: _, ...m }) => m,\n    30: m => ({ ...m, foreground: 'black' }),\n    31: m => ({ ...m, foreground: 'red' }),\n    32: m => ({ ...m, foreground: 'green' }),\n    33: m => ({ ...m, foreground: 'yellow' }),\n    34: m => ({ ...m, foreground: 'blue' }),\n    35: m => ({ ...m, foreground: 'magenta' }),\n    36: m => ({ ...m, foreground: 'cyan' }),\n    37: m => ({ ...m, foreground: 'white' }),\n    39: ({ foreground: _, ...m }) => m,\n    90: m => ({ ...m, foreground: 'grey' }),\n    40: m => ({ ...m, background: 'black' }),\n    41: m => ({ ...m, background: 'red' }),\n    42: m => ({ ...m, background: 'green' }),\n    43: m => ({ ...m, background: 'yellow' }),\n    44: m => ({ ...m, background: 'blue' }),\n    45: m => ({ ...m, background: 'magenta' }),\n    46: m => ({ ...m, background: 'cyan' }),\n    47: m => ({ ...m, background: 'white' }),\n    49: ({ background: _, ...m }) => m,\n  } as Record<string, (m: ChunkModifiers) => ChunkModifiers>).map(\n    ([code, modifier]) => [`\\x1b[${code}m`, modifier],\n  ),\n);\n\nexport type AnsiColor =\n  | 'black'\n  | 'red'\n  | 'green'\n  | 'yellow'\n  | 'blue'\n  | 'magenta'\n  | 'cyan'\n  | 'white'\n  | 'grey';\n\nexport interface ChunkModifiers {\n  foreground?: AnsiColor;\n  background?: AnsiColor;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n}\n\nexport interface AnsiChunk {\n  text: string;\n  modifiers: ChunkModifiers;\n}\n\nexport class AnsiLine {\n  text: string;\n\n  constructor(\n    readonly lineNumber: number = 1,\n    readonly chunks: AnsiChunk[] = [],\n  ) {\n    this.text = chunks\n      .map(c => c.text)\n      .join('')\n      .toLocaleLowerCase('en-US');\n  }\n\n  lastChunk(): AnsiChunk | undefined {\n    return this.chunks[this.chunks.length - 1];\n  }\n\n  replaceLastChunk(newChunks?: AnsiChunk[]) {\n    if (newChunks) {\n      this.chunks.splice(this.chunks.length - 1, 1, ...newChunks);\n      this.text = this.chunks\n        .map(c => c.text)\n        .join('')\n        .toLocaleLowerCase('en-US');\n    }\n  }\n}\n\nexport class AnsiProcessor {\n  private text: string = '';\n  private lines: AnsiLine[] = [];\n\n  /**\n   * Processes a chunk of text while keeping internal state that optimizes\n   * subsequent processing that appends to the text.\n   */\n  process(text: string): AnsiLine[] {\n    if (this.text === text) {\n      return this.lines;\n    }\n\n    if (this.text && text.startsWith(this.text)) {\n      const lastLineIndex = this.lines.length > 0 ? this.lines.length - 1 : 0;\n      const lastLine = this.lines[lastLineIndex] ?? new AnsiLine();\n      const lastChunk = lastLine.lastChunk();\n\n      const newLines = this.processLines(\n        (lastChunk?.text ?? '') + text.slice(this.text.length),\n        lastChunk?.modifiers,\n        lastLine?.lineNumber,\n      );\n      lastLine.replaceLastChunk(newLines[0]?.chunks);\n\n      this.lines[lastLineIndex] = lastLine;\n      this.lines = this.lines.concat(newLines.slice(1));\n    } else {\n      this.lines = this.processLines(text);\n    }\n    this.text = text;\n\n    return this.lines;\n  }\n\n  // Split a chunk of text up into lines and process each line individually\n  private processLines = (\n    text: string,\n    modifiers: ChunkModifiers = {},\n    startingLineNumber: number = 1,\n  ): AnsiLine[] => {\n    const lines: AnsiLine[] = [];\n\n    let currentModifiers = modifiers;\n    let currentLineNumber = startingLineNumber;\n\n    let prevIndex = 0;\n    newlineRegex.lastIndex = 0;\n    for (;;) {\n      const match = newlineRegex.exec(text);\n      if (!match) {\n        const chunks = this.processText(\n          text.slice(prevIndex),\n          currentModifiers,\n        );\n        lines.push(new AnsiLine(currentLineNumber, chunks));\n        return lines;\n      }\n\n      const line = text.slice(prevIndex, match.index);\n      prevIndex = match.index + match[0].length;\n\n      const chunks = this.processText(line, currentModifiers);\n      lines.push(new AnsiLine(currentLineNumber, chunks));\n\n      // Modifiers that are active in the last chunk are carried over to the next line\n      currentModifiers =\n        chunks[chunks.length - 1].modifiers ?? currentModifiers;\n      currentLineNumber += 1;\n    }\n  };\n\n  // Processing of a one individual text chunk\n  private processText = (\n    fullText: string,\n    modifiers: ChunkModifiers,\n  ): AnsiChunk[] => {\n    const chunks: AnsiChunk[] = [];\n\n    let currentModifiers = modifiers;\n\n    let prevIndex = 0;\n    ansiRegex.lastIndex = 0;\n    for (;;) {\n      const match = ansiRegex.exec(fullText);\n      if (!match) {\n        chunks.push({\n          text: fullText.slice(prevIndex),\n          modifiers: currentModifiers,\n        });\n        return chunks;\n      }\n\n      const text = fullText.slice(prevIndex, match.index);\n      chunks.push({ text, modifiers: currentModifiers });\n\n      // For every escape code that we encounter we keep track of where the\n      // next chunk of text starts, and what modifiers it has\n      prevIndex = match.index + match[0].length;\n      currentModifiers = this.processCode(match[0], currentModifiers);\n    }\n  };\n\n  private processCode = (\n    code: string,\n    modifiers: ChunkModifiers,\n  ): ChunkModifiers => {\n    return codeModifiers[code]?.(modifiers) ?? modifiers;\n  };\n}\n"],"names":["chunks"],"mappings":"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"}