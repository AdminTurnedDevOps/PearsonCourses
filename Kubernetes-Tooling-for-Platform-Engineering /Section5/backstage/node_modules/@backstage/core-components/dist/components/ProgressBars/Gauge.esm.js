import { makeStyles, useTheme } from '@material-ui/core/styles';
import { Circle } from 'rc-progress';
import React__default, { useState, useEffect } from 'react';
import Box from '@material-ui/core/Box';
import classNames from 'classnames';

const useStyles = makeStyles(
  (theme) => ({
    root: {
      position: "relative",
      lineHeight: 0
    },
    overlay: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -60%)",
      fontSize: theme.typography.pxToRem(45),
      fontWeight: theme.typography.fontWeightBold,
      color: theme.palette.textContrast
    },
    overlaySmall: {
      fontSize: theme.typography.pxToRem(25)
    },
    description: {
      fontSize: "100%",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      position: "absolute",
      wordBreak: "break-all",
      display: "inline-block"
    },
    circle: {
      width: "80%",
      transform: "translate(10%, 0)"
    },
    colorUnknown: {}
  }),
  { name: "BackstageGauge" }
);
const defaultGaugeProps = {
  fractional: true,
  inverse: false,
  unit: "%",
  max: 100,
  relativeToMax: false
};
const getProgressColor = ({
  palette,
  value,
  inverse,
  max
}) => {
  if (isNaN(value)) {
    return "#ddd";
  }
  const actualMax = max ? max : defaultGaugeProps.max;
  const actualValue = inverse ? actualMax - value : value;
  if (actualValue < actualMax / 3) {
    return palette.status.error;
  } else if (actualValue < actualMax * (2 / 3)) {
    return palette.status.warning;
  }
  return palette.status.ok;
};
function Gauge(props) {
  const [hoverRef, setHoverRef] = useState(null);
  const { getColor = getProgressColor, size = "normal" } = props;
  const classes = useStyles(props);
  const { palette } = useTheme();
  const {
    value,
    fractional,
    inverse,
    unit,
    max,
    description,
    relativeToMax,
    decimalDigits
  } = {
    ...defaultGaugeProps,
    ...props
  };
  let asPercentage;
  if (relativeToMax) {
    asPercentage = value / max * 100;
  } else {
    asPercentage = fractional ? Math.round(value * max) : value;
  }
  let asActual;
  if (relativeToMax) {
    asActual = value;
  } else {
    asActual = max !== 100 ? Math.round(value) : asPercentage;
  }
  const asDisplay = decimalDigits === void 0 ? asActual.toString() : asActual.toFixed(decimalDigits);
  const [isHovering, setIsHovering] = useState(false);
  useEffect(() => {
    const node = hoverRef;
    const handleMouseOver = () => setIsHovering(true);
    const handleMouseOut = () => setIsHovering(false);
    if (node && description) {
      node.addEventListener("mouseenter", handleMouseOver);
      node.addEventListener("mouseleave", handleMouseOut);
      return () => {
        node.removeEventListener("mouseenter", handleMouseOver);
        node.removeEventListener("mouseleave", handleMouseOut);
      };
    }
    return () => {
      setIsHovering(false);
    };
  }, [description, hoverRef]);
  return /* @__PURE__ */ React__default.createElement(Box, { ...{ ref: setHoverRef }, className: classes.root }, /* @__PURE__ */ React__default.createElement(
    Circle,
    {
      strokeLinecap: "butt",
      percent: asPercentage,
      strokeWidth: 12,
      trailWidth: 12,
      strokeColor: getColor({
        palette,
        value: asPercentage,
        inverse,
        max: relativeToMax ? 100 : max
      }),
      className: classes.circle
    }
  ), description && isHovering ? /* @__PURE__ */ React__default.createElement(Box, { className: classes.description }, description) : /* @__PURE__ */ React__default.createElement(
    Box,
    {
      className: classNames(classes.overlay, {
        [classes.overlaySmall]: size === "small"
      })
    },
    isNaN(value) ? "N/A" : `${asDisplay}${unit}`
  ));
}

export { Gauge, getProgressColor };
//# sourceMappingURL=Gauge.esm.js.map
