import ansiRegexMaker from 'ansi-regex';

const ansiRegex = ansiRegexMaker();
const newlineRegex = /\n\r?/g;
const codeModifiers = Object.fromEntries(
  Object.entries({
    1: (m) => ({ ...m, bold: true }),
    3: (m) => ({ ...m, italic: true }),
    4: (m) => ({ ...m, underline: true }),
    22: ({ bold: _, ...m }) => m,
    23: ({ italic: _, ...m }) => m,
    24: ({ underline: _, ...m }) => m,
    30: (m) => ({ ...m, foreground: "black" }),
    31: (m) => ({ ...m, foreground: "red" }),
    32: (m) => ({ ...m, foreground: "green" }),
    33: (m) => ({ ...m, foreground: "yellow" }),
    34: (m) => ({ ...m, foreground: "blue" }),
    35: (m) => ({ ...m, foreground: "magenta" }),
    36: (m) => ({ ...m, foreground: "cyan" }),
    37: (m) => ({ ...m, foreground: "white" }),
    39: ({ foreground: _, ...m }) => m,
    90: (m) => ({ ...m, foreground: "grey" }),
    40: (m) => ({ ...m, background: "black" }),
    41: (m) => ({ ...m, background: "red" }),
    42: (m) => ({ ...m, background: "green" }),
    43: (m) => ({ ...m, background: "yellow" }),
    44: (m) => ({ ...m, background: "blue" }),
    45: (m) => ({ ...m, background: "magenta" }),
    46: (m) => ({ ...m, background: "cyan" }),
    47: (m) => ({ ...m, background: "white" }),
    49: ({ background: _, ...m }) => m
  }).map(
    ([code, modifier]) => [`\x1B[${code}m`, modifier]
  )
);
class AnsiLine {
  constructor(lineNumber = 1, chunks = []) {
    this.lineNumber = lineNumber;
    this.chunks = chunks;
    this.text = chunks.map((c) => c.text).join("").toLocaleLowerCase("en-US");
  }
  text;
  lastChunk() {
    return this.chunks[this.chunks.length - 1];
  }
  replaceLastChunk(newChunks) {
    if (newChunks) {
      this.chunks.splice(this.chunks.length - 1, 1, ...newChunks);
      this.text = this.chunks.map((c) => c.text).join("").toLocaleLowerCase("en-US");
    }
  }
}
class AnsiProcessor {
  text = "";
  lines = [];
  /**
   * Processes a chunk of text while keeping internal state that optimizes
   * subsequent processing that appends to the text.
   */
  process(text) {
    if (this.text === text) {
      return this.lines;
    }
    if (this.text && text.startsWith(this.text)) {
      const lastLineIndex = this.lines.length > 0 ? this.lines.length - 1 : 0;
      const lastLine = this.lines[lastLineIndex] ?? new AnsiLine();
      const lastChunk = lastLine.lastChunk();
      const newLines = this.processLines(
        (lastChunk?.text ?? "") + text.slice(this.text.length),
        lastChunk?.modifiers,
        lastLine?.lineNumber
      );
      lastLine.replaceLastChunk(newLines[0]?.chunks);
      this.lines[lastLineIndex] = lastLine;
      this.lines = this.lines.concat(newLines.slice(1));
    } else {
      this.lines = this.processLines(text);
    }
    this.text = text;
    return this.lines;
  }
  // Split a chunk of text up into lines and process each line individually
  processLines = (text, modifiers = {}, startingLineNumber = 1) => {
    const lines = [];
    let currentModifiers = modifiers;
    let currentLineNumber = startingLineNumber;
    let prevIndex = 0;
    newlineRegex.lastIndex = 0;
    for (; ; ) {
      const match = newlineRegex.exec(text);
      if (!match) {
        const chunks2 = this.processText(
          text.slice(prevIndex),
          currentModifiers
        );
        lines.push(new AnsiLine(currentLineNumber, chunks2));
        return lines;
      }
      const line = text.slice(prevIndex, match.index);
      prevIndex = match.index + match[0].length;
      const chunks = this.processText(line, currentModifiers);
      lines.push(new AnsiLine(currentLineNumber, chunks));
      currentModifiers = chunks[chunks.length - 1].modifiers ?? currentModifiers;
      currentLineNumber += 1;
    }
  };
  // Processing of a one individual text chunk
  processText = (fullText, modifiers) => {
    const chunks = [];
    let currentModifiers = modifiers;
    let prevIndex = 0;
    ansiRegex.lastIndex = 0;
    for (; ; ) {
      const match = ansiRegex.exec(fullText);
      if (!match) {
        chunks.push({
          text: fullText.slice(prevIndex),
          modifiers: currentModifiers
        });
        return chunks;
      }
      const text = fullText.slice(prevIndex, match.index);
      chunks.push({ text, modifiers: currentModifiers });
      prevIndex = match.index + match[0].length;
      currentModifiers = this.processCode(match[0], currentModifiers);
    }
  };
  processCode = (code, modifiers) => {
    return codeModifiers[code]?.(modifiers) ?? modifiers;
  };
}

export { AnsiLine, AnsiProcessor };
//# sourceMappingURL=AnsiProcessor.esm.js.map
