import { useAnalytics, useElementFilter } from '@backstage/core-plugin-api';
import Badge from '@material-ui/core/Badge';
import Box from '@material-ui/core/Box';
import { styled, makeStyles } from '@material-ui/core/styles';
import TextField from '@material-ui/core/TextField';
import Typography from '@material-ui/core/Typography';
import useMediaQuery from '@material-ui/core/useMediaQuery';
import ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';
import ArrowDropUpIcon from '@material-ui/icons/ArrowDropUp';
import ArrowRightIcon from '@material-ui/icons/ArrowRight';
import Search from '@material-ui/icons/Search';
import classNames from 'classnames';
import React__default, { forwardRef, useContext, useCallback, useMemo, useState } from 'react';
import { useLocation, useResolvedPath, Link, resolvePath } from 'react-router-dom';
import { SidebarConfigContext, SidebarItemWithSubmenuContext } from './config.esm.js';
import DoubleArrowLeft from './icons/DoubleArrowLeft.esm.js';
import DoubleArrowRight from './icons/DoubleArrowRight.esm.js';
import { useSidebarOpenState } from './SidebarOpenStateContext.esm.js';
import { SidebarSubmenu } from './SidebarSubmenu.esm.js';
import { isLocationMatch } from './utils.esm.js';
import Button from '@material-ui/core/Button';

const makeSidebarStyles = (sidebarConfig) => makeStyles(
  (theme) => ({
    root: {
      color: theme.palette.navigation.color,
      display: "flex",
      flexFlow: "row nowrap",
      alignItems: "center",
      height: 48,
      cursor: "pointer"
    },
    buttonItem: {
      background: "none",
      border: "none",
      width: "100%",
      margin: 0,
      padding: 0,
      textAlign: "inherit",
      font: "inherit",
      textTransform: "none"
    },
    closed: {
      width: sidebarConfig.drawerWidthClosed,
      justifyContent: "center"
    },
    open: {
      [theme.breakpoints.up("sm")]: {
        width: sidebarConfig.drawerWidthOpen
      }
    },
    highlightable: {
      "&:hover": {
        background: theme.palette.navigation.navItem?.hoverBackground ?? "#404040"
      }
    },
    highlighted: {
      background: theme.palette.navigation.navItem?.hoverBackground ?? "#404040"
    },
    label: {
      // XXX (@koroeskohr): I can't seem to achieve the desired font-weight from the designs
      fontWeight: "bold",
      whiteSpace: "nowrap",
      lineHeight: "auto",
      flex: "3 1 auto",
      width: "110px",
      overflow: "hidden",
      "text-overflow": "ellipsis"
    },
    iconContainer: {
      boxSizing: "border-box",
      height: "100%",
      width: sidebarConfig.iconContainerWidth,
      marginRight: -theme.spacing(2),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      lineHeight: "0"
    },
    searchRoot: {
      marginBottom: 12
    },
    searchField: {
      color: "#b5b5b5",
      fontWeight: theme.typography.fontWeightBold,
      fontSize: theme.typography.fontSize
    },
    searchFieldHTMLInput: {
      padding: theme.spacing(2, 0, 2)
    },
    searchContainer: {
      width: sidebarConfig.drawerWidthOpen - sidebarConfig.iconContainerWidth
    },
    secondaryAction: {
      width: theme.spacing(6),
      textAlign: "center",
      marginRight: theme.spacing(1)
    },
    closedItemIcon: {
      width: "100%",
      justifyContent: "center"
    },
    submenuArrow: {
      display: "flex"
    },
    expandButton: {
      background: "none",
      border: "none",
      color: theme.palette.navigation.color,
      width: "100%",
      cursor: "pointer",
      position: "relative",
      height: 48
    },
    arrows: {
      position: "absolute",
      right: 10
    },
    selected: {
      "&$root": {
        borderLeft: `solid ${sidebarConfig.selectedIndicatorWidth}px ${theme.palette.navigation.indicator}`,
        color: theme.palette.navigation.selectedColor
      },
      "&$closed": {
        width: sidebarConfig.drawerWidthClosed
      },
      "& $closedItemIcon": {
        paddingRight: sidebarConfig.selectedIndicatorWidth
      },
      "& $iconContainer": {
        marginLeft: -sidebarConfig.selectedIndicatorWidth
      }
    }
  }),
  { name: "BackstageSidebarItem" }
);
function useMemoStyles(sidebarConfig) {
  const useStyles = useMemo(
    () => makeSidebarStyles(sidebarConfig),
    [sidebarConfig]
  );
  return useStyles();
}
const useLocationMatch = (submenu, location) => useElementFilter(
  submenu.props.children,
  (elements) => {
    let active = false;
    elements.getElements().forEach(
      ({
        props: { to, dropdownItems }
      }) => {
        if (!active) {
          if (dropdownItems?.length) {
            dropdownItems.forEach(
              ({ to: _to }) => active = active || isLocationMatch(location, resolvePath(_to))
            );
            return;
          }
          if (to) {
            active = isLocationMatch(location, resolvePath(to));
          }
        }
      }
    );
    return active;
  },
  [location.pathname]
);
function isButtonItem(props) {
  return props.to === void 0;
}
const sidebarSubmenuType = React__default.createElement(SidebarSubmenu).type;
const WorkaroundNavLink = React__default.forwardRef(function WorkaroundNavLinkWithRef({
  to,
  end,
  style,
  className,
  activeStyle,
  caseSensitive,
  activeClassName = "active",
  "aria-current": ariaCurrentProp = "page",
  ...rest
}, ref) {
  let { pathname: locationPathname } = useLocation();
  let { pathname: toPathname } = useResolvedPath(to);
  if (!caseSensitive) {
    locationPathname = locationPathname.toLocaleLowerCase("en-US");
    toPathname = toPathname.toLocaleLowerCase("en-US");
  }
  let isActive = locationPathname === toPathname;
  if (!isActive && !end) {
    isActive = locationPathname.startsWith(`${toPathname}/`);
  }
  const ariaCurrent = isActive ? ariaCurrentProp : void 0;
  return /* @__PURE__ */ React__default.createElement(
    Link,
    {
      ...rest,
      to,
      ref,
      "aria-current": ariaCurrent,
      style: { ...style, ...isActive ? activeStyle : void 0 },
      className: classNames([
        typeof className !== "function" ? className : void 0,
        isActive ? activeClassName : void 0
      ])
    }
  );
});
const SidebarItemBase = forwardRef((props, ref) => {
  const {
    icon: Icon,
    text,
    hasNotifications = false,
    hasSubmenu = false,
    disableHighlight = false,
    onClick,
    noTrack,
    children,
    className,
    ...navLinkProps
  } = props;
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const { isOpen } = useSidebarOpenState();
  const divStyle = !isOpen && hasSubmenu ? { display: "flex", marginLeft: "20px" } : { lineHeight: "0" };
  const displayItemIcon = /* @__PURE__ */ React__default.createElement(Box, { style: divStyle }, /* @__PURE__ */ React__default.createElement(Icon, { fontSize: "small" }), !isOpen && hasSubmenu ? /* @__PURE__ */ React__default.createElement(ArrowRightIcon, { fontSize: "small" }) : /* @__PURE__ */ React__default.createElement(React__default.Fragment, null));
  const itemIcon = /* @__PURE__ */ React__default.createElement(
    Badge,
    {
      color: "secondary",
      variant: "dot",
      overlap: "circular",
      invisible: !hasNotifications,
      className: classNames({ [classes.closedItemIcon]: !isOpen })
    },
    displayItemIcon
  );
  const openContent = /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Box, { "data-testid": "login-button", className: classes.iconContainer }, itemIcon), text && /* @__PURE__ */ React__default.createElement(
    Typography,
    {
      variant: "subtitle2",
      component: "span",
      className: classes.label
    },
    text
  ), /* @__PURE__ */ React__default.createElement("div", { className: classes.secondaryAction }, children));
  const content = isOpen ? openContent : itemIcon;
  const childProps = {
    onClick,
    className: classNames(
      className,
      classes.root,
      isOpen ? classes.open : classes.closed,
      isButtonItem(props) && classes.buttonItem,
      { [classes.highlightable]: !disableHighlight }
    )
  };
  const analyticsApi = useAnalytics();
  const { pathname: to } = useResolvedPath(
    !isButtonItem(props) && props.to ? props.to : ""
  );
  const handleClick = useCallback(
    (event) => {
      if (!noTrack) {
        const action = "click";
        const subject = text ?? "Sidebar Item";
        const options = to ? { attributes: { to } } : void 0;
        analyticsApi.captureEvent(action, subject, options);
      }
      onClick?.(event);
    },
    [analyticsApi, text, to, noTrack, onClick]
  );
  if (isButtonItem(props)) {
    return /* @__PURE__ */ React__default.createElement(
      Button,
      {
        role: "button",
        "aria-label": text,
        ...childProps,
        ref,
        onClick: handleClick
      },
      content
    );
  }
  return /* @__PURE__ */ React__default.createElement(
    WorkaroundNavLink,
    {
      ...childProps,
      activeClassName: classes.selected,
      to: props.to ? props.to : "",
      ref,
      "aria-label": text ? text : props.to,
      ...navLinkProps,
      onClick: handleClick
    },
    content
  );
});
const SidebarItemWithSubmenu = ({
  children,
  ...props
}) => {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const [isHoveredOn, setIsHoveredOn] = useState(false);
  const location = useLocation();
  const isActive = useLocationMatch(children, location);
  const isSmallScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("sm")
  );
  const handleMouseEnter = () => {
    setIsHoveredOn(true);
  };
  const handleMouseLeave = () => {
    setIsHoveredOn(false);
  };
  const arrowIcon = () => {
    if (isSmallScreen) {
      return isHoveredOn ? /* @__PURE__ */ React__default.createElement(ArrowDropUpIcon, { fontSize: "small", className: classes.submenuArrow }) : /* @__PURE__ */ React__default.createElement(ArrowDropDownIcon, { fontSize: "small", className: classes.submenuArrow });
    }
    return !isHoveredOn && /* @__PURE__ */ React__default.createElement(ArrowRightIcon, { fontSize: "small", className: classes.submenuArrow });
  };
  return /* @__PURE__ */ React__default.createElement(
    SidebarItemWithSubmenuContext.Provider,
    {
      value: {
        isHoveredOn,
        setIsHoveredOn
      }
    },
    /* @__PURE__ */ React__default.createElement(
      "div",
      {
        "data-testid": "item-with-submenu",
        onMouseLeave: handleMouseLeave,
        onTouchStart: isHoveredOn ? handleMouseLeave : handleMouseEnter,
        onMouseEnter: handleMouseEnter,
        className: classNames(isHoveredOn && classes.highlighted)
      },
      /* @__PURE__ */ React__default.createElement(
        SidebarItemBase,
        {
          hasSubmenu: true,
          className: isActive ? classes.selected : "",
          ...props
        },
        arrowIcon()
      ),
      isHoveredOn && children
    )
  );
};
const SidebarItem = forwardRef((props, ref) => {
  const [submenu] = useElementFilter(
    props.children,
    (elements) => (
      // Directly comparing child.type with SidebarSubmenu will not work with in
      // combination with react-hot-loader
      //
      // https://github.com/gaearon/react-hot-loader/issues/304#issuecomment-456569720
      elements.getElements().filter((child) => child.type === sidebarSubmenuType)
    )
  );
  if (submenu) {
    return /* @__PURE__ */ React__default.createElement(SidebarItemWithSubmenu, { ...props }, submenu);
  }
  return /* @__PURE__ */ React__default.createElement(SidebarItemBase, { ...props, ref });
});
function SidebarSearchField(props) {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const [input, setInput] = useState("");
  const classes = useMemoStyles(sidebarConfig);
  const Icon = props.icon ? props.icon : Search;
  const search = () => {
    props.onSearch(input);
    setInput("");
  };
  const handleEnter = (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      search();
    }
  };
  const handleInput = (ev) => {
    setInput(ev.target.value);
  };
  const handleInputClick = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };
  const handleItemClick = (ev) => {
    search();
    ev.preventDefault();
  };
  return /* @__PURE__ */ React__default.createElement(Box, { className: classes.searchRoot }, /* @__PURE__ */ React__default.createElement(
    SidebarItem,
    {
      icon: Icon,
      to: props.to,
      onClick: handleItemClick,
      disableHighlight: true
    },
    /* @__PURE__ */ React__default.createElement(
      TextField,
      {
        placeholder: "Search",
        value: input,
        onClick: handleInputClick,
        onChange: handleInput,
        onKeyDown: handleEnter,
        className: classes.searchContainer,
        InputProps: {
          disableUnderline: true,
          className: classes.searchField
        },
        inputProps: {
          className: classes.searchFieldHTMLInput
        }
      }
    )
  ));
}
const SidebarSpace = styled("div")(
  {
    flex: 1
  },
  { name: "BackstageSidebarSpace" }
);
const SidebarSpacer = styled("div")(
  {
    height: 8
  },
  { name: "BackstageSidebarSpacer" }
);
const SidebarDivider = styled("hr")(
  ({ theme }) => ({
    height: 1,
    width: "100%",
    background: "#383838",
    border: "none",
    margin: theme.spacing(1.2, 0)
  }),
  { name: "BackstageSidebarDivider" }
);
const styledScrollbar = (theme) => ({
  overflowY: "auto",
  "&::-webkit-scrollbar": {
    backgroundColor: theme.palette.background.default,
    width: "5px",
    borderRadius: "5px"
  },
  "&::-webkit-scrollbar-thumb": {
    backgroundColor: theme.palette.text.secondary,
    borderRadius: "5px"
  }
});
const SidebarScrollWrapper = styled("div")(({ theme }) => {
  const scrollbarStyles = styledScrollbar(theme);
  return {
    flex: "0 1 auto",
    overflowX: "hidden",
    width: "100%",
    // Display at least one item in the container
    // Question: Can this be a config/theme variable - if so, which? :/
    minHeight: "48px",
    overflowY: "hidden",
    "@media (hover: none)": scrollbarStyles,
    "&:hover": scrollbarStyles
  };
});
const SidebarExpandButton = () => {
  const { sidebarConfig } = useContext(SidebarConfigContext);
  const classes = useMemoStyles(sidebarConfig);
  const { isOpen, setOpen } = useSidebarOpenState();
  const isSmallScreen = useMediaQuery(
    (theme) => theme.breakpoints.down("md"),
    { noSsr: true }
  );
  if (isSmallScreen) {
    return null;
  }
  const handleClick = () => {
    setOpen(!isOpen);
  };
  return /* @__PURE__ */ React__default.createElement(
    Button,
    {
      role: "button",
      onClick: handleClick,
      className: classes.expandButton,
      "aria-label": "Expand Sidebar",
      "data-testid": "sidebar-expand-button"
    },
    /* @__PURE__ */ React__default.createElement(Box, { className: classes.arrows }, isOpen ? /* @__PURE__ */ React__default.createElement(DoubleArrowLeft, null) : /* @__PURE__ */ React__default.createElement(DoubleArrowRight, null))
  );
};

export { SidebarDivider, SidebarExpandButton, SidebarItem, SidebarScrollWrapper, SidebarSearchField, SidebarSpace, SidebarSpacer, WorkaroundNavLink };
//# sourceMappingURL=Items.esm.js.map
