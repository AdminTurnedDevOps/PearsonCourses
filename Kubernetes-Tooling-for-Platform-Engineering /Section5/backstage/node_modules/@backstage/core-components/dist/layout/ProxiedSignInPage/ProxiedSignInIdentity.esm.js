import { ResponseError } from '@backstage/errors';
import { proxiedSessionSchema } from './types.esm.js';

const DEFAULTS = {
  // The amount of time between token refreshes, if we fail to get an actual
  // value out of the exp claim
  defaultTokenExpiryMillis: 5 * 60 * 1e3,
  // The amount of time before the actual expiry of the Backstage token, that we
  // shall start trying to get a new one
  tokenExpiryMarginMillis: 5 * 60 * 1e3
};
function tokenToExpiry(jwtToken) {
  const fallback = new Date(Date.now() + DEFAULTS.defaultTokenExpiryMillis);
  if (!jwtToken) {
    return fallback;
  }
  const [_header, rawPayload, _signature] = jwtToken.split(".");
  const payload = JSON.parse(window.atob(rawPayload));
  if (typeof payload.exp !== "number") {
    return fallback;
  }
  return new Date(payload.exp * 1e3 - DEFAULTS.tokenExpiryMarginMillis);
}
class ProxiedSignInIdentity {
  options;
  abortController;
  state;
  constructor(options) {
    this.options = options;
    this.abortController = new AbortController();
    this.state = { type: "empty" };
  }
  async start() {
    await this.getSessionAsync();
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getUserId} */
  getUserId() {
    const { backstageIdentity } = this.getSessionSync();
    const ref = backstageIdentity.identity.userEntityRef;
    const match = /^([^:/]+:)?([^:/]+\/)?([^:/]+)$/.exec(ref);
    if (!match) {
      throw new TypeError(`Invalid user entity reference "${ref}"`);
    }
    return match[3];
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getIdToken} */
  async getIdToken() {
    const session = await this.getSessionAsync();
    return session.backstageIdentity.token;
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getProfile} */
  getProfile() {
    const session = this.getSessionSync();
    return session.profile;
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getProfileInfo} */
  async getProfileInfo() {
    const session = await this.getSessionAsync();
    return session.profile;
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getBackstageIdentity} */
  async getBackstageIdentity() {
    const session = await this.getSessionAsync();
    return session.backstageIdentity.identity;
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.getCredentials} */
  async getCredentials() {
    const session = await this.getSessionAsync();
    return {
      token: session.backstageIdentity.token
    };
  }
  /** {@inheritdoc @backstage/core-plugin-api#IdentityApi.signOut} */
  async signOut() {
    this.abortController.abort();
  }
  getSessionSync() {
    if (this.state.type === "active") {
      return this.state.session;
    } else if (this.state.type === "fetching" && this.state.previous) {
      return this.state.previous;
    }
    throw new Error("No session available. Try reloading your browser page.");
  }
  async getSessionAsync() {
    if (this.state.type === "fetching") {
      return this.state.promise;
    } else if (this.state.type === "active" && /* @__PURE__ */ new Date() < this.state.expiresAt) {
      return this.state.session;
    }
    const previous = this.state.type === "active" ? this.state.session : void 0;
    const promise = this.fetchSession().then(
      (session) => {
        this.state = {
          type: "active",
          session,
          expiresAt: tokenToExpiry(session.backstageIdentity.token)
        };
        return session;
      },
      (error) => {
        this.state = {
          type: "failed",
          error
        };
        throw error;
      }
    );
    this.state = {
      type: "fetching",
      promise,
      previous
    };
    return promise;
  }
  async fetchSession() {
    const baseUrl = await this.options.discoveryApi.getBaseUrl("auth");
    const headers = typeof this.options.headers === "function" ? await this.options.headers() : this.options.headers;
    const mergedHeaders = new Headers(headers);
    mergedHeaders.set("X-Requested-With", "XMLHttpRequest");
    const response = await fetch(
      `${baseUrl}/${this.options.provider}/refresh`,
      {
        signal: this.abortController.signal,
        headers: mergedHeaders,
        credentials: "include"
      }
    );
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return proxiedSessionSchema.parse(await response.json());
  }
}

export { DEFAULTS, ProxiedSignInIdentity, tokenToExpiry };
//# sourceMappingURL=ProxiedSignInIdentity.esm.js.map
