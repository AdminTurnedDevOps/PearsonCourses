'use strict';

var Router = require('express-promise-router');
var httpProxyMiddleware = require('http-proxy-middleware');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

const safeForwardHeaders = [
  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header
  "cache-control",
  "content-language",
  "content-length",
  "content-type",
  "expires",
  "last-modified",
  "pragma",
  // host is overridden by default. if changeOrigin is configured to false,
  // we assume this is a intentional and should also be forwarded.
  "host",
  // other headers that we assume to be ok
  "accept",
  "accept-language",
  "user-agent"
];
function buildMiddleware(pathPrefix, logger, route, config, reviveConsumedRequestBodies, httpRouterService) {
  let fullConfig;
  let credentialsPolicy;
  if (typeof config === "string") {
    fullConfig = { target: config };
    credentialsPolicy = "require";
  } else {
    const { credentials, ...rest } = config;
    fullConfig = rest;
    credentialsPolicy = credentials ?? "require";
  }
  const credentialsPolicyCandidates = [
    "require",
    "forward",
    "dangerously-allow-unauthenticated"
  ];
  if (!credentialsPolicyCandidates.includes(credentialsPolicy)) {
    const valid = credentialsPolicyCandidates.map((c) => `'${c}'`).join(", ");
    throw new Error(
      `Unknown credentials policy '${credentialsPolicy}' for proxy route '${route}'; expected one of ${valid}`
    );
  }
  if (credentialsPolicy === "dangerously-allow-unauthenticated") {
    httpRouterService?.addAuthPolicy({
      path: route,
      allow: "unauthenticated"
    });
  }
  const targetType = typeof fullConfig.target;
  if (targetType !== "string") {
    throw new Error(
      `Proxy target for route "${route}" must be a string, but is of type ${targetType}`
    );
  }
  try {
    new URL(fullConfig.target);
  } catch {
    throw new Error(
      `Proxy target is not a valid URL: ${fullConfig.target ?? ""}`
    );
  }
  if (fullConfig.pathRewrite === void 0) {
    let routeWithSlash = route.endsWith("/") ? route : `${route}/`;
    if (!pathPrefix.endsWith("/") && !routeWithSlash.startsWith("/")) {
      routeWithSlash = `/${routeWithSlash}`;
    } else if (pathPrefix.endsWith("/") && routeWithSlash.startsWith("/")) {
      routeWithSlash = routeWithSlash.substring(1);
    }
    fullConfig.pathRewrite = {
      [`^${pathPrefix}${routeWithSlash}?`]: "/"
    };
  }
  if (fullConfig.changeOrigin === void 0) {
    fullConfig.changeOrigin = true;
  }
  fullConfig.logProvider = () => logger;
  fullConfig.logLevel = "debug";
  const requestHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all headers that are set by the proxy
      ...fullConfig.headers && Object.keys(fullConfig.headers) || [],
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  if (credentialsPolicy === "forward") {
    requestHeaderAllowList.add("authorization");
  }
  const filter = (_pathname, req) => {
    const headerNames = Object.keys(req.headers);
    headerNames.forEach((h) => {
      if (!requestHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete req.headers[h];
      }
    });
    return fullConfig?.allowedMethods?.includes(req.method) ?? true;
  };
  filter.toString = () => route;
  const responseHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  fullConfig.onProxyRes = (proxyRes) => {
    const headerNames = Object.keys(proxyRes.headers);
    headerNames.forEach((h) => {
      if (!responseHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete proxyRes.headers[h];
      }
    });
  };
  if (reviveConsumedRequestBodies) {
    fullConfig.onProxyReq = httpProxyMiddleware.fixRequestBody;
  }
  return httpProxyMiddleware.createProxyMiddleware(filter, fullConfig);
}
function readProxyConfig(config, logger) {
  const endpoints = config.getOptionalConfig("proxy.endpoints")?.get();
  if (endpoints) {
    return endpoints;
  }
  const root = config.getOptionalConfig("proxy")?.get();
  if (!root) {
    return {};
  }
  const rootEndpoints = Object.fromEntries(
    Object.entries(root).filter(([key]) => key.startsWith("/"))
  );
  if (Object.keys(rootEndpoints).length === 0) {
    return {};
  }
  logger.warn(
    "Configuring proxy endpoints in the root 'proxy' configuration is deprecated. Move this configuration to 'proxy.endpoints' instead."
  );
  return rootEndpoints;
}
async function createRouter(options) {
  return createRouterInternal(options);
}
async function createRouterInternal(options) {
  const router = Router__default.default();
  let currentRouter = Router__default.default();
  const skipInvalidProxies = options.skipInvalidProxies ?? options.config.getOptionalBoolean("proxy.skipInvalidProxies") ?? false;
  const reviveConsumedRequestBodies = options.reviveConsumedRequestBodies ?? options.config.getOptionalBoolean("proxy.reviveConsumedRequestBodies") ?? false;
  const proxyOptions = {
    skipInvalidProxies,
    reviveConsumedRequestBodies,
    logger: options.logger
  };
  const externalUrl = await options.discovery.getExternalBaseUrl("proxy");
  const { pathname: pathPrefix } = new URL(externalUrl);
  const proxyConfig = readProxyConfig(options.config, options.logger);
  configureMiddlewares(
    proxyOptions,
    currentRouter,
    pathPrefix,
    proxyConfig,
    options.httpRouterService
  );
  router.use((...args) => currentRouter(...args));
  if (options.config.subscribe) {
    let currentKey = JSON.stringify(proxyConfig);
    options.config.subscribe(() => {
      const newProxyConfig = readProxyConfig(options.config, options.logger);
      const newKey = JSON.stringify(newProxyConfig);
      if (currentKey !== newKey) {
        currentKey = newKey;
        currentRouter = Router__default.default();
        configureMiddlewares(
          proxyOptions,
          currentRouter,
          pathPrefix,
          newProxyConfig,
          options.httpRouterService
        );
      }
    });
  }
  options.httpRouterService?.use(router);
  return router;
}
function configureMiddlewares(options, router, pathPrefix, proxyConfig, httpRouterService) {
  Object.entries(proxyConfig).forEach(([route, proxyRouteConfig]) => {
    try {
      router.use(
        route,
        buildMiddleware(
          pathPrefix,
          options.logger,
          route,
          proxyRouteConfig,
          options.reviveConsumedRequestBodies,
          httpRouterService
        )
      );
    } catch (e) {
      if (options.skipInvalidProxies) {
        options.logger.warn(`skipped configuring ${route} due to ${e.message}`);
      } else {
        throw e;
      }
    }
  });
}

exports.buildMiddleware = buildMiddleware;
exports.createRouter = createRouter;
exports.createRouterInternal = createRouterInternal;
//# sourceMappingURL=router.cjs.js.map
