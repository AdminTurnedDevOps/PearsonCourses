/// <reference types="react" />
import { CatalogApi } from '@backstage/catalog-client';
export { CATALOG_FILTER_EXISTS, CatalogApi } from '@backstage/catalog-client';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiRef, IconComponent } from '@backstage/core-plugin-api';
import * as _backstage_catalog_model from '@backstage/catalog-model';
import { Entity, CompoundEntityRef } from '@backstage/catalog-model';
import { Observable } from '@backstage/types';
import React__default, { PropsWithChildren, ReactNode, ComponentProps } from 'react';
import { LinkProps, InfoCardVariants, TableColumn, TableOptions } from '@backstage/core-components';
import IconButton from '@material-ui/core/IconButton';
import { TextFieldProps } from '@material-ui/core/TextField';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';
import { scmIntegrationsApiRef } from '@backstage/integration-react';

/**
 * The API reference for the {@link @backstage/catalog-client#CatalogApi}.
 * @public
 */
declare const catalogApiRef: _backstage_core_plugin_api.ApiRef<CatalogApi>;

/**
 * An API that handles how to represent entities in the interface.
 *
 * @public
 */
declare const entityPresentationApiRef: ApiRef<EntityPresentationApi>;
/**
 * The visual presentation of an entity reference at some point in time.
 *
 * @public
 */
interface EntityRefPresentationSnapshot {
    /**
     * The ref to the entity that this snapshot represents.
     *
     * @remarks
     *
     * Note that when the input data was broken or had missing vital pieces of
     * information, this string may contain placeholders such as "unknown". You
     * can therefore not necessarily assume that the ref is completely valid and
     * usable for example for forming a clickable link to the entity.
     */
    entityRef: string;
    /**
     * A string that can be used as a plain representation of the entity, for
     * example in a header or a link.
     *
     * @remarks
     *
     * The title may be short and not contain all of the information that the
     * entity holds. When rendering the primary title, you may also want to
     * make sure to add more contextual information nearby such as the icon or
     * secondary title, since the primary could for example just be the
     * `metadata.name` of the entity which might be ambiguous to the reader.
     */
    primaryTitle: string;
    /**
     * Optionally, some additional textual information about the entity, to be
     * used as a clarification on top of the primary title.
     *
     * @remarks
     *
     * This text can for example be rendered in a tooltip or be used as a
     * subtitle. It may not be sufficient to display on its own; it should
     * typically be used in conjunction with the primary title. It can contain
     * such information as the entity ref and/or a `spec.type` etc.
     */
    secondaryTitle?: string;
    /**
     * Optionally, an icon that represents the kind/type of entity.
     *
     * @remarks
     *
     * This icon should ideally be easily recognizable as the kind of entity, and
     * be used consistently throughout the Backstage interface. It can be rendered
     * both in larger formats such as in a header, or in smaller formats such as
     * inline with regular text, so bear in mind that the legibility should be
     * high in both cases.
     *
     * A value of `false` here indicates the desire to not have an icon present
     * for the given implementation. A value of `undefined` leaves it at the
     * discretion of the display layer to choose what to do (such as for example
     * showing a fallback icon).
     */
    Icon?: IconComponent | undefined | false;
}
/**
 * The visual presentation of an entity reference.
 *
 * @public
 */
interface EntityRefPresentation {
    /**
     * The representation that's suitable to use for this entity right now.
     */
    snapshot: EntityRefPresentationSnapshot;
    /**
     * Some presentation implementations support emitting updated snapshots over
     * time, for example after retrieving additional data from the catalog or
     * elsewhere.
     */
    update$?: Observable<EntityRefPresentationSnapshot>;
    /**
     * A promise that resolves to a usable entity presentation.
     */
    promise: Promise<EntityRefPresentationSnapshot>;
}
/**
 * An API that decides how to visually represent entities in the interface.
 *
 * @remarks
 *
 * Most consumers will want to use the {@link useEntityPresentation} hook
 * instead of this interface directly.
 *
 * @public
 */
interface EntityPresentationApi {
    /**
     * Fetches the presentation for an entity.
     *
     * @param entityOrRef - Either an entity, or a string ref to it. If you pass
     *   in an entity, it is assumed that it is not a partial one - i.e. only pass
     *   in an entity if you know that it was fetched in such a way that it
     *   contains all of the fields that the representation renderer needs.
     * @param context - Contextual information that may affect the presentation.
     */
    forEntity(entityOrRef: Entity | string, context?: {
        defaultKind?: string;
        defaultNamespace?: string;
    }): EntityRefPresentation;
}

/**
 * This returns the default representation of an entity.
 *
 * @public
 * @param entityOrRef - Either an entity, or a ref to it.
 * @param context - Contextual information that may affect the presentation.
 */
declare function defaultEntityPresentation(entityOrRef: Entity | CompoundEntityRef | string, context?: {
    defaultKind?: string;
    defaultNamespace?: string;
}): EntityRefPresentationSnapshot;

/**
 * Returns information about how to represent an entity in the interface.
 *
 * @public
 * @param entityOrRef - The entity to represent, or an entity ref to it. If you
 *   pass in an entity, it is assumed that it is NOT a partial one - i.e. only
 *   pass in an entity if you know that it was fetched in such a way that it
 *   contains all of the fields that the representation renderer needs.
 * @param context - Optional context that control details of the presentation.
 * @returns A snapshot of the entity presentation, which may change over time
 */
declare function useEntityPresentation(entityOrRef: Entity | CompoundEntityRef | string, context?: {
    defaultKind?: string;
    defaultNamespace?: string;
}): EntityRefPresentationSnapshot;

/**
 * An API to store starred entities
 *
 * @public
 */
declare const starredEntitiesApiRef: ApiRef<StarredEntitiesApi>;
/**
 * An API to store and retrieve starred entities
 *
 * @public
 */
interface StarredEntitiesApi {
    /**
     * Toggle the star state of the entity
     *
     * @param entityRef - an entity reference to toggle
     */
    toggleStarred(entityRef: string): Promise<void>;
    /**
     * Observe the set of starred entity references.
     */
    starredEntitie$(): Observable<Set<string>>;
}

/**
 * An in-memory mock implementation of the StarredEntitiesApi.
 *
 * @public
 */
declare class MockStarredEntitiesApi implements StarredEntitiesApi {
    private readonly starredEntities;
    private readonly subscribers;
    private readonly observable;
    toggleStarred(entityRef: string): Promise<void>;
    starredEntitie$(): Observable<Set<string>>;
}

/** @public */
declare const CatalogFilterLayout: {
    (props: {
        children: React__default.ReactNode;
    }): React__default.JSX.Element;
    Filters: (props: {
        children: React__default.ReactNode;
        options?: {
            drawerBreakpoint?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | number;
            drawerAnchor?: 'left' | 'right' | 'top' | 'bottom';
        };
    }) => React__default.JSX.Element;
    Content: (props: {
        children: React__default.ReactNode;
    }) => React__default.JSX.Element;
};

/** @public */
type EntityFilter = {
    /**
     * Get filters to add to the catalog-backend request. These are a dot-delimited field with
     * value(s) to accept, extracted on the backend by parseEntityFilterParams. For example:
     *   `{ field: 'kind', values: ['component'] }`
     *   `{ field: 'metadata.name', values: ['component-1', 'component-2'] }`
     */
    getCatalogFilters?: () => Record<string, string | symbol | (string | symbol)[]>;
    /**
     * Filter entities on the frontend after a catalog-backend request. This function will be called
     * with each backend-resolved entity. This is used when frontend information is required for
     * filtering, such as a user's starred entities.
     */
    filterEntity?: (entity: Entity) => boolean;
    /**
     * Serialize the filter value to a string for query params. The UI component responsible for
     * handling this filter should retrieve this from useEntityList.queryParameters. The
     * value restored should be in the precedence: queryParameters `>` initialValue prop `>` default.
     */
    toQueryValue?: () => string | string[];
};
/** @public */
type UserListFilterKind = 'owned' | 'starred' | 'all';
/** @public */
type EntityListPagination = boolean | {
    mode?: 'cursor';
    limit?: number;
} | {
    mode: 'offset';
    limit?: number;
    offset?: number;
};

/** @public */
type CatalogReactEntityOwnerPickerClassKey = 'input';
/** @public */
type FixedWidthFormControlLabelClassKey = 'label' | 'root';
/**
 * @public
 */
type EntityOwnerPickerProps = {
    mode?: 'owners-only' | 'all';
};
/** @public */
declare const EntityOwnerPicker: (props?: EntityOwnerPickerProps) => React__default.JSX.Element | null;

/**
 * Props for default filters.
 *
 * @public
 */
type DefaultFiltersProps = {
    initialKind?: string;
    initiallySelectedFilter?: UserListFilterKind;
    ownerPickerMode?: EntityOwnerPickerProps['mode'];
    initiallySelectedNamespaces?: string[];
};
/** @public */
declare const DefaultFilters: (props: DefaultFiltersProps) => React__default.JSX.Element;

/**
 * Props for {@link EntityKindPicker}.
 *
 * @public
 */
interface EntityKindPickerProps {
    /**
     * Entity kinds to show in the dropdown; by default all kinds are fetched from the catalog and
     * displayed.
     */
    allowedKinds?: string[];
    initialFilter?: string;
    hidden?: boolean;
}
/** @public */
declare const EntityKindPicker: (props: EntityKindPickerProps) => React__default.JSX.Element | null;

/** @public */
type CatalogReactEntityLifecyclePickerClassKey = 'input';
/** @public */
declare const EntityLifecyclePicker: (props: {
    initialFilter?: string[];
}) => React__default.JSX.Element;

/**
 * The available style class keys for {@link EntityDisplayName}, under the name
 * "CatalogReactEntityDisplayName".
 *
 * @public
 */
type CatalogReactEntityDisplayNameClassKey = 'root' | 'icon';
/**
 * Props for {@link EntityDisplayName}.
 *
 * @public
 */
type EntityDisplayNameProps = {
    entityRef: Entity | CompoundEntityRef | string;
    hideIcon?: boolean;
    disableTooltip?: boolean;
    defaultKind?: string;
    defaultNamespace?: string;
};
/**
 * Shows a nice representation of a reference to an entity.
 *
 * @public
 */
declare const EntityDisplayName: (props: EntityDisplayNameProps) => JSX.Element;

/**
 * Props for {@link EntityRefLink}.
 *
 * @public
 */
type EntityRefLinkProps = {
    entityRef: Entity | CompoundEntityRef | string;
    defaultKind?: string;
    defaultNamespace?: string;
    /** @deprecated This option should no longer be used; presentation is requested through the {@link entityPresentationApiRef} instead */
    title?: string;
    children?: React__default.ReactNode;
    hideIcon?: boolean;
    disableTooltip?: boolean;
} & Omit<LinkProps, 'to'>;
/**
 * Shows a clickable link to an entity.
 *
 * @public
 */
declare const EntityRefLink: (props: EntityRefLinkProps) => JSX.Element;

/**
 * Props for {@link EntityRefLink}.
 *
 * @public
 */
type EntityRefLinksProps<TRef extends string | CompoundEntityRef | Entity> = {
    defaultKind?: string;
    entityRefs: TRef[];
    hideIcons?: boolean;
    /** @deprecated This option is no longer used; presentation is handled by entityPresentationApiRef instead */
    fetchEntities?: boolean;
    /** @deprecated This option is no longer used; presentation is handled by entityPresentationApiRef instead */
    getTitle?(entity: TRef): string | undefined;
} & Omit<LinkProps, 'to'>;
/**
 * Shows a list of clickable links to entities.
 *
 * @public
 */
declare function EntityRefLinks<TRef extends string | CompoundEntityRef | Entity>(props: EntityRefLinksProps<TRef>): React__default.JSX.Element;

/**
 * @param defaultNamespace - if set to false then namespace is never omitted,
 * if set to string which matches namespace of entity then omitted
 *
 * @public
 **/
declare function humanizeEntityRef(entityRef: Entity | CompoundEntityRef, opts?: {
    defaultKind?: string;
    defaultNamespace?: string | false;
}): string;

/**
 * Properties for an entity popover on hover of a component.
 *
 * @public
 */
type EntityPeekAheadPopoverProps = PropsWithChildren<{
    entityRef: string;
    delayTime?: number;
}>;
/**
 * Shows an entity popover on hover of a component.
 *
 * @public
 */
declare const EntityPeekAheadPopover: (props: EntityPeekAheadPopoverProps) => React__default.JSX.Element;

/** @public */
type CatalogReactEntitySearchBarClassKey = 'searchToolbar' | 'input';
/**
 * Renders search bar for filtering the entity list.
 * @public
 */
declare const EntitySearchBar: () => React__default.JSX.Element;

/**
 * Props for {@link EntityTable}.
 *
 * @public
 */
interface EntityTableProps<T extends Entity> {
    title: string;
    variant?: InfoCardVariants;
    entities: T[];
    emptyContent?: ReactNode;
    columns: TableColumn<T>[];
    tableOptions?: TableOptions;
}
/**
 * A general entity table component, that can be used for composing more
 * specific entity tables.
 *
 * @public
 */
declare const EntityTable: {
    <T extends Entity>(props: EntityTableProps<T>): React__default.JSX.Element;
    columns: Readonly<{
        createEntityRefColumn<T_1 extends Entity>(options: {
            defaultKind?: string | undefined;
        }): TableColumn<T_1>;
        createEntityRelationColumn<T_2 extends Entity>(options: {
            title: string;
            relation: string;
            defaultKind?: string | undefined;
            filter?: {
                kind: string;
            } | undefined;
        }): TableColumn<T_2>;
        createOwnerColumn<T_3 extends Entity>(): TableColumn<T_3>;
        createDomainColumn<T_4 extends Entity>(): TableColumn<T_4>;
        createSystemColumn<T_5 extends Entity>(): TableColumn<T_5>;
        createMetadataDescriptionColumn<T_6 extends Entity>(): TableColumn<T_6>;
        createSpecLifecycleColumn<T_7 extends Entity>(): TableColumn<T_7>;
        createSpecTypeColumn<T_8 extends Entity>(): TableColumn<T_8>;
    }>;
    systemEntityColumns: TableColumn<_backstage_catalog_model.SystemEntity>[];
    componentEntityColumns: TableColumn<_backstage_catalog_model.ComponentEntity>[];
};

/** @public */
declare const columnFactories: Readonly<{
    createEntityRefColumn<T extends Entity>(options: {
        defaultKind?: string;
    }): TableColumn<T>;
    createEntityRelationColumn<T_1 extends Entity>(options: {
        title: string;
        relation: string;
        defaultKind?: string;
        filter?: {
            kind: string;
        };
    }): TableColumn<T_1>;
    createOwnerColumn<T_2 extends Entity>(): TableColumn<T_2>;
    createDomainColumn<T_3 extends Entity>(): TableColumn<T_3>;
    createSystemColumn<T_4 extends Entity>(): TableColumn<T_4>;
    createMetadataDescriptionColumn<T_5 extends Entity>(): TableColumn<T_5>;
    createSpecLifecycleColumn<T_6 extends Entity>(): TableColumn<T_6>;
    createSpecTypeColumn<T_7 extends Entity>(): TableColumn<T_7>;
}>;

/** @public */
type CatalogReactEntityTagPickerClassKey = 'input';
/** @public */
type EntityTagPickerProps = {
    showCounts?: boolean;
};
/** @public */
declare const EntityTagPicker: (props: EntityTagPickerProps) => React__default.JSX.Element;

/**
 * Props for {@link EntityTypePicker}.
 *
 * @public
 */
interface EntityTypePickerProps {
    initialFilter?: string;
    hidden?: boolean;
}
/** @public */
declare const EntityTypePicker: (props: EntityTypePickerProps) => React__default.JSX.Element | null;

/** @public */
type FavoriteEntityProps = ComponentProps<typeof IconButton> & {
    entity: Entity;
};
/**
 * IconButton for showing if a current entity is starred and adding/removing it from the favorite entities
 * @param props - MaterialUI IconButton props extended by required `entity` prop
 * @public
 */
declare const FavoriteEntity: (props: FavoriteEntityProps) => React__default.JSX.Element;

/**
 * A dialog that lets users inspect the low level details of their entities.
 *
 * @public
 */
declare function InspectEntityDialog(props: {
    open: boolean;
    entity: Entity;
    onClose: () => void;
}): React__default.JSX.Element | null;

/** @public */
type UnregisterEntityDialogProps = {
    open: boolean;
    onConfirm: () => any;
    onClose: () => any;
    entity: Entity;
};
/** @public */
declare const UnregisterEntityDialog: (props: UnregisterEntityDialogProps) => React__default.JSX.Element;

/** @public */
type CatalogReactUserListPickerClassKey = 'root' | 'title' | 'listIcon' | 'menuItem' | 'groupWrapper';
/** @public */
type UserListPickerProps = {
    initialFilter?: UserListFilterKind;
    availableFilters?: UserListFilterKind[];
};
/** @public */
declare const UserListPicker: (props: UserListPickerProps) => React__default.JSX.Element;

/** @public */
type CatalogReactEntityProcessingStatusPickerClassKey = 'input';
/** @public */
declare const EntityProcessingStatusPicker: () => React__default.JSX.Element;

/** @public */
type CatalogReactEntityNamespacePickerClassKey = 'input';
/**
 * Props for {@link EntityNamespacePicker}.
 *
 * @public
 */
interface EntityNamespacePickerProps {
    initiallySelectedNamespaces?: string[];
}
/** @public */
declare const EntityNamespacePicker: (props: EntityNamespacePickerProps) => React__default.JSX.Element;

/**
 * Filter entities based on Kind.
 * @public
 */
declare class EntityKindFilter implements EntityFilter {
    readonly value: string;
    readonly label: string;
    constructor(value: string, label: string);
    getCatalogFilters(): Record<string, string | string[]>;
    toQueryValue(): string;
}
/**
 * Filters entities based on type
 * @public
 */
declare class EntityTypeFilter implements EntityFilter {
    readonly value: string | string[];
    constructor(value: string | string[]);
    getTypes(): string[];
    getCatalogFilters(): Record<string, string | string[]>;
    toQueryValue(): string[];
}
/**
 * Filters entities based on tag.
 * @public
 */
declare class EntityTagFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
    getCatalogFilters(): Record<string, string | string[]>;
    toQueryValue(): string[];
}
/**
 * Filters entities where the text matches spec, title or tags.
 * @public
 */
declare class EntityTextFilter implements EntityFilter {
    readonly value: string;
    constructor(value: string);
    filterEntity(entity: Entity): boolean;
    getFullTextFilters(): {
        term: string;
        fields: string[];
    };
    toQueryValue(): string;
    private toUpperArray;
}
/**
 * Filter matching entities that are owned by group.
 * @public
 *
 * CAUTION: This class may contain both full and partial entity refs.
 */
declare class EntityOwnerFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    getCatalogFilters(): Record<string, string | string[]>;
    filterEntity(entity: Entity): boolean;
    /**
     * Get the URL query parameter value. May be a mix of full and humanized entity refs.
     * @returns list of entity refs.
     */
    toQueryValue(): string[];
}
/**
 * Filters entities on lifecycle.
 * @public
 */
declare class EntityLifecycleFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    getCatalogFilters(): Record<string, string | string[]>;
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string[];
}
/**
 * Filters entities to those within the given namespace(s).
 * @public
 */
declare class EntityNamespaceFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    getCatalogFilters(): Record<string, string | string[]>;
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string[];
}
/**
 * @public
 */
declare class EntityUserFilter implements EntityFilter {
    readonly value: UserListFilterKind;
    readonly refs?: string[] | undefined;
    private constructor();
    static owned(ownershipEntityRefs: string[]): EntityUserFilter;
    static all(): EntityUserFilter;
    static starred(starredEntityRefs: string[]): EntityUserFilter;
    getCatalogFilters(): Record<string, string[]>;
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string;
}
/**
 * Filters entities based on whatever the user has starred or owns them.
 * @deprecated use EntityUserFilter
 * @public
 */
declare class UserListFilter implements EntityFilter {
    readonly value: UserListFilterKind;
    readonly isOwnedEntity: (entity: Entity) => boolean;
    readonly isStarredEntity: (entity: Entity) => boolean;
    constructor(value: UserListFilterKind, isOwnedEntity: (entity: Entity) => boolean, isStarredEntity: (entity: Entity) => boolean);
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string;
}
/**
 * Filters entities based if it is an orphan or not.
 * @public
 */
declare class EntityOrphanFilter implements EntityFilter {
    readonly value: boolean;
    constructor(value: boolean);
    getCatalogFilters(): Record<string, string | string[]>;
    filterEntity(entity: Entity): boolean;
}
/**
 * Filters entities based on if it has errors or not.
 * @public
 */
declare class EntityErrorFilter implements EntityFilter {
    readonly value: boolean;
    constructor(value: boolean);
    filterEntity(entity: Entity): boolean;
}

/** @public */
type DefaultEntityFilters = {
    kind?: EntityKindFilter;
    type?: EntityTypeFilter;
    user?: UserListFilter | EntityUserFilter;
    owners?: EntityOwnerFilter;
    lifecycles?: EntityLifecycleFilter;
    tags?: EntityTagFilter;
    text?: EntityTextFilter;
    orphan?: EntityOrphanFilter;
    error?: EntityErrorFilter;
    namespace?: EntityNamespaceFilter;
};
/** @public */
type PaginationMode = 'cursor' | 'offset' | 'none';
/** @public */
type EntityListContextProps<EntityFilters extends DefaultEntityFilters = DefaultEntityFilters> = {
    /**
     * The currently registered filters, adhering to the shape of DefaultEntityFilters or an extension
     * of that default (to add custom filter types).
     */
    filters: EntityFilters;
    /**
     * The resolved list of catalog entities, after all filters are applied.
     */
    entities: Entity[];
    /**
     * The resolved list of catalog entities, after _only catalog-backend_ filters are applied.
     */
    backendEntities: Entity[];
    /**
     * Update one or more of the registered filters. Optional filters can be set to `undefined` to
     * reset the filter.
     */
    updateFilters: (filters: Partial<EntityFilters> | ((prevFilters: EntityFilters) => Partial<EntityFilters>)) => void;
    /**
     * Filter values from query parameters.
     */
    queryParameters: Partial<Record<keyof EntityFilters, string | string[]>>;
    loading: boolean;
    error?: Error;
    pageInfo?: {
        next?: () => void;
        prev?: () => void;
    };
    totalItems?: number;
    limit: number;
    offset?: number;
    setLimit: (limit: number) => void;
    setOffset?: (offset: number) => void;
    paginationMode: PaginationMode;
};
/**
 * Creates new context for entity listing and filtering.
 * @public
 */
declare const EntityListContext: React__default.Context<EntityListContextProps<any> | undefined>;
/**
 * @public
 */
type EntityListProviderProps = PropsWithChildren<{
    pagination?: EntityListPagination;
}>;
/**
 * Provides entities and filters for a catalog listing.
 * @public
 */
declare const EntityListProvider: <EntityFilters extends DefaultEntityFilters>(props: EntityListProviderProps) => React__default.JSX.Element;
/**
 * Hook for interacting with the entity list context provided by the {@link EntityListProvider}.
 * @public
 */
declare function useEntityList<EntityFilters extends DefaultEntityFilters = DefaultEntityFilters>(): EntityListContextProps<EntityFilters>;

/** @public */
type AllowedEntityFilters<T extends DefaultEntityFilters> = {
    [K in keyof T]-?: NonNullable<T[K]> extends EntityFilter & {
        values: string[];
    } ? K : never;
}[keyof T];
/** @public */
type EntityAutocompletePickerProps<T extends DefaultEntityFilters = DefaultEntityFilters, Name extends AllowedEntityFilters<T> = AllowedEntityFilters<T>> = {
    label: string;
    name: Name;
    path: string;
    showCounts?: boolean;
    Filter: {
        new (values: string[]): NonNullable<T[Name]>;
    };
    InputProps?: TextFieldProps;
    initialSelectedOptions?: string[];
    filtersForAvailableValues?: Array<keyof T>;
};
/** @public */
type CatalogReactEntityAutocompletePickerClassKey = 'root' | 'label';
/** @public */
declare function EntityAutocompletePicker<T extends DefaultEntityFilters = DefaultEntityFilters, Name extends AllowedEntityFilters<T> = AllowedEntityFilters<T>>(props: EntityAutocompletePickerProps<T, Name>): React__default.JSX.Element | null;

/** @public */
type MissingAnnotationEmptyStateClassKey = 'code';
/**
 * @public
 * Renders an empty state when an annotation is missing from an entity.
 */
declare function MissingAnnotationEmptyState(props: {
    annotation: string | string[];
    readMoreUrl?: string;
}): React__default.JSX.Element;

/** @public */
type EntityLoadingStatus<TEntity extends Entity = Entity> = {
    entity?: TEntity;
    loading: boolean;
    error?: Error;
    refresh?: VoidFunction;
};
/**
 * Properties for the AsyncEntityProvider component.
 *
 * @public
 */
interface AsyncEntityProviderProps {
    children: ReactNode;
    entity?: Entity;
    loading: boolean;
    error?: Error;
    refresh?: VoidFunction;
}
/**
 * Provides a loaded entity to be picked up by the `useEntity` hook.
 *
 * @public
 */
declare const AsyncEntityProvider: (props: AsyncEntityProviderProps) => React__default.JSX.Element;
/**
 * Properties for the EntityProvider component.
 *
 * @public
 */
interface EntityProviderProps {
    children: ReactNode;
    entity?: Entity;
}
/**
 * Provides an entity to be picked up by the `useEntity` hook.
 *
 * @public
 */
declare const EntityProvider: (props: EntityProviderProps) => React__default.JSX.Element;
/**
 * Grab the current entity from the context, throws if the entity has not yet been loaded
 * or is not available.
 *
 * @public
 */
declare function useEntity<TEntity extends Entity = Entity>(): {
    entity: TEntity;
};
/**
 * Grab the current entity from the context, provides loading state and errors, and the ability to refresh.
 *
 * @public
 */
declare function useAsyncEntity<TEntity extends Entity = Entity>(): EntityLoadingStatus<TEntity>;

/**
 * A hook built on top of `useEntityList` for enabling selection of valid `spec.type` values
 * based on the selected EntityKindFilter.
 * @public
 */
declare function useEntityTypeFilter(): {
    loading: boolean;
    error?: Error;
    availableTypes: string[];
    selectedTypes: string[];
    setSelectedTypes: (types: string[]) => void;
};

/**
 * Fetches all entities that appear in the entity's relations, optionally
 * filtered by relation type and kind.
 *
 * @public
 */
declare function useRelatedEntities(entity: Entity, relationFilter: {
    type?: string;
    kind?: string;
}): {
    entities: Entity[] | undefined;
    loading: boolean;
    error: Error | undefined;
};

/** @public */
declare function useStarredEntities(): {
    starredEntities: Set<string>;
    toggleStarredEntity: (entityOrRef: Entity | CompoundEntityRef | string) => void;
    isStarredEntity: (entityOrRef: Entity | CompoundEntityRef | string) => boolean;
};

/** @public */
declare function useStarredEntity(entityOrRef: Entity | CompoundEntityRef | string): {
    toggleStarredEntity: () => void;
    isStarredEntity: boolean;
};

/**
 * Returns a function that checks whether the currently signed-in user is an
 * owner of a given entity. When the hook is initially mounted, the loading
 * flag will be true and the results returned from the function will always be
 * false.
 *
 * @public
 *
 * @returns a function that checks if the signed in user owns an entity
 */
declare function useEntityOwnership(): {
    loading: boolean;
    isOwnedEntity: (entity: Entity) => boolean;
};

/**
 * A stable route ref that points to the catalog page for an individual entity.
 *
 * This `RouteRef` can be imported and used directly, and does not need to be referenced
 * via an `ExternalRouteRef`.
 *
 * If you want to replace the `EntityPage` from `@backstage/catalog-plugin` in your app,
 * you need to use the `entityRouteRef` as the mount point instead of your own.
 * @public
 */
declare const entityRouteRef: _backstage_core_plugin_api.RouteRef<{
    name: string;
    kind: string;
    namespace: string;
}>;
/**
 * Utility function to get suitable route params for entityRoute, given an
 * @public
 */
declare function entityRouteParams(entity: Entity): {
    readonly kind: string;
    readonly namespace: string;
    readonly name: string;
};

/** @public */
type CatalogReactComponentsNameToClassKey = {
    CatalogReactUserListPicker: CatalogReactUserListPickerClassKey;
    CatalogReactEntityDisplayName: CatalogReactEntityDisplayNameClassKey;
    CatalogReactEntityLifecyclePicker: CatalogReactEntityLifecyclePickerClassKey;
    CatalogReactEntitySearchBar: CatalogReactEntitySearchBarClassKey;
    CatalogReactEntityTagPicker: CatalogReactEntityTagPickerClassKey;
    CatalogReactEntityOwnerPicker: CatalogReactEntityOwnerPickerClassKey;
    CatalogReactFixedWidthFormControlLabel: FixedWidthFormControlLabelClassKey;
    CatalogReactEntityProcessingStatusPicker: CatalogReactEntityProcessingStatusPickerClassKey;
    CatalogReactEntityAutocompletePickerClassKey: CatalogReactEntityAutocompletePickerClassKey;
    CatalogReactMissingAnnotationEmptyState: MissingAnnotationEmptyStateClassKey;
};
/** @public */
type BackstageOverrides = Overrides & {
    [Name in keyof CatalogReactComponentsNameToClassKey]?: Partial<StyleRules<CatalogReactComponentsNameToClassKey[Name]>>;
};
declare module '@backstage/theme' {
    interface OverrideComponentNameToClassKeys extends CatalogReactComponentsNameToClassKey {
    }
}

/**
 * Get the related entity references.
 *
 * @public
 */
declare function getEntityRelations(entity: Entity | undefined, relationType: string, filter?: {
    kind: string;
}): CompoundEntityRef[];

/** @public */
type EntitySourceLocation = {
    locationTargetUrl: string;
    integrationType?: string;
};
/** @public */
declare function getEntitySourceLocation(entity: Entity, scmIntegrationsApi: typeof scmIntegrationsApiRef.T): EntitySourceLocation | undefined;

/**
 * @public
 * @deprecated Moved to `@backstage/plugin-catalog-react/testUtils`
 */
declare function MockEntityListContextProvider<T extends DefaultEntityFilters = DefaultEntityFilters>(props: PropsWithChildren<{
    value?: Partial<EntityListContextProps<T>>;
}>): React__default.JSX.Element;

export { type AllowedEntityFilters, AsyncEntityProvider, type AsyncEntityProviderProps, type BackstageOverrides, CatalogFilterLayout, type CatalogReactComponentsNameToClassKey, type CatalogReactEntityAutocompletePickerClassKey, type CatalogReactEntityDisplayNameClassKey, type CatalogReactEntityLifecyclePickerClassKey, type CatalogReactEntityNamespacePickerClassKey, type CatalogReactEntityOwnerPickerClassKey, type CatalogReactEntityProcessingStatusPickerClassKey, type CatalogReactEntitySearchBarClassKey, type CatalogReactEntityTagPickerClassKey, type CatalogReactUserListPickerClassKey, type DefaultEntityFilters, DefaultFilters, type DefaultFiltersProps, EntityAutocompletePicker, type EntityAutocompletePickerProps, EntityDisplayName, type EntityDisplayNameProps, EntityErrorFilter, type EntityFilter, EntityKindFilter, EntityKindPicker, type EntityKindPickerProps, EntityLifecycleFilter, EntityLifecyclePicker, EntityListContext, type EntityListContextProps, type EntityListPagination, EntityListProvider, type EntityListProviderProps, type EntityLoadingStatus, EntityNamespaceFilter, EntityNamespacePicker, type EntityNamespacePickerProps, EntityOrphanFilter, EntityOwnerFilter, EntityOwnerPicker, type EntityOwnerPickerProps, EntityPeekAheadPopover, type EntityPeekAheadPopoverProps, type EntityPresentationApi, EntityProcessingStatusPicker, EntityProvider, type EntityProviderProps, EntityRefLink, type EntityRefLinkProps, EntityRefLinks, type EntityRefLinksProps, type EntityRefPresentation, type EntityRefPresentationSnapshot, EntitySearchBar, type EntitySourceLocation, EntityTable, type EntityTableProps, EntityTagFilter, EntityTagPicker, type EntityTagPickerProps, EntityTextFilter, EntityTypeFilter, EntityTypePicker, type EntityTypePickerProps, EntityUserFilter, FavoriteEntity, type FavoriteEntityProps, type FixedWidthFormControlLabelClassKey, InspectEntityDialog, MissingAnnotationEmptyState, type MissingAnnotationEmptyStateClassKey, MockEntityListContextProvider, MockStarredEntitiesApi, type PaginationMode, type StarredEntitiesApi, UnregisterEntityDialog, type UnregisterEntityDialogProps, UserListFilter, type UserListFilterKind, UserListPicker, type UserListPickerProps, catalogApiRef, columnFactories, defaultEntityPresentation, entityPresentationApiRef, entityRouteParams, entityRouteRef, getEntityRelations, getEntitySourceLocation, humanizeEntityRef, starredEntitiesApiRef, useAsyncEntity, useEntity, useEntityList, useEntityOwnership, useEntityPresentation, useEntityTypeFilter, useRelatedEntities, useStarredEntities, useStarredEntity };
