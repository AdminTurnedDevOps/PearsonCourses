import { compact, isEqual } from 'lodash';
import qs from 'qs';
import React, { createContext, useState, useMemo, useCallback, useContext } from 'react';
import { useLocation } from 'react-router-dom';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import useDebounce from 'react-use/esm/useDebounce';
import useMountedState from 'react-use/esm/useMountedState';
import { catalogApiRef } from '../api.esm.js';
import { reduceCatalogFilters, reduceBackendCatalogFilters, reduceEntityFilters } from '../utils/filters.esm.js';
import { useApi } from '@backstage/core-plugin-api';

const EntityListContext = createContext(void 0);
const EntityListProvider = (props) => {
  const isMounted = useMountedState();
  const catalogApi = useApi(catalogApiRef);
  const [requestedFilters, setRequestedFilters] = useState(
    {}
  );
  const location = useLocation();
  const getPaginationMode = () => {
    if (props.pagination === true) {
      return "cursor";
    }
    return typeof props.pagination === "object" ? props.pagination.mode ?? "cursor" : "none";
  };
  const paginationMode = getPaginationMode();
  const paginationLimit = typeof props.pagination === "object" ? props.pagination.limit ?? 20 : 20;
  const {
    queryParameters,
    cursor: initialCursor,
    offset: initialOffset,
    limit: initialLimit
  } = useMemo(() => {
    const parsed = qs.parse(location.search, {
      ignoreQueryPrefix: true
    });
    let limit2 = paginationLimit;
    if (typeof parsed.limit === "string") {
      const queryLimit = Number.parseInt(parsed.limit, 10);
      if (!isNaN(queryLimit)) {
        limit2 = queryLimit;
      }
    }
    const offset2 = typeof parsed.offset === "string" && paginationMode === "offset" ? Number.parseInt(parsed.offset, 10) : void 0;
    return {
      queryParameters: parsed.filters ?? {},
      cursor: typeof parsed.cursor === "string" && paginationMode === "cursor" ? parsed.cursor : void 0,
      offset: paginationMode === "offset" && offset2 && !isNaN(offset2) ? offset2 : void 0,
      limit: limit2
    };
  }, [paginationMode, location.search, paginationLimit]);
  const [cursor, setCursor] = useState(initialCursor);
  const [offset, setOffset] = useState(initialOffset);
  const [limit, setLimit] = useState(initialLimit);
  const [outputState, setOutputState] = useState(
    () => {
      return {
        appliedFilters: {},
        entities: [],
        backendEntities: [],
        pageInfo: paginationMode === "cursor" ? {} : void 0,
        offset,
        limit
      };
    }
  );
  const [{ loading, error }, refresh] = useAsyncFn(
    async () => {
      const compacted = compact(Object.values(requestedFilters));
      const queryParams = Object.keys(requestedFilters).reduce(
        (params, key) => {
          const filter = requestedFilters[key];
          if (filter?.toQueryValue) {
            params[key] = filter.toQueryValue();
          }
          return params;
        },
        {}
      );
      if (paginationMode !== "none") {
        if (cursor) {
          if (cursor !== outputState.appliedCursor) {
            const entityFilter = reduceEntityFilters(compacted);
            const response = await catalogApi.queryEntities({
              cursor,
              limit
            });
            setOutputState({
              appliedFilters: requestedFilters,
              appliedCursor: cursor,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems
            });
          }
        } else {
          const entityFilter = reduceEntityFilters(compacted);
          const backendFilter = reduceCatalogFilters(compacted);
          const previousBackendFilter = reduceCatalogFilters(
            compact(Object.values(outputState.appliedFilters))
          );
          if (paginationMode === "offset" || !isEqual(previousBackendFilter, backendFilter)) {
            const response = await catalogApi.queryEntities({
              ...backendFilter,
              limit,
              offset,
              orderFields: [{ field: "metadata.name", order: "asc" }]
            });
            setOutputState({
              appliedFilters: requestedFilters,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo,
              totalItems: response.totalItems,
              limit,
              offset
            });
          }
        }
      } else {
        const entityFilter = reduceEntityFilters(compacted);
        const backendFilter = reduceBackendCatalogFilters(compacted);
        const previousBackendFilter = reduceBackendCatalogFilters(
          compact(Object.values(outputState.appliedFilters))
        );
        if (!isEqual(previousBackendFilter, backendFilter)) {
          const response = await catalogApi.getEntities({
            filter: backendFilter
          });
          const entities = response.items.filter(entityFilter);
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: response.items,
            entities,
            totalItems: entities.length
          });
        } else {
          const entities = outputState.backendEntities.filter(entityFilter);
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: outputState.backendEntities,
            entities,
            totalItems: entities.length
          });
        }
      }
      if (isMounted()) {
        const oldParams = qs.parse(location.search, {
          ignoreQueryPrefix: true
        });
        const newParams = qs.stringify(
          { ...oldParams, filters: queryParams, cursor, offset, limit },
          { addQueryPrefix: true, arrayFormat: "repeat" }
        );
        const newUrl = `${window.location.pathname}${newParams}`;
        window.history?.replaceState(null, document.title, newUrl);
      }
    },
    [
      catalogApi,
      queryParameters,
      requestedFilters,
      outputState,
      cursor,
      paginationMode,
      limit,
      offset
    ],
    { loading: true }
  );
  useDebounce(refresh, 10, [requestedFilters, cursor, limit, offset]);
  const updateFilters = useCallback(
    (update) => {
      setCursor(void 0);
      setRequestedFilters((prevFilters) => {
        const newFilters = typeof update === "function" ? update(prevFilters) : update;
        return { ...prevFilters, ...newFilters };
      });
    },
    []
  );
  const pageInfo = useMemo(() => {
    if (paginationMode !== "cursor") {
      return void 0;
    }
    const prevCursor = outputState.pageInfo?.prevCursor;
    const nextCursor = outputState.pageInfo?.nextCursor;
    return {
      prev: prevCursor ? () => setCursor(prevCursor) : void 0,
      next: nextCursor ? () => setCursor(nextCursor) : void 0
    };
  }, [paginationMode, outputState.pageInfo]);
  const value = useMemo(
    () => ({
      filters: outputState.appliedFilters,
      entities: outputState.entities,
      backendEntities: outputState.backendEntities,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo,
      totalItems: outputState.totalItems,
      limit,
      offset,
      setLimit,
      setOffset,
      paginationMode
    }),
    [
      outputState,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo,
      limit,
      offset,
      paginationMode,
      setLimit,
      setOffset
    ]
  );
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, { value }, props.children);
};
function useEntityList() {
  const context = useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityList must be used within EntityListProvider");
  return context;
}

export { EntityListContext, EntityListProvider, useEntityList };
//# sourceMappingURL=useEntityListProvider.esm.js.map
