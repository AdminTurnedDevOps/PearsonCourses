import { useApi } from '@backstage/core-plugin-api';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import { catalogApiRef } from '../../api.esm.js';
import { useState } from 'react';
import { parseEntityRef } from '@backstage/catalog-model';

function useFacetsEntities({ enabled }) {
  const catalogApi = useApi(catalogApiRef);
  const [facetsPromise] = useState(async () => {
    if (!enabled) {
      return [];
    }
    const facet = "relations.ownedBy";
    return catalogApi.getEntityFacets({ facets: [facet] }).then(
      (response) => response.facets[facet].map((e) => e.value).map((ref) => {
        const { kind, name, namespace } = parseEntityRef(ref);
        return {
          apiVersion: "backstage.io/v1beta1",
          kind,
          metadata: { name, namespace }
        };
      }).sort(
        (a, b) => a.kind.localeCompare(b.kind, "en-US") || a.metadata.namespace.localeCompare(
          b.metadata.namespace,
          "en-US"
        ) || a.metadata.name.localeCompare(b.metadata.name, "en-US")
      )
    ).catch(() => []);
  });
  return useAsyncFn(
    async (request, options) => {
      const facets = await facetsPromise;
      if (!facets) {
        return {
          items: []
        };
      }
      const limit = options?.limit ?? 20;
      const { text, start } = decodeCursor(request);
      const filteredRefs = facets.filter((e) => filterEntity(text, e));
      const end = start + limit;
      return {
        items: filteredRefs.slice(0, end),
        ...encodeCursor({
          entities: filteredRefs,
          limit: end,
          payload: {
            text,
            start: end
          }
        })
      };
    },
    [facetsPromise],
    { loading: true, value: { items: [] } }
  );
}
function decodeCursor(request) {
  if (isFacetsResponse(request) && request.cursor) {
    return JSON.parse(atob(request.cursor));
  }
  return {
    text: request.text || "",
    start: 0
  };
}
function isFacetsResponse(request) {
  return !!request.cursor;
}
function encodeCursor({
  entities,
  limit,
  payload
}) {
  if (entities.length > limit) {
    return { cursor: btoa(JSON.stringify(payload)) };
  }
  return {};
}
function filterEntity(text, entity) {
  const normalizedText = text.trim();
  return entity.kind.includes(normalizedText) || entity.metadata.namespace?.includes(normalizedText) || entity.metadata.name.includes(normalizedText);
}

export { useFacetsEntities };
//# sourceMappingURL=useFacetsEntities.esm.js.map
