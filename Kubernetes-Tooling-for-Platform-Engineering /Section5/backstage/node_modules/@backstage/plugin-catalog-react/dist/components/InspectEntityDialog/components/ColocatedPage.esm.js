import { ANNOTATION_LOCATION, ANNOTATION_ORIGIN_LOCATION, stringifyEntityRef } from '@backstage/catalog-model';
import { Progress, ResponseErrorPanel } from '@backstage/core-components';
import { useApi } from '@backstage/core-plugin-api';
import DialogContentText from '@material-ui/core/DialogContentText';
import List from '@material-ui/core/List';
import ListItem from '@material-ui/core/ListItem';
import { makeStyles } from '@material-ui/core/styles';
import Alert from '@material-ui/lab/Alert';
import React from 'react';
import useAsync from 'react-use/esm/useAsync';
import { catalogApiRef } from '../../../api.esm.js';
import { EntityRefLink } from '../../EntityRefLink/EntityRefLink.esm.js';
import 'lodash/get';
import { KeyValueListItem, ListItemText } from './common.esm.js';
import { catalogReactTranslationRef } from '../../../translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';

const useStyles = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
function useColocated(entity) {
  const catalogApi = useApi(catalogApiRef);
  const currentEntityRef = stringifyEntityRef(entity);
  const location = entity.metadata.annotations?.[ANNOTATION_LOCATION];
  const origin = entity.metadata.annotations?.[ANNOTATION_ORIGIN_LOCATION];
  const { loading, error, value } = useAsync(async () => {
    if (!location && !origin) {
      return [];
    }
    const response = await catalogApi.getEntities({
      filter: [
        ...location ? [{ [`metadata.annotations.${ANNOTATION_LOCATION}`]: location }] : [],
        ...origin ? [{ [`metadata.annotations.${ANNOTATION_ORIGIN_LOCATION}`]: origin }] : []
      ]
    });
    return response.items;
  }, [location, origin]);
  return {
    loading,
    error,
    location,
    originLocation: origin,
    colocatedEntities: value?.filter(
      (colocated) => stringifyEntityRef(colocated) !== currentEntityRef
    )
  };
}
function EntityList(props) {
  return /* @__PURE__ */ React.createElement(List, { dense: true }, props.header && /* @__PURE__ */ React.createElement(KeyValueListItem, { key: "header", entry: props.header }), props.entities.map((entity) => /* @__PURE__ */ React.createElement(ListItem, { key: stringifyEntityRef(entity) }, /* @__PURE__ */ React.createElement(ListItemText, { primary: /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: entity }) }))));
}
function Contents(props) {
  const { entity } = props;
  const { t } = useTranslationRef(catalogReactTranslationRef);
  const { loading, error, location, originLocation, colocatedEntities } = useColocated(entity);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  if (!location && !originLocation) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "warning" }, t("inspectEntityDialog.colocatedPage.alertNoLocation"));
  } else if (!colocatedEntities?.length) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, t("inspectEntityDialog.colocatedPage.alertNoEntity"));
  }
  if (location === originLocation) {
    return /* @__PURE__ */ React.createElement(EntityList, { entities: colocatedEntities });
  }
  const atLocation = colocatedEntities.filter(
    (e) => e.metadata.annotations?.[ANNOTATION_LOCATION] === location
  );
  const atOrigin = colocatedEntities.filter(
    (e) => e.metadata.annotations?.[ANNOTATION_ORIGIN_LOCATION] === originLocation
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, atLocation.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atLocation,
      header: ["At the same location", location]
    }
  ), atOrigin.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atOrigin,
      header: ["At the same origin", originLocation]
    }
  ));
}
function ColocatedPage(props) {
  const classes = useStyles();
  const { t } = useTranslationRef(catalogReactTranslationRef);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, t("inspectEntityDialog.colocatedPage.title")), /* @__PURE__ */ React.createElement(DialogContentText, null, t("inspectEntityDialog.colocatedPage.description")), /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Contents, { entity: props.entity })));
}

export { ColocatedPage };
//# sourceMappingURL=ColocatedPage.esm.js.map
