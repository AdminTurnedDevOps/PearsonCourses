import useAsyncFn from 'react-use/esm/useAsyncFn';
import { catalogApiRef } from '../../api.esm.js';
import React, { useState, useMemo, useEffect } from 'react';
import HoverPopover from 'material-ui-popup-state/HoverPopover';
import { usePopupState, bindHover, bindPopover } from 'material-ui-popup-state/hooks';
import Box from '@material-ui/core/Box';
import Card from '@material-ui/core/Card';
import CardActions from '@material-ui/core/CardActions';
import CardContent from '@material-ui/core/CardContent';
import Chip from '@material-ui/core/Chip';
import Tooltip from '@material-ui/core/Tooltip';
import Typography from '@material-ui/core/Typography';
import { makeStyles } from '@material-ui/core/styles';
import { useApiHolder } from '@backstage/core-plugin-api';
import { isUserEntity, isGroupEntity } from '@backstage/catalog-model';
import { ResponseErrorPanel, Progress } from '@backstage/core-components';
import { EntityCardActions } from './CardActionComponents/EntityCardActions.esm.js';
import { GroupCardActions } from './CardActionComponents/GroupCardActions.esm.js';
import { UserCardActions } from './CardActionComponents/UserCardActions.esm.js';
import { debounce } from 'lodash';
import { catalogReactTranslationRef } from '../../translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';

const useStyles = makeStyles(() => {
  return {
    popoverPaper: {
      width: "30em"
    },
    descriptionTypography: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitLineClamp: 2,
      WebkitBoxOrient: "vertical"
    }
  };
});
const maxTagChips = 4;
const EntityPeekAheadPopover = (props) => {
  const { entityRef, children, delayTime = 500 } = props;
  const { t } = useTranslationRef(catalogReactTranslationRef);
  const classes = useStyles();
  const apiHolder = useApiHolder();
  const popupState = usePopupState({
    variant: "popover",
    popupId: "entity-peek-ahead"
  });
  const [isHovered, setIsHovered] = useState(false);
  const debouncedHandleMouseEnter = useMemo(
    () => debounce(() => setIsHovered(true), delayTime),
    [delayTime]
  );
  const [{ loading, error, value: entity }, load] = useAsyncFn(async () => {
    const catalogApi = apiHolder.get(catalogApiRef);
    if (catalogApi) {
      const retrievedEntity = await catalogApi.getEntityByRef(entityRef);
      if (!retrievedEntity) {
        throw new Error(`${entityRef} not found`);
      }
      return retrievedEntity;
    }
    return void 0;
  }, [apiHolder, entityRef]);
  const handleOnMouseLeave = () => {
    setIsHovered(false);
    debouncedHandleMouseEnter.cancel();
  };
  useEffect(() => {
    if (popupState.isOpen && !entity && !error && !loading) {
      load();
    }
  }, [popupState.isOpen, load, entity, error, loading]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { component: "span", onMouseEnter: debouncedHandleMouseEnter }, /* @__PURE__ */ React.createElement(
    Typography,
    {
      component: "span",
      "data-testid": "trigger",
      ...bindHover(popupState)
    },
    children
  )), isHovered && /* @__PURE__ */ React.createElement(
    HoverPopover,
    {
      PaperProps: {
        className: classes.popoverPaper
      },
      ...bindPopover(popupState),
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      onMouseLeave: handleOnMouseLeave
    },
    /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, error && /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }), loading && /* @__PURE__ */ React.createElement(Progress, null), entity && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { color: "textSecondary" }, entity.metadata.namespace), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", component: "div" }, entity.metadata.name), /* @__PURE__ */ React.createElement(Typography, { color: "textSecondary", gutterBottom: true }, entity.kind), entity.metadata.description && /* @__PURE__ */ React.createElement(
      Typography,
      {
        className: classes.descriptionTypography,
        paragraph: true
      },
      entity.metadata.description
    ), /* @__PURE__ */ React.createElement(Typography, null, entity.spec?.type?.toString()), /* @__PURE__ */ React.createElement(Box, { marginTop: "0.5em" }, (entity.metadata.tags || []).slice(0, maxTagChips).map((tag) => {
      return /* @__PURE__ */ React.createElement(Chip, { key: tag, size: "small", label: tag });
    }), entity.metadata.tags?.length && entity.metadata.tags?.length > maxTagChips && /* @__PURE__ */ React.createElement(Tooltip, { title: t("entityPeekAheadPopover.title") }, /* @__PURE__ */ React.createElement(Chip, { key: "other-tags", size: "small", label: "..." }))))), !error && entity && /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(React.Fragment, null, isUserEntity(entity) && /* @__PURE__ */ React.createElement(UserCardActions, { entity }), isGroupEntity(entity) && /* @__PURE__ */ React.createElement(GroupCardActions, { entity }), /* @__PURE__ */ React.createElement(EntityCardActions, { entity }))))
  ));
};

export { EntityPeekAheadPopover };
//# sourceMappingURL=EntityPeekAheadPopover.esm.js.map
