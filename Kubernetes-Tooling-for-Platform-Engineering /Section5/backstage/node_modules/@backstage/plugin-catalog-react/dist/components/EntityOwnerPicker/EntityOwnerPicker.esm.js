import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import Box from '@material-ui/core/Box';
import Checkbox from '@material-ui/core/Checkbox';
import FormControlLabel from '@material-ui/core/FormControlLabel';
import TextField from '@material-ui/core/TextField';
import Typography from '@material-ui/core/Typography';
import Tooltip from '@material-ui/core/Tooltip';
import { makeStyles, createStyles, withStyles } from '@material-ui/core/styles';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useState, useMemo, useEffect } from 'react';
import { useEntityList } from '../../hooks/useEntityListProvider.esm.js';
import { EntityOwnerFilter } from '../../filters.esm.js';
import { useDebouncedEffect } from '@react-hookz/web';
import PersonIcon from '@material-ui/icons/Person';
import GroupIcon from '@material-ui/icons/Group';
import { humanizeEntity, humanizeEntityRef } from '../EntityRefLink/humanize.esm.js';
import { useFetchEntities } from './useFetchEntities.esm.js';
import '../../apis/EntityPresentationApi/EntityPresentationApi.esm.js';
import 'lodash/get';
import { useEntityPresentation } from '../../apis/EntityPresentationApi/useEntityPresentation.esm.js';
import '../../apis/StarredEntitiesApi/StarredEntitiesApi.esm.js';
import 'zen-observable';
import { catalogReactTranslationRef } from '../../translation.esm.js';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';

const useStyles = makeStyles(
  (theme) => createStyles({
    root: {},
    label: {
      textTransform: "none",
      fontWeight: "bold"
    },
    input: {
      backgroundColor: theme.palette.background.paper
    },
    fullWidth: { width: "100%" },
    boxLabel: {
      width: "100%",
      textOverflow: "ellipsis",
      overflow: "hidden"
    }
  }),
  { name: "CatalogReactEntityOwnerPicker" }
);
const FixedWidthFormControlLabel = withStyles(
  (_theme) => ({
    label: {
      width: "100%"
    },
    root: {
      width: "90%"
    }
  }),
  { name: "FixedWidthFormControlLabel" }
)(FormControlLabel);
const icon = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
function RenderOptionLabel(props) {
  const classes = useStyles();
  const isGroup = props.entity.kind.toLocaleLowerCase("en-US") === "group";
  const { primaryTitle: title } = useEntityPresentation(props.entity);
  return /* @__PURE__ */ React.createElement(Box, { className: classes.fullWidth }, /* @__PURE__ */ React.createElement(
    FixedWidthFormControlLabel,
    {
      className: classes.fullWidth,
      control: /* @__PURE__ */ React.createElement(
        Checkbox,
        {
          icon,
          checkedIcon,
          checked: props.isSelected
        }
      ),
      onClick: (event) => event.preventDefault(),
      label: /* @__PURE__ */ React.createElement(Tooltip, { title }, /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, isGroup ? /* @__PURE__ */ React.createElement(GroupIcon, { fontSize: "small" }) : /* @__PURE__ */ React.createElement(PersonIcon, { fontSize: "small" }), "\xA0", /* @__PURE__ */ React.createElement(Box, { className: classes.boxLabel }, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, title))))
    }
  ));
}
const EntityOwnerPicker = (props) => {
  const classes = useStyles();
  const { mode = "owners-only" } = props || {};
  const {
    updateFilters,
    filters,
    queryParameters: { owners: ownersParameter }
  } = useEntityList();
  const [text, setText] = useState("");
  const { t } = useTranslationRef(catalogReactTranslationRef);
  const queryParamOwners = useMemo(
    () => [ownersParameter].flat().filter(Boolean),
    [ownersParameter]
  );
  const [selectedOwners, setSelectedOwners] = useState(
    queryParamOwners.length ? queryParamOwners : filters.owners?.values ?? []
  );
  const [{ value, loading }, handleFetch, cache] = useFetchEntities({
    mode,
    initialSelectedOwnersRefs: selectedOwners
  });
  useDebouncedEffect(() => handleFetch({ text }), [text, handleFetch], 250);
  const availableOwners = value?.items || [];
  useEffect(() => {
    if (queryParamOwners.length) {
      const filter = new EntityOwnerFilter(queryParamOwners);
      setSelectedOwners(filter.values);
    }
  }, [queryParamOwners]);
  useEffect(() => {
    updateFilters({
      owners: selectedOwners.length ? new EntityOwnerFilter(selectedOwners) : void 0
    });
  }, [selectedOwners, updateFilters]);
  if (["user", "group"].includes(
    filters.kind?.value.toLocaleLowerCase("en-US") || ""
  )) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Box, { className: classes.root, pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(Typography, { className: classes.label, variant: "button", component: "label" }, t("entityOwnerPicker.title"), /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      PopperComponent: Popper,
      multiple: true,
      disableCloseOnSelect: true,
      loading,
      options: availableOwners,
      value: selectedOwners,
      getOptionSelected: (o, v) => {
        if (typeof v === "string") {
          return stringifyEntityRef(o) === v;
        }
        return o === v;
      },
      getOptionLabel: (o) => {
        const entity = typeof o === "string" ? cache.getEntity(o) || parseEntityRef(o, {
          defaultKind: "group",
          defaultNamespace: "default"
        }) : o;
        return humanizeEntity(entity, humanizeEntityRef(entity));
      },
      onChange: (_, owners) => {
        setText("");
        setSelectedOwners(
          owners.map((e) => {
            const entityRef = typeof e === "string" ? e : stringifyEntityRef(e);
            if (typeof e !== "string") {
              cache.setEntity(e);
            }
            return entityRef;
          })
        );
      },
      filterOptions: (x) => x,
      renderOption: (entity, { selected }) => {
        return /* @__PURE__ */ React.createElement(RenderOptionLabel, { entity, isSelected: selected });
      },
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { "data-testid": "owner-picker-expand" }),
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          className: classes.input,
          onChange: (e) => {
            setText(e.currentTarget.value);
          },
          variant: "outlined"
        }
      ),
      ListboxProps: {
        onScroll: (e) => {
          const element = e.currentTarget;
          const hasReachedEnd = Math.abs(
            element.scrollHeight - element.clientHeight - element.scrollTop
          ) < 1;
          if (hasReachedEnd && value?.cursor) {
            handleFetch({ items: value.items, cursor: value.cursor });
          }
        },
        "data-testid": "owner-picker-listbox"
      }
    }
  )));
};
function Popper({ children }) {
  return /* @__PURE__ */ React.createElement("div", null, children);
}

export { EntityOwnerPicker };
//# sourceMappingURL=EntityOwnerPicker.esm.js.map
