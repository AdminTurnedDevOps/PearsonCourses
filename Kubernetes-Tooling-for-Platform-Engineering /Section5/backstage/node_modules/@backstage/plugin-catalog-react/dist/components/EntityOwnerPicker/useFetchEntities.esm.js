import { useRef } from 'react';
import { useFacetsEntities } from './useFacetsEntities.esm.js';
import { useQueryEntities } from './useQueryEntities.esm.js';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { catalogApiRef } from '../../api.esm.js';
import useAsyncFn from 'react-use/esm/useAsyncFn';
import { useMountEffect } from '@react-hookz/web';

function useFetchEntities({
  mode,
  initialSelectedOwnersRefs
}) {
  const isOwnersOnlyMode = mode === "owners-only";
  const queryEntitiesResponse = useQueryEntities();
  const facetsEntitiesResponse = useFacetsEntities({
    enabled: isOwnersOnlyMode
  });
  const [state, handleFetch] = isOwnersOnlyMode ? facetsEntitiesResponse : queryEntitiesResponse;
  return [
    state,
    handleFetch,
    useSelectedOwners({
      enabled: !isOwnersOnlyMode,
      initialSelectedOwnersRefs
    })
  ];
}
function useSelectedOwners({
  enabled,
  initialSelectedOwnersRefs
}) {
  const allEntities = useRef({});
  const catalogApi = useApi(catalogApiRef);
  const [, handleFetch] = useAsyncFn(async () => {
    const initialSelectedEntities = await catalogApi.getEntitiesByRefs({
      entityRefs: initialSelectedOwnersRefs
    });
    initialSelectedEntities.items.forEach((e) => {
      if (e) {
        allEntities.current[stringifyEntityRef(e)] = e;
      }
    });
  }, []);
  useMountEffect(() => {
    if (enabled && initialSelectedOwnersRefs.length > 0) {
      handleFetch();
    }
  });
  return {
    getEntity: (entityRef) => allEntities.current[entityRef],
    setEntity: (entity) => {
      allEntities.current[stringifyEntityRef(entity)] = entity;
    }
  };
}

export { useFetchEntities };
//# sourceMappingURL=useFetchEntities.esm.js.map
