/// <reference types="react" />
export { ApiMock, ErrorWithContext, MockConfigApi, MockErrorApi, MockErrorApiOptions, MockFetchApi, MockFetchApiOptions, MockPermissionApi, MockStorageApi, MockStorageBucket, TestApiProvider, TestApiProviderProps, TestApiRegistry, mockApis, registerMswTestHooks, withLogCollector } from '@backstage/test-utils';
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { AnalyticsApi, AnalyticsEvent, AnyExtensionDataRef, AppNode, ExtensionDataRef, ExtensionDefinitionParameters, ExtensionDefinition, RouteRef } from '@backstage/frontend-plugin-api';
import { FrontendFeature } from '@backstage/frontend-app-api';
import { RenderResult } from '@testing-library/react';
import { JsonObject } from '@backstage/types';

/**
 * @public
 * @deprecated Use `registerMswTestHooks` from `@backstage/frontend-test-utils` instead.
 */
declare function setupRequestMockHandlers(worker: {
    listen: (t: any) => void;
    close: () => void;
    resetHandlers: () => void;
}): void;

/**
 * Mock implementation of {@link frontend-plugin-api#AnalyticsApi} with helpers to ensure that events are sent correctly.
 * Use getEvents in tests to verify captured events.
 *
 * @public
 */
declare class MockAnalyticsApi implements AnalyticsApi {
    private events;
    captureEvent(event: AnalyticsEvent): void;
    getEvents(): AnalyticsEvent[];
}

/** @public */
declare class ExtensionQuery<UOutput extends AnyExtensionDataRef> {
    #private;
    constructor(node: AppNode);
    get node(): AppNode;
    get instance(): _backstage_frontend_plugin_api.AppNodeInstance;
    get<TId extends UOutput['id']>(ref: ExtensionDataRef<any, TId, any>): UOutput extends ExtensionDataRef<infer IData, TId, infer IConfig> ? IConfig['optional'] extends true ? IData | undefined : IData : never;
}
/** @public */
declare class ExtensionTester<UOutput extends AnyExtensionDataRef> {
    #private;
    add<T extends ExtensionDefinitionParameters>(extension: ExtensionDefinition<T>, options?: {
        config?: T['configInput'];
    }): ExtensionTester<UOutput>;
    get<TId extends UOutput['id']>(ref: ExtensionDataRef<any, TId, any>): UOutput extends ExtensionDataRef<infer IData, TId, infer IConfig> ? IConfig['optional'] extends true ? IData | undefined : IData : never;
    query<T extends ExtensionDefinitionParameters>(extension: ExtensionDefinition<T>): ExtensionQuery<NonNullable<T['output']>>;
    reactElement(): JSX.Element;
}
/** @public */
declare function createExtensionTester<T extends ExtensionDefinitionParameters>(subject: ExtensionDefinition<T>, options?: {
    config?: T['configInput'];
}): ExtensionTester<NonNullable<T['output']>>;

/**
 * Options to customize the behavior of the test app.
 * @public
 */
type TestAppOptions = {
    /**
     * An object of paths to mount route ref on, with the key being the path and the value
     * being the RouteRef that the path will be bound to. This allows the route refs to be
     * used by `useRouteRef` in the rendered elements.
     *
     * @example
     * ```ts
     * renderInTestApp(<MyComponent />, {
     *   mountedRoutes: {
     *     '/my-path': myRouteRef,
     *   }
     * })
     * // ...
     * const link = useRouteRef(myRouteRef)
     * ```
     */
    mountedRoutes?: {
        [path: string]: RouteRef;
    };
    /**
     * Additional configuration passed to the app when rendering elements inside it.
     */
    config?: JsonObject;
    /**
     * Additional extensions to add to the test app.
     */
    extensions?: ExtensionDefinition<any>[];
    /**
     * Additional features to add to the test app.
     */
    features?: FrontendFeature[];
};
/**
 * @public
 * Renders the given element in a test app, for use in unit tests.
 */
declare function renderInTestApp(element: JSX.Element, options?: TestAppOptions): RenderResult;

export { ExtensionQuery, ExtensionTester, MockAnalyticsApi, type TestAppOptions, createExtensionTester, renderInTestApp, setupRequestMockHandlers };
