import { isInternalFrontendModule, toInternalFrontendModule } from '../../../frontend-plugin-api/src/wiring/createFrontendModule.esm.js';
import { toInternalExtension } from '../../../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';
import { OpaqueFrontendPlugin } from '../../../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';
import '../../../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';

function resolveAppNodeSpecs(options) {
  const {
    builtinExtensions = [],
    parameters = [],
    forbidden = /* @__PURE__ */ new Set(),
    features = []
  } = options;
  const plugins = features.filter(OpaqueFrontendPlugin.isType);
  const modules = features.filter(isInternalFrontendModule);
  const pluginExtensions = plugins.flatMap((source) => {
    return OpaqueFrontendPlugin.toInternal(source).extensions.map(
      (extension) => ({
        ...extension,
        source
      })
    );
  });
  const moduleExtensions = modules.flatMap(
    (mod) => toInternalFrontendModule(mod).extensions.flatMap((extension) => {
      const source = plugins.find((p) => p.id === mod.pluginId);
      if (!source) {
        return [];
      }
      return [{ ...extension, source }];
    })
  );
  if (pluginExtensions.some(({ id }) => forbidden.has(id))) {
    const pluginsStr = pluginExtensions.filter(({ id }) => forbidden.has(id)).map(({ source }) => `'${source.id}'`).join(", ");
    const forbiddenStr = [...forbidden].map((id) => `'${id}'`).join(", ");
    throw new Error(
      `It is forbidden to override the following extension(s): ${forbiddenStr}, which is done by the following plugin(s): ${pluginsStr}`
    );
  }
  if (moduleExtensions.some(({ id }) => forbidden.has(id))) {
    const pluginsStr = moduleExtensions.filter(({ id }) => forbidden.has(id)).map(({ source }) => `'${source.id}'`).join(", ");
    const forbiddenStr = [...forbidden].map((id) => `'${id}'`).join(", ");
    throw new Error(
      `It is forbidden to override the following extension(s): ${forbiddenStr}, which is done by a module for the following plugin(s): ${pluginsStr}`
    );
  }
  const configuredExtensions = [
    ...pluginExtensions.map(({ source, ...extension }) => {
      const internalExtension = toInternalExtension(extension);
      return {
        extension: internalExtension,
        params: {
          source,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      };
    }),
    ...builtinExtensions.map((extension) => {
      const internalExtension = toInternalExtension(extension);
      return {
        extension: internalExtension,
        params: {
          source: void 0,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      };
    })
  ];
  for (const extension of moduleExtensions) {
    const internalExtension = toInternalExtension(extension);
    const index = configuredExtensions.findIndex(
      (e) => e.extension.id === extension.id
    );
    if (index !== -1) {
      configuredExtensions[index].extension = internalExtension;
      configuredExtensions[index].params.attachTo = internalExtension.attachTo;
      configuredExtensions[index].params.disabled = internalExtension.disabled;
    } else {
      configuredExtensions.push({
        extension: internalExtension,
        params: {
          source: extension.source,
          attachTo: internalExtension.attachTo,
          disabled: internalExtension.disabled,
          config: void 0
        }
      });
    }
  }
  const duplicatedExtensionIds = /* @__PURE__ */ new Set();
  const duplicatedExtensionData = configuredExtensions.reduce((data, { extension, params }) => {
    const extensionId = extension.id;
    const extensionData = data?.[extensionId];
    if (extensionData) duplicatedExtensionIds.add(extensionId);
    const pluginId = params.source?.id ?? "internal";
    const pluginCount = extensionData?.[pluginId] ?? 0;
    return {
      ...data,
      [extensionId]: { ...extensionData, [pluginId]: pluginCount + 1 }
    };
  }, {});
  if (duplicatedExtensionIds.size > 0) {
    throw new Error(
      `The following extensions are duplicated: ${Array.from(
        duplicatedExtensionIds
      ).map(
        (extensionId) => `The extension '${extensionId}' was provided ${Object.keys(
          duplicatedExtensionData[extensionId]
        ).map(
          (pluginId) => `${duplicatedExtensionData[extensionId][pluginId]} time(s) by the plugin '${pluginId}'`
        ).join(" and ")}`
      ).join(", ")}`
    );
  }
  const order = /* @__PURE__ */ new Map();
  for (const overrideParam of parameters) {
    const extensionId = overrideParam.id;
    if (forbidden.has(extensionId)) {
      throw new Error(
        `Configuration of the '${extensionId}' extension is forbidden`
      );
    }
    const existing = configuredExtensions.find(
      (e) => e.extension.id === extensionId
    );
    if (existing) {
      if (overrideParam.attachTo) {
        existing.params.attachTo = overrideParam.attachTo;
      }
      if (overrideParam.config) {
        existing.params.config = overrideParam.config;
      }
      if (Boolean(existing.params.disabled) !== Boolean(overrideParam.disabled)) {
        existing.params.disabled = Boolean(overrideParam.disabled);
      }
      order.set(extensionId, existing);
    } else {
      throw new Error(`Extension ${extensionId} does not exist`);
    }
  }
  const orderedExtensions = [
    ...order.values(),
    ...configuredExtensions.filter((e) => !order.has(e.extension.id))
  ];
  return orderedExtensions.map((param) => ({
    id: param.extension.id,
    attachTo: param.params.attachTo,
    extension: param.extension,
    disabled: param.params.disabled,
    source: param.params.source,
    config: param.params.config
  }));
}

export { resolveAppNodeSpecs };
//# sourceMappingURL=resolveAppNodeSpecs.esm.js.map
