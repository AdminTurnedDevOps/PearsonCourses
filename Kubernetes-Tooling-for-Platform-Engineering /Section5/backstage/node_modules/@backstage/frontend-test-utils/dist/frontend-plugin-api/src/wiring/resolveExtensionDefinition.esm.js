import { OpaqueExtensionDefinition } from '../../../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';
import '../../../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';

function toInternalExtension(overrides) {
  const internal = overrides;
  if (internal.$$type !== "@backstage/Extension") {
    throw new Error(
      `Invalid extension instance, bad type '${internal.$$type}'`
    );
  }
  const version = internal.version;
  if (version !== "v1" && version !== "v2") {
    throw new Error(`Invalid extension instance, bad version '${version}'`);
  }
  return internal;
}
function resolveExtensionDefinition(definition, context) {
  const internalDefinition = OpaqueExtensionDefinition.toInternal(definition);
  const {
    name,
    kind,
    namespace: _skip1,
    override: _skip2,
    ...rest
  } = internalDefinition;
  const namespace = internalDefinition.namespace ?? context?.namespace;
  const namePart = name && namespace ? `${namespace}/${name}` : namespace || name;
  if (!namePart) {
    throw new Error(
      `Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${kind} namespace=${namespace} name=${name}`
    );
  }
  const id = kind ? `${kind}:${namePart}` : namePart;
  return {
    ...rest,
    $$type: "@backstage/Extension",
    version: internalDefinition.version,
    id,
    toString() {
      return `Extension{id=${id}}`;
    }
  };
}

export { resolveExtensionDefinition, toInternalExtension };
//# sourceMappingURL=resolveExtensionDefinition.esm.js.map
