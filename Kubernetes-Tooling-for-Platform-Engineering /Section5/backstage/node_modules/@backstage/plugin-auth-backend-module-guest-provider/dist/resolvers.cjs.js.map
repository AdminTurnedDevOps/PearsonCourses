{"version":3,"file":"resolvers.cjs.js","sources":["../src/resolvers.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stringifyEntityRef } from '@backstage/catalog-model';\nimport type { Config } from '@backstage/config';\nimport { SignInResolver } from '@backstage/plugin-auth-node';\nimport { NotImplementedError } from '@backstage/errors';\n\n/**\n * Provide a default implementation of the user to resolve to. By default, this\n *  is `user:development/guest`. We will attempt to get that user if they're in the\n *  catalog. If that user doesn't exist in the catalog, we will still create a\n *  token for them so they can keep viewing.\n */\nexport const signInAsGuestUser: (config: Config) => SignInResolver<{}> =\n  (config: Config) => async (_, ctx) => {\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      config.getOptionalBoolean('dangerouslyAllowOutsideDevelopment') !== true\n    ) {\n      throw new NotImplementedError(\n        'The guest provider is NOT recommended for use outside of a development environment. If you want to enable this, set `auth.providers.guest.dangerouslyAllowOutsideDevelopment: true` in your app config.',\n      );\n    }\n    const userRef =\n      config.getOptionalString('userEntityRef') ??\n      stringifyEntityRef({\n        kind: 'user',\n        namespace: 'development',\n        name: 'guest',\n      });\n    const ownershipRefs = config.getOptionalStringArray(\n      'ownershipEntityRefs',\n    ) ?? [userRef];\n    try {\n      return await ctx.signInWithCatalogUser({ entityRef: userRef });\n    } catch (err) {\n      // We can't guarantee that a guest user exists in the catalog, so we issue a token directly,\n      return ctx.issueToken({\n        claims: {\n          sub: userRef,\n          ent: ownershipRefs,\n        },\n      });\n    }\n  };\n"],"names":["NotImplementedError","stringifyEntityRef"],"mappings":";;;;;AA2BO,MAAM,iBACX,GAAA,CAAC,MAAmB,KAAA,OAAO,GAAG,GAAQ,KAAA;AACpC,EACE,IAAA,OAAA,CAAQ,IAAI,QAAa,KAAA,aAAA,IACzB,OAAO,kBAAmB,CAAA,oCAAoC,MAAM,IACpE,EAAA;AACA,IAAA,MAAM,IAAIA,0BAAA;AAAA,MACR;AAAA,KACF;AAAA;AAEF,EAAA,MAAM,OACJ,GAAA,MAAA,CAAO,iBAAkB,CAAA,eAAe,KACxCC,+BAAmB,CAAA;AAAA,IACjB,IAAM,EAAA,MAAA;AAAA,IACN,SAAW,EAAA,aAAA;AAAA,IACX,IAAM,EAAA;AAAA,GACP,CAAA;AACH,EAAA,MAAM,gBAAgB,MAAO,CAAA,sBAAA;AAAA,IAC3B;AAAA,GACF,IAAK,CAAC,OAAO,CAAA;AACb,EAAI,IAAA;AACF,IAAA,OAAO,MAAM,GAAI,CAAA,qBAAA,CAAsB,EAAE,SAAA,EAAW,SAAS,CAAA;AAAA,WACtD,GAAK,EAAA;AAEZ,IAAA,OAAO,IAAI,UAAW,CAAA;AAAA,MACpB,MAAQ,EAAA;AAAA,QACN,GAAK,EAAA,OAAA;AAAA,QACL,GAAK,EAAA;AAAA;AACP,KACD,CAAA;AAAA;AAEL;;;;"}