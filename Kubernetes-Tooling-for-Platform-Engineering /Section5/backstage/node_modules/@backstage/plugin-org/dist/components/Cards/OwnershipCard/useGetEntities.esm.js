import { parseEntityRef, stringifyEntityRef, RELATION_MEMBER_OF, RELATION_PARENT_OF } from '@backstage/catalog-model';
import { catalogApiRef, humanizeEntityRef, getEntityRelations } from '@backstage/plugin-catalog-react';
import limiterFactory from 'p-limit';
import { useApi } from '@backstage/core-plugin-api';
import useAsync from 'react-use/esm/useAsync';
import qs from 'qs';
import { uniqBy, uniq } from 'lodash';

const limiter = limiterFactory(5);
const getQueryParams = (ownersEntityRef, selectedEntity) => {
  const { kind, type } = selectedEntity;
  const owners = ownersEntityRef.map(
    (owner) => humanizeEntityRef(parseEntityRef(owner), { defaultKind: "group" })
  );
  const filters = {
    kind: kind.toLocaleLowerCase("en-US"),
    type,
    owners,
    user: "all"
  };
  return qs.stringify({ filters }, { arrayFormat: "repeat" });
};
const getMemberOfEntityRefs = (owner) => {
  const parentGroups = getEntityRelations(owner, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  const ownerGroupsNames = parentGroups.map(
    ({ kind, namespace, name }) => stringifyEntityRef({
      kind,
      namespace,
      name
    })
  );
  return [...ownerGroupsNames, stringifyEntityRef(owner)];
};
const isEntity = (entity) => entity !== void 0;
const getChildOwnershipEntityRefs = async (entity, catalogApi, alreadyRetrievedParentRefs = []) => {
  const childGroups = getEntityRelations(entity, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const hasChildGroups = childGroups.length > 0;
  const entityRef = stringifyEntityRef(entity);
  if (hasChildGroups) {
    const entityRefs = childGroups.map((r) => stringifyEntityRef(r));
    const childGroupResponse = await limiter(
      () => catalogApi.getEntitiesByRefs({
        fields: ["kind", "metadata.namespace", "metadata.name", "relations"],
        entityRefs
      })
    );
    const childGroupEntities = childGroupResponse.items.filter(isEntity);
    const unknownChildren = childGroupEntities.filter(
      (childGroupEntity) => !alreadyRetrievedParentRefs.includes(
        stringifyEntityRef(childGroupEntity)
      )
    );
    const childrenRefs = (await Promise.all(
      unknownChildren.map(
        (childGroupEntity) => getChildOwnershipEntityRefs(childGroupEntity, catalogApi, [
          ...alreadyRetrievedParentRefs,
          entityRef
        ])
      )
    )).flatMap((aggregated) => aggregated);
    return uniq([...childrenRefs, entityRef]);
  }
  return [entityRef];
};
const getOwners = async (entity, relationAggregation, catalogApi) => {
  const isGroup = entity.kind === "Group";
  const isAggregated = relationAggregation === "aggregated";
  const isUserEntity = entity.kind === "User";
  if (isAggregated && isGroup) {
    return getChildOwnershipEntityRefs(entity, catalogApi);
  }
  if (isAggregated && isUserEntity) {
    return getMemberOfEntityRefs(entity);
  }
  return [stringifyEntityRef(entity)];
};
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const batchGetOwnedEntitiesByOwners = async (owners, kinds, catalogApi, batchSize = 100, delayMs = 100) => {
  const results = [];
  for (let i = 0; i < owners.length; i += batchSize) {
    const batch = owners.slice(i, i + batchSize);
    const response = await catalogApi.getEntities({
      filter: [
        {
          kind: kinds,
          "relations.ownedBy": batch
        }
      ],
      fields: [
        "kind",
        "metadata.name",
        "metadata.namespace",
        "spec.type",
        "relations"
      ]
    });
    results.push(...response.items);
    if (i + batchSize < owners.length) await delay(delayMs);
  }
  return uniqBy(results, stringifyEntityRef);
};
function useGetEntities(entity, relationAggregation, entityFilterKind, entityLimit = 6) {
  const catalogApi = useApi(catalogApiRef);
  const kinds = entityFilterKind ?? ["Component", "API", "System"];
  const {
    loading,
    error,
    value: componentsWithCounters
  } = useAsync(async () => {
    const owners = await getOwners(entity, relationAggregation, catalogApi);
    const ownedEntitiesList = await batchGetOwnedEntitiesByOwners(
      owners,
      kinds,
      catalogApi
    );
    const counts = ownedEntitiesList.reduce(
      (acc, ownedEntity) => {
        const match = acc.find(
          (x) => x.kind === ownedEntity.kind && x.type === ownedEntity.spec?.type
        );
        if (match) {
          match.count += 1;
        } else {
          acc.push({
            kind: ownedEntity.kind,
            type: ownedEntity.spec?.type?.toString(),
            count: 1
          });
        }
        return acc;
      },
      []
    );
    const topN = counts.sort((a, b) => b.count - a.count).slice(0, entityLimit);
    return topN.map((topOwnedEntity) => ({
      counter: topOwnedEntity.count,
      type: topOwnedEntity.type,
      kind: topOwnedEntity.kind,
      queryParams: getQueryParams(owners, topOwnedEntity)
    }));
  }, [catalogApi, entity, relationAggregation]);
  return {
    componentsWithCounters,
    loading,
    error
  };
}

export { useGetEntities };
//# sourceMappingURL=useGetEntities.esm.js.map
