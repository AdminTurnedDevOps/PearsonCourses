'use strict';

var configLoader = require('@backstage/config-loader');
var config = require('@backstage/config');
var paths = require('../../../lib/paths.cjs.js');
var getPackages = require('@manypkg/get-packages');
var cliNode = require('@backstage/cli-node');

async function loadCliConfig(options) {
  const { packages } = await getPackages.getPackages(paths.paths.targetDir);
  let localPackageNames;
  if (options.fromPackage) {
    if (packages.length) {
      const graph = cliNode.PackageGraph.fromPackages(packages);
      localPackageNames = Array.from(
        graph.collectPackageNames([options.fromPackage], (node) => {
          if (node.name === "@backstage/cli") {
            return void 0;
          }
          return node.localDependencies.keys();
        })
      );
    } else {
      localPackageNames = [options.fromPackage];
    }
  } else {
    localPackageNames = packages.map((p) => p.packageJson.name);
  }
  const schema = await configLoader.loadConfigSchema({
    dependencies: localPackageNames,
    // Include the package.json in the project root if it exists
    packagePaths: [paths.paths.resolveTargetRoot("package.json")],
    noUndeclaredProperties: options.strict
  });
  const source = configLoader.ConfigSources.default({
    allowMissingDefaultConfig: true,
    substitutionFunc: options.mockEnv ? async (name) => process.env[name] || "x" : void 0,
    watch: Boolean(options.watch),
    rootDir: paths.paths.targetRoot,
    argv: options.args.flatMap((t) => ["--config", paths.paths.resolveTarget(t)])
  });
  const appConfigs = await new Promise((resolve, reject) => {
    async function loadConfigReaderLoop() {
      let loaded = false;
      try {
        const abortController = new AbortController();
        for await (const { configs } of source.readConfigData({
          signal: abortController.signal
        })) {
          if (loaded) {
            const newFrontendAppConfigs = schema.process(configs, {
              visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
              withFilteredKeys: options.withFilteredKeys,
              withDeprecatedKeys: options.withDeprecatedKeys,
              ignoreSchemaErrors: !options.strict
            });
            options.watch?.(newFrontendAppConfigs);
          } else {
            resolve(configs);
            loaded = true;
            if (!options.watch) {
              abortController.abort();
            }
          }
        }
      } catch (error) {
        if (loaded) {
          console.error(`Failed to reload configuration, ${error}`);
        } else {
          reject(error);
        }
      }
    }
    loadConfigReaderLoop();
  });
  const configurationLoadedMessage = appConfigs.length ? `Loaded config from ${appConfigs.map((c) => c.context).join(", ")}` : `No configuration files found, running without config`;
  process.stderr.write(`${configurationLoadedMessage}
`);
  try {
    const frontendAppConfigs = schema.process(appConfigs, {
      visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
      withFilteredKeys: options.withFilteredKeys,
      withDeprecatedKeys: options.withDeprecatedKeys,
      ignoreSchemaErrors: !options.strict
    });
    const frontendConfig = config.ConfigReader.fromConfigs(frontendAppConfigs);
    const fullConfig = config.ConfigReader.fromConfigs(appConfigs);
    return {
      schema,
      appConfigs,
      frontendConfig,
      frontendAppConfigs,
      fullConfig
    };
  } catch (error) {
    const maybeSchemaError = error;
    if (maybeSchemaError.messages) {
      const messages = maybeSchemaError.messages.join("\n  ");
      throw new Error(`Configuration does not match schema

  ${messages}`);
    }
    throw error;
  }
}

exports.loadCliConfig = loadCliConfig;
//# sourceMappingURL=config.cjs.js.map
