'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var yaml = require('yaml');
var config$1 = require('@backstage/config');
var config = require('../lib/config.cjs.js');

var print = async (opts) => {
  const { schema, appConfigs } = await config.loadCliConfig({
    args: opts.config,
    fromPackage: opts.package,
    mockEnv: opts.lax,
    fullVisibility: !opts.frontend
  });
  const visibility = getVisibilityOption(opts);
  const data = serializeConfigData(appConfigs, schema, visibility);
  if (opts.format === "json") {
    process.stdout.write(`${JSON.stringify(data, null, 2)}
`);
  } else {
    process.stdout.write(`${yaml.stringify(data)}
`);
  }
};
function getVisibilityOption(opts) {
  if (opts.frontend && opts.withSecrets) {
    throw new Error("Not allowed to combine frontend and secret config");
  }
  if (opts.frontend) {
    return "frontend";
  } else if (opts.withSecrets) {
    return "secret";
  }
  return "backend";
}
function serializeConfigData(appConfigs, schema, visibility) {
  if (visibility === "frontend") {
    const frontendConfigs = schema.process(appConfigs, {
      visibility: ["frontend"]
    });
    return config$1.ConfigReader.fromConfigs(frontendConfigs).get();
  } else if (visibility === "secret") {
    return config$1.ConfigReader.fromConfigs(appConfigs).get();
  }
  const sanitizedConfigs = schema.process(appConfigs, {
    valueTransform: (value, context) => context.visibility === "secret" ? "<secret>" : value
  });
  return config$1.ConfigReader.fromConfigs(sanitizedConfigs).get();
}

exports.default = print;
//# sourceMappingURL=print.cjs.js.map
