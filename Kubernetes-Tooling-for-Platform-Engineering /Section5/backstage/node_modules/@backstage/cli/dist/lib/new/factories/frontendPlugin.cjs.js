'use strict';

var fs = require('fs-extra');
var chalk = require('chalk');
var camelCase = require('lodash/camelCase');
var upperFirst = require('lodash/upperFirst');
var paths = require('../../paths.cjs.js');
var codeowners = require('../../codeowners/codeowners.cjs.js');
var types = require('../types.cjs.js');
var tasks = require('../../tasks.cjs.js');
var prompts = require('./common/prompts.cjs.js');
var tasks$1 = require('./common/tasks.cjs.js');
var util = require('./common/util.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var camelCase__default = /*#__PURE__*/_interopDefaultCompat(camelCase);
var upperFirst__default = /*#__PURE__*/_interopDefaultCompat(upperFirst);

const frontendPlugin = types.createFactory({
  name: "plugin",
  description: "A new frontend plugin",
  optionsDiscovery: async () => ({
    codeOwnersPath: await codeowners.getCodeownersFilePath(paths.paths.targetRoot)
  }),
  optionsPrompts: [prompts.pluginIdPrompt(), prompts.ownerPrompt()],
  async create(options, ctx) {
    const { id } = options;
    const name = util.resolvePackageName({
      baseName: id,
      scope: ctx.scope,
      plugin: true
    });
    const extensionName = `${upperFirst__default.default(camelCase__default.default(id))}Page`;
    tasks.Task.log();
    tasks.Task.log(`Creating frontend plugin ${chalk__default.default.cyan(name)}`);
    const targetDir = ctx.isMonoRepo ? paths.paths.resolveTargetRoot("plugins", id) : paths.paths.resolveTargetRoot(`backstage-plugin-${id}`);
    await tasks$1.executePluginPackageTemplate(ctx, {
      targetDir,
      templateName: "default-plugin",
      values: {
        id,
        name,
        extensionName,
        pluginVar: `${camelCase__default.default(id)}Plugin`,
        pluginVersion: ctx.defaultVersion,
        privatePackage: ctx.private,
        npmRegistry: ctx.npmRegistry,
        license: ctx.license
      }
    });
    if (await fs__default.default.pathExists(paths.paths.resolveTargetRoot("packages/app"))) {
      await tasks.Task.forItem("app", "adding dependency", async () => {
        await tasks.addPackageDependency(
          paths.paths.resolveTargetRoot("packages/app/package.json"),
          {
            dependencies: {
              [name]: `^${ctx.defaultVersion}`
            }
          }
        );
      });
      await tasks.Task.forItem("app", "adding import", async () => {
        const pluginsFilePath = paths.paths.resolveTargetRoot(
          "packages/app/src/App.tsx"
        );
        if (!await fs__default.default.pathExists(pluginsFilePath)) {
          return;
        }
        const content = await fs__default.default.readFile(pluginsFilePath, "utf8");
        const revLines = content.split("\n").reverse();
        const lastImportIndex = revLines.findIndex(
          (line) => line.match(/ from ("|').*("|')/)
        );
        const lastRouteIndex = revLines.findIndex(
          (line) => line.match(/<\/FlatRoutes/)
        );
        if (lastImportIndex !== -1 && lastRouteIndex !== -1) {
          const importLine = `import { ${extensionName} } from '${name}';`;
          if (!content.includes(importLine)) {
            revLines.splice(lastImportIndex, 0, importLine);
          }
          const componentLine = `<Route path="/${id}" element={<${extensionName} />} />`;
          if (!content.includes(componentLine)) {
            const [indentation] = revLines[lastRouteIndex + 1].match(/^\s*/) ?? [];
            revLines.splice(lastRouteIndex + 1, 0, indentation + componentLine);
          }
          const newContent = revLines.reverse().join("\n");
          await fs__default.default.writeFile(pluginsFilePath, newContent, "utf8");
        }
      });
    }
    if (options.owner) {
      await codeowners.addCodeownersEntry(`/plugins/${id}`, options.owner);
    }
    await tasks.Task.forCommand("yarn install", { cwd: targetDir, optional: true });
    await tasks.Task.forCommand("yarn lint --fix", {
      cwd: targetDir,
      optional: true
    });
  }
});

exports.frontendPlugin = frontendPlugin;
//# sourceMappingURL=frontendPlugin.cjs.js.map
