'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var openBrowser = require('react-dev-utils/openBrowser');
var webpack = require('webpack');
var WebpackDevServer = require('webpack-dev-server');
var paths$1 = require('../paths.cjs.js');
var config = require('../../modules/config/lib/config.cjs.js');
var config$1 = require('./config.cjs.js');
var packageDetection = require('./packageDetection.cjs.js');
var paths = require('./paths.cjs.js');
var hasReactDomClient = require('./hasReactDomClient.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var openBrowser__default = /*#__PURE__*/_interopDefaultCompat(openBrowser);
var webpack__default = /*#__PURE__*/_interopDefaultCompat(webpack);
var WebpackDevServer__default = /*#__PURE__*/_interopDefaultCompat(WebpackDevServer);

async function serveBundle(options) {
  const paths$2 = paths.resolveBundlingPaths(options);
  const targetPkg = await fs__default.default.readJson(paths$2.targetPackageJson);
  if (options.verifyVersions) {
    if (targetPkg.dependencies?.["react-router"]?.includes("beta") || targetPkg.dependencies?.["react-router-dom"]?.includes("beta")) {
      console.warn(
        chalk__default.default.yellow(`
DEPRECATION WARNING: React Router Beta is deprecated and support for it will be removed in a future release.
                     Please migrate to use React Router v6 stable.
                     See https://backstage.io/docs/tutorials/react-router-stable-migration
`)
      );
    }
  }
  checkReactVersion();
  const { name } = await fs__default.default.readJson(paths$1.paths.resolveTarget("package.json"));
  let webpackServer = void 0;
  let viteServer = void 0;
  let latestFrontendAppConfigs = [];
  const triggerReload = () => {
    if (viteServer) {
      viteServer.restart();
    }
    if (webpackServer) {
      webpackServer.invalidate();
      if (process.env.EXPERIMENTAL_RSPACK) {
        webpackServer.sendMessage(
          webpackServer.webSocketServer?.clients ?? [],
          "static-changed"
        );
      }
    }
  };
  const cliConfig = await config.loadCliConfig({
    args: options.configPaths,
    fromPackage: name,
    withFilteredKeys: true,
    watch(appConfigs) {
      latestFrontendAppConfigs = appConfigs;
      triggerReload();
    }
  });
  latestFrontendAppConfigs = cliConfig.frontendAppConfigs;
  const appBaseUrl = cliConfig.frontendConfig.getOptionalString("app.baseUrl");
  const backendBaseUrl = cliConfig.frontendConfig.getOptionalString("backend.baseUrl");
  if (appBaseUrl && appBaseUrl === backendBaseUrl) {
    console.log(
      chalk__default.default.yellow(
        `\u26A0\uFE0F   Conflict between app baseUrl and backend baseUrl:

    app.baseUrl:     ${appBaseUrl}
    backend.baseUrl: ${backendBaseUrl}

    Must have unique hostname and/or ports.

    This can be resolved by changing app.baseUrl and backend.baseUrl to point to their respective local development ports.
`
      )
    );
  }
  const { frontendConfig, fullConfig } = cliConfig;
  const url = config$1.resolveBaseUrl(frontendConfig, options.moduleFederation);
  const { host, port } = config$1.resolveEndpoint(
    frontendConfig,
    options.moduleFederation
  );
  const detectedModulesEntryPoint = await packageDetection.createDetectedModulesEntryPoint({
    config: fullConfig,
    targetPath: paths$2.targetPath,
    watch() {
      triggerReload();
    }
  });
  const rspack = process.env.EXPERIMENTAL_RSPACK ? require("@rspack/core") : void 0;
  const commonConfigOptions = {
    ...options,
    checksEnabled: options.checksEnabled,
    isDev: true,
    baseUrl: url,
    frontendConfig,
    rspack,
    getFrontendAppConfigs: () => {
      return latestFrontendAppConfigs;
    }
  };
  const config$2 = await config$1.createConfig(paths$2, {
    ...commonConfigOptions,
    additionalEntryPoints: detectedModulesEntryPoint,
    moduleFederation: options.moduleFederation
  });
  if (process.env.EXPERIMENTAL_VITE) {
    const vite = require("vite");
    const { default: viteReact } = require("@vitejs/plugin-react");
    const { default: viteYaml } = require("@modyfi/vite-plugin-yaml");
    const { nodePolyfills: viteNodePolyfills } = require("vite-plugin-node-polyfills");
    const { createHtmlPlugin: viteHtml } = require("vite-plugin-html");
    viteServer = await vite.createServer({
      define: {
        "process.argv": JSON.stringify(process.argv),
        "process.env.APP_CONFIG": JSON.stringify(cliConfig.frontendAppConfigs),
        // This allows for conditional imports of react-dom/client, since there's no way
        // to check for presence of it in source code without module resolution errors.
        "process.env.HAS_REACT_DOM_CLIENT": JSON.stringify(hasReactDomClient.hasReactDomClient())
      },
      optimizeDeps: {
        esbuildOptions: {
          plugins: [
            {
              name: "custom-define",
              setup(build) {
                const define = build.initialOptions.define ||= {};
                define["process.env.HAS_REACT_DOM_CLIENT"] = JSON.stringify(
                  hasReactDomClient.hasReactDomClient()
                );
                define["process.env.NODE_ENV"] = JSON.stringify("development");
              }
            }
          ]
        }
      },
      plugins: [
        viteReact(),
        viteNodePolyfills({
          include: [
            "buffer",
            "events",
            "fs",
            "http",
            "https",
            "os",
            "path",
            "process",
            "querystring",
            "stream",
            "url",
            "util",
            "zlib"
          ],
          globals: {
            global: true,
            Buffer: true,
            process: true
          }
        }),
        viteYaml(),
        viteHtml({
          entry: paths$2.targetEntry,
          // todo(blam): we should look at contributing to thPe plugin here
          // to support absolute paths, but works in the interim at least.
          template: "public/index.html",
          inject: {
            data: {
              config: frontendConfig,
              publicPath: config$2.output?.publicPath
            }
          }
        })
      ],
      server: {
        host,
        port
      },
      publicDir: paths$2.targetPublic,
      root: paths$2.targetPath
    });
  } else {
    const bundler = rspack ?? webpack__default.default;
    const DevServer = rspack ? require("@rspack/dev-server").RspackDevServer : WebpackDevServer__default.default;
    if (rspack) {
      console.log(
        chalk__default.default.yellow(`\u26A0\uFE0F  WARNING: Using experimental RSPack dev server.`)
      );
    }
    const publicPaths = await paths.resolveOptionalBundlingPaths({
      entry: "src/index-public-experimental",
      dist: "dist/public"
    });
    if (publicPaths) {
      console.log(
        chalk__default.default.yellow(
          `\u26A0\uFE0F  WARNING: The app /public entry point is an experimental feature that may receive immediate breaking changes.`
        )
      );
    }
    const compiler = publicPaths ? bundler([config$2, await config$1.createConfig(publicPaths, commonConfigOptions)]) : bundler(config$2);
    webpackServer = new DevServer(
      {
        hot: !process.env.CI,
        devMiddleware: {
          publicPath: config$2.output?.publicPath,
          stats: "errors-warnings"
        },
        static: paths$2.targetPublic ? {
          publicPath: config$2.output?.publicPath,
          directory: paths$2.targetPublic
        } : void 0,
        historyApiFallback: options.moduleFederation?.mode === "remote" ? false : {
          // Paths with dots should still use the history fallback.
          // See https://github.com/facebookincubator/create-react-app/issues/387.
          disableDotRule: true,
          // The index needs to be rewritten relative to the new public path, including subroutes.
          index: `${config$2.output?.publicPath}index.html`
        },
        server: url.protocol === "https:" ? {
          type: "https",
          options: {
            cert: fullConfig.getString("app.https.certificate.cert"),
            key: fullConfig.getString("app.https.certificate.key")
          }
        } : {},
        host,
        port,
        proxy: targetPkg.proxy,
        // When the dev server is behind a proxy, the host and public hostname differ
        allowedHosts: [url.hostname],
        client: {
          webSocketURL: { hostname: host, port }
        },
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, OPTIONS",
          "Access-Control-Allow-Headers": "X-Requested-With, content-type, Authorization"
        }
      },
      compiler
    );
  }
  await viteServer?.listen();
  await new Promise(async (resolve, reject) => {
    if (webpackServer) {
      webpackServer.startCallback((err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    } else {
      resolve();
    }
  });
  if (!options.skipOpenBrowser) {
    openBrowser__default.default(url.href);
  }
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        webpackServer?.stop();
        viteServer?.close();
        process.exit();
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}
function checkReactVersion() {
  try {
    const reactPkgPath = require.resolve("react/package.json", {
      paths: [paths$1.paths.targetRoot]
    });
    const reactPkg = require(reactPkgPath);
    if (reactPkg.version.startsWith("16.")) {
      console.log(
        chalk__default.default.yellow(
          `
\u26A0\uFE0F                                                                           \u26A0\uFE0F
\u26A0\uFE0F You are using React version 16, which is deprecated for use in Backstage. \u26A0\uFE0F
\u26A0\uFE0F Please upgrade to React 17 by updating your packages/app dependencies.    \u26A0\uFE0F
\u26A0\uFE0F                                                                           \u26A0\uFE0F
`
        )
      );
    }
  } catch {
  }
}

exports.serveBundle = serveBundle;
//# sourceMappingURL=server.cjs.js.map
