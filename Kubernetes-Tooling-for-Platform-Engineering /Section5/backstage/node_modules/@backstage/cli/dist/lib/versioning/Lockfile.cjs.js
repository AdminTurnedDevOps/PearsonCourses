'use strict';

var fs = require('fs-extra');
var parsers = require('@yarnpkg/parsers');
var lockfile = require('@yarnpkg/lockfile');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const ENTRY_PATTERN = /^((?:@[^/]+\/)?[^@/]+)@(.+)$/;
const NEW_HEADER = `${[
  `# This file is generated by running "yarn install" inside your project.
`,
  `# Manual changes might be lost - proceed with caution!
`
].join(``)}
`;
const LEGACY_REGEX = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;
const SPECIAL_OBJECT_KEYS = [
  `__metadata`,
  `version`,
  `resolution`,
  `dependencies`,
  `peerDependencies`,
  `dependenciesMeta`,
  `peerDependenciesMeta`,
  `binaries`
];
class Lockfile {
  constructor(packages, data, legacy = false) {
    this.packages = packages;
    this.data = data;
    this.legacy = legacy;
  }
  static async load(path) {
    const lockfileContents = await fs__default.default.readFile(path, "utf8");
    return Lockfile.parse(lockfileContents);
  }
  static parse(content) {
    const legacy = LEGACY_REGEX.test(content);
    let data;
    try {
      data = parsers.parseSyml(content);
    } catch (err) {
      throw new Error(`Failed yarn.lock parse, ${err}`);
    }
    const packages = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(data)) {
      if (SPECIAL_OBJECT_KEYS.includes(key)) continue;
      const [, name, ranges] = ENTRY_PATTERN.exec(key) ?? [];
      if (!name) {
        throw new Error(`Failed to parse yarn.lock entry '${key}'`);
      }
      let queries = packages.get(name);
      if (!queries) {
        queries = [];
        packages.set(name, queries);
      }
      for (let range of ranges.split(/\s*,\s*/)) {
        if (range.startsWith(`${name}@`)) {
          range = range.slice(`${name}@`.length);
        }
        if (range.startsWith("npm:")) {
          range = range.slice("npm:".length);
        }
        queries.push({ range, version: value.version, dataKey: key });
      }
    }
    return new Lockfile(packages, data, legacy);
  }
  /** Get the entries for a single package in the lockfile */
  get(name) {
    return this.packages.get(name);
  }
  /** Returns the name of all packages available in the lockfile */
  keys() {
    return this.packages.keys();
  }
  toString() {
    return this.legacy ? lockfile.stringify(this.data) : NEW_HEADER + parsers.stringifySyml(this.data);
  }
}

exports.Lockfile = Lockfile;
//# sourceMappingURL=Lockfile.cjs.js.map
