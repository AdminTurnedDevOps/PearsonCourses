'use strict';

var chalk = require('chalk');
var inquirer = require('inquirer');
var index = require('./factories/index.cjs.js');
var partition = require('lodash/partition');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var inquirer__default = /*#__PURE__*/_interopDefaultCompat(inquirer);
var partition__default = /*#__PURE__*/_interopDefaultCompat(partition);

function applyPromptMessageTransforms(prompt, transforms) {
  return {
    ...prompt,
    message: prompt.message && (async (answers) => {
      if (typeof prompt.message === "function") {
        return transforms.message(await prompt.message(answers));
      }
      return transforms.message(await prompt.message);
    }),
    validate: prompt.validate && (async (...args) => {
      const result = await prompt.validate(...args);
      if (typeof result === "string") {
        return transforms.error(result);
      }
      return result;
    })
  };
}
class FactoryRegistry {
  static factoryMap = new Map(
    Object.values(index).map((factory) => [factory.name, factory])
  );
  static async interactiveSelect(preselected) {
    let selected = preselected;
    if (!selected) {
      const answers = await inquirer__default.default.prompt([
        {
          type: "list",
          name: "name",
          message: "What do you want to create?",
          choices: Array.from(this.factoryMap.values()).map((factory2) => ({
            name: `${factory2.name} - ${factory2.description}`,
            value: factory2.name
          }))
        }
      ]);
      selected = answers.name;
    }
    const factory = this.factoryMap.get(selected);
    if (!factory) {
      throw new Error(`Unknown selection '${selected}'`);
    }
    return factory;
  }
  static async populateOptions(factory, provided) {
    let currentOptions = provided;
    if (factory.optionsDiscovery) {
      const discoveredOptions = await factory.optionsDiscovery();
      currentOptions = {
        ...currentOptions,
        ...discoveredOptions
      };
    }
    if (factory.optionsPrompts) {
      const [hasAnswers, needsAnswers] = partition__default.default(
        factory.optionsPrompts,
        (option) => option.name in currentOptions
      );
      for (const option of hasAnswers) {
        const value = provided[option.name];
        if (option.validate) {
          const result = option.validate(value);
          if (result !== true) {
            throw new Error(`Invalid option '${option.name}'. ${result}`);
          }
        }
      }
      currentOptions = await inquirer__default.default.prompt(
        needsAnswers.map(
          (option) => applyPromptMessageTransforms(option, {
            message: chalk__default.default.blue,
            error: chalk__default.default.red
          })
        ),
        currentOptions
      );
    }
    return currentOptions;
  }
}

exports.FactoryRegistry = FactoryRegistry;
//# sourceMappingURL=FactoryRegistry.cjs.js.map
