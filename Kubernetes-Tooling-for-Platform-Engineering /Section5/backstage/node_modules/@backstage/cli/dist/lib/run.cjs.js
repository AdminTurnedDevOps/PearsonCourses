'use strict';

var child_process = require('child_process');
var errors$1 = require('./errors.cjs.js');
var util = require('util');
var errors = require('@backstage/errors');

const execFile = util.promisify(child_process.execFile);
async function run(name, args = [], options = {}) {
  const { stdoutLogFunc, stderrLogFunc } = options;
  const env = {
    ...process.env,
    FORCE_COLOR: "true",
    ...options.env ?? {}
  };
  const stdio = [
    "inherit",
    stdoutLogFunc ? "pipe" : "inherit",
    stderrLogFunc ? "pipe" : "inherit"
  ];
  const child = child_process.spawn(name, args, {
    stdio,
    shell: true,
    ...options,
    env
  });
  if (stdoutLogFunc && child.stdout) {
    child.stdout.on("data", stdoutLogFunc);
  }
  if (stderrLogFunc && child.stderr) {
    child.stderr.on("data", stderrLogFunc);
  }
  await waitForExit(child, name);
}
async function runPlain(cmd, ...args) {
  try {
    const { stdout } = await execFile(cmd, args, { shell: true });
    return stdout.trim();
  } catch (error) {
    errors.assertError(error);
    if ("stderr" in error) {
      process.stderr.write(error.stderr);
    }
    if (typeof error.code === "number") {
      throw new errors$1.ExitCodeError(error.code, [cmd, ...args].join(" "));
    }
    throw new errors.ForwardedError("Unknown execution error", error);
  }
}
async function runCheck(cmd, ...args) {
  try {
    await execFile(cmd, args, { shell: true });
    return true;
  } catch (error) {
    return false;
  }
}
async function waitForExit(child, name) {
  if (typeof child.exitCode === "number") {
    if (child.exitCode) {
      throw new errors$1.ExitCodeError(child.exitCode, name);
    }
    return;
  }
  await new Promise((resolve, reject) => {
    child.once("error", (error) => reject(error));
    child.once("exit", (code) => {
      if (code) {
        reject(new errors$1.ExitCodeError(code, name));
      } else {
        resolve();
      }
    });
  });
}

exports.execFile = execFile;
exports.run = run;
exports.runCheck = runCheck;
exports.runPlain = runPlain;
exports.waitForExit = waitForExit;
//# sourceMappingURL=run.cjs.js.map
