'use strict';

var chokidar = require('chokidar');
var ctrlcWindows = require('ctrlc-windows');
var IpcServer = require('../ipc/IpcServer.cjs.js');
var ServerDataStore = require('../ipc/ServerDataStore.cjs.js');
var debounce = require('lodash/debounce');
var url = require('url');
var path = require('path');
var paths = require('../paths.cjs.js');
var spawn = require('cross-spawn');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var debounce__default = /*#__PURE__*/_interopDefaultCompat(debounce);
var spawn__default = /*#__PURE__*/_interopDefaultCompat(spawn);

const loaderArgs = [
  "--enable-source-maps",
  "--require",
  require.resolve("@backstage/cli/config/nodeTransform.cjs")
  // TODO: Support modules, although there's currently no way to load them since import() is transpiled tp require()
];
async function runBackend(options) {
  const envEnv = process.env;
  if (!envEnv.NODE_ENV) {
    envEnv.NODE_ENV = "development";
  }
  const server = new IpcServer.IpcServer();
  ServerDataStore.ServerDataStore.bind(server);
  let exiting = false;
  let firstStart = true;
  let child;
  let watcher = void 0;
  let shutdownPromise = void 0;
  const watchedPaths = /* @__PURE__ */ new Set();
  const restart = debounce__default.default(async () => {
    if (firstStart) {
      firstStart = false;
    } else {
      console.log();
      console.log("Change detected, restarting the development server...");
      console.log();
    }
    if (shutdownPromise) {
      return;
    }
    if (child && !child.killed && child.exitCode === null) {
      shutdownPromise = new Promise((resolve) => child.once("exit", resolve));
      if (process.platform === "win32" && child.pid) {
        ctrlcWindows.ctrlc(child.pid);
      } else {
        child.kill();
      }
      await shutdownPromise;
      shutdownPromise = void 0;
    }
    if (exiting) {
      return;
    }
    const optionArgs = new Array();
    if (options.inspectEnabled) {
      const inspect = typeof options.inspectEnabled === "string" ? `--inspect=${options.inspectEnabled}` : "--inspect";
      optionArgs.push(inspect);
    } else if (options.inspectBrkEnabled) {
      const inspect = typeof options.inspectBrkEnabled === "string" ? `--inspect-brk=${options.inspectBrkEnabled}` : "--inspect-brk";
      optionArgs.push(inspect);
    }
    if (options.require) {
      optionArgs.push(`--require=${options.require}`);
    }
    const userArgs = process.argv.slice(["node", "backstage-cli", "package", "start"].length).filter((arg) => !optionArgs.includes(arg));
    child = spawn__default.default(
      process.execPath,
      [...loaderArgs, ...optionArgs, options.entry, ...userArgs],
      {
        stdio: ["ignore", "inherit", "inherit", "ipc"],
        env: {
          ...process.env,
          BACKSTAGE_CLI_LINKED_WORKSPACE: options.linkedWorkspace,
          BACKSTAGE_CLI_CHANNEL: "1",
          ESBK_TSCONFIG_PATH: paths.paths.resolveTargetRoot("tsconfig.json")
        },
        serialization: "advanced"
      }
    );
    server.addChild(child);
    child.on("message", (data) => {
      if (!watcher) {
        return;
      }
      if (typeof data === "object" && data?.type === "watch") {
        let path$1 = data.path;
        if (path$1.startsWith("file:")) {
          path$1 = url.fileURLToPath(path$1);
        }
        if (path.isAbsolute(path$1) && !watchedPaths.has(path$1)) {
          watchedPaths.add(path$1);
          watcher.add(path$1);
        }
      }
    });
  }, 100);
  restart();
  watcher = chokidar.watch(["./package.json"], {
    cwd: process.cwd(),
    ignoreInitial: true,
    ignorePermissionErrors: true
  }).on("all", restart);
  process.stdin.on("data", restart);
  const exitPromise = new Promise((resolveExitPromise) => {
    async function handleSignal(signal) {
      exiting = true;
      if (child && child.exitCode === null) {
        await new Promise((resolve) => {
          child.on("close", resolve);
          child.kill(signal);
        });
      }
      resolveExitPromise();
    }
    process.once("SIGINT", handleSignal);
    process.once("SIGTERM", handleSignal);
  });
  return () => exitPromise;
}

exports.runBackend = runBackend;
//# sourceMappingURL=runBackend.cjs.js.map
