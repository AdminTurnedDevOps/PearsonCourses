'use strict';

var chalk = require('chalk');
var entryPoints = require('../entryPoints.cjs.js');
var typeDistProject = require('../typeDistProject.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

async function getModuleFederationOptions(packageJson, packageDir, isModuleFederationRemote) {
  if (!isModuleFederationRemote && !process.env.EXPERIMENTAL_MODULE_FEDERATION) {
    return void 0;
  }
  console.log(
    chalk__default.default.yellow(
      `\u26A0\uFE0F  WARNING: Module federation is experimental and will receive immediate breaking changes in the future.`
    )
  );
  let exposes;
  const packageRole = packageJson.backstage?.role;
  if (isModuleFederationRemote && packageJson.exports && packageRole) {
    const project = await typeDistProject.createTypeDistProject();
    exposes = Object.fromEntries(
      entryPoints.readEntryPoints(packageJson).filter((ep) => {
        if (ep.mount === "./package.json") {
          return false;
        }
        if (ep.mount === ".") {
          return true;
        }
        return typeDistProject.getEntryPointDefaultFeatureType(
          packageRole,
          packageDir,
          project,
          ep.path
        ) !== null;
      }).map((ep) => [ep.mount, ep.path])
    );
  }
  return {
    mode: isModuleFederationRemote ? "remote" : "host",
    // The default output mode requires the name to be a usable as a code
    // symbol, there might be better options here but for now we need to
    // sanitize the name.
    name: packageJson.name.replaceAll("@", "").replaceAll("/", "__").replaceAll("-", "_"),
    exposes
  };
}

exports.getModuleFederationOptions = getModuleFederationOptions;
//# sourceMappingURL=moduleFederation.cjs.js.map
