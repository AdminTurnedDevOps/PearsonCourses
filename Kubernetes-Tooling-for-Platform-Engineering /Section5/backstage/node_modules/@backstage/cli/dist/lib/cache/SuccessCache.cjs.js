'use strict';

var fs = require('fs-extra');
var node_path = require('node:path');
var paths = require('../paths.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const DEFAULT_CACHE_BASE_PATH = "node_modules/.cache/backstage-cli";
const CACHE_MAX_AGE_MS = 7 * 24 * 36e5;
class SuccessCache {
  #path;
  /**
   * Trim any occurrences of the workspace root path from the input string. This
   * is useful to ensure stable hashes that don't vary based on the workspace
   * location.
   */
  static trimPaths(input) {
    return input.replaceAll(paths.paths.targetRoot, "");
  }
  constructor(name, basePath) {
    this.#path = node_path.resolve(basePath ?? DEFAULT_CACHE_BASE_PATH, name);
  }
  async read() {
    try {
      const stat = await fs__default.default.stat(this.#path);
      if (!stat.isDirectory()) {
        await fs__default.default.rm(this.#path);
        return /* @__PURE__ */ new Set();
      }
    } catch (error) {
      if (error.code === "ENOENT") {
        return /* @__PURE__ */ new Set();
      }
      throw error;
    }
    const items = await fs__default.default.readdir(this.#path);
    const returned = /* @__PURE__ */ new Set();
    const removed = /* @__PURE__ */ new Set();
    const now = Date.now();
    for (const item of items) {
      const split = item.split("_");
      if (split.length !== 2) {
        removed.add(item);
        continue;
      }
      const createdAt = parseInt(split[0], 10);
      if (Number.isNaN(createdAt) || now - createdAt > CACHE_MAX_AGE_MS) {
        removed.add(item);
      } else {
        returned.add(split[1]);
      }
    }
    for (const item of removed) {
      await fs__default.default.unlink(node_path.resolve(this.#path, item));
    }
    return returned;
  }
  async write(newEntries) {
    const now = Date.now();
    await fs__default.default.ensureDir(this.#path);
    const existingItems = await fs__default.default.readdir(this.#path);
    const empty = Buffer.alloc(0);
    for (const key of newEntries) {
      const trimmedItems = existingItems.filter(
        (item) => item.endsWith(`_${key}`)
      );
      for (const trimmedItem of trimmedItems) {
        await fs__default.default.unlink(node_path.resolve(this.#path, trimmedItem));
      }
      await fs__default.default.writeFile(node_path.resolve(this.#path, `${now}_${key}`), empty);
    }
  }
}

exports.SuccessCache = SuccessCache;
//# sourceMappingURL=SuccessCache.cjs.js.map
