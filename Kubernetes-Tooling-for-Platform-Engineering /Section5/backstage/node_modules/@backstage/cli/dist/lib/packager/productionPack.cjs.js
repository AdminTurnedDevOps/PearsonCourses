'use strict';

var fs = require('fs-extra');
var npmPackList = require('npm-packlist');
var path = require('path');
var entryPoints = require('../entryPoints.cjs.js');
var typeDistProject = require('../typeDistProject.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var npmPackList__default = /*#__PURE__*/_interopDefaultCompat(npmPackList);

const PKG_PATH = "package.json";
const PKG_BACKUP_PATH = "package.json-prepack";
const SKIPPED_KEYS = ["access", "registry", "tag"];
const SCRIPT_EXTS = [".js", ".jsx", ".ts", ".tsx"];
async function productionPack(options) {
  const { packageDir, targetDir } = options;
  const pkgPath = path.resolve(packageDir, PKG_PATH);
  const pkgContent = await fs__default.default.readFile(pkgPath, "utf8");
  const pkg = JSON.parse(pkgContent);
  if (!targetDir) {
    await fs__default.default.writeFile(PKG_BACKUP_PATH, pkgContent);
  }
  await rewriteEntryPoints(pkg, packageDir, options.featureDetectionProject);
  const publishConfig = pkg.publishConfig ?? {};
  for (const key of Object.keys(publishConfig)) {
    if (!SKIPPED_KEYS.includes(key)) {
      pkg[key] = publishConfig[key];
    }
  }
  if (pkg.bundled) {
    delete pkg.dependencies;
    delete pkg.devDependencies;
    delete pkg.peerDependencies;
    delete pkg.optionalDependencies;
  }
  if (targetDir) {
    const filePaths = await npmPackList__default.default({
      path: packageDir,
      // This makes sure we use the updated package.json when listing files
      packageJsonCache: /* @__PURE__ */ new Map([
        [path.resolve(packageDir, PKG_PATH), pkg]
      ])
      // Seems like this parameter type is wrong,
    });
    await fs__default.default.ensureDir(targetDir);
    for (const filePath of filePaths.sort()) {
      const target = path.resolve(targetDir, filePath);
      if (filePath === PKG_PATH) {
        await fs__default.default.writeJson(target, pkg, { encoding: "utf8", spaces: 2 });
      } else {
        await fs__default.default.copy(path.resolve(packageDir, filePath), target);
      }
    }
  } else {
    await fs__default.default.writeJson(pkgPath, pkg, { encoding: "utf8", spaces: 2 });
  }
}
async function revertProductionPack(packageDir) {
  try {
    await fs__default.default.move(PKG_BACKUP_PATH, PKG_PATH, { overwrite: true });
    const pkg = await fs__default.default.readJson(PKG_PATH);
    const entryPoints$1 = entryPoints.readEntryPoints(pkg);
    for (const entryPoint of entryPoints$1) {
      if (entryPoint.mount !== "." && SCRIPT_EXTS.includes(entryPoint.ext)) {
        await fs__default.default.remove(path.resolve(packageDir, entryPoint.name));
      }
    }
  } catch (error) {
    console.warn(
      `Failed to restore package.json, ${error}. Your package will be fine but you may have ended up with some garbage in the repo.`
    );
  }
}
const EXPORT_MAP = {
  import: ".esm.js",
  require: ".cjs.js",
  types: ".d.ts"
};
async function rewriteEntryPoints(pkg, packageDir, featureDetectionProject) {
  const distPath = path.resolve(packageDir, "dist");
  if (!await fs__default.default.pathExists(distPath)) {
    return void 0;
  }
  const distFiles = await fs__default.default.readdir(distPath);
  const outputExports = {};
  const entryPoints$1 = entryPoints.readEntryPoints(pkg);
  if (pkg.typesVersions) {
    pkg.typesVersions = { "*": {} };
  }
  for (const entryPoint of entryPoints$1) {
    if (!SCRIPT_EXTS.includes(entryPoint.ext)) {
      outputExports[entryPoint.mount] = entryPoint.path;
      continue;
    }
    let exp = {};
    for (const [key, ext] of Object.entries(EXPORT_MAP)) {
      const name = `${entryPoint.name}${ext}`;
      if (distFiles.includes(name)) {
        exp[key] = `./${path.posix.join(`dist`, name)}`;
      }
    }
    if (exp.types) {
      if (!pkg.typesVersions) {
        pkg.typesVersions = { "*": {} };
      }
      pkg.typesVersions["*"][entryPoint.name] = [
        `dist/${entryPoint.name}.d.ts`
      ];
    }
    exp.default = exp.require ?? exp.import;
    if (exp.types && featureDetectionProject) {
      const defaultFeatureType = pkg.backstage?.role && typeDistProject.getEntryPointDefaultFeatureType(
        pkg.backstage?.role,
        packageDir,
        featureDetectionProject,
        exp.types
      );
      if (defaultFeatureType) {
        exp = { backstage: defaultFeatureType, ...exp };
      }
    }
    if (entryPoint.mount === ".") {
      if (exp.default) {
        pkg.main = exp.default;
      }
      if (exp.import) {
        pkg.module = exp.import;
      }
      if (exp.types) {
        pkg.types = exp.types;
      }
    }
    if (Object.keys(exp).length > 0) {
      outputExports[entryPoint.mount] = exp;
    }
  }
  if (pkg.exports) {
    pkg.exports = outputExports;
    pkg.exports["./package.json"] = "./package.json";
  }
  return void 0;
}

exports.productionPack = productionPack;
exports.revertProductionPack = revertProductionPack;
//# sourceMappingURL=productionPack.cjs.js.map
