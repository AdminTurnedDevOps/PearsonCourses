'use strict';

var config = require('@backstage/config');
var chokidar = require('chokidar');
var fs = require('fs-extra');
var PQueue = require('p-queue');
var path = require('path');
var paths = require('../paths.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

const DETECTED_MODULES_MODULE_NAME = "__backstage-autodetected-plugins__";
function readPackageDetectionConfig(config$1) {
  const packages = config$1.getOptional("app.experimental.packages");
  if (packages === void 0 || packages === null) {
    return void 0;
  }
  if (typeof packages === "string") {
    if (packages !== "all") {
      throw new Error(
        `Invalid app.experimental.packages mode, got '${packages}', expected 'all'`
      );
    }
    return {};
  }
  if (typeof packages !== "object" || Array.isArray(packages)) {
    throw new Error(
      "Invalid config at 'app.experimental.packages', expected object"
    );
  }
  const packagesConfig = new config.ConfigReader(
    packages,
    "app.experimental.packages"
  );
  return {
    include: packagesConfig.getOptionalStringArray("include"),
    exclude: packagesConfig.getOptionalStringArray("exclude")
  };
}
async function detectPackages(targetPath, { include, exclude }) {
  const pkg = await fs__default.default.readJson(
    path.resolve(targetPath, "package.json")
  );
  return Object.keys(pkg.dependencies ?? {}).flatMap((depName) => {
    if (exclude?.includes(depName)) {
      return [];
    }
    if (include && !include.includes(depName)) {
      return [];
    }
    try {
      const depPackageJson = require(require.resolve(
        `${depName}/package.json`,
        { paths: [targetPath] }
      ));
      if (["frontend-plugin", "frontend-plugin-module"].includes(
        depPackageJson.backstage?.role ?? ""
      )) {
        const exp = depPackageJson.exports;
        if (exp && typeof exp === "object" && "./alpha" in exp) {
          return [
            { name: depName, import: depName },
            { name: depName, export: "./alpha", import: `${depName}/alpha` }
          ];
        }
        return [{ name: depName, import: depName }];
      }
    } catch {
    }
    return [];
  });
}
const writeQueue = new PQueue__default.default({ concurrency: 1 });
async function writeDetectedPackagesModule(pkgs) {
  const requirePackageScript = pkgs?.map(
    (pkg) => `{ name: ${JSON.stringify(pkg.name)}, export: ${JSON.stringify(
      pkg.export
    )}, default: require('${pkg.import}').default }`
  ).join(",");
  await writeQueue.add(
    () => fs__default.default.writeFile(
      path.join(
        paths.paths.targetRoot,
        "node_modules",
        `${DETECTED_MODULES_MODULE_NAME}.js`
      ),
      `window['__@backstage/discovered__'] = { modules: [${requirePackageScript}] };`
    )
  );
}
async function createDetectedModulesEntryPoint(options) {
  const { config, watch, targetPath } = options;
  const detectionConfig = readPackageDetectionConfig(config);
  if (!detectionConfig) {
    return [];
  }
  if (watch) {
    const watcher = chokidar__default.default.watch(path.resolve(targetPath, "package.json"));
    watcher.on("change", async () => {
      await writeDetectedPackagesModule(
        await detectPackages(targetPath, detectionConfig)
      );
      watch();
    });
  }
  await writeDetectedPackagesModule(
    await detectPackages(targetPath, detectionConfig)
  );
  return [DETECTED_MODULES_MODULE_NAME];
}

exports.createDetectedModulesEntryPoint = createDetectedModulesEntryPoint;
//# sourceMappingURL=packageDetection.cjs.js.map
