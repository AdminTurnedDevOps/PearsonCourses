'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var path = require('path');
var pLimit = require('p-limit');
var os = require('os');
var tar = require('tar');
var partition = require('lodash/partition');
var paths = require('../paths.cjs.js');
var run = require('../run.cjs.js');
var _package = require('../../packages/cli/package.json.cjs.js');
var packager = require('../builder/packager.cjs.js');
var types = require('../builder/types.cjs.js');
var productionPack = require('./productionPack.cjs.js');
var cliNode = require('@backstage/cli-node');
var parallel = require('../parallel.cjs.js');
var typeDistProject = require('../typeDistProject.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);
var tar__default = /*#__PURE__*/_interopDefaultCompat(tar);
var partition__default = /*#__PURE__*/_interopDefaultCompat(partition);

const UNSAFE_PACKAGES = [
  ...Object.keys(_package.dependencies),
  ...Object.keys(_package.devDependencies)
];
function prefixLogFunc(prefix, out) {
  return (data) => {
    for (const line of data.toString("utf8").split(/\r?\n/)) {
      process[out].write(`${prefix} ${line}
`);
    }
  };
}
async function createDistWorkspace(packageNames, options = {}) {
  const targetDir = options.targetDir ?? await fs__default.default.mkdtemp(path.resolve(os.tmpdir(), "dist-workspace"));
  const packages = await cliNode.PackageGraph.listTargetPackages();
  const packageGraph = cliNode.PackageGraph.fromPackages(packages);
  const targetNames = packageGraph.collectPackageNames(packageNames, (node) => {
    if (node.packageJson.bundled) {
      return void 0;
    }
    return node.publishedLocalDependencies.keys();
  });
  const targets = Array.from(targetNames).map((name) => packageGraph.get(name));
  if (options.buildDependencies) {
    const exclude = options.buildExcludes ?? [];
    const configPaths = options.configPaths ?? [];
    const toBuild = new Set(
      targets.map((_) => _.name).filter((name) => !exclude.includes(name))
    );
    const standardBuilds = new Array();
    const customBuild = new Array();
    for (const pkg of packages) {
      if (!toBuild.has(pkg.packageJson.name)) {
        continue;
      }
      const role = pkg.packageJson.backstage?.role;
      if (!role) {
        console.warn(
          `Building ${pkg.packageJson.name} separately because it has no role`
        );
        customBuild.push({ dir: pkg.dir, name: pkg.packageJson.name });
        continue;
      }
      const buildScript = pkg.packageJson.scripts?.build;
      if (!buildScript) {
        customBuild.push({ dir: pkg.dir, name: pkg.packageJson.name });
        continue;
      }
      if (!buildScript.startsWith("backstage-cli package build")) {
        console.warn(
          `Building ${pkg.packageJson.name} separately because it has a custom build script, '${buildScript}'`
        );
        customBuild.push({ dir: pkg.dir, name: pkg.packageJson.name });
        continue;
      }
      if (cliNode.PackageRoles.getRoleInfo(role).output.includes("bundle")) {
        console.warn(
          `Building ${pkg.packageJson.name} separately because it is a bundled package`
        );
        const args = buildScript.includes("--config") ? [] : configPaths.map((p) => ["--config", p]).flat();
        customBuild.push({ dir: pkg.dir, name: pkg.packageJson.name, args });
        continue;
      }
      const outputs = packager.getOutputsForRole(role);
      outputs.delete(types.Output.types);
      if (outputs.size > 0) {
        standardBuilds.push({
          targetDir: pkg.dir,
          packageJson: pkg.packageJson,
          outputs,
          logPrefix: `${chalk__default.default.cyan(path.relative(paths.paths.targetRoot, pkg.dir))}: `,
          minify: options.minify,
          workspacePackages: packages
        });
      }
    }
    await packager.buildPackages(standardBuilds);
    if (customBuild.length > 0) {
      await parallel.runParallelWorkers({
        items: customBuild,
        worker: async ({ name, dir, args }) => {
          await run.run("yarn", ["run", "build", ...args || []], {
            cwd: dir,
            stdoutLogFunc: prefixLogFunc(`${name}: `, "stdout"),
            stderrLogFunc: prefixLogFunc(`${name}: `, "stderr")
          });
        }
      });
    }
  }
  await moveToDistWorkspace(
    targetDir,
    targets,
    Boolean(options.alwaysPack),
    Boolean(options.enableFeatureDetection)
  );
  const files = options.files ?? ["yarn.lock", "package.json"];
  for (const file of files) {
    const src = typeof file === "string" ? file : file.src;
    const dest = typeof file === "string" ? file : file.dest;
    await fs__default.default.copy(paths.paths.resolveTargetRoot(src), path.resolve(targetDir, dest));
  }
  if (options.skeleton) {
    const skeletonFiles = targets.map((target) => {
      const dir = path.relative(paths.paths.targetRoot, target.dir);
      return path.join(dir, "package.json");
    }).sort();
    await tar__default.default.create(
      {
        file: path.resolve(targetDir, options.skeleton),
        cwd: targetDir,
        portable: true,
        noMtime: true,
        gzip: options.skeleton.endsWith(".gz")
      },
      skeletonFiles
    );
  }
  return targetDir;
}
const FAST_PACK_SCRIPTS = [
  void 0,
  "backstage-cli prepack",
  "backstage-cli package prepack"
];
async function moveToDistWorkspace(workspaceDir, localPackages, alwaysPack, enableFeatureDetection) {
  const [fastPackPackages, slowPackPackages] = partition__default.default(
    localPackages,
    (pkg) => !alwaysPack && FAST_PACK_SCRIPTS.includes(pkg.packageJson.scripts?.prepack)
  );
  const featureDetectionProject = fastPackPackages.length > 0 && enableFeatureDetection ? await typeDistProject.createTypeDistProject() : void 0;
  await Promise.all(
    fastPackPackages.map(async (target) => {
      console.log(`Moving ${target.name} into dist workspace`);
      const outputDir = path.relative(paths.paths.targetRoot, target.dir);
      const absoluteOutputPath = path.resolve(workspaceDir, outputDir);
      await productionPack.productionPack({
        packageDir: target.dir,
        targetDir: absoluteOutputPath,
        featureDetectionProject
      });
    })
  );
  async function pack(target, archive) {
    console.log(`Repacking ${target.name} into dist workspace`);
    const archivePath = path.resolve(workspaceDir, archive);
    await run.run("yarn", ["pack", "--filename", archivePath], {
      cwd: target.dir
    });
    const outputDir = path.relative(paths.paths.targetRoot, target.dir);
    const absoluteOutputPath = path.resolve(workspaceDir, outputDir);
    await fs__default.default.ensureDir(absoluteOutputPath);
    await tar__default.default.extract({
      file: archivePath,
      cwd: absoluteOutputPath,
      strip: 1
    });
    await fs__default.default.remove(archivePath);
    if (target.packageJson.bundled) {
      const pkgJson = await fs__default.default.readJson(
        path.resolve(absoluteOutputPath, "package.json")
      );
      delete pkgJson.dependencies;
      delete pkgJson.devDependencies;
      delete pkgJson.peerDependencies;
      delete pkgJson.optionalDependencies;
      await fs__default.default.writeJson(
        path.resolve(absoluteOutputPath, "package.json"),
        pkgJson,
        {
          spaces: 2
        }
      );
    }
  }
  const [unsafePackages, safePackages] = partition__default.default(
    slowPackPackages,
    (p) => UNSAFE_PACKAGES.includes(p.name)
  );
  for (const target of unsafePackages) {
    await pack(target, `temp-package.tgz`);
  }
  const limit = pLimit__default.default(10);
  await Promise.all(
    safePackages.map(
      (target, index) => limit(() => pack(target, `temp-package-${index}.tgz`))
    )
  );
}

exports.createDistWorkspace = createDistWorkspace;
//# sourceMappingURL=createDistWorkspace.cjs.js.map
