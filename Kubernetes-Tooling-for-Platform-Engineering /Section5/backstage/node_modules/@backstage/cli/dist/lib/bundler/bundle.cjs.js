'use strict';

var yn = require('yn');
var fs = require('fs-extra');
var path = require('path');
var webpack = require('webpack');
var FileSizeReporter = require('react-dev-utils/FileSizeReporter');
var formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');
var config = require('./config.cjs.js');
var paths = require('./paths.cjs.js');
var chalk = require('chalk');
var packageDetection = require('./packageDetection.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var webpack__default = /*#__PURE__*/_interopDefaultCompat(webpack);
var formatWebpackMessages__default = /*#__PURE__*/_interopDefaultCompat(formatWebpackMessages);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
function applyContextToError(error, moduleName) {
  return `Failed to compile '${moduleName}':
  ${error}`;
}
async function buildBundle(options) {
  const { statsJsonEnabled, schema: configSchema, rspack } = options;
  const paths$1 = paths.resolveBundlingPaths(options);
  const publicPaths = await paths.resolveOptionalBundlingPaths({
    targetDir: options.targetDir,
    entry: "src/index-public-experimental",
    dist: "dist/public"
  });
  const commonConfigOptions = {
    ...options,
    checksEnabled: false,
    isDev: false,
    getFrontendAppConfigs: () => options.frontendAppConfigs
  };
  const configs = [];
  if (options.moduleFederation?.mode === "remote") {
    configs.push(await config.createConfig(paths$1, commonConfigOptions));
  } else {
    const detectedModulesEntryPoint = await packageDetection.createDetectedModulesEntryPoint({
      config: options.fullConfig,
      targetPath: paths$1.targetPath
    });
    configs.push(
      await config.createConfig(paths$1, {
        ...commonConfigOptions,
        additionalEntryPoints: detectedModulesEntryPoint,
        appMode: publicPaths ? "protected" : "public"
      })
    );
    if (publicPaths) {
      console.log(
        chalk__default.default.yellow(
          `\u26A0\uFE0F  WARNING: The app /public entry point is an experimental feature that may receive immediate breaking changes.`
        )
      );
      configs.push(
        await config.createConfig(publicPaths, {
          ...commonConfigOptions,
          appMode: "public"
        })
      );
    }
  }
  const isCi = yn__default.default(process.env.CI, { default: false });
  const previousFileSizes = await FileSizeReporter.measureFileSizesBeforeBuild(paths$1.targetDist);
  const previousAuthSizes = publicPaths ? await FileSizeReporter.measureFileSizesBeforeBuild(publicPaths.targetDist) : void 0;
  await fs__default.default.emptyDir(paths$1.targetDist);
  if (paths$1.targetPublic) {
    await fs__default.default.copy(paths$1.targetPublic, paths$1.targetDist, {
      dereference: true,
      filter: (file) => file !== paths$1.targetHtml
    });
    if (publicPaths) {
      await fs__default.default.copy(paths$1.targetPublic, publicPaths.targetDist, {
        dereference: true,
        filter: (file) => file !== paths$1.targetHtml
      });
    }
  }
  if (configSchema) {
    await fs__default.default.writeJson(
      path.resolve(paths$1.targetDist, ".config-schema.json"),
      configSchema.serialize(),
      { spaces: 2 }
    );
  }
  if (rspack) {
    console.log(
      chalk__default.default.yellow(`\u26A0\uFE0F  WARNING: Using experimental RSPack bundler.`)
    );
  }
  const { stats } = await build(configs, isCi, rspack);
  if (!stats) {
    throw new Error("No stats returned");
  }
  const [mainStats, authStats] = stats.stats;
  if (statsJsonEnabled) {
    await require("bfj").write(
      path.resolve(paths$1.targetDist, "bundle-stats.json"),
      mainStats.toJson()
    );
  }
  FileSizeReporter.printFileSizesAfterBuild(
    mainStats,
    previousFileSizes,
    paths$1.targetDist,
    WARN_AFTER_BUNDLE_GZIP_SIZE,
    WARN_AFTER_CHUNK_GZIP_SIZE
  );
  if (publicPaths && previousAuthSizes) {
    FileSizeReporter.printFileSizesAfterBuild(
      authStats,
      previousAuthSizes,
      publicPaths.targetDist,
      WARN_AFTER_BUNDLE_GZIP_SIZE,
      WARN_AFTER_CHUNK_GZIP_SIZE
    );
  }
}
async function build(configs, isCi, rspack) {
  const bundler = rspack ?? webpack__default.default;
  const stats = await new Promise(
    (resolve, reject) => {
      bundler(configs, (err, buildStats) => {
        if (err) {
          if (err.message) {
            const { errors: errors2 } = formatWebpackMessages__default.default({
              errors: [err.message],
              warnings: new Array(),
              _showErrors: true,
              _showWarnings: true
            });
            throw new Error(errors2[0]);
          } else {
            reject(err);
          }
        } else {
          resolve(buildStats);
        }
      });
    }
  );
  if (!stats) {
    throw new Error("Failed to compile: No stats provided");
  }
  const serializedStats = stats.toJson({
    all: false,
    warnings: true,
    errors: true
  });
  const { errors, warnings } = formatWebpackMessages__default.default({
    errors: serializedStats.errors,
    warnings: serializedStats.warnings
  });
  if (errors.length) {
    const errorWithContext = applyContextToError(
      errors[0],
      serializedStats.errors?.[0]?.moduleName ?? ""
    );
    throw new Error(errorWithContext);
  }
  if (isCi && warnings.length) {
    const warningsWithContext = warnings.map((warning, i) => {
      return applyContextToError(
        warning,
        serializedStats.warnings?.[i]?.moduleName ?? ""
      );
    });
    console.log(
      chalk__default.default.yellow(
        "\nTreating warnings as errors because process.env.CI = true.\n"
      )
    );
    throw new Error(warningsWithContext.join("\n\n"));
  }
  return { stats };
}

exports.buildBundle = buildBundle;
//# sourceMappingURL=bundle.cjs.js.map
