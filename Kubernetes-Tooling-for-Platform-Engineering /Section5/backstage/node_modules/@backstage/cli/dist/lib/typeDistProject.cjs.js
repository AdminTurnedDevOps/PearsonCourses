'use strict';

var path = require('path');
var tsMorph = require('ts-morph');
var paths = require('./paths.cjs.js');

const createTypeDistProject = async () => {
  return new tsMorph.Project({
    tsConfigFilePath: paths.paths.resolveTargetRoot("tsconfig.json"),
    skipAddingFilesFromTsConfig: true
  });
};
const targetPackageRoles = [
  "backend-plugin",
  "backend-plugin-module",
  "frontend-plugin",
  "frontend-plugin-module",
  "web-library",
  "node-library"
];
const targetFeatureTypes = [
  "@backstage/BackendFeature",
  "@backstage/BackstagePlugin",
  "@backstage/FrontendPlugin",
  "@backstage/FrontendModule"
];
const getEntryPointDefaultFeatureType = (role, packageDir, project, entryPoint) => {
  if (isTargetPackageRole(role)) {
    const distPath = path.resolve(packageDir, entryPoint);
    try {
      const defaultFeatureType = getSourceFileDefaultFeatureType(
        project.addSourceFileAtPath(distPath)
      );
      if (defaultFeatureType) {
        return defaultFeatureType;
      }
    } catch (error) {
      console.error(
        `Failed to extract default feature type from ${distPath}, ${error}. Your package will publish fine but it may be missing metadata about its default feature.`
      );
    }
  }
  return null;
};
function getSourceFileDefaultFeatureType(sourceFile) {
  for (const exportSymbol of sourceFile.getExportSymbols()) {
    const declaration = exportSymbol.getDeclarations()[0];
    const exportName = declaration.getSymbol()?.getName();
    if (exportName !== "default") {
      continue;
    }
    let exportType;
    if (declaration) {
      if (declaration.isKind(tsMorph.SyntaxKind.ExportAssignment)) {
        exportType = declaration.getExpression().getType();
      } else if (declaration.isKind(tsMorph.SyntaxKind.ExportSpecifier)) {
        if (!declaration.isTypeOnly()) {
          exportType = declaration.getType();
        }
      } else if (declaration.isKind(tsMorph.SyntaxKind.VariableDeclaration)) {
        exportType = declaration.getType();
      }
    }
    if (exportName && exportType) {
      const $$type = getBackstagePackageFeature$$TypeFromType(exportType);
      if ($$type) {
        return $$type;
      }
    }
  }
  return null;
}
function getBackstagePackageFeature$$TypeFromType(type) {
  const exportType = type.getTargetType() ?? type;
  for (const property of exportType.getProperties()) {
    if (property.getName() === "$$type") {
      const $$type = property.getValueDeclaration()?.getText().match(/(\$\$type: '(?<type>.+)')/)?.groups?.type;
      if ($$type && isTargetFeatureType($$type)) {
        return $$type;
      }
    }
  }
  return null;
}
function isTargetPackageRole(role) {
  return !!role && targetPackageRoles.includes(role);
}
function isTargetFeatureType(type) {
  return !!type && targetFeatureTypes.includes(type);
}

exports.createTypeDistProject = createTypeDistProject;
exports.getEntryPointDefaultFeatureType = getEntryPointDefaultFeatureType;
//# sourceMappingURL=typeDistProject.cjs.js.map
