'use strict';

var fs = require('fs-extra');
var path = require('path');
var cliNode = require('@backstage/cli-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const REACT_ROUTER_DEPS = ["react-router", "react-router-dom"];
const REACT_ROUTER_RANGE = "6.0.0-beta.0 || ^6.3.0";
async function command() {
  const packages = await cliNode.PackageGraph.listTargetPackages();
  await Promise.all(
    packages.map(async ({ dir, packageJson }) => {
      const role = cliNode.PackageRoles.getRoleFromPackage(packageJson);
      if (role === "frontend") {
        console.log(`Skipping ${packageJson.name}`);
        return;
      }
      let changed = false;
      for (const depName of ["dependencies", "devDependencies"]) {
        const depsCollection = packageJson[depName];
        if (depsCollection) {
          for (const key of Object.keys(depsCollection)) {
            if (REACT_ROUTER_DEPS.includes(key)) {
              delete depsCollection[key];
              const peerDeps = packageJson.peerDependencies = packageJson.peerDependencies ?? {};
              peerDeps[key] = REACT_ROUTER_RANGE;
              changed = true;
            }
          }
        }
      }
      if (changed) {
        console.log(`Updating dependencies for ${packageJson.name}`);
        await fs__default.default.writeJson(path.resolve(dir, "package.json"), packageJson, {
          spaces: 2
        });
      }
    })
  );
}

exports.command = command;
//# sourceMappingURL=reactRouterDeps.cjs.js.map
