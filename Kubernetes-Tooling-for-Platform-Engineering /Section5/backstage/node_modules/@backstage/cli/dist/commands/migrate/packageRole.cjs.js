'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs-extra');
var path = require('path');
var getPackages = require('@manypkg/get-packages');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

var packageRole = async () => {
  const { packages } = await getPackages.getPackages(paths.paths.targetDir);
  await Promise.all(
    packages.map(async ({ dir, packageJson: pkg }) => {
      const { name } = pkg;
      const existingRole = cliNode.PackageRoles.getRoleFromPackage(pkg);
      if (existingRole) {
        return;
      }
      const detectedRole = cliNode.PackageRoles.detectRoleFromPackage(pkg);
      if (!detectedRole) {
        console.error(`No role detected for package ${name}`);
        return;
      }
      console.log(`Detected package role of ${name} as ${detectedRole}`);
      let newPkg = pkg;
      const pkgKeys = Object.keys(pkg);
      if (pkgKeys.includes("backstage")) {
        newPkg.backstage = {
          ...newPkg.backstage,
          role: detectedRole
        };
      } else {
        const index = Math.max(
          pkgKeys.indexOf("version"),
          pkgKeys.indexOf("private"),
          pkgKeys.indexOf("publishConfig")
        ) + 1 || pkgKeys.length;
        const pkgEntries = Object.entries(pkg);
        pkgEntries.splice(index, 0, ["backstage", { role: detectedRole }]);
        newPkg = Object.fromEntries(pkgEntries);
      }
      await fs__default.default.writeJson(path.resolve(dir, "package.json"), newPkg, {
        spaces: 2
      });
    })
  );
};

exports.default = packageRole;
//# sourceMappingURL=packageRole.cjs.js.map
