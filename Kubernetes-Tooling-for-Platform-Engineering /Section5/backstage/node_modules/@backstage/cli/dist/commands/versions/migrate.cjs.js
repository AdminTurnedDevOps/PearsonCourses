'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cliNode = require('@backstage/cli-node');
var chalk = require('chalk');
var path = require('path');
var fs = require('fs-extra');
var minimatch = require('minimatch');
var utils = require('./utils.cjs.js');
var replace = require('replace-in-file');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var replace__default = /*#__PURE__*/_interopDefaultCompat(replace);

var migrate = async (options) => {
  const changed = await migrateMovedPackages({
    pattern: options.pattern,
    skipCodeChanges: options.skipCodeChanges
  });
  if (changed) {
    await utils.runYarnInstall();
  }
};
async function migrateMovedPackages(options) {
  console.log(
    "Checking for moved packages to the @backstage-community namespace..."
  );
  const packages = await cliNode.PackageGraph.listTargetPackages();
  let didAnythingChange = false;
  for (const pkg of packages) {
    const pkgName = pkg.packageJson.name;
    let didPackageChange = false;
    const movedPackages = /* @__PURE__ */ new Map();
    for (const depType of [
      "dependencies",
      "devDependencies",
      "peerDependencies"
    ]) {
      const depsObj = pkg.packageJson[depType];
      if (!depsObj) {
        continue;
      }
      for (const [depName, depVersion] of Object.entries(depsObj)) {
        if (options?.pattern && !minimatch.minimatch(depName, options.pattern)) {
          continue;
        }
        let packageInfo;
        try {
          packageInfo = await fs.readJson(
            require.resolve(`${depName}/package.json`, {
              paths: [pkg.dir]
            })
          );
        } catch (ex) {
          console.warn(
            chalk__default.default.yellow(
              `Could not find package.json for ${depName}@${depVersion} in ${pkgName} (${depType})`
            )
          );
          continue;
        }
        const movedPackageName = packageInfo.backstage?.moved;
        if (movedPackageName) {
          movedPackages.set(depName, movedPackageName);
          console.log(
            chalk__default.default.yellow(
              `Found a moved package ${depName}@${depVersion} -> ${movedPackageName} in ${pkgName} (${depType})`
            )
          );
          didPackageChange = true;
          didAnythingChange = true;
          depsObj[movedPackageName] = depsObj[depName];
          delete depsObj[depName];
        }
      }
    }
    if (didPackageChange) {
      await fs.writeJson(path.resolve(pkg.dir, "package.json"), pkg.packageJson, {
        spaces: 2
      });
      if (!options?.skipCodeChanges) {
        const files = await replace__default.default({
          files: path.join(pkg.dir, "src", "**"),
          allowEmptyPaths: true,
          processor: (content) => {
            return Array.from(movedPackages.entries()).reduce(
              (newContent, [oldName, newName]) => {
                return newContent.replace(new RegExp(`"${oldName}"`, "g"), `"${newName}"`).replace(new RegExp(`'${oldName}'`, "g"), `'${newName}'`).replace(new RegExp(`${oldName}/`, "g"), `${newName}/`);
              },
              content
            );
          }
        });
        if (files.length > 0) {
          console.log(
            chalk__default.default.green(
              `Updated ${files.length} files in ${pkgName} to use the new package names`
            )
          );
        }
      }
    }
  }
  return didAnythingChange;
}

exports.default = migrate;
exports.migrateMovedPackages = migrateMovedPackages;
//# sourceMappingURL=migrate.cjs.js.map
