'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var globalAgent = require('global-agent');
var fs = require('fs-extra');
var chalk = require('chalk');
var semver = require('semver');
var yaml = require('yaml');
var z = require('zod');
var errors = require('@backstage/errors');
var path = require('path');
var paths = require('../../lib/paths.cjs.js');
var Lockfile = require('../../lib/versioning/Lockfile.cjs.js');
var packages = require('../../lib/versioning/packages.cjs.js');
var cliCommon = require('@backstage/cli-common');
var parallel = require('../../lib/parallel.cjs.js');
var releaseManifests = require('@backstage/release-manifests');
var migrate = require('./migrate.cjs.js');
var utils = require('./utils.cjs.js');
var run = require('../../lib/run.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var semver__default = /*#__PURE__*/_interopDefaultCompat(semver);
var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);
var z__default = /*#__PURE__*/_interopDefaultCompat(z);

if (shouldUseGlobalAgent()) {
  globalAgent.bootstrap();
}
function shouldUseGlobalAgent() {
  const namespace = process.env.GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE ?? "GLOBAL_AGENT_";
  if (process.env[`${namespace}HTTP_PROXY`] || process.env[`${namespace}HTTPS_PROXY`]) {
    return true;
  }
  return false;
}
const DEP_TYPES = [
  "dependencies",
  "devDependencies",
  "peerDependencies",
  "optionalDependencies"
];
const DEFAULT_PATTERN_GLOB = "@backstage/*";
var bump = async (opts) => {
  const lockfilePath = paths.paths.resolveTargetRoot("yarn.lock");
  const lockfile = await Lockfile.Lockfile.load(lockfilePath);
  const hasYarnPlugin = await getHasYarnPlugin();
  let pattern = opts.pattern;
  if (!pattern) {
    console.log(`Using default pattern glob ${DEFAULT_PATTERN_GLOB}`);
    pattern = DEFAULT_PATTERN_GLOB;
  } else {
    console.log(`Using custom pattern glob ${pattern}`);
  }
  let findTargetVersion;
  let releaseManifest;
  if (semver__default.default.valid(opts.release)) {
    releaseManifest = await releaseManifests.getManifestByVersion({ version: opts.release });
    findTargetVersion = createStrictVersionFinder({
      releaseManifest
    });
  } else {
    if (opts.release === "next") {
      const next = await releaseManifests.getManifestByReleaseLine({
        releaseLine: "next"
      });
      const main = await releaseManifests.getManifestByReleaseLine({
        releaseLine: "main"
      });
      releaseManifest = semver__default.default.gt(next.releaseVersion, main.releaseVersion) ? next : main;
    } else {
      releaseManifest = await releaseManifests.getManifestByReleaseLine({
        releaseLine: opts.release
      });
    }
    findTargetVersion = createVersionFinder({
      releaseLine: opts.releaseLine,
      releaseManifest
    });
  }
  if (hasYarnPlugin) {
    console.log();
    console.log(
      `Updating yarn plugin to v${releaseManifest.releaseVersion}...`
    );
    console.log();
    await run.run("yarn", [
      "plugin",
      "import",
      `https://versions.backstage.io/v1/releases/${releaseManifest.releaseVersion}/yarn-plugin`
    ]);
    console.log();
  }
  const dependencyMap = await packages.mapDependencies(paths.paths.targetDir, pattern);
  const versionBumps = /* @__PURE__ */ new Map();
  await parallel.runParallelWorkers({
    parallelismFactor: 4,
    items: dependencyMap.entries(),
    async worker([name, pkgs]) {
      let target;
      try {
        target = await findTargetVersion(name);
      } catch (error) {
        if (errors.isError(error) && error.name === "NotFoundError") {
          console.log(`Package info not found, ignoring package ${name}`);
          return;
        }
        throw error;
      }
      for (const pkg of pkgs) {
        versionBumps.set(
          pkg.name,
          (versionBumps.get(pkg.name) ?? []).concat({
            name,
            location: pkg.location,
            range: `^${target}`,
            // TODO(Rugvip): Option to use something else than ^?
            target
          })
        );
      }
    }
  });
  if (versionBumps.size === 0) {
    console.log(chalk__default.default.green("All Backstage packages are up to date!"));
  } else {
    console.log(chalk__default.default.yellow("Some packages are outdated, updating"));
    console.log();
    const breakingUpdates = /* @__PURE__ */ new Map();
    await parallel.runParallelWorkers({
      parallelismFactor: 4,
      items: versionBumps.entries(),
      async worker([name, deps]) {
        const pkgPath = path.resolve(deps[0].location, "package.json");
        const pkgJson = await fs__default.default.readJson(pkgPath);
        for (const dep of deps) {
          console.log(
            `${chalk__default.default.cyan("bumping")} ${dep.name} in ${chalk__default.default.cyan(
              name
            )} to ${chalk__default.default.yellow(dep.range)}`
          );
          for (const depType of DEP_TYPES) {
            if (depType in pkgJson && dep.name in pkgJson[depType]) {
              const oldRange = pkgJson[depType][dep.name];
              const oldLockfileRange = await asLockfileVersion(oldRange);
              const useBackstageRange = hasYarnPlugin && // Only use backstage:^ versions if the package is present in
              // the manifest for the release we're bumping to.
              releaseManifest.packages.find(
                ({ name: manifestPackageName }) => dep.name === manifestPackageName
              ) && // Don't use backstage:^ versions for peerDependencies; they only
              // support npm and workspace: versions.
              depType !== "peerDependencies";
              const newRange = useBackstageRange ? "backstage:^" : dep.range;
              pkgJson[depType][dep.name] = newRange;
              const lockfileEntry = lockfile.get(dep.name)?.find((entry) => entry.range === oldLockfileRange);
              if (lockfileEntry) {
                const from = lockfileEntry.version;
                const to = dep.target;
                if (!semver__default.default.satisfies(to, `^${from}`)) {
                  breakingUpdates.set(dep.name, { from, to });
                }
              }
            }
          }
        }
        await fs__default.default.writeJson(pkgPath, pkgJson, { spaces: 2 });
      }
    });
    console.log();
    if (pattern === DEFAULT_PATTERN_GLOB) {
      await bumpBackstageJsonVersion(
        releaseManifest.releaseVersion,
        hasYarnPlugin
      );
    } else {
      console.log(
        chalk__default.default.yellow(
          `Skipping backstage.json update as custom pattern is used`
        )
      );
    }
    if (!opts.skipInstall) {
      await utils.runYarnInstall();
    } else {
      console.log();
      console.log(chalk__default.default.yellow(`Skipping yarn install`));
    }
    if (!opts.skipMigrate) {
      console.log();
      const changed = await migrate.migrateMovedPackages({
        pattern: opts.pattern
      });
      if (changed && !opts.skipInstall) {
        await utils.runYarnInstall();
      }
    }
    if (breakingUpdates.size > 0) {
      console.log();
      console.log(
        chalk__default.default.yellow("\u26A0\uFE0F  The following packages may have breaking changes:")
      );
      console.log();
      for (const [name, { from, to }] of Array.from(
        breakingUpdates.entries()
      ).sort()) {
        console.log(
          `  ${chalk__default.default.yellow(name)} : ${chalk__default.default.yellow(from)} ~> ${chalk__default.default.yellow(
            to
          )}`
        );
        let path;
        if (name.startsWith("@backstage/plugin-")) {
          path = `plugins/${name.replace("@backstage/plugin-", "")}`;
        } else if (name.startsWith("@backstage/")) {
          path = `packages/${name.replace("@backstage/", "")}`;
        }
        if (path) {
          console.log(
            `    https://github.com/backstage/backstage/blob/master/${path}/CHANGELOG.md`
          );
        }
        console.log();
      }
    } else {
      console.log();
    }
    if (hasYarnPlugin) {
      console.log();
      console.log(
        chalk__default.default.blue(
          `${chalk__default.default.bold(
            "NOTE"
          )}: this bump used backstage:^ versions in package.json files, since the Backstage yarn plugin was detected in the repository. To migrate back to explicit npm versions, remove the plugin by running "yarn plugin remove @yarnpkg/plugin-backstage", then repeat this command.`
        )
      );
      console.log();
    }
    console.log(chalk__default.default.green("Version bump complete!"));
  }
  console.log();
};
function createStrictVersionFinder(options) {
  const releasePackages = new Map(
    options.releaseManifest.packages.map((p) => [p.name, p.version])
  );
  return async function findTargetVersion(name) {
    console.log(`Checking for updates of ${name}`);
    const manifestVersion = releasePackages.get(name);
    if (manifestVersion) {
      return manifestVersion;
    }
    throw new errors.NotFoundError(`Package ${name} not found in release manifest`);
  };
}
function createVersionFinder(options) {
  const {
    releaseLine = "latest",
    packageInfoFetcher = packages.fetchPackageInfo,
    releaseManifest
  } = options;
  const distTag = releaseLine === "main" ? "latest" : releaseLine;
  const found = /* @__PURE__ */ new Map();
  const releasePackages = new Map(
    releaseManifest?.packages.map((p) => [p.name, p.version])
  );
  return async function findTargetVersion(name) {
    const existing = found.get(name);
    if (existing) {
      return existing;
    }
    console.log(`Checking for updates of ${name}`);
    const manifestVersion = releasePackages.get(name);
    if (manifestVersion) {
      return manifestVersion;
    }
    const info = await packageInfoFetcher(name);
    const latestVersion = info["dist-tags"].latest;
    if (!latestVersion) {
      throw new Error(`No target 'latest' version found for ${name}`);
    }
    const taggedVersion = info["dist-tags"][distTag];
    if (distTag === "latest" || !taggedVersion) {
      found.set(name, latestVersion);
      return latestVersion;
    }
    const latestVersionDateStr = info.time[latestVersion];
    const taggedVersionDateStr = info.time[taggedVersion];
    if (!latestVersionDateStr) {
      throw new Error(
        `No time available for version '${latestVersion}' of ${name}`
      );
    }
    if (!taggedVersionDateStr) {
      throw new Error(
        `No time available for version '${taggedVersion}' of ${name}`
      );
    }
    const latestVersionRelease = new Date(latestVersionDateStr).getTime();
    const taggedVersionRelease = new Date(taggedVersionDateStr).getTime();
    if (latestVersionRelease > taggedVersionRelease) {
      found.set(name, latestVersion);
      return latestVersion;
    }
    found.set(name, taggedVersion);
    return taggedVersion;
  };
}
function getBackstageJsonPath() {
  return paths.paths.resolveTargetRoot(cliCommon.BACKSTAGE_JSON);
}
async function getBackstageJson() {
  const backstageJsonPath = getBackstageJsonPath();
  return fs__default.default.readJSON(backstageJsonPath).catch((e) => {
    if (e.code === "ENOENT") {
      return;
    }
    throw e;
  });
}
async function bumpBackstageJsonVersion(version, useYarnPlugin) {
  const backstageJson = await getBackstageJson();
  const prevVersion = backstageJson?.version;
  if (prevVersion === version) {
    return;
  }
  const { yellow, cyan, green } = chalk__default.default;
  if (prevVersion) {
    const from = encodeURIComponent(prevVersion);
    const to = encodeURIComponent(version);
    let link = `https://backstage.github.io/upgrade-helper/?from=${from}&to=${to}`;
    if (useYarnPlugin) {
      link += "&yarnPlugin=1";
    }
    console.log(
      yellow(
        `Upgraded from release ${green(prevVersion)} to ${green(
          version
        )}, please review these template changes:`
      )
    );
    console.log();
    console.log(`  ${cyan(link)}`);
    console.log();
  } else {
    console.log(
      yellow(
        `Your project is now at version ${version}, which has been written to ${cliCommon.BACKSTAGE_JSON}`
      )
    );
  }
  await fs__default.default.writeJson(
    getBackstageJsonPath(),
    { ...backstageJson, version },
    {
      spaces: 2,
      encoding: "utf8"
    }
  );
}
async function asLockfileVersion(version) {
  if (version === "backstage:^") {
    return `backstage:${(await getBackstageJson())?.version}`;
  }
  return version;
}
const yarnRcSchema = z__default.default.object({
  plugins: z__default.default.array(
    z__default.default.object({
      path: z__default.default.string()
    })
  ).optional()
});
async function getHasYarnPlugin() {
  const yarnRcPath = paths.paths.resolveTargetRoot(".yarnrc.yml");
  const yarnRcContent = await fs__default.default.readFile(yarnRcPath, "utf-8").catch((e) => {
    if (e.code === "ENOENT") {
      return "";
    }
    throw e;
  });
  if (!yarnRcContent) {
    return false;
  }
  const parseResult = yarnRcSchema.safeParse(yaml__default.default.parse(yarnRcContent));
  if (!parseResult.success) {
    throw new Error(
      `Unexpected content in .yarnrc.yml: ${parseResult.error.toString()}`
    );
  }
  const yarnRc = parseResult.data;
  return yarnRc.plugins?.some(
    (plugin) => plugin.path === ".yarn/plugins/@yarnpkg/plugin-backstage.cjs"
  );
}

exports.bumpBackstageJsonVersion = bumpBackstageJsonVersion;
exports.createStrictVersionFinder = createStrictVersionFinder;
exports.createVersionFinder = createVersionFinder;
exports.default = bump;
//# sourceMappingURL=bump.cjs.js.map
