'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var os = require('os');
var fs = require('fs-extra');
var path = require('path');
var FactoryRegistry = require('../../lib/new/FactoryRegistry.cjs.js');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');
var errors = require('@backstage/errors');
var tasks = require('../../lib/tasks.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function parseOptions(optionStrings) {
  const options = {};
  for (const str of optionStrings) {
    const [key] = str.split("=", 1);
    const value = str.slice(key.length + 1);
    if (!key || str[key.length] !== "=") {
      throw new Error(
        `Invalid option '${str}', must be of the format <key>=<value>`
      );
    }
    options[key] = value;
  }
  return options;
}
var _new = async (opts) => {
  const factory = await FactoryRegistry.FactoryRegistry.interactiveSelect(opts.select);
  const providedOptions = parseOptions(opts.option);
  const options = await FactoryRegistry.FactoryRegistry.populateOptions(
    factory,
    providedOptions
  );
  let defaultVersion = "0.1.0";
  if (opts.baseVersion) {
    defaultVersion = opts.baseVersion;
  } else {
    const lernaVersion = await fs__default.default.readJson(paths.paths.resolveTargetRoot("lerna.json")).then((pkg) => pkg.version).catch(() => void 0);
    if (lernaVersion) {
      defaultVersion = lernaVersion;
    }
  }
  const tempDirs = new Array();
  async function createTemporaryDirectory(name) {
    const dir = await fs__default.default.mkdtemp(path.join(os__default.default.tmpdir(), name));
    tempDirs.push(dir);
    return dir;
  }
  const license = opts.license ?? "Apache-2.0";
  let modified = false;
  try {
    await factory.create(options, {
      isMonoRepo: await cliNode.isMonoRepo(),
      defaultVersion,
      license,
      scope: opts.scope?.replace(/^@/, ""),
      npmRegistry: opts.npmRegistry,
      private: Boolean(opts.private),
      createTemporaryDirectory,
      markAsModified() {
        modified = true;
      }
    });
    tasks.Task.log();
    tasks.Task.log(`\u{1F389}  Successfully created ${factory.name}`);
    tasks.Task.log();
  } catch (error) {
    errors.assertError(error);
    tasks.Task.error(error.message);
    if (modified) {
      tasks.Task.log("It seems that something went wrong in the creation process \u{1F914}");
      tasks.Task.log();
      tasks.Task.log(
        "We have left the changes that were made intact in case you want to"
      );
      tasks.Task.log(
        "continue manually, but you can also revert the changes and try again."
      );
      tasks.Task.error(`\u{1F525}  Failed to create ${factory.name}!`);
    }
  } finally {
    for (const dir of tempDirs) {
      try {
        await fs__default.default.remove(dir);
      } catch (error) {
        console.error(
          `Failed to remove temporary directory '${dir}', ${error}`
        );
      }
    }
  }
};

exports.default = _new;
//# sourceMappingURL=new.cjs.js.map
