'use strict';

var cliNode = require('@backstage/cli-node');
var fs = require('fs-extra');
var path = require('path');
var paths = require('../../lib/paths.cjs.js');
var publishing = require('../../lib/publishing.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

async function readFixablePackages() {
  const packages = await cliNode.PackageGraph.listTargetPackages();
  return packages.map((pkg) => ({ ...pkg, changed: false }));
}
function printPackageFixHint(packages) {
  const changed = packages.filter((pkg) => pkg.changed);
  if (changed.length > 0) {
    const rootPkg = require(paths.paths.resolveTargetRoot("package.json"));
    const fixCmd = rootPkg.scripts?.fix === "backstage-cli repo fix" ? "fix" : "backstage-cli repo fix";
    console.log(
      `The following packages are out of sync, run 'yarn ${fixCmd}' to fix them:`
    );
    for (const pkg of changed) {
      console.log(`  ${pkg.packageJson.name}`);
    }
    return true;
  }
  return false;
}
async function writeFixedPackages(packages) {
  await Promise.all(
    packages.map(async (pkg) => {
      if (!pkg.changed) {
        return;
      }
      await fs__default.default.writeJson(
        path.resolve(pkg.dir, "package.json"),
        pkg.packageJson,
        {
          spaces: 2
        }
      );
    })
  );
}
function trimRelative(path) {
  if (path.startsWith("./")) {
    return path.slice(2);
  }
  return path;
}
function fixPackageExports(pkg) {
  let { exports: exp } = pkg.packageJson;
  if (!exp) {
    return;
  }
  if (Array.isArray(exp)) {
    throw new Error("Unexpected array in package.json exports field");
  }
  if (typeof exp === "string") {
    pkg.changed = true;
    exp = { ".": exp };
    pkg.packageJson.exports = exp;
  } else if (typeof exp !== "object") {
    return;
  }
  if (!exp["./package.json"]) {
    pkg.changed = true;
    exp["./package.json"] = "./package.json";
  }
  const existingTypesVersions = JSON.stringify(pkg.packageJson.typesVersions);
  const typeEntries = {};
  for (const [path, value] of Object.entries(exp)) {
    if (path === ".") {
      continue;
    }
    const newPath = trimRelative(path);
    if (typeof value === "string") {
      typeEntries[newPath] = [trimRelative(value)];
    } else if (value && typeof value === "object" && !Array.isArray(value)) {
      if (typeof value.types === "string") {
        typeEntries[newPath] = [trimRelative(value.types)];
      } else if (typeof value.default === "string") {
        typeEntries[newPath] = [trimRelative(value.default)];
      }
    }
  }
  const typesVersions = { "*": typeEntries };
  if (existingTypesVersions !== JSON.stringify(typesVersions)) {
    const newPkgEntries = Object.entries(pkg.packageJson).filter(
      ([name]) => name !== "typesVersions"
    );
    newPkgEntries.splice(
      newPkgEntries.findIndex(([name]) => name === "exports") + 1,
      0,
      ["typesVersions", typesVersions]
    );
    pkg.packageJson = Object.fromEntries(newPkgEntries);
    pkg.changed = true;
  }
  const publishConfig = pkg.packageJson.publishConfig;
  if (publishConfig) {
    for (const field of ["main", "module", "browser", "types"]) {
      if (publishConfig[field]) {
        delete publishConfig[field];
        pkg.changed = true;
      }
    }
  }
}
function fixSideEffects(pkg) {
  const role = cliNode.PackageRoles.getRoleFromPackage(pkg.packageJson);
  if (!role) {
    return;
  }
  const roleInfo = cliNode.PackageRoles.getRoleInfo(role);
  if (roleInfo.platform === "node") {
    return;
  }
  if (roleInfo.output.length === 1 && roleInfo.output[0] === "bundle") {
    return;
  }
  if ("sideEffects" in pkg.packageJson) {
    return;
  }
  const pkgEntries = Object.entries(pkg.packageJson);
  pkgEntries.splice(
    // Place it just above the scripts field
    pkgEntries.findIndex(([name]) => name === "scripts"),
    0,
    ["sideEffects", false]
  );
  pkg.packageJson = Object.fromEntries(pkgEntries);
  pkg.changed = true;
}
function createRepositoryFieldFixer() {
  const rootPkg = require(paths.paths.resolveTargetRoot("package.json"));
  const rootRepoField = rootPkg.repository;
  if (!rootRepoField) {
    return () => {
    };
  }
  const rootType = rootRepoField.type || "git";
  const rootUrl = rootRepoField.url;
  const rootDir = rootRepoField.directory || "";
  return (pkg) => {
    const expectedPath = path.posix.join(
      rootDir,
      path.relative(paths.paths.targetRoot, pkg.dir)
    );
    const repoField = pkg.packageJson.repository;
    if (!repoField || typeof repoField === "string") {
      const pkgEntries = Object.entries(pkg.packageJson);
      pkgEntries.splice(
        // Place it just above the backstage field
        pkgEntries.findIndex(([name]) => name === "backstage"),
        0,
        [
          "repository",
          {
            type: rootType,
            url: rootUrl,
            directory: expectedPath
          }
        ]
      );
      pkg.packageJson = Object.fromEntries(pkgEntries);
      pkg.changed = true;
      return;
    }
    if (repoField.type !== rootType || repoField.url !== rootUrl) {
      return;
    }
    if (repoField.directory !== expectedPath) {
      repoField.directory = expectedPath;
      pkg.changed = true;
    }
  };
}
function guessPluginId(role, pkgName) {
  switch (role) {
    case "frontend":
    case "frontend-plugin":
      return pkgName.match(/plugin-(.*)/)?.[1];
    case "frontend-plugin-module":
      return pkgName.match(/plugin-(.*)-module-/)?.[1];
    case "backend-plugin":
      return pkgName.match(/plugin-(.*)-backend$/)?.[1];
    case "backend-plugin-module":
      return pkgName.match(/plugin-(.*)-backend-module-/)?.[1];
    case "common-library":
      return pkgName.match(/plugin-(.*)-(?:common)$/)?.[1];
    case "web-library":
      return pkgName.match(/plugin-(.*)-(?:react|test-utils)/)?.[1];
    case "node-library":
      return pkgName.match(/plugin-(.*)-(?:node|backend)-?/)?.[1];
    default:
      throw new Error(
        `Invalid 'backstage.role' field in "${pkgName}", got '${role}'`
      );
  }
}
function fixPluginId(pkg) {
  const role = pkg.packageJson.backstage?.role;
  if (!role) {
    return;
  }
  if (role === "backend" || role === "frontend" || role === "cli") {
    return;
  }
  const currentId = pkg.packageJson.backstage?.pluginId;
  if (currentId !== void 0) {
    if (typeof currentId !== "string" && currentId !== null) {
      throw new Error(
        `Invalid 'backstage.pluginId' field in "${pkg.packageJson.name}", must be a string`
      );
    }
    return;
  }
  const guessedPluginId = guessPluginId(role, pkg.packageJson.name);
  if (!guessedPluginId && (role === "frontend-plugin" || role === "frontend-plugin-module" || role === "backend-plugin" || role === "backend-plugin-module")) {
    const path$1 = path.relative(
      paths.paths.targetRoot,
      path.resolve(pkg.dir, "package.json")
    );
    const msg = `Failed to guess plugin ID for "${pkg.packageJson.name}", please set the 'backstage.pluginId' field manually in "${path$1}"`;
    if (role.endsWith("module")) {
      const suggestedRole = role.startsWith("frontend") ? "web-library" : "node-library";
      throw new Error(
        `${msg}. It is also possible that this package is not a module, and should use the '${suggestedRole}' role instead.`
      );
    } else {
      throw new Error(msg);
    }
  }
  if (guessedPluginId) {
    pkg.packageJson.backstage = {
      ...pkg.packageJson.backstage,
      pluginId: guessedPluginId
    };
    pkg.changed = true;
  }
}
const backendPluginPackageNameByPluginId = new Map(
  [
    "app",
    "auth",
    "catalog",
    "events",
    "kubernetes",
    "notifications",
    "permission",
    "scaffolder",
    "search",
    "signals",
    "techdocs"
  ].map((pluginId) => [pluginId, `@backstage/plugin-${pluginId}-backend`])
);
const pluginPackageRoles = [
  "frontend-plugin",
  "backend-plugin",
  "common-library",
  "web-library",
  "node-library"
];
function fixPluginPackages(pkg, repoPackages) {
  const pkgBackstage = pkg.packageJson.backstage;
  const role = pkgBackstage?.role;
  if (!role) {
    return;
  }
  if (role === "backend" || role === "frontend" || role === "cli") {
    return;
  }
  const pluginId = pkgBackstage.pluginId;
  if (!pluginId) {
    if (role === "common-library" || role === "web-library" || role === "node-library" || role === "frontend-plugin-module") {
      return;
    }
    throw new Error(
      `Missing 'backstage.pluginId' field in "${pkg.packageJson.name}"`
    );
  }
  if (role === "backend-plugin-module" || role === "frontend-plugin-module") {
    const targetRole = role.replace("-module", "");
    const pluginPkgName = repoPackages.find(
      (p) => p.packageJson.backstage?.pluginId === pluginId && p.packageJson.backstage?.role === targetRole
    )?.packageJson.name ?? backendPluginPackageNameByPluginId.get(pluginId);
    if (!pluginPkgName) {
      if (pkgBackstage.pluginPackage) {
        return;
      }
      const path$1 = path.relative(
        paths.paths.targetRoot,
        path.resolve(pkg.dir, "package.json")
      );
      const suggestedRole = role === "frontend-plugin-module" ? "web-library" : "node-library";
      throw new Error(
        `Failed to find plugin package for "${pkg.packageJson.name}", please declare the name of the plugin package that this package is a module for in the 'backstage.pluginPackage' field in "${path$1}". It is also possible that this package is not a module, and should use the '${suggestedRole}' role instead.`
      );
    }
    if (pkgBackstage.pluginPackage !== pluginPkgName) {
      pkgBackstage.pluginPackage = pluginPkgName;
      pkg.changed = true;
    }
  } else {
    let pluginPackages = repoPackages.filter(
      (p) => p.packageJson.backstage?.pluginId === pluginId && pluginPackageRoles.includes(p.packageJson.backstage?.role)
    ).map((p) => p.packageJson.name).sort();
    if (pluginPackages.length === 0) {
      pluginPackages = void 0;
    }
    if (pkgBackstage.pluginPackages?.join(",") !== pluginPackages?.join(",")) {
      pkgBackstage.pluginPackages = pluginPackages;
      pkg.changed = true;
    }
  }
}
async function command(opts) {
  const packages = await readFixablePackages();
  const fixRepositoryField = createRepositoryFieldFixer();
  const fixers = [fixPackageExports, fixSideEffects];
  if (opts.publish) {
    fixers.push(
      fixRepositoryField,
      fixPluginId,
      fixPluginPackages,
      // Run the publish preflight check too, to make sure we don't uncover errors during publishing
      publishing.publishPreflightCheck
    );
  }
  for (const fixer of fixers) {
    for (const pkg of packages) {
      fixer(pkg, packages);
    }
  }
  if (opts.check) {
    if (printPackageFixHint(packages)) {
      process.exit(1);
    }
  } else {
    await writeFixedPackages(packages);
  }
}

exports.command = command;
exports.createRepositoryFieldFixer = createRepositoryFieldFixer;
exports.fixPackageExports = fixPackageExports;
exports.fixPluginId = fixPluginId;
exports.fixPluginPackages = fixPluginPackages;
exports.fixSideEffects = fixSideEffects;
exports.printPackageFixHint = printPackageFixHint;
exports.readFixablePackages = readFixablePackages;
exports.writeFixedPackages = writeFixedPackages;
//# sourceMappingURL=fix.cjs.js.map
