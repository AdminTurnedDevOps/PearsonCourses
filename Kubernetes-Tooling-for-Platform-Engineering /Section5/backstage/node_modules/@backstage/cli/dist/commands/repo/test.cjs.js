'use strict';

var os = require('os');
var crypto = require('node:crypto');
var yargs = require('yargs');
var jestCli = require('jest-cli');
var path = require('path');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');
var run = require('../../lib/run.cjs.js');
var cliCommon = require('@backstage/cli-common');
var SuccessCache = require('../../lib/cache/SuccessCache.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);
var yargs__default = /*#__PURE__*/_interopDefaultCompat(yargs);

async function readPackageTreeHashes(graph) {
  const pkgs = Array.from(graph.values()).map((pkg) => ({
    ...pkg,
    path: path.relative(paths.paths.targetRoot, pkg.dir)
  }));
  const output = await run.runPlain(
    "git",
    "ls-tree",
    '--format="%(objectname)=%(path)"',
    "HEAD",
    "--",
    ...pkgs.map((pkg) => pkg.path)
  );
  const map = new Map(
    output.trim().split(/\r?\n/).map((line) => {
      const [itemSha, ...itemPathParts] = line.split("=");
      const itemPath = itemPathParts.join("=");
      const pkg = pkgs.find((p) => p.path === itemPath);
      if (!pkg) {
        throw new Error(
          `Unexpectedly missing tree sha entry for path ${itemPath}`
        );
      }
      return [pkg.packageJson.name, itemSha];
    })
  );
  return (pkgName) => {
    const sha = map.get(pkgName);
    if (!sha) {
      throw new Error(`Tree sha not found for ${pkgName}`);
    }
    return sha;
  };
}
function createFlagFinder(args) {
  const flags = /* @__PURE__ */ new Set();
  for (const arg of args) {
    if (arg.startsWith("--no-")) {
      flags.add(`--${arg.slice("--no-".length)}`);
    } else if (arg.startsWith("--")) {
      flags.add(arg.split("=")[0]);
    } else if (arg.startsWith("-")) {
      const shortFlags = arg.slice(1).split("");
      for (const shortFlag of shortFlags) {
        flags.add(`-${shortFlag}`);
      }
    }
  }
  return (...findFlags) => {
    for (const flag of findFlags) {
      if (flags.has(flag)) {
        return true;
      }
    }
    return false;
  };
}
function removeOptionArg(args, option, size = 2) {
  let changed = false;
  do {
    changed = false;
    const index = args.indexOf(option);
    if (index >= 0) {
      changed = true;
      args.splice(index, size);
    }
    const indexEq = args.findIndex((arg) => arg.startsWith(`${option}=`));
    if (indexEq >= 0) {
      changed = true;
      args.splice(indexEq, 1);
    }
  } while (changed);
}
async function command(opts, cmd) {
  const testGlobal = global;
  let parent = cmd;
  while (parent.parent) {
    parent = parent.parent;
  }
  const allArgs = parent.args;
  const args = allArgs.slice(allArgs.indexOf("test") + 1);
  const hasFlags = createFlagFinder(args);
  const { _: parsedArgs } = await yargs__default.default(args).options(jestCli.yargsOptions).argv;
  if (!hasFlags("-c", "--config")) {
    args.push("--config", paths.paths.resolveOwn("config/jest.js"));
  }
  if (!hasFlags("--passWithNoTests")) {
    args.push("--passWithNoTests");
  }
  let isSingleWatchMode = args.includes("--watch");
  if (!opts.since && !process.env.CI && !hasFlags("--coverage", "--watch", "--watchAll")) {
    const isGitRepo = () => run.runCheck("git", "rev-parse", "--is-inside-work-tree");
    const isMercurialRepo = () => run.runCheck("hg", "--cwd", ".", "root");
    if (await isGitRepo() || await isMercurialRepo()) {
      isSingleWatchMode = true;
      args.push("--watch");
    } else {
      args.push("--watchAll");
    }
  }
  if (isSingleWatchMode && parsedArgs.length > 0) {
    testGlobal.__backstageCli_watchProjectFilter = {
      async filter(projectConfigs) {
        const selectedProjects2 = [];
        const usedArgs = /* @__PURE__ */ new Set();
        for (const project of projectConfigs) {
          for (const arg of parsedArgs) {
            if (cliCommon.isChildPath(project.rootDir, String(arg))) {
              selectedProjects2.push(project);
              usedArgs.add(arg);
            }
          }
        }
        if (usedArgs.size !== parsedArgs.length) {
          return projectConfigs;
        }
        return selectedProjects2;
      }
    };
  }
  if (!hasFlags("--workerIdleMemoryLimit")) {
    args.push("--workerIdleMemoryLimit=1000M");
  }
  if (os__default.default.cpus().length <= 3 && !hasFlags("-i", "--runInBand", "-w", "--maxWorkers")) {
    args.push("--maxWorkers=2");
  }
  if (opts.since) {
    removeOptionArg(args, "--since");
  }
  let packageGraph;
  async function getPackageGraph() {
    if (packageGraph) {
      return packageGraph;
    }
    const packages = await cliNode.PackageGraph.listTargetPackages();
    packageGraph = cliNode.PackageGraph.fromPackages(packages);
    return packageGraph;
  }
  let selectedProjects = void 0;
  if (opts.since && !hasFlags("--selectProjects")) {
    const graph = await getPackageGraph();
    const changedPackages = await graph.listChangedPackages({
      ref: opts.since,
      analyzeLockfile: true
    });
    selectedProjects = Array.from(
      graph.collectPackageNames(
        changedPackages.map((pkg) => pkg.name),
        (pkg) => pkg.allLocalDependents.keys()
      )
    );
    if (selectedProjects.length === 0) {
      console.log(`No packages changed since ${opts.since}`);
      return;
    }
    args.push("--selectProjects", ...selectedProjects);
  }
  if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = "test";
  }
  if (!process.env.TZ) {
    process.env.TZ = "UTC";
  }
  if (args.includes("--jest-help")) {
    removeOptionArg(args, "--jest-help");
    args.push("--help");
    process.stdout._handle.setBlocking(true);
  }
  if (opts.successCache) {
    removeOptionArg(args, "--successCache", 1);
    removeOptionArg(args, "--successCacheDir");
    if (parsedArgs.length > 0) {
      throw new Error(
        `The --successCache flag can not be combined with the following arguments: ${parsedArgs.join(
          ", "
        )}`
      );
    }
    if (args.includes("--shard")) {
      throw new Error(
        `The --successCache flag can not be combined with the --shard flag`
      );
    }
    const cache = new SuccessCache.SuccessCache("test", opts.successCacheDir);
    const graph = await getPackageGraph();
    const projectHashes = /* @__PURE__ */ new Map();
    const outputSuccessCache = new Array();
    testGlobal.__backstageCli_jestSuccessCache = {
      // This is called by `config/jest.js` after the project configs have been gathered
      async filterConfigs(projectConfigs, globalRootConfig) {
        const cacheEntries = await cache.read();
        const lockfile = await cliNode.Lockfile.load(
          paths.paths.resolveTargetRoot("yarn.lock")
        );
        const getPackageTreeHash = await readPackageTreeHashes(graph);
        const baseHash = crypto__default.default.createHash("sha1");
        baseHash.update("v1");
        baseHash.update("\0");
        baseHash.update(process.version);
        baseHash.update("\0");
        baseHash.update(
          SuccessCache.SuccessCache.trimPaths(JSON.stringify(globalRootConfig))
        );
        const baseSha = baseHash.digest("hex");
        return projectConfigs.filter((project) => {
          const packageName = project.displayName;
          const pkg = graph.get(packageName);
          if (!pkg) {
            throw new Error(
              `Package ${packageName} not found in package graph`
            );
          }
          const hash = crypto__default.default.createHash("sha1");
          hash.update(baseSha);
          const packageTreeSha = getPackageTreeHash(packageName);
          hash.update(packageTreeSha);
          for (const [depName, depPkg] of pkg.allLocalDependencies) {
            const depHash = getPackageTreeHash(depPkg.name);
            hash.update(`${depName}:${depHash}`);
          }
          hash.update(SuccessCache.SuccessCache.trimPaths(JSON.stringify(project)));
          hash.update(lockfile.getDependencyTreeHash(packageName));
          const sha = hash.digest("hex");
          projectHashes.set(packageName, sha);
          if (cacheEntries.has(sha)) {
            if (!selectedProjects || selectedProjects.includes(packageName)) {
              console.log(`Skipped ${packageName} due to cache hit`);
            }
            outputSuccessCache.push(sha);
            return void 0;
          }
          return project;
        });
      },
      // This is called by `config/jestCacheResultProcess.cjs` after all tests have run
      async reportResults(results) {
        const successful = /* @__PURE__ */ new Set();
        const failed = /* @__PURE__ */ new Set();
        for (const testResult of results.testResults) {
          for (const [pkgName, pkg] of graph) {
            if (cliCommon.isChildPath(pkg.dir, testResult.testFilePath)) {
              if (testResult.testExecError || testResult.failureMessage || testResult.numFailingTests > 0) {
                failed.add(pkgName);
                successful.delete(pkgName);
              } else if (!failed.has(pkgName)) {
                successful.add(pkgName);
              }
              break;
            }
          }
        }
        for (const pkgName of successful) {
          const sha = projectHashes.get(pkgName);
          if (sha) {
            outputSuccessCache.push(sha);
          }
        }
        await cache.write(outputSuccessCache);
      }
    };
  }
  await jestCli.run(args);
}

exports.command = command;
exports.createFlagFinder = createFlagFinder;
//# sourceMappingURL=test.cjs.js.map
