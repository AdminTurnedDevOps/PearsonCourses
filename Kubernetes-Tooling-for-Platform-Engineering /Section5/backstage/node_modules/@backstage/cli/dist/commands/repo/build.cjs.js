'use strict';

var chalk = require('chalk');
var path = require('path');
var packager = require('../../lib/builder/packager.cjs.js');
var paths = require('../../lib/paths.cjs.js');
var cliNode = require('@backstage/cli-node');
var parallel = require('../../lib/parallel.cjs.js');
var buildFrontend = require('../build/buildFrontend.cjs.js');
var buildBackend = require('../build/buildBackend.cjs.js');
var optionsParser = require('./optionsParser.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);

async function command(opts, cmd) {
  let packages = await cliNode.PackageGraph.listTargetPackages();
  const shouldUseRspack = Boolean(process.env.EXPERIMENTAL_RSPACK);
  const rspack = shouldUseRspack ? require("@rspack/core") : void 0;
  if (opts.since) {
    const graph = cliNode.PackageGraph.fromPackages(packages);
    const changedPackages = await graph.listChangedPackages({
      ref: opts.since,
      analyzeLockfile: true
    });
    const withDevDependents = graph.collectPackageNames(
      changedPackages.map((pkg) => pkg.name),
      (pkg) => pkg.localDevDependents.keys()
    );
    packages = Array.from(withDevDependents).map((name) => graph.get(name));
  }
  const apps = new Array();
  const backends = new Array();
  const parseBuildScript = optionsParser.createScriptOptionsParser(cmd, ["package", "build"]);
  const options = packages.flatMap((pkg) => {
    const role = pkg.packageJson.backstage?.role ?? cliNode.PackageRoles.detectRoleFromPackage(pkg.packageJson);
    if (!role) {
      console.warn(`Ignored ${pkg.packageJson.name} because it has no role`);
      return [];
    }
    if (role === "frontend") {
      apps.push(pkg);
      return [];
    } else if (role === "backend") {
      backends.push(pkg);
      return [];
    }
    const outputs = packager.getOutputsForRole(role);
    if (outputs.size === 0) {
      console.warn(`Ignored ${pkg.packageJson.name} because it has no output`);
      return [];
    }
    const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
    if (!buildOptions) {
      console.warn(
        `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
      );
      return [];
    }
    return {
      targetDir: pkg.dir,
      packageJson: pkg.packageJson,
      outputs,
      logPrefix: `${chalk__default.default.cyan(path.relative(paths.paths.targetRoot, pkg.dir))}: `,
      workspacePackages: packages,
      minify: opts.minify ?? buildOptions.minify
    };
  });
  console.log("Building packages");
  await packager.buildPackages(options);
  if (opts.all) {
    console.log("Building apps");
    await parallel.runParallelWorkers({
      items: apps,
      parallelismFactor: 1 / 2,
      worker: async (pkg) => {
        const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
        if (!buildOptions) {
          console.warn(
            `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
          );
          return;
        }
        await buildFrontend.buildFrontend({
          targetDir: pkg.dir,
          configPaths: buildOptions.config ?? [],
          writeStats: Boolean(buildOptions.stats),
          rspack
        });
      }
    });
    console.log("Building backends");
    await parallel.runParallelWorkers({
      items: backends,
      parallelismFactor: 1 / 2,
      worker: async (pkg) => {
        const buildOptions = parseBuildScript(pkg.packageJson.scripts?.build);
        if (!buildOptions) {
          console.warn(
            `Ignored ${pkg.packageJson.name} because it does not have a matching build script`
          );
          return;
        }
        await buildBackend.buildBackend({
          targetDir: pkg.dir,
          skipBuildDependencies: true,
          minify: opts.minify ?? buildOptions.minify
        });
      }
    });
  }
}

exports.command = command;
//# sourceMappingURL=build.cjs.js.map
