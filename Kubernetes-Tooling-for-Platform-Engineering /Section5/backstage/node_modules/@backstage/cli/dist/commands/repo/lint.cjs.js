'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var crypto = require('crypto');
var path = require('path');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');
var parallel = require('../../lib/parallel.cjs.js');
var optionsParser = require('./optionsParser.cjs.js');
var SuccessCache = require('../../lib/cache/SuccessCache.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function depCount(pkg) {
  const deps = pkg.dependencies ? Object.keys(pkg.dependencies).length : 0;
  const devDeps = pkg.devDependencies ? Object.keys(pkg.devDependencies).length : 0;
  return deps + devDeps;
}
async function command(opts, cmd) {
  let packages = await cliNode.PackageGraph.listTargetPackages();
  const cache = new SuccessCache.SuccessCache("lint", opts.successCacheDir);
  const cacheContext = opts.successCache ? {
    entries: await cache.read(),
    lockfile: await cliNode.Lockfile.load(paths.paths.resolveTargetRoot("yarn.lock"))
  } : void 0;
  if (opts.since) {
    const graph = cliNode.PackageGraph.fromPackages(packages);
    packages = await graph.listChangedPackages({
      ref: opts.since,
      analyzeLockfile: true
    });
  }
  packages.sort((a, b) => depCount(b.packageJson) - depCount(a.packageJson));
  if (opts.format === "eslint-formatter-friendly") {
    process.chdir(paths.paths.targetRoot);
  }
  if (!process.env.FORCE_COLOR) {
    process.env.FORCE_COLOR = "1";
  }
  const parseLintScript = optionsParser.createScriptOptionsParser(cmd, ["package", "lint"]);
  const items = await Promise.all(
    packages.map(async (pkg) => {
      const lintOptions = parseLintScript(pkg.packageJson.scripts?.lint);
      const base = {
        fullDir: pkg.dir,
        relativeDir: path.relative(paths.paths.targetRoot, pkg.dir),
        lintOptions,
        parentHash: void 0
      };
      if (!cacheContext) {
        return base;
      }
      const hash = crypto.createHash("sha1");
      hash.update(
        cacheContext.lockfile.getDependencyTreeHash(pkg.packageJson.name)
      );
      hash.update("\0");
      hash.update(JSON.stringify(lintOptions ?? {}));
      hash.update("\0");
      hash.update(process.version);
      hash.update("\0");
      hash.update("v1");
      return {
        ...base,
        parentHash: hash.digest("hex")
      };
    })
  );
  const resultsList = await parallel.runWorkerQueueThreads({
    items: items.filter((item) => item.lintOptions),
    // Filter out packages without lint script
    workerData: {
      fix: Boolean(opts.fix),
      format: opts.format,
      shouldCache: Boolean(cacheContext),
      successCache: cacheContext?.entries,
      rootDir: paths.paths.targetRoot
    },
    workerFactory: async ({
      fix,
      format,
      shouldCache,
      successCache,
      rootDir
    }) => {
      const { ESLint } = require("eslint");
      const crypto = require("crypto");
      const globby = require("globby");
      const { readFile } = require("fs/promises");
      const workerPath = require("path");
      return async ({
        fullDir,
        relativeDir,
        lintOptions,
        parentHash
      }) => {
        process.cwd = () => fullDir;
        const start = Date.now();
        const eslint = new ESLint({
          cwd: fullDir,
          fix,
          extensions: ["js", "jsx", "ts", "tsx", "mjs", "cjs"]
        });
        let sha = void 0;
        if (shouldCache) {
          const result = await globby(relativeDir, {
            gitignore: true,
            onlyFiles: true,
            cwd: rootDir
          });
          const hash = crypto.createHash("sha1");
          hash.update(parentHash);
          hash.update("\0");
          for (const path of result.sort()) {
            const absPath = workerPath.resolve(rootDir, path);
            const pathInPackage = workerPath.relative(fullDir, absPath);
            if (await eslint.isPathIgnored(pathInPackage)) {
              continue;
            }
            hash.update(pathInPackage);
            hash.update("\0");
            hash.update(await readFile(absPath));
            hash.update("\0");
            hash.update(
              JSON.stringify(
                await eslint.calculateConfigForFile(pathInPackage)
              ).replaceAll(rootDir, "")
            );
            hash.update("\0");
          }
          sha = await hash.digest("hex");
          if (successCache?.has(sha)) {
            console.log(`Skipped ${relativeDir} due to cache hit`);
            return { relativeDir, sha, failed: false };
          }
        }
        const formatter = await eslint.loadFormatter(format);
        const results = await eslint.lintFiles(["."]);
        const count = String(results.length).padStart(3);
        const time = ((Date.now() - start) / 1e3).toFixed(2);
        console.log(`Checked ${count} files in ${relativeDir} ${time}s`);
        if (fix) {
          await ESLint.outputFixes(results);
        }
        const maxWarnings = lintOptions?.maxWarnings ?? 0;
        const ignoreWarnings = +maxWarnings === -1;
        const resultText = formatter.format(results);
        const failed2 = results.some((r) => r.errorCount > 0) || !ignoreWarnings && results.reduce((current, next) => current + next.warningCount, 0) > maxWarnings;
        return {
          relativeDir,
          resultText,
          failed: failed2,
          sha
        };
      };
    }
  });
  const outputSuccessCache = [];
  let errorOutput = "";
  let failed = false;
  for (const {
    relativeDir,
    resultText,
    failed: runFailed,
    sha
  } of resultsList) {
    if (runFailed) {
      console.log(chalk__default.default.red(`Lint failed in ${relativeDir}`));
      failed = true;
      if (resultText) {
        if (opts.outputFile) {
          errorOutput += `${resultText}
`;
        } else {
          console.log();
          console.log(resultText.trimStart());
        }
      }
    } else if (sha) {
      outputSuccessCache.push(sha);
    }
  }
  if (opts.outputFile && errorOutput) {
    await fs__default.default.writeFile(paths.paths.resolveTargetRoot(opts.outputFile), errorOutput);
  }
  if (cacheContext) {
    await cache.write(outputSuccessCache);
  }
  if (failed) {
    process.exit(1);
  }
}

exports.command = command;
//# sourceMappingURL=lint.cjs.js.map
