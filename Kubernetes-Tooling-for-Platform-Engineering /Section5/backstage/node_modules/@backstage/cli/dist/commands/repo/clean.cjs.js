'use strict';

var child_process = require('child_process');
var fs = require('fs-extra');
var path = require('path');
var util = require('util');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const execFile = util.promisify(child_process.execFile);
async function command() {
  const packages = await cliNode.PackageGraph.listTargetPackages();
  await fs__default.default.remove(paths.paths.resolveTargetRoot("dist"));
  await fs__default.default.remove(paths.paths.resolveTargetRoot("dist-types"));
  await fs__default.default.remove(paths.paths.resolveTargetRoot("coverage"));
  await Promise.all(
    Array.from(Array(10), async () => {
      while (packages.length > 0) {
        const pkg = packages.pop();
        const cleanScript = pkg.packageJson.scripts?.clean;
        if (cleanScript === "backstage-cli clean" || cleanScript === "backstage-cli package clean") {
          await fs__default.default.remove(path.resolve(pkg.dir, "dist"));
          await fs__default.default.remove(path.resolve(pkg.dir, "dist-types"));
          await fs__default.default.remove(path.resolve(pkg.dir, "coverage"));
        } else if (cleanScript) {
          const result = await execFile("yarn", ["run", "clean"], {
            cwd: pkg.dir,
            shell: true
          });
          process.stdout.write(result.stdout);
          process.stderr.write(result.stderr);
        }
      }
    })
  );
}

exports.command = command;
//# sourceMappingURL=clean.cjs.js.map
