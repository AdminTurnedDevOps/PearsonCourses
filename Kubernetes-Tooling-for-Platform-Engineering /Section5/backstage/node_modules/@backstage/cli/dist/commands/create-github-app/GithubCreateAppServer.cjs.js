'use strict';

var crypto = require('crypto');
var openBrowser = require('react-dev-utils/openBrowser');
var request = require('@octokit/request');
var express = require('express');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);
var openBrowser__default = /*#__PURE__*/_interopDefaultCompat(openBrowser);
var express__default = /*#__PURE__*/_interopDefaultCompat(express);

const FORM_PAGE = `
<html>
  <body>
    <form id="form" action="ACTION_URL" method="post">
      <input type="hidden" name="manifest" value="MANIFEST_JSON">
      <input type="submit" value="Continue">
    </form>
    <script>
      document.getElementById("form").submit()
    <\/script>
  </body>
</html>
`;
class GithubCreateAppServer {
  constructor(actionUrl, permissions) {
    this.actionUrl = actionUrl;
    this.permissions = permissions;
    const webhookId = crypto__default.default.randomBytes(15).toString("base64").replace(/[\+\/]/g, "");
    this.webhookUrl = `https://smee.io/${webhookId}`;
  }
  baseUrl;
  webhookUrl;
  static async run(options) {
    const encodedOrg = encodeURIComponent(options.org);
    const actionUrl = `https://github.com/organizations/${encodedOrg}/settings/apps/new`;
    const server = new GithubCreateAppServer(actionUrl, options.permissions);
    return server.start();
  }
  async start() {
    const app = express__default.default();
    app.get("/", this.formHandler);
    const callPromise = new Promise((resolve, reject) => {
      app.get("/callback", (req, res) => {
        request.request(
          `POST /app-manifests/${encodeURIComponent(
            req.query.code
          )}/conversions`
        ).then(({ data }) => {
          resolve({
            name: data.name,
            slug: data.slug,
            appId: data.id,
            webhookUrl: this.webhookUrl,
            clientId: data.client_id,
            clientSecret: data.client_secret,
            webhookSecret: data.webhook_secret,
            privateKey: data.pem
          });
          res.redirect(302, `${data.html_url}/installations/new`);
        }, reject);
      });
    });
    this.baseUrl = await this.listen(app);
    openBrowser__default.default(this.baseUrl);
    return callPromise;
  }
  formHandler = (_req, res) => {
    const baseUrl = this.baseUrl;
    if (!baseUrl) {
      throw new Error("baseUrl is not set");
    }
    const manifest = {
      default_events: ["create", "delete", "push", "repository"],
      default_permissions: {
        metadata: "read",
        ...this.permissions.includes("members") && {
          members: "read"
        },
        ...this.permissions.includes("read") && {
          contents: "read",
          checks: "read"
        },
        ...this.permissions.includes("write") && {
          contents: "write",
          checks: "read",
          actions: "write"
        }
      },
      name: "Backstage-<changeme>",
      url: "https://backstage.io",
      description: "GitHub App for Backstage",
      public: false,
      redirect_url: `${baseUrl}/callback`,
      hook_attributes: {
        url: this.webhookUrl,
        active: false
      }
    };
    const manifestJson = JSON.stringify(manifest).replace(/\"/g, "&quot;");
    let body = FORM_PAGE;
    body = body.replace("MANIFEST_JSON", manifestJson);
    body = body.replace("ACTION_URL", this.actionUrl);
    res.setHeader("content-type", "text/html");
    res.send(body);
  };
  async listen(app) {
    return new Promise((resolve, reject) => {
      const listener = app.listen(0, () => {
        const info = listener.address();
        if (typeof info !== "object" || info === null) {
          reject(new Error(`Unexpected listener info '${info}'`));
          return;
        }
        const { port } = info;
        resolve(`http://localhost:${port}`);
      });
    });
  }
}

exports.GithubCreateAppServer = GithubCreateAppServer;
//# sourceMappingURL=GithubCreateAppServer.cjs.js.map
