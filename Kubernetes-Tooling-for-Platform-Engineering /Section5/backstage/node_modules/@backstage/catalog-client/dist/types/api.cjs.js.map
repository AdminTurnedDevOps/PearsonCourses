{"version":3,"file":"api.cjs.js","sources":["../../src/types/api.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CompoundEntityRef, Entity } from '@backstage/catalog-model';\nimport { SerializedError } from '@backstage/errors';\n\n/**\n * This symbol can be used in place of a value when passed to filters in e.g.\n * {@link CatalogClient.getEntities}, to signify that you want to filter on the\n * presence of that key no matter what its value is.\n *\n * @public\n */\nexport const CATALOG_FILTER_EXISTS = Symbol.for(\n  // Random UUID to ensure no collisions\n  'CATALOG_FILTER_EXISTS_0e15b590c0b343a2bae3e787e84c2111',\n);\n\n/**\n * A key-value based filter expression for entities.\n *\n * @remarks\n *\n * Each key of a record is a dot-separated path into the entity structure, e.g.\n * `metadata.name`.\n *\n * The values are literal values to match against. As a value you can also pass\n * in the symbol `CATALOG_FILTER_EXISTS` (exported from this package), which\n * means that you assert on the existence of that key, no matter what its value\n * is.\n *\n * All matching of keys and values is case insensitive.\n *\n * If multiple filter sets are given as an array, then there is effectively an\n * OR between each filter set.\n *\n * Within one filter set, there is effectively an AND between the various keys.\n *\n * Within one key, if there are more than one value, then there is effectively\n * an OR between them.\n *\n * Example: For an input of\n *\n * ```\n * [\n *   { kind: ['API', 'Component'] },\n *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n * ]\n * ```\n *\n * This effectively means\n *\n * ```\n * (kind = EITHER 'API' OR 'Component')\n * OR\n * (metadata.name = 'a' AND metadata.namespace = 'b' )\n * ```\n *\n * @public\n */\nexport type EntityFilterQuery =\n  | Record<string, string | symbol | (string | symbol)[]>[]\n  | Record<string, string | symbol | (string | symbol)[]>;\n\n/**\n * A set of dot-separated paths into an entity's keys, showing what parts of an\n * entity to include in a response, and excluding all others.\n *\n * @remarks\n *\n * Example: For an input of `['kind', 'metadata.annotations']`, then response\n * objects will be shaped like\n *\n * ```\n * {\n *   \"kind\": \"Component\",\n *   \"metadata\": {\n *     \"annotations\": {\n *       \"foo\": \"bar\"\n *     }\n *   }\n * }\n * ```\n * @public\n */\nexport type EntityFieldsQuery = string[];\n\n/**\n * Dot-separated field based ordering directives, controlling the sort order of\n * the output entities.\n *\n * @remarks\n *\n * Each field is a dot-separated path into an entity's keys. The order is either\n * ascending (`asc`, lexicographical order) or descending (`desc`, reverse\n * lexicographical order). The ordering is case insensitive.\n *\n * If more than one order directive is given, later directives have lower\n * precedence (they are applied only when directives of higher precedence have\n * equal values).\n *\n * Example:\n *\n * ```\n * [\n *   { field: 'kind', order: 'asc' },\n *   { field: 'metadata.name', order: 'desc' },\n * ]\n * ```\n *\n * This will order the output first by kind ascending, and then within each kind\n * (if there's more than one of a given kind) by their name descending.\n *\n * When given a field that does NOT exist on all entities in the result set,\n * those entities that do not have the field will always be sorted last in that\n * particular order step, no matter what the desired order was.\n *\n * @public\n */\nexport type EntityOrderQuery =\n  | {\n      field: string;\n      order: 'asc' | 'desc';\n    }\n  | Array<{\n      field: string;\n      order: 'asc' | 'desc';\n    }>;\n\n/**\n * The request type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesRequest {\n  /**\n   * If given, return only entities that match the given filter.\n   */\n  filter?: EntityFilterQuery;\n  /**\n   * If given, return only the parts of each entity that match the field\n   * declarations.\n   */\n  fields?: EntityFieldsQuery;\n  /**\n   *If given, order the result set by those directives.\n   */\n  order?: EntityOrderQuery;\n  /**\n   * If given, skips over the first N items in the result set.\n   */\n  offset?: number;\n  /**\n   * If given, returns at most N items from the result set.\n   */\n  limit?: number;\n  /**\n   * If given, skips over all items before that cursor as returned by a previous\n   * request.\n   */\n  after?: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesResponse {\n  items: Entity[];\n}\n\n/**\n * The request type for {@link CatalogClient.getEntitiesByRefs}.\n *\n * @public\n */\nexport interface GetEntitiesByRefsRequest {\n  /**\n   * The list of entity refs to fetch.\n   *\n   * @remarks\n   *\n   * The returned list of entities will be in the same order as the refs, and\n   * null will be returned in those positions that were not found.\n   */\n  entityRefs: string[];\n  /**\n   * If given, return only the parts of each entity that match the field\n   * declarations.\n   */\n  fields?: EntityFieldsQuery | undefined;\n  /**\n   * If given, return only entities that match the given filter.\n   */\n  filter?: EntityFilterQuery;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntitiesByRefs}.\n *\n * @public\n */\nexport interface GetEntitiesByRefsResponse {\n  /**\n   * The returned list of entities.\n   *\n   * @remarks\n   *\n   * The list will be in the same order as the refs given in the request, and\n   * null will be returned in those positions that were not found.\n   */\n  items: Array<Entity | undefined>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsRequest {\n  entityRef: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsResponse {\n  rootEntityRef: string;\n  items: Array<{\n    entity: Entity;\n    parentEntityRefs: string[];\n  }>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?: EntityFilterQuery;\n  /**\n   * Dot separated paths for the facets to extract from each entity.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations.backstage.io/orphan']`, then the\n   * response will be shaped like\n   *\n   * ```\n   * {\n   *   \"facets\": {\n   *     \"kind\": [\n   *       { \"key\": \"Component\", \"count\": 22 },\n   *       { \"key\": \"API\", \"count\": 13 }\n   *     ],\n   *     \"metadata.annotations.backstage.io/orphan\": [\n   *       { \"key\": \"true\", \"count\": 2 }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  facets: string[];\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsResponse {\n  /**\n   * The computed facets, one entry per facet in the request.\n   */\n  facets: Record<string, Array<{ value: string; count: number }>>;\n}\n\n/**\n * Options you can pass into a catalog request for additional information.\n *\n * @public\n */\nexport interface CatalogRequestOptions {\n  token?: string;\n}\n\n/**\n * Entity location for a specific entity.\n *\n * @public\n */\nexport type Location = {\n  id: string;\n  type: string;\n  target: string;\n};\n\n/**\n * The request type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationRequest = {\n  type?: string;\n  target: string;\n  /**\n   * If set to true, the location will not be added, but the response will\n   * contain the entities that match the given location.\n   */\n  dryRun?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationResponse = {\n  location: Location;\n  /**\n   * The entities matching this location. Will only be filled in dryRun mode\n   */\n  entities: Entity[];\n  /**\n   * True, if the location exists. Will only be filled in dryRun mode\n   */\n  exists?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.validateEntity}\n *\n * @public\n */\nexport type ValidateEntityResponse =\n  | { valid: true }\n  | { valid: false; errors: SerializedError[] };\n\n/**\n * The request type for {@link CatalogClient.queryEntities}.\n *\n * @public\n */\nexport type QueryEntitiesRequest =\n  | QueryEntitiesInitialRequest\n  | QueryEntitiesCursorRequest;\n\n/**\n * A request type for {@link CatalogClient.queryEntities}.\n * The method takes this type in an initial pagination request,\n * when requesting the first batch of entities.\n *\n * The properties filter, sortField, query and sortFieldOrder, are going\n * to be immutable for the entire lifecycle of the following requests.\n *\n * @public\n */\nexport type QueryEntitiesInitialRequest = {\n  fields?: string[];\n  limit?: number;\n  offset?: number;\n  filter?: EntityFilterQuery;\n  orderFields?: EntityOrderQuery;\n  fullTextFilter?: {\n    term: string;\n    fields?: string[];\n  };\n};\n\n/**\n * A request type for {@link CatalogClient.queryEntities}.\n * The method takes this type in a pagination request, following\n * the initial request.\n *\n * @public\n */\nexport type QueryEntitiesCursorRequest = {\n  fields?: string[];\n  limit?: number;\n  cursor: string;\n};\n\n/**\n * The response type for {@link CatalogClient.queryEntities}.\n *\n * @public\n */\nexport type QueryEntitiesResponse = {\n  /* The list of entities for the current request */\n  items: Entity[];\n  /* The number of entities among all the requests */\n  totalItems: number;\n  pageInfo: {\n    /* The cursor for the next batch of entities */\n    nextCursor?: string;\n    /* The cursor for the previous batch of entities */\n    prevCursor?: string;\n  };\n};\n\n/**\n * A client for interacting with the Backstage software catalog through its API.\n *\n * @public\n */\nexport interface CatalogApi {\n  /**\n   * Lists catalog entities.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse>;\n\n  /**\n   * Gets a batch of entities, by their entity refs.\n   *\n   * @remarks\n   *\n   * The output list of entities is of the same size and in the same order as\n   * the requested list of entity refs. Entries that are not found are returned\n   * as null.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntitiesByRefs(\n    request: GetEntitiesByRefsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesByRefsResponse>;\n\n  /**\n   * Gets paginated entities from the catalog.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * ```\n   * const response = await catalogClient.queryEntities({\n   *   filter: [{ kind: 'group' }],\n   *   limit: 20,\n   *   fullTextFilter: {\n   *     term: 'A',\n   *   },\n   *   orderFields: { field: 'metadata.name', order: 'asc' },\n   * });\n   * ```\n   *\n   * this will match all entities of type group having a name starting\n   * with 'A', ordered by name ascending.\n   *\n   * The response will contain a maximum of 20 entities. In case\n   * more than 20 entities exist, the response will contain a nextCursor\n   * property that can be used to fetch the next batch of entities.\n   *\n   * ```\n   * const secondBatchResponse = await catalogClient\n   *  .queryEntities({ cursor: response.nextCursor });\n   * ```\n   *\n   * secondBatchResponse will contain the next batch of (maximum) 20 entities,\n   * together with a prevCursor property, useful to fetch the previous batch.\n   *\n   * @public\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  queryEntities(\n    request?: QueryEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<QueryEntitiesResponse>;\n\n  /**\n   * Gets entity ancestor information, i.e. the hierarchy of parent entities\n   * whose processing resulted in a given entity appearing in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse>;\n\n  /**\n   * Gets a single entity from the catalog by its ref (kind, namespace, name)\n   * triplet.\n   *\n   * @param entityRef - A complete entity ref, either on string or compound form\n   * @param options - Additional options\n   * @returns The matching entity, or undefined if there was no entity with that ref\n   */\n  getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined>;\n\n  /**\n   * Removes a single entity from the catalog by entity UID.\n   *\n   * @param uid - An entity UID\n   * @param options - Additional options\n   */\n  removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Refreshes (marks for reprocessing) an entity in the catalog.\n   *\n   * @param entityRef - An entity ref on string form (e.g.\n   *        'component/default:my-component')\n   * @param options - Additional options\n   */\n  refreshEntity(\n    entityRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Gets a summary of field facets of entities in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse>;\n\n  // Locations\n\n  /**\n   * Gets a registered location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Gets a registered location by its ref.\n   *\n   * @param locationRef - A location ref, e.g. \"url:https://github.com/...\"\n   * @param options - Additional options\n   */\n  getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Registers a new location.\n   *\n   * @param location - Request parameters\n   * @param options - Additional options\n   */\n  addLocation(\n    location: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse>;\n\n  /**\n   * Removes a registered Location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Gets a location associated with an entity.\n   *\n   * @param entityRef - A complete entity ref, either on string or compound form\n   * @param options - Additional options\n   */\n  getLocationByEntity(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Validate entity and its location.\n   *\n   * @param entity - Entity to validate\n   * @param locationRef - Location ref in format `url:http://example.com/file`\n   * @param options - Additional options\n   */\n  validateEntity(\n    entity: Entity,\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<ValidateEntityResponse>;\n}\n"],"names":[],"mappings":";;AA0BO,MAAM,wBAAwB,MAAO,CAAA,GAAA;AAAA;AAAA,EAE1C;AACF;;;;"}