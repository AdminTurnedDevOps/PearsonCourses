import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { stringifyEntityRef, parseEntityRef, DEFAULT_NAMESPACE } from '@backstage/catalog-model';
import { NotFoundError, NotImplementedError } from '@backstage/errors';
import { traverse } from '../plugins/catalog-backend/src/database/operations/stitcher/buildEntitySearch.esm.js';

function buildEntitySearch(entity) {
  const rows = traverse(entity);
  if (entity.metadata?.name) {
    rows.push({
      key: "metadata.name",
      value: entity.metadata.name.toLocaleLowerCase("en-US")
    });
  }
  if (entity.metadata?.namespace) {
    rows.push({
      key: "metadata.namespace",
      value: entity.metadata.namespace.toLocaleLowerCase("en-US")
    });
  }
  if (entity.metadata?.uid) {
    rows.push({
      key: "metadata.uid",
      value: entity.metadata.uid.toLocaleLowerCase("en-US")
    });
  }
  if (!entity.metadata.namespace) {
    rows.push({ key: "metadata.namespace", value: DEFAULT_NAMESPACE });
  }
  for (const relation of entity.relations ?? []) {
    rows.push({
      key: `relations.${relation.type.toLocaleLowerCase("en-US")}`,
      value: relation.targetRef.toLocaleLowerCase("en-US")
    });
  }
  return rows;
}
function createFilter(filterOrFilters) {
  if (!filterOrFilters) {
    return () => true;
  }
  const filters = [filterOrFilters].flat();
  return (entity) => {
    const rows = buildEntitySearch(entity);
    return filters.some((filter) => {
      for (const [key, expectedValue] of Object.entries(filter)) {
        const searchValues = rows.filter((row) => row.key === key.toLocaleLowerCase("en-US")).map((row) => row.value?.toString().toLocaleLowerCase("en-US"));
        if (searchValues.length === 0) {
          return false;
        }
        if (expectedValue === CATALOG_FILTER_EXISTS) {
          continue;
        }
        if (!searchValues?.includes(
          String(expectedValue).toLocaleLowerCase("en-US")
        )) {
          return false;
        }
      }
      return true;
    });
  };
}
class InMemoryCatalogClient {
  #entities;
  constructor(options) {
    this.#entities = options?.entities?.slice() ?? [];
  }
  async getEntities(request) {
    const filter = createFilter(request?.filter);
    return { items: this.#entities.filter(filter) };
  }
  async getEntitiesByRefs(request) {
    const filter = createFilter(request.filter);
    const refMap = this.#createEntityRefMap();
    return {
      items: request.entityRefs.map((ref) => refMap.get(ref)).map((e) => e && filter(e) ? e : void 0)
    };
  }
  async queryEntities(request) {
    if (request && "cursor" in request) {
      return { items: [], pageInfo: {}, totalItems: 0 };
    }
    const filter = createFilter(request?.filter);
    const items = this.#entities.filter(filter);
    return {
      items,
      pageInfo: {},
      totalItems: items.length
    };
  }
  async getEntityAncestors(request) {
    const entity = this.#createEntityRefMap().get(request.entityRef);
    if (!entity) {
      throw new NotFoundError(`Entity with ref ${request.entityRef} not found`);
    }
    return {
      items: [{ entity, parentEntityRefs: [] }],
      rootEntityRef: request.entityRef
    };
  }
  async getEntityByRef(entityRef) {
    return this.#createEntityRefMap().get(
      stringifyEntityRef(parseEntityRef(entityRef))
    );
  }
  async removeEntityByUid(uid) {
    const index = this.#entities.findIndex((e) => e.metadata.uid === uid);
    if (index !== -1) {
      this.#entities.splice(index, 1);
    }
  }
  async refreshEntity(_entityRef) {
  }
  async getEntityFacets(request) {
    const filter = createFilter(request.filter);
    const filteredEntities = this.#entities.filter(filter);
    const facets = Object.fromEntries(
      request.facets.map((facet) => {
        const facetValues = /* @__PURE__ */ new Map();
        for (const entity of filteredEntities) {
          const rows = buildEntitySearch(entity);
          const value = rows.find(
            (row) => row.key === facet.toLocaleLowerCase("en-US")
          )?.value;
          if (value) {
            facetValues.set(
              String(value),
              (facetValues.get(String(value)) ?? 0) + 1
            );
          }
        }
        const counts = Array.from(facetValues.entries()).map(
          ([value, count]) => ({ value, count })
        );
        return [facet, counts];
      })
    );
    return {
      facets
    };
  }
  async getLocationById(_id) {
    throw new NotImplementedError("Method not implemented.");
  }
  async getLocationByRef(_locationRef) {
    throw new NotImplementedError("Method not implemented.");
  }
  async addLocation(_location) {
    throw new NotImplementedError("Method not implemented.");
  }
  async removeLocationById(_id) {
    throw new NotImplementedError("Method not implemented.");
  }
  async getLocationByEntity(_entityRef) {
    throw new NotImplementedError("Method not implemented.");
  }
  async validateEntity(_entity, _locationRef) {
    throw new NotImplementedError("Method not implemented.");
  }
  #createEntityRefMap() {
    return new Map(this.#entities.map((e) => [stringifyEntityRef(e), e]));
  }
}

export { InMemoryCatalogClient };
//# sourceMappingURL=InMemoryCatalogClient.esm.js.map
