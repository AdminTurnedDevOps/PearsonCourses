'use strict';

var crossFetch = require('cross-fetch');
var pluginId = require('../pluginId.cjs.js');
var parser = require('uri-template');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var crossFetch__default = /*#__PURE__*/_interopDefaultCompat(crossFetch);
var parser__namespace = /*#__PURE__*/_interopNamespaceCompat(parser);

class DefaultApiClient {
  discoveryApi;
  fetchApi;
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch__default.default };
  }
  /**
   * Validate a given location.
   * @param analyzeLocationRequest -
   */
  async analyzeLocation(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/analyze-location`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Create a location for a given target.
   * @param createLocationRequest -
   * @param dryRun -
   */
  async createLocation(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/locations{?dryRun}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Delete a single entity by UID.
   * @param uid -
   */
  async deleteEntityByUid(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-uid/{uid}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      uid: request.path.uid
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "DELETE"
    });
  }
  /**
   * Delete a location by id.
   * @param id -
   */
  async deleteLocation(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/locations/{id}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      id: request.path.id
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "DELETE"
    });
  }
  /**
   * Get all entities matching a given filter.
   * @param fields - Restrict to just these fields in the response.
   * @param limit - Number of records to return in the response.
   * @param filter - Filter for just the entities defined by this filter.
   * @param offset - Number of records to skip in the query page.
   * @param after - Pointer to the previous page of results.
   * @param order -
   */
  async getEntities(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities{?fields,limit,filter*,offset,after,order*}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Search for entities by a given query.
   * @param fields - Restrict to just these fields in the response.
   * @param limit - Number of records to return in the response.
   * @param offset - Number of records to skip in the query page.
   * @param orderField - The fields to sort returned results by.
   * @param cursor - Cursor to a set page of results.
   * @param filter - Filter for just the entities defined by this filter.
   * @param fullTextFilterTerm - Text search term.
   * @param fullTextFilterFields - A comma separated list of fields to sort returned results by.
   */
  async getEntitiesByQuery(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-query{?fields,limit,offset,orderField*,cursor,filter*,fullTextFilterTerm,fullTextFilterFields}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get a batch set of entities given an array of entityRefs.
   * @param filter - Filter for just the entities defined by this filter.
   * @param getEntitiesByRefsRequest -
   */
  async getEntitiesByRefs(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-refs{?filter*}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Get an entity's ancestry by entity ref.
   * @param kind -
   * @param namespace -
   * @param name -
   */
  async getEntityAncestryByName(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}/ancestry`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      kind: request.path.kind,
      namespace: request.path.namespace,
      name: request.path.name
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get an entity by an entity ref.
   * @param kind -
   * @param namespace -
   * @param name -
   */
  async getEntityByName(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      kind: request.path.kind,
      namespace: request.path.namespace,
      name: request.path.name
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get a single entity by the UID.
   * @param uid -
   */
  async getEntityByUid(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entities/by-uid/{uid}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      uid: request.path.uid
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get all entity facets that match the given filters.
   * @param facet -
   * @param filter - Filter for just the entities defined by this filter.
   */
  async getEntityFacets(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/entity-facets{?facet*,filter*}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      ...request.query
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get a location by id.
   * @param id -
   */
  async getLocation(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/locations/{id}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      id: request.path.id
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get a location for entity.
   * @param kind -
   * @param namespace -
   * @param name -
   */
  async getLocationByEntity(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/locations/by-entity/{kind}/{namespace}/{name}`;
    const uri = parser__namespace.parse(uriTemplate).expand({
      kind: request.path.kind,
      namespace: request.path.namespace,
      name: request.path.name
    });
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Get all locations
   */
  async getLocations(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/locations`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "GET"
    });
  }
  /**
   * Refresh the entity related to entityRef.
   * @param refreshEntityRequest -
   */
  async refreshEntity(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/refresh`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
  /**
   * Validate that a passed in entity has no errors in schema.
   * @param validateEntityRequest -
   */
  async validateEntity(request, options) {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId.pluginId);
    const uriTemplate = `/validate-entity`;
    const uri = parser__namespace.parse(uriTemplate).expand({});
    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        "Content-Type": "application/json",
        ...options?.token && { Authorization: `Bearer ${options?.token}` }
      },
      method: "POST",
      body: JSON.stringify(request.body)
    });
  }
}

exports.DefaultApiClient = DefaultApiClient;
//# sourceMappingURL=Api.client.cjs.js.map
