{"version":3,"file":"response.cjs.js","sources":["../../src/serialization/response.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ConsumedResponse } from '../errors/types';\nimport { SerializedError } from './error';\n\n/**\n * A standard shape of JSON data returned as the body of backend errors.\n *\n * @public\n */\nexport type ErrorResponseBody = {\n  /** Details of the error that was caught */\n  error: SerializedError;\n\n  /** Details about the incoming request */\n  request?: {\n    /** The HTTP method of the request */\n    method: string;\n    /** The URL of the request (excluding protocol and host/port) */\n    url: string;\n  };\n\n  /** Details about the response */\n  response: {\n    /** The numeric HTTP status code that was returned */\n    statusCode: number;\n  };\n};\n\n/**\n * Attempts to construct an ErrorResponseBody out of a failed server request.\n * Assumes that the response has already been checked to be not ok. This\n * function consumes the body of the response, and assumes that it hasn't\n * been consumed before.\n *\n * The code is forgiving, and constructs a useful synthetic body as best it can\n * if the response body wasn't on the expected form.\n *\n * @public\n * @param response - The response of a failed request\n */\nexport async function parseErrorResponseBody(\n  response: ConsumedResponse & { text(): Promise<string> },\n): Promise<ErrorResponseBody> {\n  try {\n    const text = await response.text();\n    if (text) {\n      if (\n        response.headers.get('content-type')?.startsWith('application/json')\n      ) {\n        try {\n          const body = JSON.parse(text);\n          if (body.error && body.response) {\n            return body;\n          }\n        } catch {\n          // ignore\n        }\n      }\n\n      return {\n        error: {\n          name: 'Error',\n          message: `Request failed with status ${response.status} ${response.statusText}, ${text}`,\n        },\n        response: {\n          statusCode: response.status,\n        },\n      };\n    }\n  } catch {\n    // ignore\n  }\n\n  return {\n    error: {\n      name: 'Error',\n      message: `Request failed with status ${response.status} ${response.statusText}`,\n    },\n    response: {\n      statusCode: response.status,\n    },\n  };\n}\n"],"names":[],"mappings":";;AAuDA,eAAsB,uBACpB,QAC4B,EAAA;AAC5B,EAAI,IAAA;AACF,IAAM,MAAA,IAAA,GAAO,MAAM,QAAA,CAAS,IAAK,EAAA;AACjC,IAAA,IAAI,IAAM,EAAA;AACR,MAAA,IACE,SAAS,OAAQ,CAAA,GAAA,CAAI,cAAc,CAAG,EAAA,UAAA,CAAW,kBAAkB,CACnE,EAAA;AACA,QAAI,IAAA;AACF,UAAM,MAAA,IAAA,GAAO,IAAK,CAAA,KAAA,CAAM,IAAI,CAAA;AAC5B,UAAI,IAAA,IAAA,CAAK,KAAS,IAAA,IAAA,CAAK,QAAU,EAAA;AAC/B,YAAO,OAAA,IAAA;AAAA;AACT,SACM,CAAA,MAAA;AAAA;AAER;AAGF,MAAO,OAAA;AAAA,QACL,KAAO,EAAA;AAAA,UACL,IAAM,EAAA,OAAA;AAAA,UACN,OAAA,EAAS,8BAA8B,QAAS,CAAA,MAAM,IAAI,QAAS,CAAA,UAAU,KAAK,IAAI,CAAA;AAAA,SACxF;AAAA,QACA,QAAU,EAAA;AAAA,UACR,YAAY,QAAS,CAAA;AAAA;AACvB,OACF;AAAA;AACF,GACM,CAAA,MAAA;AAAA;AAIR,EAAO,OAAA;AAAA,IACL,KAAO,EAAA;AAAA,MACL,IAAM,EAAA,OAAA;AAAA,MACN,SAAS,CAA8B,2BAAA,EAAA,QAAA,CAAS,MAAM,CAAA,CAAA,EAAI,SAAS,UAAU,CAAA;AAAA,KAC/E;AAAA,IACA,QAAU,EAAA;AAAA,MACR,YAAY,QAAS,CAAA;AAAA;AACvB,GACF;AACF;;;;"}