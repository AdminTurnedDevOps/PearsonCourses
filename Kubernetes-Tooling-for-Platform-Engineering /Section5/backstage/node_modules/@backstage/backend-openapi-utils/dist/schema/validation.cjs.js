'use strict';

var Ajv = require('ajv');
var Parser = require('@apidevtools/swagger-parser');
var parameterValidation = require('./parameter-validation.cjs.js');
var errors = require('./errors.cjs.js');
var requestBodyValidation = require('./request-body-validation.cjs.js');
var utils = require('./utils.cjs.js');
var responseBodyValidation = require('./response-body-validation.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultCompat(Ajv);
var Parser__default = /*#__PURE__*/_interopDefaultCompat(Parser);

const ajv = new Ajv__default.default({ allErrors: true });
class RequestBodyValidator {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  async validate({ pair, operation }) {
    const { request, response } = pair;
    if (response.statusCode === 400) {
      return;
    }
    const parser = requestBodyValidation.RequestBodyParser.fromOperation(operation, { ajv });
    const fetchRequest = utils.mockttpToFetchRequest(request);
    await parser.parse(fetchRequest);
  }
}
class ResponseBodyValidator {
  schema;
  constructor(schema) {
    this.schema = schema;
  }
  async validate({ pair, operation }) {
    const { response } = pair;
    const parser = responseBodyValidation.ResponseBodyParser.fromOperation(operation, { ajv });
    const fetchResponse = utils.mockttpToFetchResponse(response);
    await parser.parse(fetchResponse);
  }
}
function findOperationByRequest(openApiSchema, request) {
  const { url } = request;
  const { pathname } = new URL(url);
  const parts = pathname.split("/");
  for (const [path, schema] of Object.entries(openApiSchema.paths)) {
    const pathParts = path.split("/");
    if (parts.length !== pathParts.length) {
      continue;
    }
    let found = true;
    for (let i = 0; i < parts.length; i++) {
      if (pathParts[i] === parts[i]) {
        continue;
      }
      if (pathParts[i].startsWith("{") && pathParts[i].endsWith("}")) {
        continue;
      }
      found = false;
      break;
    }
    if (!found) {
      continue;
    }
    let matchingOperationType = void 0;
    for (const [operationType, operation] of Object.entries(schema)) {
      if (operationType === request.method.toLowerCase()) {
        matchingOperationType = operation;
        break;
      }
    }
    if (!matchingOperationType) {
      continue;
    }
    return [path, matchingOperationType];
  }
  return void 0;
}
class OpenApiProxyValidator {
  schema;
  validators;
  async initialize(url) {
    this.schema = await Parser__default.default.dereference(url);
    this.validators = [
      new parameterValidation.ParameterValidator(this.schema),
      new RequestBodyValidator(this.schema),
      new ResponseBodyValidator(this.schema)
    ];
  }
  async validate(request, response) {
    const operationPathTuple = findOperationByRequest(this.schema, request);
    if (!operationPathTuple) {
      throw new errors.OperationError(
        { path: request.path, method: request.method },
        `No operation schema found for ${request.url}`
      );
    }
    const [path, operationSchema] = operationPathTuple;
    const operation = { path, method: request.method, schema: operationSchema };
    const validators = this.validators;
    await Promise.all(
      validators.map(
        (validator) => validator.validate({
          pair: { request, response },
          operation
        })
      )
    );
  }
}

exports.OpenApiProxyValidator = OpenApiProxyValidator;
exports.findOperationByRequest = findOperationByRequest;
//# sourceMappingURL=validation.cjs.js.map
