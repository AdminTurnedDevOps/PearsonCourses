'use strict';

var errors = require('./errors.cjs.js');

class DisabledResponseBodyParser {
  operation;
  constructor(operation) {
    this.operation = operation;
  }
  async parse(response) {
    const body = await response.text();
    if (body?.length) {
      throw new errors.OperationError(
        this.operation,
        "Received a body but no schema was found"
      );
    }
    return void 0;
  }
}
class ResponseBodyParser {
  operation;
  ajv;
  static fromOperation(operation, options) {
    return operation.schema.responses && Object.keys(operation.schema.responses).length ? new ResponseBodyParser(operation, options) : new DisabledResponseBodyParser(operation);
  }
  constructor(operation, options) {
    this.operation = operation;
    this.ajv = options.ajv;
    const responseSchemas = operation.schema.responses;
    for (const [statusCode, schema] of Object.entries(responseSchemas)) {
      const contentTypes = schema.content;
      if (!contentTypes) {
        continue;
      }
      const jsonContentType = Object.keys(contentTypes).find(
        (contentType) => contentType.split(";").includes("application/json")
      );
      if (!jsonContentType) {
        throw new errors.OperationError(
          this.operation,
          `No application/json content type found in response for status code ${statusCode}`
        );
      } else if ("$ref" in contentTypes[jsonContentType].schema) {
        throw new errors.OperationError(
          this.operation,
          "Reference objects are not supported"
        );
      }
    }
  }
  async parse(response) {
    const body = await response.text();
    const responseSchema = this.findResponseSchema(
      this.operation.schema,
      response
    );
    if (!responseSchema?.content && !body?.length) {
      return void 0;
    }
    if (!responseSchema) {
      throw new errors.OperationResponseError(
        this.operation,
        response,
        `No schema found.`
      );
    }
    const contentTypes = responseSchema.content;
    if (!contentTypes && body?.length) {
      throw new errors.OperationResponseError(
        this.operation,
        response,
        "Received a body but no schema was found"
      );
    }
    const jsonContentType = Object.keys(contentTypes ?? {}).find(
      (contentType) => contentType.split(";").includes("application/json")
    );
    if (!jsonContentType) {
      throw new errors.OperationResponseError(
        this.operation,
        response,
        "No application/json content type found in response"
      );
    }
    const schema = responseSchema.content[jsonContentType].schema;
    if (!schema) {
      throw new errors.OperationError(this.operation, "No schema found in response");
    }
    if ("$ref" in schema) {
      throw new errors.OperationResponseError(
        this.operation,
        response,
        "Reference objects are not supported"
      );
    }
    if (!schema.required && !body?.length) {
      throw new errors.OperationResponseError(
        this.operation,
        response,
        "Response body is required but missing"
      );
    } else if (!schema.required && !body?.length) {
      return void 0;
    }
    const validate = this.ajv.compile(schema);
    const jsonBody = await response.json();
    const valid = validate(jsonBody);
    if (!valid) {
      throw new errors.OperationParsingResponseError(
        this.operation,
        response,
        "Response body",
        validate.errors
      );
    }
    return jsonBody;
  }
  findResponseSchema(operationSchema, { status }) {
    return operationSchema.responses?.[status] ?? operationSchema.responses?.default;
  }
}

exports.ResponseBodyParser = ResponseBodyParser;
//# sourceMappingURL=response-body-validation.cjs.js.map
