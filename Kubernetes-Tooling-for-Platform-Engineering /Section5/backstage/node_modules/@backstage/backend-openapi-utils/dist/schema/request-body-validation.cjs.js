'use strict';

var errors = require('./errors.cjs.js');

class DisabledRequestBodyParser {
  operation;
  constructor(operation) {
    this.operation = operation;
  }
  async parse(request) {
    const bodyText = await request.text();
    if (bodyText?.length) {
      throw new errors.OperationError(
        this.operation,
        "Received a body but no schema was found"
      );
    }
    return void 0;
  }
}
class RequestBodyParser {
  operation;
  disabled = false;
  validate;
  schema;
  requestBodySchema;
  static fromOperation(operation, options) {
    return operation.schema.requestBody ? new RequestBodyParser(operation, options) : new DisabledRequestBodyParser(operation);
  }
  constructor(operation, options) {
    this.operation = operation;
    const { schema: operationSchema } = this.operation;
    const requestBody = operationSchema.requestBody;
    if (!requestBody) {
      throw new errors.OperationError(
        this.operation,
        "No request body found in operation"
      );
    }
    if ("$ref" in requestBody) {
      throw new errors.OperationError(
        this.operation,
        "Reference objects are not supported"
      );
    }
    if (!requestBody.content) {
      throw new errors.OperationError(
        this.operation,
        "No content found in request body"
      );
    }
    const contentTypes = requestBody.content;
    const jsonContentType = Object.keys(contentTypes).find(
      (contentType) => contentType.split(";").includes("application/json")
    );
    if (!jsonContentType) {
      throw new errors.OperationError(
        this.operation,
        "No application/json content type found in request body"
      );
    }
    const schema = requestBody.content[jsonContentType].schema;
    if (!schema) {
      throw new errors.OperationError(
        this.operation,
        "No JSON schema found in request body"
      );
    }
    if ("$ref" in schema) {
      throw new errors.OperationError(
        this.operation,
        "Reference objects are not supported"
      );
    }
    this.validate = options.ajv.compile(schema);
    this.schema = schema;
    this.requestBodySchema = requestBody;
  }
  async parse(request) {
    const bodyText = await request.text();
    if (this.requestBodySchema.required && !bodyText?.length) {
      throw new errors.OperationError(
        this.operation,
        `No request body found for ${request.url}`
      );
    }
    const contentType = request.headers.get("content-type") || "application/json";
    if (!contentType.split(";").includes("application/json")) {
      throw new errors.OperationError(
        this.operation,
        "Content type is not application/json"
      );
    }
    const body = await request.json();
    const valid = this.validate(body);
    if (!valid) {
      throw new errors.OperationParsingError(
        this.operation,
        `Request body`,
        this.validate.errors
      );
    }
    return body;
  }
}

exports.RequestBodyParser = RequestBodyParser;
//# sourceMappingURL=request-body-validation.cjs.js.map
