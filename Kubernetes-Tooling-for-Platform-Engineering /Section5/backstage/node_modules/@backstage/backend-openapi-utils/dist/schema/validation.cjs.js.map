{"version":3,"file":"validation.cjs.js","sources":["../../src/schema/validation.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CompletedRequest, CompletedResponse } from 'mockttp';\nimport { OpenAPIObject, OperationObject } from 'openapi3-ts';\nimport Ajv from 'ajv';\nimport Parser from '@apidevtools/swagger-parser';\nimport { Operation, Validator, ValidatorParams } from './types';\nimport { ParameterValidator } from './parameter-validation';\nimport { OperationError } from './errors';\nimport { RequestBodyParser } from './request-body-validation';\nimport { mockttpToFetchRequest, mockttpToFetchResponse } from './utils';\nimport { ResponseBodyParser } from './response-body-validation';\n\nconst ajv = new Ajv({ allErrors: true });\n\nclass RequestBodyValidator implements Validator {\n  schema: OpenAPIObject;\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair, operation }: ValidatorParams) {\n    const { request, response } = pair;\n    if (response.statusCode === 400) {\n      // If the response is a 400, then the request is invalid and we shouldn't validate the parameters\n      return;\n    }\n\n    // NOTE: There may be a worthwhile optimization here to cache these results to avoid re-parsing the schema for every request. As is, I don't think this is a big deal.\n    const parser = RequestBodyParser.fromOperation(operation, { ajv });\n    const fetchRequest = mockttpToFetchRequest(request);\n    await parser.parse(fetchRequest);\n  }\n}\n\nclass ResponseBodyValidator implements Validator {\n  schema: OpenAPIObject;\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair, operation }: ValidatorParams) {\n    const { response } = pair;\n    // NOTE: There may be a worthwhile optimization here to cache these results to avoid re-parsing the schema for every request. As is, I don't think this is a big deal.\n    const parser = ResponseBodyParser.fromOperation(operation, { ajv });\n    const fetchResponse = mockttpToFetchResponse(response);\n    await parser.parse(fetchResponse);\n  }\n}\n\n/**\n * Find an operation in an OpenAPI schema that matches a request. This is done by comparing the request URL to the paths in the schema.\n * @param openApiSchema - The OpenAPI schema to search for the operation in.\n * @param request - The request to find the operation for.\n * @returns A tuple of the path and the operation object that matches the request.\n */\nexport function findOperationByRequest(\n  openApiSchema: OpenAPIObject,\n  request: CompletedRequest,\n): [string, OperationObject] | undefined {\n  const { url } = request;\n  const { pathname } = new URL(url);\n\n  const parts = pathname.split('/');\n  for (const [path, schema] of Object.entries(openApiSchema.paths)) {\n    const pathParts = path.split('/');\n    if (parts.length !== pathParts.length) {\n      continue;\n    }\n    let found = true;\n    for (let i = 0; i < parts.length; i++) {\n      if (pathParts[i] === parts[i]) {\n        continue;\n      }\n      // If the path part is a parameter, we can count it as a match. eg /api/{id} will match /api/1\n      if (pathParts[i].startsWith('{') && pathParts[i].endsWith('}')) {\n        continue;\n      }\n      found = false;\n      break;\n    }\n    if (!found) {\n      continue;\n    }\n    let matchingOperationType: OperationObject | undefined = undefined;\n    for (const [operationType, operation] of Object.entries(schema)) {\n      if (operationType === request.method.toLowerCase()) {\n        matchingOperationType = operation as OperationObject;\n        break;\n      }\n    }\n    if (!matchingOperationType) {\n      continue;\n    }\n    return [path, matchingOperationType];\n  }\n\n  return undefined;\n}\n\nexport class OpenApiProxyValidator {\n  schema: OpenAPIObject | undefined;\n  validators: Validator[] | undefined;\n\n  async initialize(url: string) {\n    this.schema = (await Parser.dereference(url)) as unknown as OpenAPIObject;\n    this.validators = [\n      new ParameterValidator(this.schema),\n      new RequestBodyValidator(this.schema),\n      new ResponseBodyValidator(this.schema),\n    ];\n  }\n\n  async validate(request: CompletedRequest, response: CompletedResponse) {\n    const operationPathTuple = findOperationByRequest(this.schema!, request);\n    if (!operationPathTuple) {\n      throw new OperationError(\n        { path: request.path, method: request.method } as Operation,\n        `No operation schema found for ${request.url}`,\n      );\n    }\n\n    const [path, operationSchema] = operationPathTuple;\n    const operation = { path, method: request.method, schema: operationSchema };\n\n    const validators = this.validators!;\n    await Promise.all(\n      validators.map(validator =>\n        validator.validate({\n          pair: { request, response },\n          operation,\n        }),\n      ),\n    );\n  }\n}\n"],"names":["Ajv","RequestBodyParser","mockttpToFetchRequest","ResponseBodyParser","mockttpToFetchResponse","Parser","ParameterValidator","OperationError"],"mappings":"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"}