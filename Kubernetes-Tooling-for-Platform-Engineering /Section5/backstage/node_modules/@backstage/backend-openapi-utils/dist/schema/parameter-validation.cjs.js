'use strict';

var Ajv = require('ajv');
var errors = require('./errors.cjs.js');
var utils = require('./utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultCompat(Ajv);

class BaseParameterParser {
  ajv;
  operation;
  parameters = {};
  constructor(parameterIn, operation, options) {
    this.ajv = options.ajv;
    this.operation = operation;
    const { schema, path, method } = operation;
    const parameters = schema.parameters || [];
    for (const parameter of parameters) {
      if ("$ref" in parameter) {
        throw new Error(
          `[(${method}) ${path}] Reference objects are not supported`
        );
      }
      if (!parameter.schema) {
        throw new errors.OperationError(
          operation,
          "Schema not found for path parameter"
        );
      }
      if ("$ref" in parameter.schema) {
        throw new errors.OperationError(
          this.operation,
          "Reference objects are not supported for parameters"
        );
      }
      if (parameter.in === parameterIn) {
        this.parameters[parameter.name] = parameter;
      }
    }
  }
  /**
   * Attempt to transform a string value to its expected type, this allows Ajv to perform validation. As these are parameters,
   *  support for edge cases like nested type casting is not currently supported.
   * @param value
   * @param schema
   * @returns
   */
  optimisticallyParseValue(value, schema) {
    if (schema.type === "integer") {
      return parseInt(value, 10);
    }
    if (schema.type === "number") {
      return parseFloat(value);
    }
    if (schema.type === "boolean") {
      if (["true", "false"].includes(value)) {
        return value === "true";
      }
      throw new Error('Invalid boolean value must be either "true" or "false"');
    }
    return value;
  }
}
class QueryParameterParser extends BaseParameterParser {
  constructor(operation, options) {
    super("query", operation, options);
  }
  async parse(request) {
    const { searchParams } = new URL(request.url);
    const remainingQueryParameters = new Set(searchParams.keys());
    const queryParameters = {};
    let parameterIterator = Object.entries(this.parameters);
    const isFormExplode = (parameter) => {
      return parameter.schema?.type === "object" && (parameter.style === "form" || !parameter.style) && parameter.explode;
    };
    const regularParameters = parameterIterator.filter(
      ([_, parameter]) => !isFormExplode(parameter)
    );
    const formExplodeParameters = parameterIterator.filter(
      ([_, parameter]) => isFormExplode(parameter)
    );
    if (formExplodeParameters.length > 1) {
      throw new errors.OperationError(
        this.operation,
        "Ambiguous query parameters, you cannot have 2 form explode parameters"
      );
    }
    parameterIterator = [...regularParameters, ...formExplodeParameters];
    for (const [name, parameter] of parameterIterator) {
      if (!parameter.schema) {
        throw new errors.OperationError(
          this.operation,
          "Schema not found for query parameter"
        );
      }
      if ("$ref" in parameter.schema) {
        throw new errors.OperationError(
          this.operation,
          "Reference objects are not supported for parameters"
        );
      }
      let [param, indices] = this.#findQueryParameters(
        this.parameters,
        remainingQueryParameters,
        searchParams,
        name
      );
      if (!!param) {
        indices.forEach((index) => remainingQueryParameters.delete(index));
      }
      if (parameter.schema.type !== "array" && Array.isArray(param)) {
        param = param.length > 0 ? param[0] : void 0;
      }
      if (parameter.required && !indices.some((index) => searchParams.has(index))) {
        throw new errors.OperationError(
          this.operation,
          `Required query parameter ${name} not found`
        );
      } else if (!param && !parameter.required) {
        continue;
      }
      if (param) {
        param = this.optimisticallyParseValue(param, parameter.schema);
      }
      const validate = this.ajv.compile(parameter.schema);
      const valid = validate(param);
      if (!valid) {
        throw new errors.OperationParsingError(
          this.operation,
          "Query parameter",
          validate.errors
        );
      }
      queryParameters[name] = param;
    }
    if (remainingQueryParameters.size > 0) {
      throw new errors.OperationError(
        this.operation,
        `Unexpected query parameters: ${Array.from(
          remainingQueryParameters
        ).join(", ")}`
      );
    }
    return queryParameters;
  }
  #findQueryParameters(parameters, remainingQueryParameters, searchParams, name) {
    const parameter = parameters[name];
    const schema = parameter.schema;
    const getIfExists = (key) => searchParams.has(key) ? searchParams.getAll(key) : null;
    if (schema.type === "array") {
      if (parameter.style === "form" || typeof parameter.style === "undefined") {
        if (parameter.explode || typeof parameter.explode === "undefined") {
          if (!searchParams.has(name) && searchParams.has(`${name}[0]`)) {
            const values = [];
            const indices = [];
            let index = 0;
            while (searchParams.has(`${name}[${index}]`)) {
              values.push(searchParams.get(`${name}[${index}]`));
              indices.push(`${name}[${index}]`);
              index++;
            }
            return [values, indices];
          }
          return [getIfExists(name), [name]];
        }
        if (!searchParams.has(name) && searchParams.has(`${name}[]`)) {
          return [searchParams.get(`${name}[]`)?.split(","), [`${name}[]`]];
        }
        if (searchParams.has(name) && searchParams.getAll(name).length > 1) {
          throw new errors.OperationError(
            this.operation,
            "Arrays must be comma separated in non-explode mode"
          );
        }
        return [searchParams.get(name)?.split(","), [name]];
      } else if (parameter.style === "spaceDelimited") {
        return [searchParams.get(name)?.split(" "), [name]];
      } else if (parameter.style === "pipeDelimited") {
        return [searchParams.get(name)?.split("|"), [name]];
      }
      throw new errors.OperationError(
        this.operation,
        "Unsupported style for array parameter"
      );
    }
    if (schema.type === "object") {
      if (parameter.style === "form" || typeof parameter.style === "undefined") {
        if (parameter.explode) {
          const obj2 = {};
          const indices = [];
          for (const [key, value2] of searchParams.entries()) {
            if (!remainingQueryParameters.has(key)) {
              continue;
            }
            indices.push(key);
            obj2[key] = value2;
          }
          return [obj2, indices];
        }
        const obj = {};
        const value = searchParams.get(name);
        if (value) {
          const parts = value.split(",");
          if (parts.length % 2 !== 0) {
            throw new errors.OperationError(
              this.operation,
              "Invalid object query parameter, must have an even number of key-value pairs"
            );
          }
          for (let i = 0; i < parts.length; i += 2) {
            obj[parts[i]] = parts[i + 1];
          }
        }
        return [obj, [name]];
      } else if (parameter.style === "deepObject") {
        const obj = {};
        const indices = [];
        for (const [key, value] of searchParams.entries()) {
          if (key.startsWith(`${name}[`)) {
            indices.push(key);
            const parts = key.split("[");
            let currentLayer = obj;
            for (let partIndex = 1; partIndex < parts.length - 1; partIndex++) {
              const part = parts[partIndex];
              if (!part.includes("]")) {
                throw new errors.OperationError(
                  this.operation,
                  `Invalid object parameter, missing closing bracket for key "${key}"`
                );
              }
              const objKey = part.split("]")[0];
              if (!currentLayer[objKey]) {
                currentLayer[objKey] = {};
              }
              currentLayer = currentLayer[objKey];
            }
            const lastPart = parts[parts.length - 1];
            if (!lastPart.includes("]")) {
              throw new errors.OperationError(
                this.operation,
                `Invalid object parameter, missing closing bracket for key "${key}"`
              );
            }
            currentLayer[lastPart.split("]")[0]] = value;
          }
        }
        return [obj, indices];
      }
      throw new errors.OperationError(
        this.operation,
        `Unsupported style for object parameter, "${parameter.style}"`
      );
    }
    return [getIfExists(name), [name]];
  }
}
class HeaderParameterParser extends BaseParameterParser {
  constructor(operation, options) {
    super("header", operation, options);
  }
  async parse(request) {
    const headerParameters = {};
    for (const [name, parameter] of Object.entries(this.parameters)) {
      const header = request.headers.get(name);
      if (!header) {
        if (parameter.required) {
          throw new errors.OperationError(
            this.operation,
            `Header parameter ${name} not found`
          );
        }
        continue;
      }
      if (!parameter.schema) {
        throw new errors.OperationError(
          this.operation,
          "Schema not found for header parameter"
        );
      }
      if ("$ref" in parameter.schema) {
        throw new errors.OperationError(
          this.operation,
          "Reference objects are not supported for parameters"
        );
      }
      const validate = this.ajv.compile(parameter.schema);
      const valid = validate(header);
      if (!valid) {
        throw new errors.OperationParsingError(
          this.operation,
          "Header parameter",
          validate.errors
        );
      }
      headerParameters[name] = header;
    }
    return headerParameters;
  }
}
class PathParameterParser extends BaseParameterParser {
  constructor(operation, options) {
    super("path", operation, options);
  }
  async parse(request) {
    const { pathname } = new URL(request.url);
    const params = PathParameterParser.parsePath({
      operation: this.operation,
      path: pathname,
      schema: this.operation.path
    });
    const pathParameters = {};
    for (const [name, parameter] of Object.entries(this.parameters)) {
      let param = params[name];
      if (!param && parameter.required) {
        throw new errors.OperationError(
          this.operation,
          `Path parameter ${name} not found`
        );
      } else if (!params[name] && !parameter.required) {
        continue;
      }
      if (param) {
        param = this.optimisticallyParseValue(param, parameter.schema);
      }
      const validate = this.ajv.compile(parameter.schema);
      const valid = validate(param);
      if (!valid) {
        throw new errors.OperationParsingError(
          this.operation,
          "Path parameter",
          validate.errors
        );
      }
      pathParameters[name] = param;
    }
    return pathParameters;
  }
  static parsePath({
    operation,
    schema,
    path
  }) {
    const parts = path.split("/");
    const pathParts = schema.split("/");
    if (parts.length !== pathParts.length) {
      throw new errors.OperationError(operation, "Path parts do not match");
    }
    const params = {};
    for (let i = 0; i < parts.length; i++) {
      if (pathParts[i] === parts[i]) {
        continue;
      }
      if (pathParts[i].startsWith("{") && pathParts[i].endsWith("}")) {
        params[pathParts[i].slice(1, -1)] = parts[i];
        continue;
      }
      break;
    }
    return params;
  }
}
class ParameterValidator {
  schema;
  cache = {};
  constructor(schema) {
    this.schema = schema;
  }
  async validate({ pair: { request, response }, operation }) {
    if (response.statusCode === 400) {
      return;
    }
    const ajv = new Ajv__default.default();
    const queryParser = new QueryParameterParser(operation, { ajv });
    const headerParser = new HeaderParameterParser(operation, { ajv });
    const pathParser = new PathParameterParser(operation, { ajv });
    const fetchRequest = utils.mockttpToFetchRequest(request);
    await Promise.all([
      queryParser.parse(fetchRequest),
      headerParser.parse(fetchRequest),
      pathParser.parse(fetchRequest)
    ]);
  }
}

exports.HeaderParameterParser = HeaderParameterParser;
exports.ParameterValidator = ParameterValidator;
exports.PathParameterParser = PathParameterParser;
exports.QueryParameterParser = QueryParameterParser;
//# sourceMappingURL=parameter-validation.cjs.js.map
