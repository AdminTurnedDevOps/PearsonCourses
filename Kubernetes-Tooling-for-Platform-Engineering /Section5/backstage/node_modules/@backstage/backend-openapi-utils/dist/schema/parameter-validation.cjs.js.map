{"version":3,"file":"parameter-validation.cjs.js","sources":["../../src/schema/parameter-validation.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OpenAPIObject, ParameterObject, SchemaObject } from 'openapi3-ts';\nimport {\n  Operation,\n  ParserOptions,\n  RequestParser,\n  Validator,\n  ValidatorParams,\n} from './types';\nimport Ajv from 'ajv';\nimport { OperationError, OperationParsingError } from './errors';\nimport { mockttpToFetchRequest } from './utils';\n\ntype ReferencelessSchemaObject = SchemaObject & { $ref?: never };\n\ntype ReferencelessParameterObject = Omit<ParameterObject, 'schema'> & {\n  schema: ReferencelessSchemaObject;\n};\n\nclass BaseParameterParser {\n  ajv: Ajv;\n  operation: Operation;\n  parameters: Record<string, ReferencelessParameterObject> = {};\n  constructor(\n    parameterIn: string,\n    operation: Operation,\n    options: ParserOptions,\n  ) {\n    this.ajv = options.ajv;\n    this.operation = operation;\n    const { schema, path, method } = operation;\n    const parameters = schema.parameters || [];\n    for (const parameter of parameters) {\n      if ('$ref' in parameter) {\n        throw new Error(\n          `[(${method}) ${path}] Reference objects are not supported`,\n        );\n      }\n\n      if (!parameter.schema) {\n        throw new OperationError(\n          operation,\n          'Schema not found for path parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      if (parameter.in === parameterIn) {\n        this.parameters[parameter.name] =\n          parameter as ReferencelessParameterObject;\n      }\n    }\n  }\n\n  /**\n   * Attempt to transform a string value to its expected type, this allows Ajv to perform validation. As these are parameters,\n   *  support for edge cases like nested type casting is not currently supported.\n   * @param value\n   * @param schema\n   * @returns\n   */\n  optimisticallyParseValue(value: string, schema: SchemaObject) {\n    if (schema.type === 'integer') {\n      return parseInt(value, 10);\n    }\n    if (schema.type === 'number') {\n      return parseFloat(value);\n    }\n    if (schema.type === 'boolean') {\n      if (['true', 'false'].includes(value)) {\n        return value === 'true';\n      }\n      throw new Error('Invalid boolean value must be either \"true\" or \"false\"');\n    }\n    return value;\n  }\n}\n\nexport class QueryParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('query', operation, options);\n  }\n  async parse(request: Request) {\n    const { searchParams } = new URL(request.url);\n    const remainingQueryParameters = new Set<string>(searchParams.keys());\n    const queryParameters: Record<string, any> = {};\n\n    let parameterIterator = Object.entries(this.parameters);\n\n    const isFormExplode = (parameter: ReferencelessParameterObject) => {\n      return (\n        parameter.schema?.type === 'object' &&\n        (parameter.style === 'form' || !parameter.style) &&\n        parameter.explode\n      );\n    };\n\n    const regularParameters = parameterIterator.filter(\n      ([_, parameter]) => !isFormExplode(parameter),\n    );\n\n    const formExplodeParameters = parameterIterator.filter(([_, parameter]) =>\n      isFormExplode(parameter),\n    );\n\n    if (formExplodeParameters.length > 1) {\n      throw new OperationError(\n        this.operation,\n        'Ambiguous query parameters, you cannot have 2 form explode parameters',\n      );\n    }\n\n    // Sort the parameters so that form explode parameters are processed last.\n    parameterIterator = [...regularParameters, ...formExplodeParameters];\n\n    for (const [name, parameter] of parameterIterator) {\n      if (!parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Schema not found for query parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      // eslint-disable-next-line prefer-const\n      let [param, indices]: [any | null, string[]] = this.#findQueryParameters(\n        this.parameters,\n        remainingQueryParameters,\n        searchParams,\n        name,\n      );\n      if (!!param) {\n        indices.forEach(index => remainingQueryParameters.delete(index));\n      }\n\n      // The query parameters can be either a single value or an array of values, try to wrangle them into the expected format if they're not explicitly an array.\n      if (parameter.schema.type !== 'array' && Array.isArray(param)) {\n        param = param.length > 0 ? param[0] : undefined;\n      }\n      if (\n        parameter.required &&\n        !indices.some(index => searchParams.has(index))\n      ) {\n        throw new OperationError(\n          this.operation,\n          `Required query parameter ${name} not found`,\n        );\n      } else if (!param && !parameter.required) {\n        continue;\n      }\n      if (param) {\n        // We do this here because all query parameters are strings but the schema will expect the real value.\n        param = this.optimisticallyParseValue(param, parameter.schema);\n      }\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(param);\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Query parameter',\n          validate.errors!,\n        );\n      }\n      queryParameters[name] = param;\n    }\n    if (remainingQueryParameters.size > 0) {\n      throw new OperationError(\n        this.operation,\n        `Unexpected query parameters: ${Array.from(\n          remainingQueryParameters,\n        ).join(', ')}`,\n      );\n    }\n    return queryParameters;\n  }\n\n  #findQueryParameters(\n    parameters: Record<string, ParameterObject>,\n    remainingQueryParameters: Set<string>,\n    searchParams: URLSearchParams,\n    name: string,\n  ): [any | null, string[]] {\n    const parameter = parameters[name];\n    const schema = parameter.schema as SchemaObject;\n\n    // Since getAll will return an empty array if the key is not found, we need to check if the key exists first.\n    const getIfExists = (key: string) =>\n      searchParams.has(key) ? searchParams.getAll(key) : null;\n\n    if (schema.type === 'array') {\n      // Form is the default array format.\n      if (\n        parameter.style === 'form' ||\n        typeof parameter.style === 'undefined'\n      ) {\n        // As is explode = true.\n        if (parameter.explode || typeof parameter.explode === 'undefined') {\n          // Support for qs explode format. Every value is stored as a separate query parameter.\n          if (!searchParams.has(name) && searchParams.has(`${name}[0]`)) {\n            const values: string[] = [];\n            const indices: string[] = [];\n            let index = 0;\n            while (searchParams.has(`${name}[${index}]`)) {\n              values.push(searchParams.get(`${name}[${index}]`)!);\n              indices.push(`${name}[${index}]`);\n              index++;\n            }\n            return [values, indices];\n          }\n          // If not qs format, grab all values with the same name from search params.\n          return [getIfExists(name), [name]];\n        }\n        // Add support for qs non-standard array format. This is helpful for search-backend, since that uses qs still.\n        if (!searchParams.has(name) && searchParams.has(`${name}[]`)) {\n          return [searchParams.get(`${name}[]`)?.split(','), [`${name}[]`]];\n        }\n        // Non-explode arrays should be comma separated.\n        if (searchParams.has(name) && searchParams.getAll(name).length > 1) {\n          throw new OperationError(\n            this.operation,\n            'Arrays must be comma separated in non-explode mode',\n          );\n        }\n        return [searchParams.get(name)?.split(','), [name]];\n      } else if (parameter.style === 'spaceDelimited') {\n        return [searchParams.get(name)?.split(' '), [name]];\n      } else if (parameter.style === 'pipeDelimited') {\n        return [searchParams.get(name)?.split('|'), [name]];\n      }\n      throw new OperationError(\n        this.operation,\n        'Unsupported style for array parameter',\n      );\n    }\n    if (schema.type === 'object') {\n      // Form is the default object format.\n      if (\n        parameter.style === 'form' ||\n        typeof parameter.style === 'undefined'\n      ) {\n        if (parameter.explode) {\n          // Object form/explode is a collection of disjoint keys, there's no mapping for what they are so we collect all of them.\n          // This means we need to run this as the last query parameter that is processed.\n          const obj: Record<string, string> = {};\n          const indices: string[] = [];\n          for (const [key, value] of searchParams.entries()) {\n            // Have we processed this query parameter as part of another parameter parsing? If not, consider it to be a part of this object.\n            if (!remainingQueryParameters.has(key)) {\n              continue;\n            }\n            indices.push(key);\n            obj[key] = value;\n          }\n          return [obj, indices];\n        }\n        // For non-explode, the schema is comma separated key,value \"pairs\", so filter=key1,value1,key2,value2 would parse to {key1: value1, key2: value2}.\n        const obj: Record<string, string> = {};\n        const value = searchParams.get(name);\n        if (value) {\n          const parts = value.split(',');\n          if (parts.length % 2 !== 0) {\n            throw new OperationError(\n              this.operation,\n              'Invalid object query parameter, must have an even number of key-value pairs',\n            );\n          }\n          for (let i = 0; i < parts.length; i += 2) {\n            obj[parts[i]] = parts[i + 1];\n          }\n        }\n        return [obj, [name]];\n      } else if (parameter.style === 'deepObject') {\n        // Deep object is a nested object structure, so we need to parse the keys to build the object.\n        // example: ?filter[key1]=value1&filter[key2]=value2 => { key1: value1, key2: value2 }\n        const obj: Record<string, any> = {};\n        const indices: string[] = [];\n        for (const [key, value] of searchParams.entries()) {\n          if (key.startsWith(`${name}[`)) {\n            indices.push(key);\n            const parts = key.split('[');\n            let currentLayer = obj;\n            for (let partIndex = 1; partIndex < parts.length - 1; partIndex++) {\n              const part = parts[partIndex];\n              if (!part.includes(']')) {\n                throw new OperationError(\n                  this.operation,\n                  `Invalid object parameter, missing closing bracket for key \"${key}\"`,\n                );\n              }\n              const objKey = part.split(']')[0];\n              if (!currentLayer[objKey]) {\n                currentLayer[objKey] = {};\n              }\n              currentLayer = currentLayer[objKey];\n            }\n            const lastPart = parts[parts.length - 1];\n            if (!lastPart.includes(']')) {\n              throw new OperationError(\n                this.operation,\n                `Invalid object parameter, missing closing bracket for key \"${key}\"`,\n              );\n            }\n            currentLayer[lastPart.split(']')[0]] = value;\n          }\n        }\n        return [obj, indices];\n      }\n      throw new OperationError(\n        this.operation,\n        `Unsupported style for object parameter, \"${parameter.style}\"`,\n      );\n    }\n    // For everything else, just return the value.\n    return [getIfExists(name), [name]];\n  }\n}\n\nexport class HeaderParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('header', operation, options);\n  }\n  async parse(request: Request) {\n    const headerParameters: Record<string, any> = {};\n    for (const [name, parameter] of Object.entries(this.parameters)) {\n      const header = request.headers.get(name);\n      if (!header) {\n        if (parameter.required) {\n          throw new OperationError(\n            this.operation,\n            `Header parameter ${name} not found`,\n          );\n        }\n        continue;\n      }\n      if (!parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Schema not found for header parameter',\n        );\n      }\n      if ('$ref' in parameter.schema) {\n        throw new OperationError(\n          this.operation,\n          'Reference objects are not supported for parameters',\n        );\n      }\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(header);\n\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Header parameter',\n          validate.errors!,\n        );\n      }\n      headerParameters[name] = header;\n    }\n    return headerParameters;\n  }\n}\n\nexport class PathParameterParser\n  extends BaseParameterParser\n  implements RequestParser<Record<string, any>>\n{\n  constructor(operation: Operation, options: ParserOptions) {\n    super('path', operation, options);\n  }\n  async parse(request: Request) {\n    const { pathname } = new URL(request.url);\n    const params = PathParameterParser.parsePath({\n      operation: this.operation,\n      path: pathname,\n      schema: this.operation.path,\n    });\n    const pathParameters: Record<string, any> = {};\n    for (const [name, parameter] of Object.entries(this.parameters)) {\n      let param: string | number | boolean = params[name];\n      if (!param && parameter.required) {\n        throw new OperationError(\n          this.operation,\n          `Path parameter ${name} not found`,\n        );\n      } else if (!params[name] && !parameter.required) {\n        continue;\n      }\n\n      if (param) {\n        param = this.optimisticallyParseValue(param, parameter.schema);\n      }\n\n      const validate = this.ajv.compile(parameter.schema);\n      const valid = validate(param);\n\n      if (!valid) {\n        throw new OperationParsingError(\n          this.operation,\n          'Path parameter',\n          validate.errors!,\n        );\n      }\n      pathParameters[name] = param;\n    }\n    return pathParameters;\n  }\n\n  static parsePath({\n    operation,\n    schema,\n    path,\n  }: {\n    operation: Operation;\n    schema: string;\n    path: string;\n  }) {\n    const parts = path.split('/');\n    const pathParts = schema.split('/');\n    if (parts.length !== pathParts.length) {\n      throw new OperationError(operation, 'Path parts do not match');\n    }\n    const params: Record<string, string> = {};\n    for (let i = 0; i < parts.length; i++) {\n      if (pathParts[i] === parts[i]) {\n        continue;\n      }\n      if (pathParts[i].startsWith('{') && pathParts[i].endsWith('}')) {\n        params[pathParts[i].slice(1, -1)] = parts[i];\n        continue;\n      }\n      break;\n    }\n    return params;\n  }\n}\n\nexport class ParameterValidator implements Validator {\n  schema: OpenAPIObject;\n  cache: Record<string, any> = {};\n  constructor(schema: OpenAPIObject) {\n    this.schema = schema;\n  }\n\n  async validate({ pair: { request, response }, operation }: ValidatorParams) {\n    if (response.statusCode === 400) {\n      // If the response is a 400, then the request is invalid and we shouldn't validate the parameters\n      return;\n    }\n\n    const ajv = new Ajv();\n    const queryParser = new QueryParameterParser(operation, { ajv });\n    const headerParser = new HeaderParameterParser(operation, { ajv });\n    const pathParser = new PathParameterParser(operation, { ajv });\n\n    const fetchRequest = mockttpToFetchRequest(request);\n\n    await Promise.all([\n      queryParser.parse(fetchRequest),\n      headerParser.parse(fetchRequest),\n      pathParser.parse(fetchRequest),\n    ]);\n  }\n}\n"],"names":["OperationError","OperationParsingError","obj","value","Ajv","mockttpToFetchRequest"],"mappings":"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"}