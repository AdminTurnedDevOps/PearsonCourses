/// <reference types="node" />
import { JSONSchema, FromSchema } from 'json-schema-to-ts';
import { ReferenceObject, OpenAPIObject, ContentObject, RequestBodyObject, ResponseObject, ParameterObject, SchemaObject } from 'openapi3-ts';
import core from 'express-serve-static-core';
import { Router, Express, RequestHandler } from 'express';
import { Server } from 'http';
import { middleware } from 'express-openapi-validator';

/**
 * This file is meant to hold Immutable overwrites of the values provided by the `openapi3-ts`
 *  package due to issues with `as const` supporting only readonly values.
 */
/**
 * From {@link https://github.com/microsoft/TypeScript/issues/13923#issuecomment-653675557}, allows
 *  us to convert from `as const` to the various OpenAPI types documented in `openapi3-ts`.
 *
 * @public
 */
type Immutable<T> = T extends Function | boolean | number | string | null | undefined ? T : T extends Map<infer K, infer V> ? ReadonlyMap<Immutable<K>, Immutable<V>> : T extends Set<infer S> ? ReadonlySet<Immutable<S>> : {
    readonly [P in keyof T]: Immutable<T[P]>;
};
/**
 * @public
 */
type ImmutableObject<T> = {
    readonly [K in keyof T]: Immutable<T[K]>;
};
/**
 * @public
 */
type ImmutableReferenceObject = ImmutableObject<ReferenceObject>;
/**
 * @public
 */
type ImmutableOpenAPIObject = ImmutableObject<OpenAPIObject>;
/**
 * @public
 */
type ImmutableContentObject = ImmutableObject<ContentObject>;
/**
 * @public
 */
type ImmutableRequestBodyObject = ImmutableObject<RequestBodyObject>;
/**
 * @public
 */
type ImmutableResponseObject = ImmutableObject<ResponseObject>;
/**
 * @public
 */
type ImmutableParameterObject = ImmutableObject<ParameterObject>;
/**
 * @public
 */
interface HeaderObject extends ParameterObject {
    in: 'header';
    style: 'simple';
}
/**
 * @public
 */
type ImmutableHeaderObject = ImmutableObject<HeaderObject>;
/**
 * @public
 */
interface CookieObject extends ParameterObject {
    in: 'cookie';
    style?: 'form';
}
/**
 * @public
 */
type ImmutableCookieObject = ImmutableObject<CookieObject>;
/**
 * @public
 */
interface QueryObject extends ParameterObject {
    in: 'query';
    style?: 'form' | 'deepObject' | 'pipeDelimited' | 'spaceDelimited';
}
/**
 * @public
 */
type ImmutableQueryObject = ImmutableObject<QueryObject>;
/**
 * @public
 */
interface PathObject extends ParameterObject {
    in: 'path';
    style?: 'simple' | 'label' | 'matrix';
}
/**
 * @public
 */
type ImmutablePathObject = ImmutableObject<PathObject>;
/**
 * @public
 */
type ImmutableSchemaObject = ImmutableObject<SchemaObject>;

/**
 * Pulled from https://github.com/varanauskas/oatx.
 */

/**
 * Basic OpenAPI spec with paths and components properties enforced.
 * @public
 */
type RequiredDoc = Pick<ImmutableOpenAPIObject, 'paths' | 'components'>;
/**
 * @public
 */
type PathDoc = Pick<ImmutableOpenAPIObject, 'paths'>;
/**
 * Get value types of `T`.
 * @public
 */
type ValueOf<T> = T[keyof T];
/**
 * All paths for a given doc,
 * @example `/pet/{petId}` | `/pet`
 * @public
 */
type DocPath<Doc extends PathDoc> = Extract<keyof Doc['paths'], string>;
/**
 * Validate a string against OpenAPI path template, {@link https://spec.openapis.org/oas/v3.1.0#path-templating-matching}.
 *
 * @example
 * ```ts
 * const path: PathTemplate<"/posts/{postId}/comments/{commentId}"> = "/posts/:postId/comments/:commentId";
 * const pathWithoutParams: PathTemplate<"/posts/comments"> = "/posts/comments";
 * ```
 *
 * @public
 */
type PathTemplate<Path extends string> = Path extends `${infer Prefix}{${infer PathName}}${infer Suffix}` ? `${Prefix}:${PathName}${PathTemplate<Suffix>}` : Path;
/**
 * Extract path as specified in OpenAPI `Doc` based on request path
 * @example
 * ```ts
 * const spec = {
 *   paths: {
 *       "/posts/{postId}/comments/{commentId}": {},
 *       "/posts/comments": {},
 *   }
 * };
 * const specPathWithParams: DocPath<typeof spec, "/posts/:postId/comments/:commentId"> = "/posts/{postId}/comments/{commentId}";
 * const specPathWithoutParams: DocPath<typeof spec, "/posts/comments"> = "/posts/comments";
 * ```
 *
 * @public
 */
type TemplateToDocPath<Doc extends PathDoc, Path extends DocPathTemplate<Doc>> = ValueOf<{
    [Template in DocPath<Doc>]: Path extends PathTemplate<Template> ? Template : never;
}>;
/**
 * @public
 */
type DocPathTemplate<Doc extends PathDoc> = PathTemplate<DocPath<Doc>>;
/**
 * @public
 */
type DocPathMethod<Doc extends Pick<RequiredDoc, 'paths'>, Path extends DocPath<Doc>> = keyof Doc['paths'][Path];
/**
 * @public
 */
type DocPathTemplateMethod<Doc extends Pick<RequiredDoc, 'paths'>, Path extends DocPathTemplate<Doc>> = keyof Doc['paths'][TemplateToDocPath<Doc, Path>];
/**
 * @public
 */
type MethodAwareDocPath<Doc extends PathDoc, Path extends DocPathTemplate<Doc>, Method extends DocPathTemplateMethod<Doc, Path>> = ValueOf<{
    [Template in DocPath<Doc>]: Path extends PathTemplate<Template> ? Method extends DocPathTemplateMethod<Doc, Path> ? PathTemplate<Template> : never : never;
}>;
/**
 * @public
 */
type DocOperation<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends keyof Doc['paths'][Path]> = Doc['paths'][Path][Method];
/**
 * @public
 */
type ComponentTypes<Doc extends RequiredDoc> = Extract<keyof Doc['components'], string>;
/**
 * @public
 */
type ComponentRef<Doc extends RequiredDoc, Type extends ComponentTypes<Doc>, Ref extends ImmutableReferenceObject> = Ref extends {
    $ref: `#/components/${Type}/${infer Name}`;
} ? Name extends keyof Doc['components'][Type] ? Doc['components'][Type][Name] extends ImmutableReferenceObject ? ComponentRef<Doc, Type, Doc['components'][Type][Name]> : Doc['components'][Type][Name] : never : never;
/**
 * @public
 */
type SchemaRef<Doc extends RequiredDoc, Schema> = Schema extends {
    $ref: `#/components/schemas/${infer Name}`;
} ? 'schemas' extends keyof Doc['components'] ? Name extends keyof Doc['components']['schemas'] ? SchemaRef<Doc, Doc['components']['schemas'][Name]> : never : never : {
    [Key in keyof Schema]: SchemaRef<Doc, Schema[Key]>;
};
/**
 * @public
 */
type ObjectWithContentSchema<Doc extends RequiredDoc, Object extends {
    content?: ImmutableContentObject;
}> = Object['content'] extends ImmutableContentObject ? SchemaRef<Doc, Object['content']['application/json']['schema']> : never;
/**
 * From {@link https://stackoverflow.com/questions/71393738/typescript-intersection-not-union-type-from-json-schema}
 *
 * StackOverflow says not to do this, but union types aren't possible any other way.
 *
 * @public
 */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
/**
 * @public
 */
type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
/**
 * @public
 */
type Push<T extends any[], V> = [...T, V];
/**
 * @public
 */
type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;
/**
 * @public
 */
type ConvertAll<T extends ReadonlyArray<unknown>> = {
    [Index in keyof T]: T[Index] extends JSONSchema ? FromSchema<T[Index]> : T[Index];
} & {
    length: T['length'];
};
/**
 * @public
 */
type UnknownIfNever<P> = [P] extends [never] ? unknown : P;
/**
 * @public
 */
type ToTypeSafe<T> = UnknownIfNever<ConvertAll<TuplifyUnion<T>>[number]>;
/**
 * @public
 */
type DiscriminateUnion<T, K extends keyof T, V extends T[K]> = Extract<T, Record<K, V>>;
/**
 * @public
 */
type MapDiscriminatedUnion<T extends Record<K, string>, K extends keyof T> = {
    [V in T[K]]: DiscriminateUnion<T, K, V>;
};
/**
 * @public
 */
type PickOptionalKeys<T extends {
    [key: string]: any;
}> = {
    [K in keyof T]: true extends T[K]['required'] ? never : K;
}[keyof T];
/**
 * @public
 */
type PickRequiredKeys<T extends {
    [key: string]: any;
}> = {
    [K in keyof T]: true extends T[K]['required'] ? K : never;
}[keyof T];
/**
 * @public
 */
type OptionalMap<T extends {
    [key: string]: any;
}> = {
    [P in Exclude<PickOptionalKeys<T>, undefined>]?: NonNullable<T[P]>;
};
/**
 * @public
 */
type RequiredMap<T extends {
    [key: string]: any;
}> = {
    [P in Exclude<PickRequiredKeys<T>, undefined>]: NonNullable<T[P]>;
};
/**
 * @public
 */
type FullMap<T extends {
    [key: string]: any;
}> = RequiredMap<T> & OptionalMap<T>;
/**
 * @public
 */
type Filter<T, U> = T extends U ? T : never;

/**
 * @public
 */
type DocParameter<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>, Parameter extends keyof DocOperation<Doc, Path, Method>['parameters']> = DocOperation<Doc, Path, Method>['parameters'][Parameter] extends ImmutableReferenceObject ? 'parameters' extends ComponentTypes<Doc> ? ComponentRef<Doc, 'parameters', DocOperation<Doc, Path, Method>['parameters'][Parameter]> : never : DocOperation<Doc, Path, Method>['parameters'][Parameter];
/**
 * Helper to convert from string to number, used to index arrays and pull out just the indices in the array.
 * @public
 */
type FromNumberStringToNumber<NumberString extends string | number | symbol> = NumberString extends `${infer R extends number}` ? R : never;
/**
 * @public
 */
type DocParameters<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path]> = {
    [Index in keyof DocOperation<Doc, Path, Method>['parameters'] as FromNumberStringToNumber<Index>]: DocParameter<Doc, Path, Method, Index>;
};
/**
 * @public
 */
type ParameterSchema<Doc extends RequiredDoc, Schema extends ImmutableParameterObject['schema']> = SchemaRef<Doc, Schema> extends infer R ? R extends ImmutableSchemaObject ? R extends JSONSchema ? FromSchema<R> : never : never : never;
/**
 * @public
 */
type MapToSchema<Doc extends RequiredDoc, T extends Record<string, ImmutableParameterObject>> = {
    [V in keyof T]: NonNullable<T[V]> extends ImmutableParameterObject ? ParameterSchema<Doc, NonNullable<T[V]>['schema']> : never;
};
/**
 * @public
 */
type ParametersSchema<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path], FilterType extends ImmutableParameterObject> = MapToSchema<Doc, FullMap<MapDiscriminatedUnion<Filter<ValueOf<DocParameters<Doc, Path, Method>>, FilterType>, 'name'>>>;
/**
 * @public
 */
type HeaderSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ParametersSchema<Doc, Path, Method, ImmutableHeaderObject>;
/**
 * @public
 */
type CookieSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ParametersSchema<Doc, Path, Method, ImmutableCookieObject>;
/**
 * @public
 */
type PathSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ParametersSchema<Doc, Path, Method, ImmutablePathObject>;
/**
 * @public
 */
type QuerySchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ParametersSchema<Doc, Path, Method, ImmutableQueryObject>;

/**
 * Pulled from https://github.com/varanauskas/oatx.
 */

/**
 * @public
 */
type RequestBody<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path]> = DocOperation<Doc, Path, Method>['requestBody'] extends ImmutableReferenceObject ? 'requestBodies' extends ComponentTypes<Doc> ? ComponentRef<Doc, 'requestBodies', DocOperation<Doc, Path, Method>['requestBody']> : never : DocOperation<Doc, Path, Method>['requestBody'];
/**
 * @public
 */
type RequestBodySchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = RequestBody<Doc, Path, Method> extends ImmutableRequestBodyObject ? ObjectWithContentSchema<Doc, RequestBody<Doc, Path, Method>> : never;
/**
 * Transform the OpenAPI request body schema to a typesafe JSON schema.
 * @public
 */
type RequestBodyToJsonSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ToTypeSafe<RequestBodySchema<Doc, Path, Method>>;

/**
 * Pulled from https://github.com/varanauskas/oatx.
 */

/**
 * @public
 */
type Response$1<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>, StatusCode extends keyof DocOperation<Doc, Path, Method>['responses']> = DocOperation<Doc, Path, Method>['responses'][StatusCode] extends ImmutableReferenceObject ? 'responses' extends ComponentTypes<Doc> ? ComponentRef<Doc, 'responses', DocOperation<Doc, Path, Method>['responses'][StatusCode]> : never : DocOperation<Doc, Path, Method>['responses'][StatusCode];
/**
 * @public
 */
type ResponseSchemas<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = {
    [StatusCode in keyof DocOperation<Doc, Path, Method>['responses']]: Response$1<Doc, Path, Method, StatusCode> extends ImmutableResponseObject ? ObjectWithContentSchema<Doc, Response$1<Doc, Path, Method, StatusCode>> : never;
};
/**
 * Transform the OpenAPI request body schema to a typesafe JSON schema.
 * @public
 */
type ResponseBodyToJsonSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ToTypeSafe<ValueOf<ResponseSchemas<Doc, Path, Method>>>;

/**
 * Typed express request handler.
 * @public
 */
type DocRequestHandler<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = core.RequestHandler<PathSchema<Doc, Path, Method>, ResponseBodyToJsonSchema<Doc, Path, Method>, RequestBodyToJsonSchema<Doc, Path, Method>, QuerySchema<Doc, Path, Method>, Record<string, string>>;
/**
 * Typed express error handler / request handler union type.
 * @public
 */
type DocRequestHandlerParams<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = core.RequestHandlerParams<PathSchema<Doc, Path, Method>, ResponseBodyToJsonSchema<Doc, Path, Method>, RequestBodyToJsonSchema<Doc, Path, Method>, QuerySchema<Doc, Path, Method>, Record<string, string>>;
/**
 * Superset of the express router path matcher that enforces typed request and response bodies.
 * @public
 */
interface DocRequestMatcher<Doc extends RequiredDoc, T, Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head'> {
    <Path extends MethodAwareDocPath<Doc, PathTemplate<Extract<keyof Doc['paths'], string>>, Method>>(path: Path, ...handlers: Array<DocRequestHandler<Doc, TemplateToDocPath<Doc, Path>, Method>>): T;
    <Path extends MethodAwareDocPath<Doc, PathTemplate<Extract<keyof Doc['paths'], string>>, Method>>(path: Path, ...handlers: Array<DocRequestHandlerParams<Doc, TemplateToDocPath<Doc, Path>, Method>>): T;
}

/**
 * @public
 */
type EndpointMap = Record<string, {
    query?: object;
    body?: object;
    response?: object | void;
    path?: object;
}>;
/**
 * @public
 */
type HttpMethods = 'all' | 'put' | 'get' | 'post' | '_delete';
/**
 * @public
 */
type StaticPathParamsSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = `#${Method}|${Endpoint}` extends keyof Doc ? 'path' extends keyof Doc[`#${Method}|${Endpoint}`] ? Doc[`#${Method}|${Endpoint}`]['path'] : never : never;
/**
 * @public
 */
type StaticRequestBodySchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = `#${Method}|${Endpoint}` extends keyof Doc ? 'body' extends keyof Doc[`#${Method}|${Endpoint}`] ? Doc[`#${Method}|${Endpoint}`]['body'] : unknown : unknown;
/**
 * @public
 */
type StaticResponseSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = `#${Method}|${Endpoint}` extends keyof Doc ? 'response' extends keyof Doc[`#${Method}|${Endpoint}`] ? Doc[`#${Method}|${Endpoint}`]['response'] : unknown : unknown;
/**
 * @public
 */
type StaticQueryParamsSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = `#${Method}|${Endpoint}` extends keyof Doc ? 'query' extends keyof Doc[`#${Method}|${Endpoint}`] ? Doc[`#${Method}|${Endpoint}`]['query'] : never : never;
/**
 * Typed express request handler.
 * @public
 */
type EndpointMapRequestHandler<Doc extends EndpointMap, Path extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Path>> = core.RequestHandler<StaticPathParamsSchema<Doc, Path, Method>, StaticResponseSchema<Doc, Path, Method>, StaticRequestBodySchema<Doc, Path, Method>, StaticQueryParamsSchema<Doc, Path, Method>, Record<string, string>>;
/**
 * Typed express error handler / request handler union type.
 * @public
 */
type EndpointMapRequestHandlerParams<Doc extends EndpointMap, Path extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Path>> = core.RequestHandlerParams<StaticPathParamsSchema<Doc, Path, Method>, StaticResponseSchema<Doc, Path, Method>, StaticRequestBodySchema<Doc, Path, Method>, StaticQueryParamsSchema<Doc, Path, Method>, Record<string, string>>;
/**
 * @public
 */
type DocEndpoint<Doc extends EndpointMap> = ValueOf<{
    [Template in keyof Doc]: Template extends `#${string}|${infer Endpoint}` ? Endpoint : never;
}>;
/**
 * @public
 */
type DocEndpointMethod<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>> = ValueOf<{
    [Template in keyof Doc]: Template extends `#${infer Method}|${Endpoint}` ? Method : never;
}>;
/**
 * @public
 */
type MethodAwareDocEndpoints<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = ValueOf<{
    [Template in keyof Doc]: Template extends `#${Method}|${infer E}` ? E extends DocEndpoint<Doc> ? PathTemplate<E> : never : never;
}>;
/**
 * @public
 */
type DocEndpointTemplate<Doc extends EndpointMap> = PathTemplate<DocEndpoint<Doc>>;
/**
 * @public
 */
type TemplateToDocEndpoint<Doc extends EndpointMap, Path extends DocEndpointTemplate<Doc>> = ValueOf<{
    [Template in DocEndpoint<Doc>]: Path extends PathTemplate<Template> ? Template : never;
}>;
/**
 * Superset of the express router path matcher that enforces typed request and response bodies.
 * @public
 */
interface EndpointMapRequestMatcher<Doc extends EndpointMap, T, Method extends HttpMethods> {
    <TPath extends MethodAwareDocEndpoints<Doc, DocEndpoint<Doc>, Method & DocEndpointMethod<Doc, DocEndpoint<Doc>>>, TMethod extends Method & DocEndpointMethod<Doc, TemplateToDocEndpoint<Doc, TPath>>>(path: TPath, ...handlers: Array<EndpointMapRequestHandler<Doc, TemplateToDocEndpoint<Doc, TPath>, TMethod>>): T;
    <TPath extends MethodAwareDocEndpoints<Doc, DocEndpoint<Doc>, Method & DocEndpointMethod<Doc, DocEndpoint<Doc>>>, TMethod extends Method & DocEndpointMethod<Doc, TemplateToDocEndpoint<Doc, TPath>>>(path: TPath, ...handlers: Array<EndpointMapRequestHandlerParams<Doc, TemplateToDocEndpoint<Doc, TPath>, TMethod>>): T;
}

type index_d_ComponentRef<Doc extends RequiredDoc, Type extends ComponentTypes<Doc>, Ref extends ImmutableReferenceObject> = ComponentRef<Doc, Type, Ref>;
type index_d_ComponentTypes<Doc extends RequiredDoc> = ComponentTypes<Doc>;
type index_d_ConvertAll<T extends ReadonlyArray<unknown>> = ConvertAll<T>;
type index_d_CookieObject = CookieObject;
type index_d_CookieSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = CookieSchema<Doc, Path, Method>;
type index_d_DiscriminateUnion<T, K extends keyof T, V extends T[K]> = DiscriminateUnion<T, K, V>;
type index_d_DocEndpoint<Doc extends EndpointMap> = DocEndpoint<Doc>;
type index_d_DocEndpointMethod<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>> = DocEndpointMethod<Doc, Endpoint>;
type index_d_DocEndpointTemplate<Doc extends EndpointMap> = DocEndpointTemplate<Doc>;
type index_d_DocOperation<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends keyof Doc['paths'][Path]> = DocOperation<Doc, Path, Method>;
type index_d_DocParameter<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>, Parameter extends keyof DocOperation<Doc, Path, Method>['parameters']> = DocParameter<Doc, Path, Method, Parameter>;
type index_d_DocParameters<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path]> = DocParameters<Doc, Path, Method>;
type index_d_DocPath<Doc extends PathDoc> = DocPath<Doc>;
type index_d_DocPathMethod<Doc extends Pick<RequiredDoc, 'paths'>, Path extends DocPath<Doc>> = DocPathMethod<Doc, Path>;
type index_d_DocPathTemplate<Doc extends PathDoc> = DocPathTemplate<Doc>;
type index_d_DocPathTemplateMethod<Doc extends Pick<RequiredDoc, 'paths'>, Path extends DocPathTemplate<Doc>> = DocPathTemplateMethod<Doc, Path>;
type index_d_DocRequestHandler<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = DocRequestHandler<Doc, Path, Method>;
type index_d_DocRequestHandlerParams<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = DocRequestHandlerParams<Doc, Path, Method>;
type index_d_DocRequestMatcher<Doc extends RequiredDoc, T, Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head'> = DocRequestMatcher<Doc, T, Method>;
type index_d_EndpointMap = EndpointMap;
type index_d_EndpointMapRequestHandler<Doc extends EndpointMap, Path extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Path>> = EndpointMapRequestHandler<Doc, Path, Method>;
type index_d_EndpointMapRequestHandlerParams<Doc extends EndpointMap, Path extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Path>> = EndpointMapRequestHandlerParams<Doc, Path, Method>;
type index_d_EndpointMapRequestMatcher<Doc extends EndpointMap, T, Method extends HttpMethods> = EndpointMapRequestMatcher<Doc, T, Method>;
type index_d_Filter<T, U> = Filter<T, U>;
type index_d_FromNumberStringToNumber<NumberString extends string | number | symbol> = FromNumberStringToNumber<NumberString>;
type index_d_FullMap<T extends {
    [key: string]: any;
}> = FullMap<T>;
type index_d_HeaderObject = HeaderObject;
type index_d_HeaderSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = HeaderSchema<Doc, Path, Method>;
type index_d_HttpMethods = HttpMethods;
type index_d_Immutable<T> = Immutable<T>;
type index_d_ImmutableContentObject = ImmutableContentObject;
type index_d_ImmutableCookieObject = ImmutableCookieObject;
type index_d_ImmutableHeaderObject = ImmutableHeaderObject;
type index_d_ImmutableObject<T> = ImmutableObject<T>;
type index_d_ImmutableOpenAPIObject = ImmutableOpenAPIObject;
type index_d_ImmutableParameterObject = ImmutableParameterObject;
type index_d_ImmutablePathObject = ImmutablePathObject;
type index_d_ImmutableQueryObject = ImmutableQueryObject;
type index_d_ImmutableReferenceObject = ImmutableReferenceObject;
type index_d_ImmutableRequestBodyObject = ImmutableRequestBodyObject;
type index_d_ImmutableResponseObject = ImmutableResponseObject;
type index_d_ImmutableSchemaObject = ImmutableSchemaObject;
type index_d_LastOf<T> = LastOf<T>;
type index_d_MapDiscriminatedUnion<T extends Record<K, string>, K extends keyof T> = MapDiscriminatedUnion<T, K>;
type index_d_MapToSchema<Doc extends RequiredDoc, T extends Record<string, ImmutableParameterObject>> = MapToSchema<Doc, T>;
type index_d_MethodAwareDocEndpoints<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = MethodAwareDocEndpoints<Doc, Endpoint, Method>;
type index_d_MethodAwareDocPath<Doc extends PathDoc, Path extends DocPathTemplate<Doc>, Method extends DocPathTemplateMethod<Doc, Path>> = MethodAwareDocPath<Doc, Path, Method>;
type index_d_ObjectWithContentSchema<Doc extends RequiredDoc, Object extends {
    content?: ImmutableContentObject;
}> = ObjectWithContentSchema<Doc, Object>;
type index_d_OptionalMap<T extends {
    [key: string]: any;
}> = OptionalMap<T>;
type index_d_ParameterSchema<Doc extends RequiredDoc, Schema extends ImmutableParameterObject['schema']> = ParameterSchema<Doc, Schema>;
type index_d_ParametersSchema<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path], FilterType extends ImmutableParameterObject> = ParametersSchema<Doc, Path, Method, FilterType>;
type index_d_PathDoc = PathDoc;
type index_d_PathObject = PathObject;
type index_d_PathSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = PathSchema<Doc, Path, Method>;
type index_d_PathTemplate<Path extends string> = PathTemplate<Path>;
type index_d_PickOptionalKeys<T extends {
    [key: string]: any;
}> = PickOptionalKeys<T>;
type index_d_PickRequiredKeys<T extends {
    [key: string]: any;
}> = PickRequiredKeys<T>;
type index_d_Push<T extends any[], V> = Push<T, V>;
type index_d_QueryObject = QueryObject;
type index_d_QuerySchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = QuerySchema<Doc, Path, Method>;
type index_d_RequestBody<Doc extends RequiredDoc, Path extends Extract<keyof Doc['paths'], string>, Method extends keyof Doc['paths'][Path]> = RequestBody<Doc, Path, Method>;
type index_d_RequestBodySchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = RequestBodySchema<Doc, Path, Method>;
type index_d_RequestBodyToJsonSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = RequestBodyToJsonSchema<Doc, Path, Method>;
type index_d_RequiredDoc = RequiredDoc;
type index_d_RequiredMap<T extends {
    [key: string]: any;
}> = RequiredMap<T>;
type index_d_ResponseBodyToJsonSchema<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ResponseBodyToJsonSchema<Doc, Path, Method>;
type index_d_ResponseSchemas<Doc extends RequiredDoc, Path extends DocPath<Doc>, Method extends DocPathMethod<Doc, Path>> = ResponseSchemas<Doc, Path, Method>;
type index_d_SchemaRef<Doc extends RequiredDoc, Schema> = SchemaRef<Doc, Schema>;
type index_d_StaticPathParamsSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = StaticPathParamsSchema<Doc, Endpoint, Method>;
type index_d_StaticQueryParamsSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = StaticQueryParamsSchema<Doc, Endpoint, Method>;
type index_d_StaticRequestBodySchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = StaticRequestBodySchema<Doc, Endpoint, Method>;
type index_d_StaticResponseSchema<Doc extends EndpointMap, Endpoint extends DocEndpoint<Doc>, Method extends DocEndpointMethod<Doc, Endpoint>> = StaticResponseSchema<Doc, Endpoint, Method>;
type index_d_TemplateToDocEndpoint<Doc extends EndpointMap, Path extends DocEndpointTemplate<Doc>> = TemplateToDocEndpoint<Doc, Path>;
type index_d_TemplateToDocPath<Doc extends PathDoc, Path extends DocPathTemplate<Doc>> = TemplateToDocPath<Doc, Path>;
type index_d_ToTypeSafe<T> = ToTypeSafe<T>;
type index_d_TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = TuplifyUnion<T, L, N>;
type index_d_UnionToIntersection<U> = UnionToIntersection<U>;
type index_d_UnknownIfNever<P> = UnknownIfNever<P>;
type index_d_ValueOf<T> = ValueOf<T>;
declare namespace index_d {
  export type { index_d_ComponentRef as ComponentRef, index_d_ComponentTypes as ComponentTypes, index_d_ConvertAll as ConvertAll, index_d_CookieObject as CookieObject, index_d_CookieSchema as CookieSchema, index_d_DiscriminateUnion as DiscriminateUnion, index_d_DocEndpoint as DocEndpoint, index_d_DocEndpointMethod as DocEndpointMethod, index_d_DocEndpointTemplate as DocEndpointTemplate, index_d_DocOperation as DocOperation, index_d_DocParameter as DocParameter, index_d_DocParameters as DocParameters, index_d_DocPath as DocPath, index_d_DocPathMethod as DocPathMethod, index_d_DocPathTemplate as DocPathTemplate, index_d_DocPathTemplateMethod as DocPathTemplateMethod, index_d_DocRequestHandler as DocRequestHandler, index_d_DocRequestHandlerParams as DocRequestHandlerParams, index_d_DocRequestMatcher as DocRequestMatcher, index_d_EndpointMap as EndpointMap, index_d_EndpointMapRequestHandler as EndpointMapRequestHandler, index_d_EndpointMapRequestHandlerParams as EndpointMapRequestHandlerParams, index_d_EndpointMapRequestMatcher as EndpointMapRequestMatcher, index_d_Filter as Filter, index_d_FromNumberStringToNumber as FromNumberStringToNumber, index_d_FullMap as FullMap, index_d_HeaderObject as HeaderObject, index_d_HeaderSchema as HeaderSchema, index_d_HttpMethods as HttpMethods, index_d_Immutable as Immutable, index_d_ImmutableContentObject as ImmutableContentObject, index_d_ImmutableCookieObject as ImmutableCookieObject, index_d_ImmutableHeaderObject as ImmutableHeaderObject, index_d_ImmutableObject as ImmutableObject, index_d_ImmutableOpenAPIObject as ImmutableOpenAPIObject, index_d_ImmutableParameterObject as ImmutableParameterObject, index_d_ImmutablePathObject as ImmutablePathObject, index_d_ImmutableQueryObject as ImmutableQueryObject, index_d_ImmutableReferenceObject as ImmutableReferenceObject, index_d_ImmutableRequestBodyObject as ImmutableRequestBodyObject, index_d_ImmutableResponseObject as ImmutableResponseObject, index_d_ImmutableSchemaObject as ImmutableSchemaObject, index_d_LastOf as LastOf, index_d_MapDiscriminatedUnion as MapDiscriminatedUnion, index_d_MapToSchema as MapToSchema, index_d_MethodAwareDocEndpoints as MethodAwareDocEndpoints, index_d_MethodAwareDocPath as MethodAwareDocPath, index_d_ObjectWithContentSchema as ObjectWithContentSchema, index_d_OptionalMap as OptionalMap, index_d_ParameterSchema as ParameterSchema, index_d_ParametersSchema as ParametersSchema, index_d_PathDoc as PathDoc, index_d_PathObject as PathObject, index_d_PathSchema as PathSchema, index_d_PathTemplate as PathTemplate, index_d_PickOptionalKeys as PickOptionalKeys, index_d_PickRequiredKeys as PickRequiredKeys, index_d_Push as Push, index_d_QueryObject as QueryObject, index_d_QuerySchema as QuerySchema, index_d_RequestBody as RequestBody, index_d_RequestBodySchema as RequestBodySchema, index_d_RequestBodyToJsonSchema as RequestBodyToJsonSchema, index_d_RequiredDoc as RequiredDoc, index_d_RequiredMap as RequiredMap, Response$1 as Response, index_d_ResponseBodyToJsonSchema as ResponseBodyToJsonSchema, index_d_ResponseSchemas as ResponseSchemas, index_d_SchemaRef as SchemaRef, index_d_StaticPathParamsSchema as StaticPathParamsSchema, index_d_StaticQueryParamsSchema as StaticQueryParamsSchema, index_d_StaticRequestBodySchema as StaticRequestBodySchema, index_d_StaticResponseSchema as StaticResponseSchema, index_d_TemplateToDocEndpoint as TemplateToDocEndpoint, index_d_TemplateToDocPath as TemplateToDocPath, index_d_ToTypeSafe as ToTypeSafe, index_d_TuplifyUnion as TuplifyUnion, index_d_UnionToIntersection as UnionToIntersection, index_d_UnknownIfNever as UnknownIfNever, index_d_ValueOf as ValueOf };
}

/**
 * @public
 */
type Response<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = ResponseBodyToJsonSchema<Doc, TemplateToDocPath<Doc, Path>, Method>;
/**
 * @public
 */
type Request<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = RequestBodyToJsonSchema<Doc, TemplateToDocPath<Doc, Path>, Method>;
/**
 * @public
 */
type HeaderParameters<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = HeaderSchema<Doc, TemplateToDocPath<Doc, Path>, Method>;
/**
 * @public
 */
type CookieParameters<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = CookieSchema<Doc, TemplateToDocPath<Doc, Path>, Method>;
/**
 * @public
 */
type PathParameters<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = PathSchema<Doc, TemplateToDocPath<Doc, Path>, Method>;
/**
 * @public
 */
type QueryParameters<Doc extends RequiredDoc, Path extends PathTemplate<Extract<keyof Doc['paths'], string>>, Method extends DocPathTemplateMethod<Doc, Path>> = QuerySchema<Doc, TemplateToDocPath<Doc, Path>, Method>;

/**
 * Typed Express router based on an OpenAPI 3.1 spec.
 * @public
 */
interface ApiRouter<Doc extends RequiredDoc> extends Router {
    get: DocRequestMatcher<Doc, this, 'get'>;
    post: DocRequestMatcher<Doc, this, 'post'>;
    all: DocRequestMatcher<Doc, this, 'all'>;
    put: DocRequestMatcher<Doc, this, 'put'>;
    delete: DocRequestMatcher<Doc, this, 'delete'>;
    patch: DocRequestMatcher<Doc, this, 'patch'>;
    options: DocRequestMatcher<Doc, this, 'options'>;
    head: DocRequestMatcher<Doc, this, 'head'>;
}
/**
 * @public
 */
interface TypedRouter<GeneratedEndpointMap extends EndpointMap> extends Router {
    get: EndpointMapRequestMatcher<GeneratedEndpointMap, this, 'get'>;
    post: EndpointMapRequestMatcher<GeneratedEndpointMap, this, 'post'>;
    put: EndpointMapRequestMatcher<GeneratedEndpointMap, this, 'put'>;
    delete: EndpointMapRequestMatcher<GeneratedEndpointMap, this, '_delete'>;
}

/**
 * !!! THIS CURRENTLY ONLY SUPPORTS SUPERTEST !!!
 * Setup a server with a custom OpenAPI proxy. This proxy will capture all requests and responses and make sure they
 *  conform to the spec.
 * @param app - express server, needed to ensure we have the correct ports for the proxy.
 * @returns - a configured HTTP server that should be used with supertest.
 * @public
 */
declare function wrapServer(app: Express): Promise<Server>;
/**
 * !!! THIS CURRENTLY ONLY SUPPORTS SUPERTEST !!!
 * Running against supertest, we need some way to hit the optic proxy. This ensures that
 *  that happens at runtime when in the context of a `yarn optic capture` command.
 * @param app - Express router that would be passed to supertest's `request`.
 * @returns A wrapper around the express router (or the router untouched) that still works with supertest.
 * @public
 */
declare const wrapInOpenApiTestServer: (app: Express) => Server | Express;

/**
 * Given a base url for a plugin, find the given OpenAPI spec for that plugin.
 * @param baseUrl - Plugin base url.
 * @returns OpenAPI spec route for the base url.
 * @public
 */
declare function getOpenApiSpecRoute(baseUrl: string): string;
/**
 * Create a new OpenAPI router with some default middleware.
 * @param spec - Your OpenAPI spec imported as a JSON object.
 * @param validatorOptions - `openapi-express-validator` options to override the defaults.
 * @returns A new express router with validation middleware.
 * @public
 */
declare function createValidatedOpenApiRouter<T extends RequiredDoc>(spec: T, options?: {
    validatorOptions?: Partial<Parameters<typeof middleware>['0']>;
    middleware?: RequestHandler[];
}): ApiRouter<T>;
/**
 * Create a new OpenAPI router with some default middleware.
 * @param spec - Your OpenAPI spec imported as a JSON object.
 * @param validatorOptions - `openapi-express-validator` options to override the defaults.
 * @returns A new express router with validation middleware.
 * @public
 */
declare function createValidatedOpenApiRouterFromGeneratedEndpointMap<T extends EndpointMap>(spec: RequiredDoc, options?: {
    validatorOptions?: Partial<Parameters<typeof middleware>['0']>;
    middleware?: RequestHandler[];
}): TypedRouter<T>;

export { type ApiRouter, type CookieParameters, type HeaderParameters, type PathParameters, type PathTemplate, type QueryParameters, type Request, type Response, type TypedRouter, createValidatedOpenApiRouter, createValidatedOpenApiRouterFromGeneratedEndpointMap, getOpenApiSpecRoute, index_d as internal, wrapInOpenApiTestServer, wrapServer };
