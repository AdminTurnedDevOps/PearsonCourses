'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var conversion = require('../util/conversion.cjs.js');
var util = require('./util.cjs.js');

class ProcessorOutputCollector {
  constructor(logger, parentEntity) {
    this.logger = logger;
    this.parentEntity = parentEntity;
  }
  errors = new Array();
  relations = new Array();
  deferredEntities = new Array();
  refreshKeys = new Array();
  done = false;
  generic() {
    return (i) => this.receive(this.logger, i);
  }
  forProcessor(processor) {
    const logger = this.logger.child({
      processor: processor.getProcessorName()
    });
    return (i) => this.receive(logger, i);
  }
  results() {
    this.done = true;
    return {
      errors: this.errors,
      relations: this.relations,
      refreshKeys: this.refreshKeys,
      deferredEntities: this.deferredEntities
    };
  }
  receive(logger, i) {
    if (this.done) {
      logger.warn(
        `Item of type "${i.type}" was emitted after processing had completed. Stack trace: ${new Error().stack}`
      );
      return;
    }
    if (i.type === "entity") {
      let entity;
      const location = catalogModel.stringifyLocationRef(i.location);
      try {
        entity = util.validateEntityEnvelope(i.entity);
      } catch (e) {
        errors.assertError(e);
        logger.debug(`Envelope validation failed at ${location}, ${e}`);
        this.errors.push(e);
        return;
      }
      const entityRef = catalogModel.stringifyEntityRef(entity);
      if (entityRef === catalogModel.stringifyEntityRef(this.parentEntity)) {
        logger.warn(
          `Ignored emitted entity ${entityRef} whose ref was identical to the one being processed. This commonly indicates mistakenly emitting the input entity instead of returning it.`
        );
        return;
      }
      const annotations = entity.metadata.annotations || {};
      if (typeof annotations !== "object" || Array.isArray(annotations)) {
        this.errors.push(
          new Error("metadata.annotations must be a valid object")
        );
        return;
      }
      const originLocation = util.getEntityOriginLocationRef(this.parentEntity);
      entity = {
        ...entity,
        metadata: {
          ...entity.metadata,
          annotations: {
            ...annotations,
            [catalogModel.ANNOTATION_ORIGIN_LOCATION]: originLocation,
            [catalogModel.ANNOTATION_LOCATION]: location
          }
        }
      };
      this.deferredEntities.push({ entity, locationKey: location });
    } else if (i.type === "location") {
      const entity = conversion.locationSpecToLocationEntity({
        location: i.location,
        parentEntity: this.parentEntity
      });
      const locationKey = util.getEntityLocationRef(entity);
      this.deferredEntities.push({ entity, locationKey });
    } else if (i.type === "relation") {
      this.relations.push(i.relation);
    } else if (i.type === "error") {
      this.errors.push(i.error);
    } else if (i.type === "refresh") {
      this.refreshKeys.push({ key: i.key });
    }
  }
}

exports.ProcessorOutputCollector = ProcessorOutputCollector;
//# sourceMappingURL=ProcessorOutputCollector.cjs.js.map
