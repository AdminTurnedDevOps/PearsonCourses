'use strict';

var api = require('@opentelemetry/api');
var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var path = require('path');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var ProcessorOutputCollector = require('./ProcessorOutputCollector.cjs.js');
var util = require('./util.cjs.js');
var ProcessorCacheManager = require('./ProcessorCacheManager.cjs.js');
var opentelemetry = require('../util/opentelemetry.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const tracer = api.trace.getTracer(opentelemetry.TRACER_ID);
function addProcessorAttributes(span, stage, processor) {
  span.setAttribute("backstage.catalog.processor.stage", stage);
  span.setAttribute(
    "backstage.catalog.processor.name",
    processor.getProcessorName()
  );
}
class DefaultCatalogProcessingOrchestrator {
  constructor(options) {
    this.options = options;
  }
  async process(request) {
    return this.processSingleEntity(request.entity, request.state);
  }
  async processSingleEntity(unprocessedEntity, state) {
    const collector = new ProcessorOutputCollector.ProcessorOutputCollector(
      this.options.logger,
      unprocessedEntity
    );
    const cache = new ProcessorCacheManager.ProcessorCacheManager(
      util.isObject(state) && util.isObject(state.cache) ? state.cache : {}
    );
    try {
      let entity = unprocessedEntity;
      try {
        util.validateEntityEnvelope(entity);
      } catch (e) {
        throw new errors.InputError(
          `Entity envelope failed validation before processing`,
          e
        );
      }
      const context = {
        entityRef: catalogModel.stringifyEntityRef(entity),
        location: catalogModel.parseLocationRef(util.getEntityLocationRef(entity)),
        originLocation: catalogModel.parseLocationRef(util.getEntityOriginLocationRef(entity)),
        cache,
        collector
      };
      entity = await this.runPreProcessStep(entity, context);
      entity = await this.runPolicyStep(entity);
      await this.runValidateStep(entity, context);
      if (util.isLocationEntity(entity)) {
        await this.runSpecialLocationStep(entity, context);
      }
      entity = await this.runPostProcessStep(entity, context);
      const collectorResults = context.collector.results();
      for (const deferredEntity of collectorResults.deferredEntities) {
        if (!this.options.rulesEnforcer.isAllowed(
          deferredEntity.entity,
          context.originLocation
        )) {
          throw new errors.NotAllowedError(
            `Entity ${catalogModel.stringifyEntityRef(
              deferredEntity.entity
            )} at ${catalogModel.stringifyLocationRef(
              context.location
            )}, originated at ${catalogModel.stringifyLocationRef(
              context.originLocation
            )}, is not of an allowed kind for that location`
          );
        }
      }
      return {
        ...collectorResults,
        completedEntity: entity,
        state: { cache: cache.collect() },
        ok: collectorResults.errors.length === 0
      };
    } catch (error) {
      errors.assertError(error);
      return {
        ok: false,
        errors: collector.results().errors.concat(error)
      };
    }
  }
  // Pre-process phase, used to populate entities with data that is required
  // during the main processing step
  async runPreProcessStep(entity, context) {
    return await opentelemetry.withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
      opentelemetry.addEntityAttributes(stageSpan, entity);
      stageSpan.setAttribute("backstage.catalog.processor.stage", "preProcess");
      let res = entity;
      for (const processor of this.options.processors) {
        if (processor.preProcessEntity) {
          let innerRes = res;
          res = await opentelemetry.withActiveSpan(tracer, "ProcessingStep", async (span) => {
            opentelemetry.addEntityAttributes(span, entity);
            addProcessorAttributes(span, "preProcessEntity", processor);
            try {
              innerRes = await processor.preProcessEntity(
                innerRes,
                context.location,
                context.collector.forProcessor(processor),
                context.originLocation,
                context.cache.forProcessor(processor)
              );
            } catch (e) {
              throw new errors.InputError(
                `Processor ${processor.constructor.name} threw an error while preprocessing`,
                e
              );
            }
            return innerRes;
          });
        }
      }
      return res;
    });
  }
  /**
   * Enforce entity policies making sure that entities conform to a general schema
   */
  async runPolicyStep(entity) {
    return await opentelemetry.withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
      opentelemetry.addEntityAttributes(stageSpan, entity);
      stageSpan.setAttribute(
        "backstage.catalog.processor.stage",
        "enforcePolicy"
      );
      let policyEnforcedEntity;
      try {
        policyEnforcedEntity = await this.options.policy.enforce(entity);
      } catch (e) {
        throw new errors.InputError(
          `Policy check failed for ${catalogModel.stringifyEntityRef(entity)}`,
          e
        );
      }
      if (!policyEnforcedEntity) {
        throw new Error(
          `Policy unexpectedly returned no data for ${catalogModel.stringifyEntityRef(
            entity
          )}`
        );
      }
      return policyEnforcedEntity;
    });
  }
  /**
   * Validate the given entity
   */
  async runValidateStep(entity, context) {
    return await opentelemetry.withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
      opentelemetry.addEntityAttributes(stageSpan, entity);
      stageSpan.setAttribute("backstage.catalog.processor.stage", "validate");
      if (catalogModel.stringifyEntityRef(entity) !== context.entityRef) {
        throw new errors.ConflictError(
          "Fatal: The entity kind, namespace, or name changed during processing"
        );
      }
      try {
        util.validateEntity(entity);
      } catch (e) {
        throw new errors.ConflictError(
          `Entity envelope for ${context.entityRef} failed validation after preprocessing`,
          e
        );
      }
      let valid = false;
      for (const processor of this.options.processors) {
        if (processor.validateEntityKind) {
          try {
            const thisValid = await opentelemetry.withActiveSpan(
              tracer,
              "ProcessingStep",
              async (span) => {
                opentelemetry.addEntityAttributes(span, entity);
                addProcessorAttributes(span, "validateEntityKind", processor);
                return await processor.validateEntityKind(entity);
              }
            );
            if (thisValid) {
              valid = true;
              if (this.options.legacySingleProcessorValidation) {
                break;
              }
            }
          } catch (e) {
            throw new errors.InputError(
              `Processor ${processor.constructor.name} threw an error while validating the entity ${context.entityRef}`,
              e
            );
          }
        }
      }
      if (!valid) {
        throw new errors.InputError(
          `No processor recognized the entity ${context.entityRef} as valid, possibly caused by a foreign kind or apiVersion`
        );
      }
    });
  }
  /**
   * Backwards compatible processing of location entities
   */
  async runSpecialLocationStep(entity, context) {
    return await opentelemetry.withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
      opentelemetry.addEntityAttributes(stageSpan, entity);
      stageSpan.setAttribute(
        "backstage.catalog.processor.stage",
        "readLocation"
      );
      const { type = context.location.type, presence = "required" } = entity.spec;
      const targets = new Array();
      if (entity.spec.target) {
        targets.push(entity.spec.target);
      }
      if (entity.spec.targets) {
        targets.push(...entity.spec.targets);
      }
      for (const maybeRelativeTarget of targets) {
        if (type === "file" && maybeRelativeTarget.endsWith(path__default.default.sep)) {
          context.collector.generic()(
            pluginCatalogNode.processingResult.inputError(
              context.location,
              `LocationEntityProcessor cannot handle ${type} type location with target ${context.location.target} that ends with a path separator`
            )
          );
          continue;
        }
        const target = util.toAbsoluteUrl(
          this.options.integrations,
          context.location,
          type,
          maybeRelativeTarget
        );
        let didRead = false;
        for (const processor of this.options.processors) {
          if (processor.readLocation) {
            try {
              const read = await opentelemetry.withActiveSpan(
                tracer,
                "ProcessingStep",
                async (span) => {
                  opentelemetry.addEntityAttributes(span, entity);
                  addProcessorAttributes(span, "readLocation", processor);
                  return await processor.readLocation(
                    {
                      type,
                      target,
                      presence
                    },
                    presence === "optional",
                    context.collector.forProcessor(processor),
                    this.options.parser,
                    context.cache.forProcessor(processor, target)
                  );
                }
              );
              if (read) {
                didRead = true;
                break;
              }
            } catch (e) {
              throw new errors.InputError(
                `Processor ${processor.constructor.name} threw an error while reading ${type}:${target}`,
                e
              );
            }
          }
        }
        if (!didRead) {
          throw new errors.InputError(
            `No processor was able to handle reading of ${type}:${target}`
          );
        }
      }
    });
  }
  /**
   * Main processing step of the entity
   */
  async runPostProcessStep(entity, context) {
    return await opentelemetry.withActiveSpan(tracer, "ProcessingStage", async (stageSpan) => {
      opentelemetry.addEntityAttributes(stageSpan, entity);
      stageSpan.setAttribute(
        "backstage.catalog.processor.stage",
        "postProcessEntity"
      );
      let res = entity;
      for (const processor of this.options.processors) {
        if (processor.postProcessEntity) {
          let innerRes = res;
          res = await opentelemetry.withActiveSpan(tracer, "ProcessingStep", async (span) => {
            opentelemetry.addEntityAttributes(span, entity);
            addProcessorAttributes(span, "postProcessEntity", processor);
            try {
              innerRes = await processor.postProcessEntity(
                innerRes,
                context.location,
                context.collector.forProcessor(processor),
                context.cache.forProcessor(processor)
              );
            } catch (e) {
              throw new errors.InputError(
                `Processor ${processor.constructor.name} threw an error while postprocessing`,
                e
              );
            }
            return innerRes;
          });
        }
      }
      return res;
    });
  }
}

exports.DefaultCatalogProcessingOrchestrator = DefaultCatalogProcessingOrchestrator;
//# sourceMappingURL=DefaultCatalogProcessingOrchestrator.cjs.js.map
