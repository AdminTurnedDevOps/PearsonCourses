{"version":3,"file":"TaskPipeline.cjs.js","sources":["../../src/processing/TaskPipeline.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TRACER_ID, withActiveSpan } from '../util/opentelemetry';\nimport { trace } from '@opentelemetry/api';\n\nconst DEFAULT_POLLING_INTERVAL_MS = 1000;\nconst tracer = trace.getTracer(TRACER_ID);\n\ntype Options<T> = {\n  /**\n   * The callback used to load in new tasks. The number of items returned\n   * in the array must be at most `count` number of items, but may be lower.\n   *\n   * Any error thrown from this method fill be treated as an unhandled rejection.\n   */\n  loadTasks: (count: number) => Promise<Array<T>>;\n\n  /**\n   * The callback used to process a single item.\n   *\n   * Any error thrown from this method fill be treated as an unhandled rejection.\n   */\n  processTask: (item: T) => Promise<void>;\n\n  /**\n   * The target minimum number of items to process in parallel. Once the number\n   * of in-flight tasks reaches this count, more tasks will be loaded in.\n   */\n  lowWatermark: number;\n\n  /**\n   * The maximum number of items to process in parallel.\n   */\n  highWatermark: number;\n\n  /**\n   * The interval at which tasks are polled for in the background when\n   * there aren't enough tasks to load to satisfy the low watermark.\n   *\n   * @default 1000\n   */\n  pollingIntervalMs?: number;\n};\n\n/**\n * Creates a task processing pipeline which continuously loads in tasks to\n * keep the number of parallel in-flight tasks between a low and high watermark.\n *\n * @param options - The options for the pipeline.\n * @returns A stop function which when called halts all processing.\n */\nexport function startTaskPipeline<T>(options: Options<T>) {\n  const {\n    loadTasks,\n    processTask,\n    lowWatermark,\n    highWatermark,\n    pollingIntervalMs = DEFAULT_POLLING_INTERVAL_MS,\n  } = options;\n\n  if (lowWatermark >= highWatermark) {\n    throw new Error('lowWatermark must be lower than highWatermark');\n  }\n\n  // State is in an object so that it can be stably referenced from within\n  // callbacks below\n  const state = { inFlightCount: 0 };\n  const abortController = new AbortController();\n  const abortSignal = abortController.signal;\n\n  const barrier = createBarrier({\n    waitTimeoutMillis: pollingIntervalMs,\n    signal: abortSignal,\n  });\n\n  async function pipelineLoop() {\n    while (!abortSignal.aborted) {\n      if (state.inFlightCount <= lowWatermark) {\n        await withActiveSpan(tracer, 'TaskPipelineLoop', async span => {\n          const loadCount = highWatermark - state.inFlightCount;\n          const loadedItems = await Promise.resolve()\n            .then(() => loadTasks(loadCount))\n            .catch(() => {\n              // Silently swallow errors and go back to sleep to try again; we\n              // delegate to the loadTasks function itself to catch errors and log\n              // if it so desires\n              return [];\n            });\n          span.setAttribute('itemCount', loadedItems.length);\n          if (loadedItems.length && !abortSignal.aborted) {\n            state.inFlightCount += loadedItems.length;\n            for (const item of loadedItems) {\n              Promise.resolve()\n                .then(() => processTask(item))\n                .catch(() => {\n                  // Silently swallow errors and go back to sleep to try again; we\n                  // delegate to the processTask function itself to catch errors\n                  // and log if it so desires\n                })\n                .finally(() => {\n                  state.inFlightCount -= 1;\n                  barrier.release();\n                });\n            }\n          }\n        });\n      }\n      await barrier.wait();\n    }\n  }\n\n  pipelineLoop().catch(error => {\n    // This should be impossible, but if it did happen, it would signal a\n    // programming error inside the loop (errors should definitely be caught\n    // inside of it). Let's rethrow with more information, and let it be caught\n    // by the process' uncaught exception handler, which will log the occurrence\n    // at a high level.\n    throw new Error(`Unexpected error in processing pipeline loop`, error);\n  });\n\n  return () => {\n    abortController.abort();\n    barrier.destroy();\n  };\n}\n\n/**\n * Creates a barrier with a timeout, that can be awaited or prematurely\n * released either manually or by an abort signal.\n */\nexport function createBarrier(options: {\n  waitTimeoutMillis: number;\n  signal: AbortSignal;\n}): {\n  wait: () => Promise<void>;\n  release: () => void;\n  destroy: () => void;\n} {\n  const { waitTimeoutMillis, signal } = options;\n  const resolvers = new Set<() => void>();\n\n  function wait() {\n    if (signal.aborted || !(waitTimeoutMillis > 0)) {\n      return Promise.resolve();\n    }\n\n    return new Promise<void>(resolve => {\n      const timeoutHandle = setTimeout(done, waitTimeoutMillis);\n\n      function done() {\n        resolvers.delete(done);\n        clearTimeout(timeoutHandle);\n        resolve();\n      }\n\n      resolvers.add(done);\n    });\n  }\n\n  function release() {\n    const resolversToCall = new Set(resolvers);\n    resolvers.clear();\n    for (const resolver of resolversToCall) {\n      resolver();\n    }\n  }\n\n  signal.addEventListener('abort', release);\n\n  return {\n    wait,\n    release,\n    destroy: () => signal.removeEventListener('abort', release),\n  };\n}\n"],"names":["trace","TRACER_ID","withActiveSpan"],"mappings":"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"}