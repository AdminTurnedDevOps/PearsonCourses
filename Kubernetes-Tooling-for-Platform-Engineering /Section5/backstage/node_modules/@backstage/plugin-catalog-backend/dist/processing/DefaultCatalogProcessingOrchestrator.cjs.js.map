{"version":3,"file":"DefaultCatalogProcessingOrchestrator.cjs.js","sources":["../../src/processing/DefaultCatalogProcessingOrchestrator.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Span, trace } from '@opentelemetry/api';\nimport {\n  Entity,\n  EntityPolicy,\n  LocationEntity,\n  parseLocationRef,\n  stringifyEntityRef,\n  stringifyLocationRef,\n} from '@backstage/catalog-model';\nimport {\n  assertError,\n  ConflictError,\n  InputError,\n  NotAllowedError,\n} from '@backstage/errors';\nimport { JsonValue } from '@backstage/types';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport path from 'path';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport {\n  CatalogProcessor,\n  CatalogProcessorParser,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\nimport {\n  CatalogProcessingOrchestrator,\n  EntityProcessingRequest,\n  EntityProcessingResult,\n} from './types';\nimport { ProcessorOutputCollector } from './ProcessorOutputCollector';\nimport {\n  getEntityLocationRef,\n  getEntityOriginLocationRef,\n  isLocationEntity,\n  isObject,\n  toAbsoluteUrl,\n  validateEntity,\n  validateEntityEnvelope,\n} from './util';\nimport { CatalogRulesEnforcer } from '../ingestion/CatalogRules';\nimport { ProcessorCacheManager } from './ProcessorCacheManager';\nimport {\n  addEntityAttributes,\n  TRACER_ID,\n  withActiveSpan,\n} from '../util/opentelemetry';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\nconst tracer = trace.getTracer(TRACER_ID);\n\ntype Context = {\n  entityRef: string;\n  location: LocationSpec;\n  originLocation: LocationSpec;\n  collector: ProcessorOutputCollector;\n  cache: ProcessorCacheManager;\n};\n\nfunction addProcessorAttributes(\n  span: Span,\n  stage: string,\n  processor: CatalogProcessor,\n) {\n  span.setAttribute('backstage.catalog.processor.stage', stage);\n  span.setAttribute(\n    'backstage.catalog.processor.name',\n    processor.getProcessorName(),\n  );\n}\n\n/** @public */\nexport class DefaultCatalogProcessingOrchestrator\n  implements CatalogProcessingOrchestrator\n{\n  constructor(\n    private readonly options: {\n      processors: CatalogProcessor[];\n      integrations: ScmIntegrationRegistry;\n      logger: LoggerService;\n      parser: CatalogProcessorParser;\n      policy: EntityPolicy;\n      rulesEnforcer: CatalogRulesEnforcer;\n      legacySingleProcessorValidation: boolean;\n    },\n  ) {}\n\n  async process(\n    request: EntityProcessingRequest,\n  ): Promise<EntityProcessingResult> {\n    return this.processSingleEntity(request.entity, request.state);\n  }\n\n  private async processSingleEntity(\n    unprocessedEntity: Entity,\n    state: JsonValue | undefined,\n  ): Promise<EntityProcessingResult> {\n    const collector = new ProcessorOutputCollector(\n      this.options.logger,\n      unprocessedEntity,\n    );\n\n    // Cache that is scoped to the entity and processor\n    const cache = new ProcessorCacheManager(\n      isObject(state) && isObject(state.cache) ? state.cache : {},\n    );\n\n    try {\n      // This will be checked and mutated step by step below\n      let entity: Entity = unprocessedEntity;\n\n      // NOTE: At this early point, we can only rely on the envelope having to\n      // be valid; full entity + kind validation happens after the (potentially\n      // mutative) pre-steps. This means that the code below can't make a lot\n      // of assumptions about the data despite it using the Entity type.\n      try {\n        validateEntityEnvelope(entity);\n      } catch (e) {\n        throw new InputError(\n          `Entity envelope failed validation before processing`,\n          e,\n        );\n      }\n\n      // TODO: which one do we actually use for the location?\n      // source-location? - maybe probably doesn't exist yet?\n      const context: Context = {\n        entityRef: stringifyEntityRef(entity),\n        location: parseLocationRef(getEntityLocationRef(entity)),\n        originLocation: parseLocationRef(getEntityOriginLocationRef(entity)),\n        cache,\n        collector,\n      };\n\n      // Run the steps\n      entity = await this.runPreProcessStep(entity, context);\n      entity = await this.runPolicyStep(entity);\n      await this.runValidateStep(entity, context);\n      if (isLocationEntity(entity)) {\n        await this.runSpecialLocationStep(entity, context);\n      }\n      entity = await this.runPostProcessStep(entity, context);\n\n      // Check that any emitted entities are permitted to originate from that\n      // particular location according to the catalog rules\n      const collectorResults = context.collector.results();\n      for (const deferredEntity of collectorResults.deferredEntities) {\n        if (\n          !this.options.rulesEnforcer.isAllowed(\n            deferredEntity.entity,\n            context.originLocation,\n          )\n        ) {\n          throw new NotAllowedError(\n            `Entity ${stringifyEntityRef(\n              deferredEntity.entity,\n            )} at ${stringifyLocationRef(\n              context.location,\n            )}, originated at ${stringifyLocationRef(\n              context.originLocation,\n            )}, is not of an allowed kind for that location`,\n          );\n        }\n      }\n\n      return {\n        ...collectorResults,\n        completedEntity: entity,\n        state: { cache: cache.collect() },\n        ok: collectorResults.errors.length === 0,\n      };\n    } catch (error) {\n      assertError(error);\n      return {\n        ok: false,\n        errors: collector.results().errors.concat(error),\n      };\n    }\n  }\n\n  // Pre-process phase, used to populate entities with data that is required\n  // during the main processing step\n  private async runPreProcessStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute('backstage.catalog.processor.stage', 'preProcess');\n      let res = entity;\n\n      for (const processor of this.options.processors) {\n        if (processor.preProcessEntity) {\n          let innerRes = res;\n          res = await withActiveSpan(tracer, 'ProcessingStep', async span => {\n            addEntityAttributes(span, entity);\n            addProcessorAttributes(span, 'preProcessEntity', processor);\n            try {\n              innerRes = await processor.preProcessEntity!(\n                innerRes,\n                context.location,\n                context.collector.forProcessor(processor),\n                context.originLocation,\n                context.cache.forProcessor(processor),\n              );\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while preprocessing`,\n                e,\n              );\n            }\n            return innerRes;\n          });\n        }\n      }\n\n      return res;\n    });\n  }\n\n  /**\n   * Enforce entity policies making sure that entities conform to a general schema\n   */\n  private async runPolicyStep(entity: Entity): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'enforcePolicy',\n      );\n      let policyEnforcedEntity: Entity | undefined;\n\n      try {\n        policyEnforcedEntity = await this.options.policy.enforce(entity);\n      } catch (e) {\n        throw new InputError(\n          `Policy check failed for ${stringifyEntityRef(entity)}`,\n          e,\n        );\n      }\n\n      if (!policyEnforcedEntity) {\n        throw new Error(\n          `Policy unexpectedly returned no data for ${stringifyEntityRef(\n            entity,\n          )}`,\n        );\n      }\n\n      return policyEnforcedEntity;\n    });\n  }\n\n  /**\n   * Validate the given entity\n   */\n  private async runValidateStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<void> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute('backstage.catalog.processor.stage', 'validate');\n      // Double check that none of the previous steps tried to change something\n      // related to the entity ref, which would break downstream\n      if (stringifyEntityRef(entity) !== context.entityRef) {\n        throw new ConflictError(\n          'Fatal: The entity kind, namespace, or name changed during processing',\n        );\n      }\n\n      // Validate that the end result is a valid Entity at all\n      try {\n        validateEntity(entity);\n      } catch (e) {\n        throw new ConflictError(\n          `Entity envelope for ${context.entityRef} failed validation after preprocessing`,\n          e,\n        );\n      }\n\n      let valid = false;\n\n      for (const processor of this.options.processors) {\n        if (processor.validateEntityKind) {\n          try {\n            const thisValid = await withActiveSpan(\n              tracer,\n              'ProcessingStep',\n              async span => {\n                addEntityAttributes(span, entity);\n                addProcessorAttributes(span, 'validateEntityKind', processor);\n                return await processor.validateEntityKind!(entity);\n              },\n            );\n            if (thisValid) {\n              valid = true;\n              if (this.options.legacySingleProcessorValidation) {\n                break;\n              }\n            }\n          } catch (e) {\n            throw new InputError(\n              `Processor ${processor.constructor.name} threw an error while validating the entity ${context.entityRef}`,\n              e,\n            );\n          }\n        }\n      }\n\n      if (!valid) {\n        throw new InputError(\n          `No processor recognized the entity ${context.entityRef} as valid, possibly caused by a foreign kind or apiVersion`,\n        );\n      }\n    });\n  }\n\n  /**\n   * Backwards compatible processing of location entities\n   */\n  private async runSpecialLocationStep(\n    entity: LocationEntity,\n    context: Context,\n  ): Promise<void> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'readLocation',\n      );\n      const { type = context.location.type, presence = 'required' } =\n        entity.spec;\n      const targets = new Array<string>();\n      if (entity.spec.target) {\n        targets.push(entity.spec.target);\n      }\n      if (entity.spec.targets) {\n        targets.push(...entity.spec.targets);\n      }\n\n      for (const maybeRelativeTarget of targets) {\n        if (type === 'file' && maybeRelativeTarget.endsWith(path.sep)) {\n          context.collector.generic()(\n            processingResult.inputError(\n              context.location,\n              `LocationEntityProcessor cannot handle ${type} type location with target ${context.location.target} that ends with a path separator`,\n            ),\n          );\n          continue;\n        }\n        const target = toAbsoluteUrl(\n          this.options.integrations,\n          context.location,\n          type,\n          maybeRelativeTarget,\n        );\n\n        let didRead = false;\n        for (const processor of this.options.processors) {\n          if (processor.readLocation) {\n            try {\n              const read = await withActiveSpan(\n                tracer,\n                'ProcessingStep',\n                async span => {\n                  addEntityAttributes(span, entity);\n                  addProcessorAttributes(span, 'readLocation', processor);\n                  return await processor.readLocation!(\n                    {\n                      type,\n                      target,\n                      presence,\n                    },\n                    presence === 'optional',\n                    context.collector.forProcessor(processor),\n                    this.options.parser,\n                    context.cache.forProcessor(processor, target),\n                  );\n                },\n              );\n              if (read) {\n                didRead = true;\n                break;\n              }\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while reading ${type}:${target}`,\n                e,\n              );\n            }\n          }\n        }\n        if (!didRead) {\n          throw new InputError(\n            `No processor was able to handle reading of ${type}:${target}`,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Main processing step of the entity\n   */\n  private async runPostProcessStep(\n    entity: Entity,\n    context: Context,\n  ): Promise<Entity> {\n    return await withActiveSpan(tracer, 'ProcessingStage', async stageSpan => {\n      addEntityAttributes(stageSpan, entity);\n      stageSpan.setAttribute(\n        'backstage.catalog.processor.stage',\n        'postProcessEntity',\n      );\n      let res = entity;\n\n      for (const processor of this.options.processors) {\n        if (processor.postProcessEntity) {\n          let innerRes = res;\n          res = await withActiveSpan(tracer, 'ProcessingStep', async span => {\n            addEntityAttributes(span, entity);\n            addProcessorAttributes(span, 'postProcessEntity', processor);\n            try {\n              innerRes = await processor.postProcessEntity!(\n                innerRes,\n                context.location,\n                context.collector.forProcessor(processor),\n                context.cache.forProcessor(processor),\n              );\n            } catch (e) {\n              throw new InputError(\n                `Processor ${processor.constructor.name} threw an error while postprocessing`,\n                e,\n              );\n            }\n            return innerRes;\n          });\n        }\n      }\n\n      return res;\n    });\n  }\n}\n"],"names":["trace","TRACER_ID","ProcessorOutputCollector","ProcessorCacheManager","isObject","validateEntityEnvelope","InputError","stringifyEntityRef","parseLocationRef","getEntityLocationRef","getEntityOriginLocationRef","isLocationEntity","NotAllowedError","stringifyLocationRef","assertError","withActiveSpan","addEntityAttributes","ConflictError","validateEntity","path","processingResult","toAbsoluteUrl"],"mappings":"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"}