'use strict';

var errors = require('@backstage/errors');
var api = require('@opentelemetry/api');
var metrics = require('../util/metrics.cjs.js');

function progressTracker(knex, logger) {
  const promStitchedEntities = metrics.createCounterMetric({
    name: "catalog_stitched_entities_count",
    help: "Amount of entities stitched. DEPRECATED, use OpenTelemetry metrics instead"
  });
  const meter = api.metrics.getMeter("default");
  const stitchedEntities = meter.createCounter(
    "catalog.stitched.entities.count",
    {
      description: "Amount of entities stitched"
    }
  );
  const stitchingDuration = meter.createHistogram(
    "catalog.stitching.duration",
    {
      description: "Time spent executing the full stitching flow",
      unit: "seconds"
    }
  );
  const stitchingQueueCount = meter.createObservableGauge(
    "catalog.stitching.queue.length",
    { description: "Number of entities currently in the stitching queue" }
  );
  stitchingQueueCount.addCallback(async (result) => {
    const total = await knex("refresh_state").count({ count: "*" }).whereNotNull("next_stitch_at");
    result.observe(Number(total[0].count));
  });
  const stitchingQueueDelay = meter.createHistogram(
    "catalog.stitching.queue.delay",
    {
      description: "The amount of delay between being scheduled for stitching, and the start of actually being stitched",
      unit: "seconds"
    }
  );
  function stitchStart(item) {
    logger.debug(`Stitching ${item.entityRef}`);
    const startTime = process.hrtime();
    if (item.stitchRequestedAt) {
      stitchingQueueDelay.record(
        -item.stitchRequestedAt.diffNow().as("seconds")
      );
    }
    function endTime() {
      const delta = process.hrtime(startTime);
      return delta[0] + delta[1] / 1e9;
    }
    function markComplete(result) {
      promStitchedEntities.inc(1);
      stitchedEntities.add(1, { result });
      stitchingDuration.record(endTime(), { result });
    }
    function markFailed(error) {
      promStitchedEntities.inc(1);
      stitchedEntities.add(1, { result: "error" });
      stitchingDuration.record(endTime(), { result: "error" });
      logger.error(
        `Failed to stitch ${item.entityRef}, ${errors.stringifyError(error)}`
      );
    }
    return {
      markComplete,
      markFailed
    };
  }
  return { stitchStart };
}

exports.progressTracker = progressTracker;
//# sourceMappingURL=progressTracker.cjs.js.map
