'use strict';

var types$1 = require('@backstage/types');
var splitToChunks = require('lodash/chunk');
var getDeferredStitchableEntities = require('../database/operations/stitcher/getDeferredStitchableEntities.cjs.js');
var markForStitching = require('../database/operations/stitcher/markForStitching.cjs.js');
var performStitching = require('../database/operations/stitcher/performStitching.cjs.js');
var TaskPipeline = require('../processing/TaskPipeline.cjs.js');
var progressTracker = require('./progressTracker.cjs.js');
var types = require('./types.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var splitToChunks__default = /*#__PURE__*/_interopDefaultCompat(splitToChunks);

class DefaultStitcher {
  knex;
  logger;
  strategy;
  tracker;
  stopFunc;
  static fromConfig(config, options) {
    return new DefaultStitcher({
      knex: options.knex,
      logger: options.logger,
      strategy: types.stitchingStrategyFromConfig(config)
    });
  }
  constructor(options) {
    this.knex = options.knex;
    this.logger = options.logger;
    this.strategy = options.strategy;
    this.tracker = progressTracker.progressTracker(options.knex, options.logger);
  }
  async stitch(options) {
    const { entityRefs, entityIds } = options;
    if (this.strategy.mode === "deferred") {
      await markForStitching.markForStitching({
        knex: this.knex,
        strategy: this.strategy,
        entityRefs,
        entityIds
      });
      return;
    }
    if (entityRefs) {
      for (const entityRef of entityRefs) {
        await this.#stitchOne({ entityRef });
      }
    }
    if (entityIds) {
      const chunks = splitToChunks__default.default(
        Array.isArray(entityIds) ? entityIds : [...entityIds],
        100
      );
      for (const chunk of chunks) {
        const rows = await this.knex("refresh_state").select("entity_ref").whereIn("entity_id", chunk);
        for (const row of rows) {
          await this.#stitchOne({ entityRef: row.entity_ref });
        }
      }
    }
  }
  async start() {
    if (this.strategy.mode === "deferred") {
      if (this.stopFunc) {
        throw new Error("Processing engine is already started");
      }
      const { pollingInterval, stitchTimeout } = this.strategy;
      const stopPipeline = TaskPipeline.startTaskPipeline({
        lowWatermark: 2,
        highWatermark: 5,
        pollingIntervalMs: types$1.durationToMilliseconds(pollingInterval),
        loadTasks: async (count) => {
          return await this.#getStitchableEntities(count, stitchTimeout);
        },
        processTask: async (item) => {
          return await this.#stitchOne({
            entityRef: item.entityRef,
            stitchTicket: item.stitchTicket,
            stitchRequestedAt: item.stitchRequestedAt
          });
        }
      });
      this.stopFunc = () => {
        stopPipeline();
      };
    }
  }
  async stop() {
    if (this.strategy.mode === "deferred") {
      if (this.stopFunc) {
        this.stopFunc();
        this.stopFunc = void 0;
      }
    }
  }
  async #getStitchableEntities(count, stitchTimeout) {
    try {
      return await getDeferredStitchableEntities.getDeferredStitchableEntities({
        knex: this.knex,
        batchSize: count,
        stitchTimeout
      });
    } catch (error) {
      this.logger.warn("Failed to load stitchable entities", error);
      return [];
    }
  }
  async #stitchOne(options) {
    const track = this.tracker.stitchStart({
      entityRef: options.entityRef,
      stitchRequestedAt: options.stitchRequestedAt
    });
    try {
      const result = await performStitching.performStitching({
        knex: this.knex,
        logger: this.logger,
        strategy: this.strategy,
        entityRef: options.entityRef,
        stitchTicket: options.stitchTicket
      });
      track.markComplete(result);
    } catch (error) {
      track.markFailed(error);
    }
  }
}

exports.DefaultStitcher = DefaultStitcher;
//# sourceMappingURL=DefaultStitcher.cjs.js.map
