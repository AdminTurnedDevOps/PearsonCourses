'use strict';

var config = require('@backstage/config');

function stitchingStrategyFromConfig(config$1) {
  const strategyMode = config$1.getOptionalString(
    "catalog.stitchingStrategy.mode"
  );
  if (strategyMode === void 0 || strategyMode === "immediate") {
    return {
      mode: "immediate"
    };
  } else if (strategyMode === "deferred") {
    const pollingIntervalKey = "catalog.stitchingStrategy.pollingInterval";
    const stitchTimeoutKey = "catalog.stitchingStrategy.stitchTimeout";
    const pollingInterval = config$1.has(pollingIntervalKey) ? config.readDurationFromConfig(config$1, { key: pollingIntervalKey }) : { seconds: 1 };
    const stitchTimeout = config$1.has(stitchTimeoutKey) ? config.readDurationFromConfig(config$1, { key: stitchTimeoutKey }) : { seconds: 60 };
    return {
      mode: "deferred",
      pollingInterval,
      stitchTimeout
    };
  }
  throw new Error(
    `Invalid stitching strategy mode '${strategyMode}', expected one of 'immediate' or 'deferred'`
  );
}

exports.stitchingStrategyFromConfig = stitchingStrategyFromConfig;
//# sourceMappingURL=types.cjs.js.map
