'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var lodash = require('lodash');
var zod = require('zod');
var util = require('./util.cjs.js');
var applyEntityFilterToQuery = require('./request/applyEntityFilterToQuery.cjs.js');
var process = require('./response/process.cjs.js');

const DEFAULT_LIMIT = 200;
function parsePagination(input) {
  if (!input) {
    return {};
  }
  let { limit, offset } = input;
  if (input.after === void 0) {
    return { limit, offset };
  }
  let cursor;
  try {
    const json = Buffer.from(input.after, "base64").toString("utf8");
    cursor = JSON.parse(json);
  } catch {
    throw new errors.InputError("Malformed after cursor, could not be parsed");
  }
  if (cursor.limit !== void 0) {
    if (!Number.isInteger(cursor.limit)) {
      throw new errors.InputError("Malformed after cursor, limit was not an number");
    }
    limit = cursor.limit;
  }
  if (cursor.offset !== void 0) {
    if (!Number.isInteger(cursor.offset)) {
      throw new errors.InputError("Malformed after cursor, offset was not a number");
    }
    offset = cursor.offset;
  }
  return { limit, offset };
}
function stringifyPagination(input) {
  const { limit, offset } = input;
  const json = JSON.stringify({ limit, offset });
  const base64 = Buffer.from(json, "utf8").toString("base64");
  return base64;
}
class DefaultEntitiesCatalog {
  database;
  logger;
  stitcher;
  disableRelationsCompatibility;
  constructor(options) {
    this.database = options.database;
    this.logger = options.logger;
    this.stitcher = options.stitcher;
    this.disableRelationsCompatibility = Boolean(
      options.disableRelationsCompatibility
    );
  }
  async entities(request) {
    const db = this.database;
    const { limit, offset } = parsePagination(request?.pagination);
    let entitiesQuery = db("final_entities").select("final_entities.*");
    request?.order?.forEach(({ field }, index) => {
      const alias = `order_${index}`;
      entitiesQuery = entitiesQuery.leftOuterJoin(
        { [alias]: "search" },
        function search(inner) {
          inner.on(`${alias}.entity_id`, "final_entities.entity_id").andOn(`${alias}.key`, db.raw("?", [field]));
        }
      );
    });
    entitiesQuery = entitiesQuery.whereNotNull("final_entities.final_entity");
    if (request?.filter) {
      entitiesQuery = applyEntityFilterToQuery.applyEntityFilterToQuery({
        filter: request.filter,
        targetQuery: entitiesQuery,
        onEntityIdField: "final_entities.entity_id",
        knex: db
      });
    }
    request?.order?.forEach(({ order }, index) => {
      if (db.client.config.client === "pg") {
        entitiesQuery = entitiesQuery.orderBy([
          { column: `order_${index}.value`, order, nulls: "last" }
        ]);
      } else {
        entitiesQuery = entitiesQuery.orderBy([
          { column: `order_${index}.value`, order: void 0, nulls: "last" },
          { column: `order_${index}.value`, order }
        ]);
      }
    });
    if (!request?.order) {
      entitiesQuery = entitiesQuery.orderBy("final_entities.entity_ref", "asc");
    } else {
      entitiesQuery.orderBy("final_entities.entity_id", "asc");
    }
    if (limit !== void 0) {
      entitiesQuery = entitiesQuery.limit(limit + 1);
    }
    if (offset !== void 0) {
      entitiesQuery = entitiesQuery.offset(offset);
    }
    let rows = await entitiesQuery;
    let pageInfo;
    if (limit === void 0 || rows.length <= limit) {
      pageInfo = { hasNextPage: false };
    } else {
      rows = rows.slice(0, -1);
      pageInfo = {
        hasNextPage: true,
        endCursor: stringifyPagination({
          limit,
          offset: (offset ?? 0) + limit
        })
      };
    }
    return {
      entities: process.processRawEntitiesResult(
        rows.map((r) => r.final_entity),
        this.disableRelationsCompatibility ? request?.fields : (e) => {
          util.expandLegacyCompoundRelationsInEntity(e);
          if (request?.fields) {
            return request.fields(e);
          }
          return e;
        }
      ),
      pageInfo
    };
  }
  async entitiesBatch(request) {
    const lookup = /* @__PURE__ */ new Map();
    for (const chunk of lodash.chunk(request.entityRefs, 200)) {
      let query = this.database("final_entities").select({
        entityRef: "final_entities.entity_ref",
        entity: "final_entities.final_entity"
      }).whereIn("final_entities.entity_ref", chunk);
      if (request?.filter) {
        query = applyEntityFilterToQuery.applyEntityFilterToQuery({
          filter: request.filter,
          targetQuery: query,
          onEntityIdField: "final_entities.entity_id",
          knex: this.database
        });
      }
      for (const row of await query) {
        lookup.set(row.entityRef, row.entity ? row.entity : null);
      }
    }
    const items = request.entityRefs.map((ref) => lookup.get(ref) ?? null);
    return { items: process.processRawEntitiesResult(items, request.fields) };
  }
  async queryEntities(request) {
    const limit = request.limit ?? DEFAULT_LIMIT;
    const cursor = {
      orderFields: [],
      isPrevious: false,
      ...parseCursorFromRequest(request)
    };
    const shouldComputeTotalItems = cursor.totalItems === void 0 && !cursor.skipTotalItems;
    const isFetchingBackwards = cursor.isPrevious;
    if (cursor.orderFields.length > 1) {
      this.logger.warn(`Only one sort field is supported, ignoring the rest`);
    }
    const sortField = cursor.orderFields.at(0);
    const dbQuery = this.database.with(
      "filtered",
      ["entity_id", "final_entity", ...sortField ? ["value"] : []],
      (inner) => {
        inner.from("final_entities").whereNotNull("final_entity");
        if (sortField) {
          inner.leftOuterJoin(
            "search",
            (qb) => qb.on("search.entity_id", "final_entities.entity_id").andOnVal("search.key", sortField.field)
          ).select({
            entity_id: "final_entities.entity_id",
            final_entity: "final_entities.final_entity",
            value: "search.value"
          });
        } else {
          inner.select({
            entity_id: "final_entities.entity_id",
            final_entity: "final_entities.final_entity"
          });
        }
        if (cursor.filter) {
          applyEntityFilterToQuery.applyEntityFilterToQuery({
            filter: cursor.filter,
            targetQuery: inner,
            onEntityIdField: "final_entities.entity_id",
            knex: this.database
          });
        }
        const normalizedFullTextFilterTerm = cursor.fullTextFilter?.term?.trim();
        const textFilterFields = cursor.fullTextFilter?.fields ?? [
          sortField?.field || "metadata.uid"
        ];
        if (normalizedFullTextFilterTerm) {
          if (textFilterFields.length === 1 && textFilterFields[0] === sortField?.field) {
            inner.andWhereRaw(
              "search.value like ?",
              `%${normalizedFullTextFilterTerm.toLocaleLowerCase("en-US")}%`
            );
          } else {
            const matchQuery = this.database("search").select("search.entity_id").whereIn(
              "search.key",
              textFilterFields.map((field) => field.toLocaleLowerCase("en-US"))
            ).andWhere(function keyFilter() {
              this.andWhereRaw(
                "search.value like ?",
                `%${normalizedFullTextFilterTerm.toLocaleLowerCase(
                  "en-US"
                )}%`
              );
            });
            inner.andWhere("final_entities.entity_id", "in", matchQuery);
          }
        }
      }
    );
    if (shouldComputeTotalItems) {
      dbQuery.with(
        "filtered_count",
        ["count"],
        (inner) => inner.from("filtered").count("*", { as: "count" })
      ).fromRaw("filtered_count, filtered").select("count", "filtered.*");
    } else {
      dbQuery.from("filtered").select("*");
    }
    const isOrderingDescending = sortField?.order === "desc";
    if (cursor.orderFieldValues) {
      if (cursor.orderFieldValues.length === 2) {
        const [first, second] = cursor.orderFieldValues;
        dbQuery.andWhere(function nested() {
          this.where(
            "filtered.value",
            isFetchingBackwards !== isOrderingDescending ? "<" : ">",
            first
          ).orWhere("filtered.value", "=", first).andWhere(
            "filtered.entity_id",
            isFetchingBackwards !== isOrderingDescending ? "<" : ">",
            second
          );
        });
      } else if (cursor.orderFieldValues.length === 1) {
        const [first] = cursor.orderFieldValues;
        dbQuery.andWhere("entity_id", isFetchingBackwards ? "<" : ">", first);
      }
    }
    let order = sortField?.order ?? "asc";
    if (isFetchingBackwards) {
      order = invertOrder(order);
    }
    if (this.database.client.config.client === "pg") {
      dbQuery.orderBy([
        ...sortField ? [
          {
            column: "filtered.value",
            order,
            nulls: "last"
          }
        ] : [],
        {
          column: "filtered.entity_id",
          order
        }
      ]);
    } else {
      dbQuery.orderBy([
        ...sortField ? [
          {
            column: "filtered.value",
            order: void 0,
            nulls: "last"
          },
          {
            column: "filtered.value",
            order
          }
        ] : [],
        {
          column: "filtered.entity_id",
          order
        }
      ]);
    }
    if (util.isQueryEntitiesInitialRequest(request) && request.offset !== void 0) {
      dbQuery.offset(request.offset);
    }
    dbQuery.limit(isFetchingBackwards ? limit : limit + 1);
    const rows = shouldComputeTotalItems || limit > 0 ? await dbQuery : [];
    let totalItems;
    if (cursor.totalItems !== void 0) {
      totalItems = cursor.totalItems;
    } else if (cursor.skipTotalItems) {
      totalItems = 0;
    } else if (rows.length) {
      totalItems = Number(rows[0].count);
    } else {
      totalItems = 0;
    }
    if (isFetchingBackwards) {
      rows.reverse();
    }
    const hasMoreResults = limit > 0 && (isFetchingBackwards || rows.length > limit);
    if (rows.length > limit) {
      rows.length -= 1;
    }
    const isInitialRequest = cursor.firstSortFieldValues === void 0;
    const firstRow = rows[0];
    const lastRow = rows[rows.length - 1];
    const firstSortFieldValues = cursor.firstSortFieldValues || sortFieldsFromRow(firstRow, sortField);
    const nextCursor = hasMoreResults ? {
      ...cursor,
      orderFieldValues: sortFieldsFromRow(lastRow, sortField),
      firstSortFieldValues,
      isPrevious: false,
      totalItems
    } : void 0;
    const prevCursor = !isInitialRequest && rows.length > 0 && !lodash.isEqual(
      sortFieldsFromRow(firstRow, sortField),
      cursor.firstSortFieldValues
    ) ? {
      ...cursor,
      orderFieldValues: sortFieldsFromRow(firstRow, sortField),
      firstSortFieldValues: cursor.firstSortFieldValues,
      isPrevious: true,
      totalItems
    } : void 0;
    return {
      items: process.processRawEntitiesResult(
        rows.map((r) => r.final_entity),
        request.fields
      ),
      pageInfo: {
        ...!!prevCursor && { prevCursor },
        ...!!nextCursor && { nextCursor }
      },
      totalItems
    };
  }
  async removeEntityByUid(uid) {
    const dbConfig = this.database.client.config;
    if (dbConfig.client.includes("mysql")) {
      const results = await this.database("refresh_state").select("entity_id").whereIn("entity_ref", function parents(builder) {
        return builder.from("refresh_state").innerJoin(
          "refresh_state_references",
          {
            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
          }
        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
      });
      await this.database("refresh_state").update({
        result_hash: "child-was-deleted",
        next_update_at: this.database.fn.now()
      }).whereIn(
        "entity_id",
        results.map((key) => key.entity_id)
      );
    } else {
      await this.database("refresh_state").update({
        result_hash: "child-was-deleted",
        next_update_at: this.database.fn.now()
      }).whereIn("entity_ref", function parents(builder) {
        return builder.from("refresh_state").innerJoin(
          "refresh_state_references",
          {
            "refresh_state_references.target_entity_ref": "refresh_state.entity_ref"
          }
        ).where("refresh_state.entity_id", "=", uid).select("refresh_state_references.source_entity_ref");
      });
    }
    const relationPeers = await this.database.from("relations").innerJoin("refresh_state", {
      "refresh_state.entity_ref": "relations.target_entity_ref"
    }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.target_entity_ref" }).union(
      (other) => other.from("relations").innerJoin("refresh_state", {
        "refresh_state.entity_ref": "relations.source_entity_ref"
      }).where("relations.originating_entity_id", "=", uid).andWhere("refresh_state.entity_id", "!=", uid).select({ ref: "relations.source_entity_ref" })
    );
    await this.database("refresh_state").where("entity_id", uid).delete();
    await this.stitcher.stitch({
      entityRefs: new Set(relationPeers.map((p) => p.ref))
    });
  }
  async entityAncestry(rootRef) {
    const [rootRow] = await this.database("final_entities").where("final_entities.entity_ref", "=", rootRef).select({
      entityJson: "final_entities.final_entity"
    });
    if (!rootRow) {
      throw new errors.NotFoundError(`No such entity ${rootRef}`);
    }
    const rootEntity = JSON.parse(rootRow.entityJson);
    const seenEntityRefs = /* @__PURE__ */ new Set();
    const todo = new Array();
    const items = new Array();
    for (let current = rootEntity; current; current = todo.pop()) {
      const currentRef = catalogModel.stringifyEntityRef(current);
      seenEntityRefs.add(currentRef);
      const parentRows = await this.database(
        "refresh_state_references"
      ).innerJoin("final_entities", {
        "refresh_state_references.source_entity_ref": "final_entities.entity_ref"
      }).where("refresh_state_references.target_entity_ref", "=", currentRef).select({
        parentEntityRef: "final_entities.entity_ref",
        parentEntityJson: "final_entities.final_entity"
      });
      const parentRefs = [];
      for (const { parentEntityRef, parentEntityJson } of parentRows) {
        parentRefs.push(parentEntityRef);
        if (!seenEntityRefs.has(parentEntityRef)) {
          seenEntityRefs.add(parentEntityRef);
          todo.push(JSON.parse(parentEntityJson));
        }
      }
      items.push({
        entity: current,
        parentEntityRefs: parentRefs
      });
    }
    return {
      rootEntityRef: catalogModel.stringifyEntityRef(rootEntity),
      items
    };
  }
  async facets(request) {
    const query = this.database("search").whereIn(
      "search.key",
      request.facets.map((f) => f.toLocaleLowerCase("en-US"))
    ).whereNotNull("search.original_value").select({
      facet: "search.key",
      value: "search.original_value",
      count: this.database.raw("count(*)")
    }).groupBy(["search.key", "search.original_value"]);
    if (request.filter) {
      applyEntityFilterToQuery.applyEntityFilterToQuery({
        filter: request.filter,
        targetQuery: query,
        onEntityIdField: "search.entity_id",
        knex: this.database
      });
    }
    const rows = await query;
    const facets = {};
    for (const facet of request.facets) {
      const facetLowercase = facet.toLocaleLowerCase("en-US");
      facets[facet] = rows.filter((row) => row.facet === facetLowercase).map((row) => ({
        value: String(row.value),
        count: Number(row.count)
      }));
    }
    return { facets };
  }
}
const entityFilterParser = zod.z.lazy(
  () => zod.z.object({
    key: zod.z.string(),
    values: zod.z.array(zod.z.string()).optional()
  }).or(zod.z.object({ not: entityFilterParser })).or(zod.z.object({ anyOf: zod.z.array(entityFilterParser) })).or(zod.z.object({ allOf: zod.z.array(entityFilterParser) }))
);
zod.z.object({
  orderFields: zod.z.array(
    zod.z.object({ field: zod.z.string(), order: zod.z.enum(["asc", "desc"]) })
  ),
  orderFieldValues: zod.z.array(zod.z.string().or(zod.z.null())),
  filter: entityFilterParser.optional(),
  isPrevious: zod.z.boolean(),
  query: zod.z.string().optional(),
  firstSortFieldValues: zod.z.array(zod.z.string().or(zod.z.null())).optional(),
  totalItems: zod.z.number().optional()
});
function parseCursorFromRequest(request) {
  if (util.isQueryEntitiesInitialRequest(request)) {
    const {
      filter,
      orderFields: sortFields = [],
      fullTextFilter,
      skipTotalItems = false
    } = request;
    return { filter, orderFields: sortFields, fullTextFilter, skipTotalItems };
  }
  if (util.isQueryEntitiesCursorRequest(request)) {
    return {
      ...request.cursor,
      // Doesn't matter here
      skipTotalItems: false
    };
  }
  return {
    skipTotalItems: false
  };
}
function invertOrder(order) {
  return order === "asc" ? "desc" : "asc";
}
function sortFieldsFromRow(row, sortField) {
  return sortField ? [row?.value, row?.entity_id] : [row?.entity_id];
}

exports.DefaultEntitiesCatalog = DefaultEntitiesCatalog;
//# sourceMappingURL=DefaultEntitiesCatalog.cjs.js.map
