'use strict';

var errors = require('@backstage/errors');
var lodash = require('lodash');
var zod = require('zod');
var catalogModel = require('@backstage/catalog-model');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);

async function requireRequestBody(req) {
  const contentType = req.header("content-type");
  if (!contentType) {
    throw new errors.InputError("Content-Type missing");
  } else if (!contentType.match(/^application\/json($|;)/)) {
    throw new errors.InputError("Illegal Content-Type");
  }
  const body = req.body;
  if (!body) {
    throw new errors.InputError("Missing request body");
  } else if (!lodash__default.default.isPlainObject(body)) {
    throw new errors.InputError("Expected body to be a JSON object");
  } else if (Object.keys(body).length === 0) {
    throw new errors.InputError("Empty request body");
  }
  return body;
}
const locationInput = zod.z.object({
  type: zod.z.string(),
  target: zod.z.string(),
  presence: zod.z.literal("required").or(zod.z.literal("optional")).optional()
}).strict();
async function validateRequestBody(req, schema) {
  const body = await requireRequestBody(req);
  try {
    return await schema.parse(body);
  } catch (e) {
    throw new errors.InputError(`Malformed request: ${e}`);
  }
}
function disallowReadonlyMode(readonly) {
  if (readonly) {
    throw new errors.NotAllowedError("This operation not allowed in readonly mode");
  }
}
function isQueryEntitiesInitialRequest(input) {
  if (!input) {
    return false;
  }
  return !isQueryEntitiesCursorRequest(input);
}
function isQueryEntitiesCursorRequest(input) {
  if (!input) {
    return false;
  }
  return !!input.cursor;
}
const entityFilterParser = zod.z.lazy(
  () => zod.z.object({
    key: zod.z.string(),
    values: zod.z.array(zod.z.string()).optional()
  }).or(zod.z.object({ not: entityFilterParser })).or(zod.z.object({ anyOf: zod.z.array(entityFilterParser) })).or(zod.z.object({ allOf: zod.z.array(entityFilterParser) }))
);
const cursorParser = zod.z.object({
  orderFields: zod.z.array(
    zod.z.object({ field: zod.z.string(), order: zod.z.enum(["asc", "desc"]) })
  ),
  fullTextFilter: zod.z.object({
    term: zod.z.string(),
    fields: zod.z.array(zod.z.string()).optional()
  }).optional(),
  orderFieldValues: zod.z.array(zod.z.string().or(zod.z.null())),
  filter: entityFilterParser.optional(),
  isPrevious: zod.z.boolean(),
  query: zod.z.string().optional(),
  firstSortFieldValues: zod.z.array(zod.z.string().or(zod.z.null())).optional(),
  totalItems: zod.z.number().optional()
});
function encodeCursor(cursor) {
  const json = JSON.stringify(cursor);
  return Buffer.from(json, "utf8").toString("base64");
}
function decodeCursor(encodedCursor) {
  try {
    const data = Buffer.from(encodedCursor, "base64").toString("utf8");
    const result = cursorParser.safeParse(JSON.parse(data));
    if (!result.success) {
      throw new errors.InputError(`Malformed cursor: ${result.error}`);
    }
    return result.data;
  } catch (e) {
    throw new errors.InputError(`Malformed cursor: ${e}`);
  }
}
function expandLegacyCompoundRelationsInEntity(entity) {
  if (entity.relations) {
    for (const relation of entity.relations) {
      if (!relation.targetRef && relation.target) {
        relation.targetRef = catalogModel.stringifyEntityRef(relation.target);
      } else if (!relation.target && relation.targetRef) {
        relation.target = catalogModel.parseEntityRef(relation.targetRef);
      }
    }
  }
  return entity;
}

exports.cursorParser = cursorParser;
exports.decodeCursor = decodeCursor;
exports.disallowReadonlyMode = disallowReadonlyMode;
exports.encodeCursor = encodeCursor;
exports.expandLegacyCompoundRelationsInEntity = expandLegacyCompoundRelationsInEntity;
exports.isQueryEntitiesCursorRequest = isQueryEntitiesCursorRequest;
exports.isQueryEntitiesInitialRequest = isQueryEntitiesInitialRequest;
exports.locationInput = locationInput;
exports.requireRequestBody = requireRequestBody;
exports.validateRequestBody = validateRequestBody;
//# sourceMappingURL=util.cjs.js.map
