'use strict';

var catalogModel = require('@backstage/catalog-model');
var conversion = require('../util/conversion.cjs.js');
var errors = require('@backstage/errors');

class DefaultLocationService {
  constructor(store, orchestrator, options = {
    allowedLocationTypes: ["url"]
  }) {
    this.store = store;
    this.orchestrator = orchestrator;
    this.options = options;
  }
  async createLocation(input, dryRun) {
    if (!this.options.allowedLocationTypes.includes(input.type)) {
      throw new errors.InputError(
        `Registered locations must be of an allowed type ${JSON.stringify(
          this.options.allowedLocationTypes
        )}`
      );
    }
    if (dryRun) {
      return this.dryRunCreateLocation(input);
    }
    const location = await this.store.createLocation(input);
    return { location, entities: [] };
  }
  listLocations() {
    return this.store.listLocations();
  }
  getLocation(id) {
    return this.store.getLocation(id);
  }
  deleteLocation(id) {
    return this.store.deleteLocation(id);
  }
  getLocationByEntity(entityRef) {
    return this.store.getLocationByEntity(catalogModel.parseEntityRef(entityRef));
  }
  async processEntities(unprocessedEntities) {
    const entities = [];
    while (unprocessedEntities.length) {
      const currentEntity = unprocessedEntities.pop();
      if (!currentEntity) {
        continue;
      }
      const processed = await this.orchestrator.process({
        entity: currentEntity.entity,
        state: {}
        // we process without the existing cache
      });
      if (processed.ok) {
        if (entities.some(
          (e) => catalogModel.stringifyEntityRef(e) === catalogModel.stringifyEntityRef(processed.completedEntity)
        )) {
          throw new errors.InputError(
            `Duplicate nested entity: ${catalogModel.stringifyEntityRef(
              processed.completedEntity
            )}`
          );
        }
        unprocessedEntities.push(...processed.deferredEntities);
        entities.push(processed.completedEntity);
      } else {
        throw new errors.InputError(processed.errors.map(String).join(", "));
      }
    }
    return entities;
  }
  async dryRunCreateLocation(spec) {
    const existsPromise = this.store.listLocations().then(
      (locations) => locations.some((l) => l.type === spec.type && l.target === spec.target)
    );
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Location",
      metadata: {
        name: conversion.locationSpecToMetadataName({
          type: spec.type,
          target: spec.target
        }),
        namespace: "default",
        annotations: {
          [catalogModel.ANNOTATION_LOCATION]: `${spec.type}:${spec.target}`,
          [catalogModel.ANNOTATION_ORIGIN_LOCATION]: `${spec.type}:${spec.target}`
        }
      },
      spec: {
        type: spec.type,
        target: spec.target
      }
    };
    const unprocessedEntities = [
      { entity, locationKey: `${spec.type}:${spec.target}` }
    ];
    const entities = await this.processEntities(unprocessedEntities);
    return {
      exists: await existsPromise,
      location: { ...spec, id: `${spec.type}:${spec.target}` },
      entities
    };
  }
}

exports.DefaultLocationService = DefaultLocationService;
//# sourceMappingURL=DefaultLocationService.cjs.js.map
