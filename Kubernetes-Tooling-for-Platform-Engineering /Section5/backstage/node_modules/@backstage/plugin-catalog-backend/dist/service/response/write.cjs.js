'use strict';

var errors = require('@backstage/errors');
var process = require('./process.cjs.js');

const JSON_CONTENT_TYPE = "application/json; charset=utf-8";
function writeSingleEntityResponse(res, response, notFoundMessage) {
  if (response.type === "object") {
    if (!response.entities[0]) {
      throw new errors.NotFoundError(notFoundMessage);
    }
    res.json(response.entities[0]);
  } else {
    if (!response.entities[0]) {
      throw new errors.NotFoundError(notFoundMessage);
    }
    res.setHeader("Content-Type", JSON_CONTENT_TYPE);
    res.end(response.entities[0]);
  }
}
async function writeEntitiesResponse(options) {
  const { res, responseWrapper, alwaysUseObjectMode } = options;
  const items = alwaysUseObjectMode ? process.processEntitiesResponseItems(options.items, (e) => e) : options.items;
  if (items.type === "object") {
    res.json(
      responseWrapper ? responseWrapper?.(items.entities) : items.entities
    );
    return;
  }
  res.setHeader("Content-Type", JSON_CONTENT_TYPE);
  let trailing = "";
  if (responseWrapper) {
    const marker = `__MARKER_${Math.random().toString(36).slice(2, 10)}__`;
    const wrapped = JSON.stringify(responseWrapper(marker));
    const parts = wrapped.split(`"${marker}"`);
    if (parts.length !== 2) {
      throw new Error(
        `Entity items response was incorrectly wrapped into ${parts.length} different parts`
      );
    }
    res.write(parts[0], "utf8");
    trailing = parts[1];
  }
  let first = true;
  for (const entity of items.entities) {
    const prefix = first ? "[" : ",";
    first = false;
    if (await writeResponseData(res, prefix + entity)) {
      return;
    }
  }
  res.end(`${first ? "[" : ""}]${trailing}`);
}
async function writeResponseData(res, data) {
  const ok = res.write(data, "utf8");
  if (!ok) {
    if (res.closed) {
      return true;
    }
    const closed = await new Promise((resolve) => {
      function onContinue() {
        res.off("drain", onContinue);
        res.off("close", onClose);
        resolve(false);
      }
      function onClose() {
        res.off("drain", onContinue);
        res.off("close", onClose);
        resolve(true);
      }
      res.on("drain", onContinue);
      res.on("close", onClose);
    });
    return closed;
  }
  return false;
}

exports.writeEntitiesResponse = writeEntitiesResponse;
exports.writeResponseData = writeResponseData;
exports.writeSingleEntityResponse = writeSingleEntityResponse;
//# sourceMappingURL=write.cjs.js.map
