'use strict';

var backendCommon = require('@backstage/backend-common');
var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var yn = require('yn');
var zod = require('zod');
var util$1 = require('../processing/util.cjs.js');
var entitiesBatchRequest = require('./request/entitiesBatchRequest.cjs.js');
var basicEntityFilter = require('./request/basicEntityFilter.cjs.js');
var parseEntityFilterParams = require('./request/parseEntityFilterParams.cjs.js');
var parseEntityTransformParams = require('./request/parseEntityTransformParams.cjs.js');
var parseQueryEntitiesParams = require('./request/parseQueryEntitiesParams.cjs.js');
var parseEntityFacetParams = require('./request/parseEntityFacetParams.cjs.js');
var parseEntityOrderParams = require('./request/parseEntityOrderParams.cjs.js');
var util = require('./util.cjs.js');
var router = require('../schema/openapi/generated/router.cjs.js');
var parseEntityPaginationParams = require('./request/parseEntityPaginationParams.cjs.js');
var AuthorizedValidationService = require('./AuthorizedValidationService.cjs.js');
var write = require('./response/write.cjs.js');
var createEntityArrayJsonStream = require('./response/createEntityArrayJsonStream.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yn__default = /*#__PURE__*/_interopDefaultCompat(yn);

async function createRouter(options) {
  const router$1 = await router.createOpenApiRouter({
    validatorOptions: {
      // We want the spec to be up to date with the expected value, but the return type needs
      //  to be controlled by the router implementation not the request validator.
      ignorePaths: /^\/validate-entity\/?$/
    }
  });
  const {
    entitiesCatalog,
    locationAnalyzer,
    locationService,
    orchestrator,
    refreshService,
    config,
    logger,
    permissionIntegrationRouter,
    permissionsService,
    auth,
    httpAuth,
    disableRelationsCompatibility = false
  } = options;
  const readonlyEnabled = config.getOptionalBoolean("catalog.readonly") || false;
  if (readonlyEnabled) {
    logger.info("Catalog is running in readonly mode");
  }
  if (refreshService) {
    router$1.post("/refresh", async (req, res) => {
      const { authorizationToken, ...restBody } = req.body;
      const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
      await refreshService.refresh({
        ...restBody,
        credentials
      });
      res.status(200).end();
    });
  }
  if (permissionIntegrationRouter) {
    router$1.use(permissionIntegrationRouter);
  }
  if (entitiesCatalog) {
    router$1.get("/entities", async (req, res) => {
      const filter = parseEntityFilterParams.parseEntityFilterParams(req.query);
      const fields = parseEntityTransformParams.parseEntityTransformParams(req.query);
      const order = parseEntityOrderParams.parseEntityOrderParams(req.query);
      const pagination = parseEntityPaginationParams.parseEntityPaginationParams(req.query);
      const credentials = await httpAuth.credentials(req);
      if (pagination || disableRelationsCompatibility !== true) {
        const { entities, pageInfo } = await entitiesCatalog.entities({
          filter,
          fields,
          order,
          pagination,
          credentials
        });
        if (pageInfo.hasNextPage) {
          const url = new URL(`http://ignored${req.url}`);
          url.searchParams.delete("offset");
          url.searchParams.set("after", pageInfo.endCursor);
          res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
        }
        await write.writeEntitiesResponse({
          res,
          items: entities,
          alwaysUseObjectMode: !disableRelationsCompatibility
        });
        return;
      }
      const responseStream = createEntityArrayJsonStream.createEntityArrayJsonStream(res);
      const limit = 1e4;
      let cursor;
      try {
        do {
          const result = await entitiesCatalog.queryEntities(
            !cursor ? {
              credentials,
              fields,
              limit,
              filter,
              orderFields: order,
              skipTotalItems: true
            } : { credentials, fields, limit, cursor }
          );
          if (result.items.entities.length) {
            if (await responseStream.send(result.items)) {
              return;
            }
          }
          cursor = result.pageInfo?.nextCursor;
        } while (cursor);
        responseStream.complete();
      } finally {
        responseStream.close();
      }
    }).get("/entities/by-query", async (req, res) => {
      const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
        limit: req.query.limit,
        offset: req.query.offset,
        ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
        credentials: await httpAuth.credentials(req)
      });
      await write.writeEntitiesResponse({
        res,
        items,
        alwaysUseObjectMode: !disableRelationsCompatibility,
        responseWrapper: (entities) => ({
          items: entities,
          totalItems,
          pageInfo: {
            ...pageInfo.nextCursor && {
              nextCursor: util.encodeCursor(pageInfo.nextCursor)
            },
            ...pageInfo.prevCursor && {
              prevCursor: util.encodeCursor(pageInfo.prevCursor)
            }
          }
        })
      });
    }).get("/entities/by-uid/:uid", async (req, res) => {
      const { uid } = req.params;
      const { entities } = await entitiesCatalog.entities({
        filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
        credentials: await httpAuth.credentials(req)
      });
      write.writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);
    }).delete("/entities/by-uid/:uid", async (req, res) => {
      const { uid } = req.params;
      await entitiesCatalog.removeEntityByUid(uid, {
        credentials: await httpAuth.credentials(req)
      });
      res.status(204).end();
    }).get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
      const { kind, namespace, name } = req.params;
      const { items } = await entitiesCatalog.entitiesBatch({
        entityRefs: [catalogModel.stringifyEntityRef({ kind, namespace, name })],
        credentials: await httpAuth.credentials(req)
      });
      write.writeSingleEntityResponse(
        res,
        items,
        `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
      );
    }).get(
      "/entities/by-name/:kind/:namespace/:name/ancestry",
      async (req, res) => {
        const { kind, namespace, name } = req.params;
        const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
        const response = await entitiesCatalog.entityAncestry(entityRef, {
          credentials: await httpAuth.credentials(req)
        });
        res.status(200).json(response);
      }
    ).post("/entities/by-refs", async (req, res) => {
      const request = entitiesBatchRequest.entitiesBatchRequest(req);
      const { items } = await entitiesCatalog.entitiesBatch({
        entityRefs: request.entityRefs,
        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
        fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
        credentials: await httpAuth.credentials(req)
      });
      await write.writeEntitiesResponse({
        res,
        items,
        alwaysUseObjectMode: !disableRelationsCompatibility,
        responseWrapper: (entities) => ({
          items: entities
        })
      });
    }).get("/entity-facets", async (req, res) => {
      const response = await entitiesCatalog.facets({
        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
        facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
        credentials: await httpAuth.credentials(req)
      });
      res.status(200).json(response);
    });
  }
  if (locationService) {
    router$1.post("/locations", async (req, res) => {
      const location = await util.validateRequestBody(req, util.locationInput);
      const dryRun = yn__default.default(req.query.dryRun, { default: false });
      if (!dryRun) {
        util.disallowReadonlyMode(readonlyEnabled);
      }
      const output = await locationService.createLocation(location, dryRun, {
        credentials: await httpAuth.credentials(req)
      });
      res.status(201).json(output);
    }).get("/locations", async (req, res) => {
      const locations = await locationService.listLocations({
        credentials: await httpAuth.credentials(req)
      });
      res.status(200).json(locations.map((l) => ({ data: l })));
    }).get("/locations/:id", async (req, res) => {
      const { id } = req.params;
      const output = await locationService.getLocation(id, {
        credentials: await httpAuth.credentials(req)
      });
      res.status(200).json(output);
    }).delete("/locations/:id", async (req, res) => {
      util.disallowReadonlyMode(readonlyEnabled);
      const { id } = req.params;
      await locationService.deleteLocation(id, {
        credentials: await httpAuth.credentials(req)
      });
      res.status(204).end();
    }).get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
      const { kind, namespace, name } = req.params;
      const output = await locationService.getLocationByEntity(
        { kind, namespace, name },
        { credentials: await httpAuth.credentials(req) }
      );
      res.status(200).json(output);
    });
  }
  if (locationAnalyzer) {
    router$1.post("/analyze-location", async (req, res) => {
      const body = await util.validateRequestBody(
        req,
        zod.z.object({
          location: util.locationInput,
          catalogFilename: zod.z.string().optional()
        })
      );
      const schema = zod.z.object({
        location: util.locationInput,
        catalogFilename: zod.z.string().optional()
      });
      const credentials = await httpAuth.credentials(req);
      const parsedBody = schema.parse(body);
      try {
        const output = await locationAnalyzer.analyzeLocation(
          parsedBody,
          credentials
        );
        res.status(200).json(output);
      } catch (err) {
        if (
          // Catch errors from parse-url library.
          err.name === "Error" && "subject_url" in err
        ) {
          throw new errors.InputError("The given location.target is not a URL");
        }
        throw err;
      }
    });
  }
  if (orchestrator) {
    router$1.post("/validate-entity", async (req, res) => {
      const bodySchema = zod.z.object({
        entity: zod.z.unknown(),
        location: zod.z.string()
      });
      let body;
      let entity;
      let location;
      try {
        body = await util.validateRequestBody(req, bodySchema);
        entity = util$1.validateEntityEnvelope(body.entity);
        location = catalogModel.parseLocationRef(body.location);
        if (location.type !== "url")
          throw new TypeError(
            `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
          );
      } catch (err) {
        return res.status(400).json({
          errors: [errors.serializeError(err)]
        });
      }
      const credentials = await httpAuth.credentials(req);
      const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
        orchestrator,
        permissionsService
      );
      const processingResult = await authorizedValidationService.process(
        {
          entity: {
            ...entity,
            metadata: {
              ...entity.metadata,
              annotations: {
                [catalogModel.ANNOTATION_LOCATION]: body.location,
                [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
                ...entity.metadata.annotations
              }
            }
          }
        },
        credentials
      );
      if (!processingResult.ok)
        res.status(400).json({
          errors: processingResult.errors.map((e) => errors.serializeError(e))
        });
      return res.status(200).end();
    });
  }
  router$1.use(backendCommon.errorHandler());
  return router$1;
}

exports.createRouter = createRouter;
//# sourceMappingURL=createRouter.cjs.js.map
