'use strict';

var backendCommon = require('@backstage/backend-common');
var catalogModel = require('@backstage/catalog-model');
var integration = require('@backstage/integration');
var crypto = require('crypto');
var lodash = require('lodash');
var AnnotateLocationEntityProcessor = require('../processors/AnnotateLocationEntityProcessor.cjs.js');
require('git-url-parse');
var BuiltinKindsEntityProcessor = require('../processors/BuiltinKindsEntityProcessor.cjs.js');
var CodeOwnersProcessor = require('../processors/CodeOwnersProcessor.cjs.js');
var FileReaderProcessor = require('../processors/FileReaderProcessor.cjs.js');
require('path');
require('@backstage/plugin-catalog-node');
var PlaceholderProcessor = require('../processors/PlaceholderProcessor.cjs.js');
var UrlReaderProcessor = require('../processors/UrlReaderProcessor.cjs.js');
var ConfigLocationEntityProvider = require('../providers/ConfigLocationEntityProvider.cjs.js');
var DefaultLocationStore = require('../providers/DefaultLocationStore.cjs.js');
var LocationAnalyzer = require('../ingestion/LocationAnalyzer.cjs.js');
var AuthorizedLocationAnalyzer = require('./AuthorizedLocationAnalyzer.cjs.js');
var parse = require('../util/parse.cjs.js');
var refresh = require('../processing/refresh.cjs.js');
var DefaultProcessingDatabase = require('../database/DefaultProcessingDatabase.cjs.js');
var migrations = require('../database/migrations.cjs.js');
var DefaultCatalogProcessingEngine = require('../processing/DefaultCatalogProcessingEngine.cjs.js');
var DefaultLocationService = require('./DefaultLocationService.cjs.js');
var DefaultEntitiesCatalog = require('./DefaultEntitiesCatalog.cjs.js');
var DefaultCatalogProcessingOrchestrator = require('../processing/DefaultCatalogProcessingOrchestrator.cjs.js');
var DefaultStitcher = require('../stitching/DefaultStitcher.cjs.js');
var createRouter = require('./createRouter.cjs.js');
var DefaultRefreshService = require('./DefaultRefreshService.cjs.js');
var AuthorizedRefreshService = require('./AuthorizedRefreshService.cjs.js');
var CatalogRules = require('../ingestion/CatalogRules.cjs.js');
var config = require('@backstage/config');
var connectEntityProviders = require('../processing/connectEntityProviders.cjs.js');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var index = require('../permissions/rules/index.cjs.js');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var AuthorizedEntitiesCatalog = require('./AuthorizedEntitiesCatalog.cjs.js');
require('./request/entitiesBatchRequest.cjs.js');
var basicEntityFilter = require('./request/basicEntityFilter.cjs.js');
require('@backstage/errors');
require('./util.cjs.js');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var AuthorizedLocationService = require('./AuthorizedLocationService.cjs.js');
var DefaultProviderDatabase = require('../database/DefaultProviderDatabase.cjs.js');
var DefaultCatalogDatabase = require('../database/DefaultCatalogDatabase.cjs.js');
var types = require('@backstage/types');
var process$1 = require('./response/process.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);

class CatalogBuilder {
  env;
  entityPolicies;
  entityPoliciesReplace;
  placeholderResolvers;
  fieldFormatValidators;
  entityProviders;
  processors;
  locationAnalyzers;
  processorsReplace;
  parser;
  onProcessingError;
  processingInterval;
  locationAnalyzer = void 0;
  permissions;
  permissionRules;
  allowedLocationType;
  legacySingleProcessorValidation = false;
  eventBroker;
  /**
   * Creates a catalog builder.
   */
  static create(env) {
    return new CatalogBuilder(env);
  }
  constructor(env) {
    this.env = env;
    this.entityPolicies = [];
    this.entityPoliciesReplace = false;
    this.placeholderResolvers = {};
    this.fieldFormatValidators = {};
    this.entityProviders = [];
    this.processors = [];
    this.locationAnalyzers = [];
    this.processorsReplace = false;
    this.parser = void 0;
    this.permissions = [...alpha.catalogPermissions];
    this.permissionRules = Object.values(index.permissionRules);
    this.allowedLocationType = ["url"];
    this.processingInterval = CatalogBuilder.getDefaultProcessingInterval(
      env.config
    );
  }
  /**
   * Adds policies that are used to validate entities between the pre-
   * processing and post-processing stages. All such policies must pass for the
   * entity to be considered valid.
   *
   * If what you want to do is to replace the rules for what format is allowed
   * in various core entity fields (such as metadata.name), you may want to use
   * {@link CatalogBuilder#setFieldFormatValidators} instead.
   *
   * @param policies - One or more policies
   */
  addEntityPolicy(...policies) {
    this.entityPolicies.push(...policies.flat());
    return this;
  }
  /**
   * Processing interval determines how often entities should be processed.
   * Seconds provided will be multiplied by 1.5
   * The default processing interval is 100-150 seconds.
   * setting this too low will potentially deplete request quotas to upstream services.
   */
  setProcessingIntervalSeconds(seconds) {
    this.processingInterval = refresh.createRandomProcessingInterval({
      minSeconds: seconds,
      maxSeconds: seconds * 1.5
    });
    return this;
  }
  /**
   * Overwrites the default processing interval function used to spread
   * entity updates in the catalog.
   */
  setProcessingInterval(processingInterval) {
    this.processingInterval = processingInterval;
    return this;
  }
  /**
   * Overwrites the default location analyzer.
   */
  setLocationAnalyzer(locationAnalyzer) {
    this.locationAnalyzer = locationAnalyzer;
    return this;
  }
  /**
   * Sets what policies to use for validation of entities between the pre-
   * processing and post-processing stages. All such policies must pass for the
   * entity to be considered valid.
   *
   * If what you want to do is to replace the rules for what format is allowed
   * in various core entity fields (such as metadata.name), you may want to use
   * {@link CatalogBuilder#setFieldFormatValidators} instead.
   *
   * This function replaces the default set of policies; use with care.
   *
   * @param policies - One or more policies
   */
  replaceEntityPolicies(policies) {
    this.entityPolicies = [...policies];
    this.entityPoliciesReplace = true;
    return this;
  }
  /**
   * Adds, or overwrites, a handler for placeholders (e.g. $file) in entity
   * definition files.
   *
   * @param key - The key that identifies the placeholder, e.g. "file"
   * @param resolver - The resolver that gets values for this placeholder
   */
  setPlaceholderResolver(key, resolver) {
    this.placeholderResolvers[key] = resolver;
    return this;
  }
  /**
   * Sets the validator function to use for one or more special fields of an
   * entity. This is useful if the default rules for formatting of fields are
   * not sufficient.
   *
   * This function has no effect if used together with
   * {@link CatalogBuilder#replaceEntityPolicies}.
   *
   * @param validators - The (subset of) validators to set
   */
  setFieldFormatValidators(validators) {
    lodash__default.default.merge(this.fieldFormatValidators, validators);
    return this;
  }
  /**
   * Adds or replaces entity providers. These are responsible for bootstrapping
   * the list of entities out of original data sources. For example, there is
   * one entity source for the config locations, and one for the database
   * stored locations. If you ingest entities out of a third party system, you
   * may want to implement that in terms of an entity provider as well.
   *
   * @param providers - One or more entity providers
   */
  addEntityProvider(...providers) {
    this.entityProviders.push(...providers.flat());
    return this;
  }
  /**
   * Adds entity processors. These are responsible for reading, parsing, and
   * processing entities before they are persisted in the catalog.
   *
   * @param processors - One or more processors
   */
  addProcessor(...processors) {
    this.processors.push(...processors.flat());
    return this;
  }
  /**
   * Sets what entity processors to use. These are responsible for reading,
   * parsing, and processing entities before they are persisted in the catalog.
   *
   * This function replaces the default set of processors, consider using with
   * {@link CatalogBuilder#getDefaultProcessors}; use with care.
   *
   * @param processors - One or more processors
   */
  replaceProcessors(processors) {
    this.processors = [...processors];
    this.processorsReplace = true;
    return this;
  }
  /**
   * Returns the default list of entity processors. These are responsible for reading,
   * parsing, and processing entities before they are persisted in the catalog. Changing
   * the order of processing can give more control to custom processors.
   *
   * Consider using with {@link CatalogBuilder#replaceProcessors}
   *
   */
  getDefaultProcessors() {
    const { config, logger, reader } = this.env;
    const integrations = integration.ScmIntegrations.fromConfig(config);
    return [
      new FileReaderProcessor.FileReaderProcessor(),
      new UrlReaderProcessor.UrlReaderProcessor({ reader, logger }),
      CodeOwnersProcessor.CodeOwnersProcessor.fromConfig(config, { logger, reader }),
      new AnnotateLocationEntityProcessor.AnnotateLocationEntityProcessor({ integrations })
    ];
  }
  /**
   * Adds Location Analyzers. These are responsible for analyzing
   * repositories when onboarding them into the catalog, by finding
   * catalog-info.yaml files and other artifacts that can help automatically
   * register or create catalog data on the user's behalf.
   *
   * @param locationAnalyzers - One or more location analyzers
   */
  addLocationAnalyzers(...analyzers) {
    this.locationAnalyzers.push(...analyzers.flat());
    return this;
  }
  /**
   * Sets up the catalog to use a custom parser for entity data.
   *
   * This is the function that gets called immediately after some raw entity
   * specification data has been read from a remote source, and needs to be
   * parsed and emitted as structured data.
   *
   * @param parser - The custom parser
   */
  setEntityDataParser(parser) {
    this.parser = parser;
    return this;
  }
  /**
   * Adds additional permissions. See
   * {@link @backstage/plugin-permission-node#Permission}.
   *
   * @param permissions - Additional permissions
   */
  addPermissions(...permissions) {
    this.permissions.push(...permissions.flat());
    return this;
  }
  /**
   * Adds additional permission rules. Permission rules are used to evaluate
   * catalog resources against queries. See
   * {@link @backstage/plugin-permission-node#PermissionRule}.
   *
   * @param permissionRules - Additional permission rules
   */
  addPermissionRules(...permissionRules) {
    this.permissionRules.push(...permissionRules.flat());
    return this;
  }
  /**
   * Sets up the allowed location types from being registered via the location service.
   *
   * @param allowedLocationTypes - the allowed location types
   */
  setAllowedLocationTypes(allowedLocationTypes) {
    this.allowedLocationType = allowedLocationTypes;
    return this;
  }
  /**
   * Enables the legacy behaviour of canceling validation early whenever only a
   * single processor declares an entity kind to be valid.
   */
  useLegacySingleProcessorValidation() {
    this.legacySingleProcessorValidation = true;
    return this;
  }
  /**
   * Enables the publishing of events for conflicts in the DefaultProcessingDatabase
   */
  setEventBroker(broker) {
    this.eventBroker = broker;
    return this;
  }
  /**
   * Wires up and returns all of the component parts of the catalog
   */
  async build() {
    const {
      config,
      database,
      logger,
      permissions,
      scheduler,
      discovery = backendCommon.HostDiscovery.fromConfig(config)
    } = this.env;
    const { auth, httpAuth } = backendCommon.createLegacyAuthAdapters({
      ...this.env,
      discovery
    });
    const disableRelationsCompatibility = config.getOptionalBoolean(
      "catalog.disableRelationsCompatibility"
    );
    const policy = this.buildEntityPolicy();
    const processors = this.buildProcessors();
    const parser = this.parser || parse.defaultEntityDataParser;
    const dbClient = await database.getClient();
    if (!database.migrations?.skip) {
      logger.info("Performing database migration");
      await migrations.applyDatabaseMigrations(dbClient);
    }
    const stitcher = DefaultStitcher.DefaultStitcher.fromConfig(config, {
      knex: dbClient,
      logger
    });
    const processingDatabase = new DefaultProcessingDatabase.DefaultProcessingDatabase({
      database: dbClient,
      logger,
      refreshInterval: this.processingInterval,
      eventBroker: this.eventBroker
    });
    const providerDatabase = new DefaultProviderDatabase.DefaultProviderDatabase({
      database: dbClient,
      logger
    });
    const catalogDatabase = new DefaultCatalogDatabase.DefaultCatalogDatabase({
      database: dbClient,
      logger
    });
    const integrations = integration.ScmIntegrations.fromConfig(config);
    const rulesEnforcer = CatalogRules.DefaultCatalogRulesEnforcer.fromConfig(config);
    const unauthorizedEntitiesCatalog = new DefaultEntitiesCatalog.DefaultEntitiesCatalog({
      database: dbClient,
      logger,
      stitcher,
      disableRelationsCompatibility
    });
    let permissionsService;
    if ("authorizeConditional" in permissions) {
      permissionsService = permissions;
    } else {
      logger.warn(
        "PermissionAuthorizer is deprecated. Please use an instance of PermissionEvaluator instead of PermissionAuthorizer in PluginEnvironment#permissions"
      );
      permissionsService = pluginPermissionCommon.toPermissionEvaluator(permissions);
    }
    const orchestrator = new DefaultCatalogProcessingOrchestrator.DefaultCatalogProcessingOrchestrator({
      processors,
      integrations,
      rulesEnforcer,
      logger,
      parser,
      policy,
      legacySingleProcessorValidation: this.legacySingleProcessorValidation
    });
    const entitiesCatalog = new AuthorizedEntitiesCatalog.AuthorizedEntitiesCatalog(
      unauthorizedEntitiesCatalog,
      permissionsService,
      pluginPermissionNode.createConditionTransformer(this.permissionRules)
    );
    const permissionIntegrationRouter = pluginPermissionNode.createPermissionIntegrationRouter({
      resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
      getResources: async (resourceRefs) => {
        const { entities } = await unauthorizedEntitiesCatalog.entities({
          credentials: await auth.getOwnServiceCredentials(),
          filter: {
            anyOf: resourceRefs.map((resourceRef) => {
              const { kind, namespace, name } = catalogModel.parseEntityRef(resourceRef);
              return basicEntityFilter.basicEntityFilter({
                kind,
                "metadata.namespace": namespace,
                "metadata.name": name
              });
            })
          }
        });
        const entitiesByRef = lodash.keyBy(
          process$1.entitiesResponseToObjects(entities),
          catalogModel.stringifyEntityRef
        );
        return resourceRefs.map(
          (resourceRef) => entitiesByRef[catalogModel.stringifyEntityRef(catalogModel.parseEntityRef(resourceRef))]
        );
      },
      permissions: this.permissions,
      rules: this.permissionRules
    });
    const locationStore = new DefaultLocationStore.DefaultLocationStore(dbClient);
    const configLocationProvider = new ConfigLocationEntityProvider.ConfigLocationEntityProvider(config);
    const entityProviders = lodash__default.default.uniqBy(
      [...this.entityProviders, locationStore, configLocationProvider],
      (provider) => provider.getProviderName()
    );
    const processingEngine = new DefaultCatalogProcessingEngine.DefaultCatalogProcessingEngine({
      config,
      scheduler,
      logger,
      knex: dbClient,
      processingDatabase,
      orchestrator,
      stitcher,
      createHash: () => crypto.createHash("sha1"),
      pollingIntervalMs: 1e3,
      onProcessingError: (event) => {
        this.onProcessingError?.(event);
      },
      eventBroker: this.eventBroker
    });
    const locationAnalyzer = this.locationAnalyzer ?? new AuthorizedLocationAnalyzer.AuthorizedLocationAnalyzer(
      new LocationAnalyzer.RepoLocationAnalyzer(logger, integrations, this.locationAnalyzers),
      permissionsService
    );
    const locationService = new AuthorizedLocationService.AuthorizedLocationService(
      new DefaultLocationService.DefaultLocationService(locationStore, orchestrator, {
        allowedLocationTypes: this.allowedLocationType
      }),
      permissionsService
    );
    const refreshService = new AuthorizedRefreshService.AuthorizedRefreshService(
      new DefaultRefreshService.DefaultRefreshService({ database: catalogDatabase }),
      permissionsService
    );
    const router = await createRouter.createRouter({
      entitiesCatalog,
      locationAnalyzer,
      locationService,
      orchestrator,
      refreshService,
      logger,
      config,
      permissionIntegrationRouter,
      auth,
      httpAuth,
      permissionsService,
      disableRelationsCompatibility
    });
    await connectEntityProviders.connectEntityProviders(providerDatabase, entityProviders);
    return {
      processingEngine: {
        async start() {
          await processingEngine.start();
          await stitcher.start();
        },
        async stop() {
          await processingEngine.stop();
          await stitcher.stop();
        }
      },
      router
    };
  }
  subscribe(options) {
    this.onProcessingError = options.onProcessingError;
  }
  buildEntityPolicy() {
    const entityPolicies = this.entityPoliciesReplace ? [new catalogModel.SchemaValidEntityPolicy(), ...this.entityPolicies] : [
      new catalogModel.SchemaValidEntityPolicy(),
      new catalogModel.DefaultNamespaceEntityPolicy(),
      new catalogModel.NoForeignRootFieldsEntityPolicy(),
      new catalogModel.FieldFormatEntityPolicy(
        catalogModel.makeValidator(this.fieldFormatValidators)
      ),
      ...this.entityPolicies
    ];
    return catalogModel.EntityPolicies.allOf(entityPolicies);
  }
  buildProcessors() {
    const { config, reader } = this.env;
    const integrations = integration.ScmIntegrations.fromConfig(config);
    this.checkDeprecatedReaderProcessors();
    const placeholderResolvers = {
      json: PlaceholderProcessor.jsonPlaceholderResolver,
      yaml: PlaceholderProcessor.yamlPlaceholderResolver,
      text: PlaceholderProcessor.textPlaceholderResolver,
      ...this.placeholderResolvers
    };
    const processors = [
      new PlaceholderProcessor.PlaceholderProcessor({
        resolvers: placeholderResolvers,
        reader,
        integrations
      })
    ];
    const builtinKindsEntityProcessor = new BuiltinKindsEntityProcessor.BuiltinKindsEntityProcessor();
    if (!this.processors.some(
      (processor) => processor.getProcessorName() === builtinKindsEntityProcessor.getProcessorName()
    )) {
      processors.push(builtinKindsEntityProcessor);
    }
    if (!this.processorsReplace) {
      processors.push(...this.getDefaultProcessors());
    }
    processors.push(...this.processors);
    this.checkMissingExternalProcessors(processors);
    return processors;
  }
  // TODO(Rugvip): These old processors are removed, for a while we'll be throwing
  //               errors here to make sure people know where to move the config
  checkDeprecatedReaderProcessors() {
    const pc = this.env.config.getOptionalConfig("catalog.processors");
    if (pc?.has("github")) {
      throw new Error(
        `Using deprecated configuration for catalog.processors.github, move to using integrations.github instead`
      );
    }
    if (pc?.has("gitlabApi")) {
      throw new Error(
        `Using deprecated configuration for catalog.processors.gitlabApi, move to using integrations.gitlab instead`
      );
    }
    if (pc?.has("bitbucketApi")) {
      throw new Error(
        `Using deprecated configuration for catalog.processors.bitbucketApi, move to using integrations.bitbucket instead`
      );
    }
    if (pc?.has("azureApi")) {
      throw new Error(
        `Using deprecated configuration for catalog.processors.azureApi, move to using integrations.azure instead`
      );
    }
  }
  // TODO(freben): This can be removed no sooner than June 2022, after adopters have had some time to adapt to the new package structure
  checkMissingExternalProcessors(processors) {
    const skipCheckVarName = "BACKSTAGE_CATALOG_SKIP_MISSING_PROCESSORS_CHECK";
    if (process.env[skipCheckVarName]) {
      return;
    }
    const locationTypes = new Set(
      this.env.config.getOptionalConfigArray("catalog.locations")?.map((l) => l.getString("type")) ?? []
    );
    const processorNames = new Set(processors.map((p) => p.getProcessorName()));
    function check(locationType, processorName, installationUrl) {
      if (locationTypes.has(locationType) && !processorNames.has(processorName)) {
        throw new Error(
          [
            `Your config contains a "catalog.locations" entry of type ${locationType},`,
            `but does not have the corresponding catalog processor ${processorName} installed.`,
            `This processor used to be built into the catalog itself, but is now moved to an`,
            `external module that has to be installed manually. Please follow the installation`,
            `instructions at ${installationUrl} if you are using this ability, or remove the`,
            `location from your app config if you do not. You can also silence this check entirely`,
            `by setting the environment variable ${skipCheckVarName} to 'true'.`
          ].join(" ")
        );
      }
    }
    check(
      "aws-cloud-accounts",
      "AwsOrganizationCloudAccountProcessor",
      "https://backstage.io/docs/integrations"
    );
    check(
      "s3-discovery",
      "AwsS3DiscoveryProcessor",
      "https://backstage.io/docs/integrations/aws-s3/discovery"
    );
    check(
      "azure-discovery",
      "AzureDevOpsDiscoveryProcessor",
      "https://backstage.io/docs/integrations/azure/discovery"
    );
    check(
      "bitbucket-discovery",
      "BitbucketDiscoveryProcessor",
      "https://backstage.io/docs/integrations/bitbucket/discovery"
    );
    check(
      "github-discovery",
      "GithubDiscoveryProcessor",
      "https://backstage.io/docs/integrations/github/discovery"
    );
    check(
      "github-org",
      "GithubOrgReaderProcessor",
      "https://backstage.io/docs/integrations/github/org"
    );
    check(
      "gitlab-discovery",
      "GitLabDiscoveryProcessor",
      "https://backstage.io/docs/integrations/gitlab/discovery"
    );
    check(
      "ldap-org",
      "LdapOrgReaderProcessor",
      "https://backstage.io/docs/integrations/ldap/org"
    );
    check(
      "microsoft-graph-org",
      "MicrosoftGraphOrgReaderProcessor",
      "https://backstage.io/docs/integrations/azure/org"
    );
  }
  static getDefaultProcessingInterval(config$1) {
    const processingIntervalKey = "catalog.processingInterval";
    if (!config$1.has(processingIntervalKey)) {
      return refresh.createRandomProcessingInterval({
        minSeconds: 100,
        maxSeconds: 150
      });
    }
    if (!Boolean(config$1.get("catalog.processingInterval"))) {
      return () => {
        throw new Error(
          "catalog.processingInterval is set to false, processing is disabled."
        );
      };
    }
    const duration = config.readDurationFromConfig(config$1, {
      key: processingIntervalKey
    });
    const seconds = Math.max(
      1,
      Math.round(types.durationToMilliseconds(duration) / 1e3)
    );
    return refresh.createRandomProcessingInterval({
      minSeconds: seconds,
      maxSeconds: seconds * 1.5
    });
  }
}

exports.CatalogBuilder = CatalogBuilder;
//# sourceMappingURL=CatalogBuilder.cjs.js.map
