'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginEventsNode = require('@backstage/plugin-events-node');
var CatalogBuilder = require('./CatalogBuilder.cjs.js');
var alpha = require('@backstage/plugin-catalog-node/alpha');
var lodash = require('lodash');
var errors = require('@backstage/errors');

class CatalogLocationsExtensionPointImpl {
  #locationTypes;
  setAllowedLocationTypes(locationTypes) {
    this.#locationTypes = locationTypes;
  }
  get allowedLocationTypes() {
    return this.#locationTypes;
  }
}
class CatalogProcessingExtensionPointImpl {
  #processors = new Array();
  #entityProviders = new Array();
  #placeholderResolvers = {};
  #onProcessingErrorHandler;
  addProcessor(...processors) {
    this.#processors.push(...processors.flat());
  }
  addEntityProvider(...providers) {
    this.#entityProviders.push(...providers.flat());
  }
  addPlaceholderResolver(key, resolver) {
    if (key in this.#placeholderResolvers)
      throw new Error(
        `A placeholder resolver for '${key}' has already been set up, please check your config.`
      );
    this.#placeholderResolvers[key] = resolver;
  }
  setOnProcessingErrorHandler(handler) {
    this.#onProcessingErrorHandler = handler;
  }
  get processors() {
    return this.#processors;
  }
  get entityProviders() {
    return this.#entityProviders;
  }
  get placeholderResolvers() {
    return this.#placeholderResolvers;
  }
  get onProcessingErrorHandler() {
    return this.#onProcessingErrorHandler;
  }
}
class CatalogPermissionExtensionPointImpl {
  #permissions = new Array();
  #permissionRules = new Array();
  addPermissions(...permission) {
    this.#permissions.push(...permission.flat());
  }
  addPermissionRules(...rules) {
    this.#permissionRules.push(...rules.flat());
  }
  get permissions() {
    return this.#permissions;
  }
  get permissionRules() {
    return this.#permissionRules;
  }
}
class CatalogModelExtensionPointImpl {
  #fieldValidators = {};
  setFieldValidators(validators) {
    lodash.merge(this.#fieldValidators, validators);
  }
  get fieldValidators() {
    return this.#fieldValidators;
  }
  #entityDataParser;
  setEntityDataParser(parser) {
    if (this.#entityDataParser) {
      throw new Error(
        "Attempted to install second EntityDataParser. Only one can be set."
      );
    }
    this.#entityDataParser = parser;
  }
  get entityDataParser() {
    return this.#entityDataParser;
  }
}
const catalogPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "catalog",
  register(env) {
    const processingExtensions = new CatalogProcessingExtensionPointImpl();
    env.registerExtensionPoint(
      alpha.catalogProcessingExtensionPoint,
      processingExtensions
    );
    let locationAnalyzerFactory = void 0;
    const scmLocationAnalyzers = new Array();
    env.registerExtensionPoint(alpha.catalogAnalysisExtensionPoint, {
      setLocationAnalyzer(analyzerOrFactory) {
        if (locationAnalyzerFactory) {
          throw new Error("LocationAnalyzer has already been set");
        }
        if (typeof analyzerOrFactory === "function") {
          locationAnalyzerFactory = analyzerOrFactory;
        } else {
          locationAnalyzerFactory = async () => ({
            locationAnalyzer: analyzerOrFactory
          });
        }
      },
      addScmLocationAnalyzer(analyzer) {
        scmLocationAnalyzers.push(analyzer);
      }
    });
    const permissionExtensions = new CatalogPermissionExtensionPointImpl();
    env.registerExtensionPoint(
      alpha.catalogPermissionExtensionPoint,
      permissionExtensions
    );
    const modelExtensions = new CatalogModelExtensionPointImpl();
    env.registerExtensionPoint(alpha.catalogModelExtensionPoint, modelExtensions);
    const locationTypeExtensions = new CatalogLocationsExtensionPointImpl();
    env.registerExtensionPoint(
      alpha.catalogLocationsExtensionPoint,
      locationTypeExtensions
    );
    env.registerInit({
      deps: {
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        reader: backendPluginApi.coreServices.urlReader,
        permissions: backendPluginApi.coreServices.permissions,
        database: backendPluginApi.coreServices.database,
        httpRouter: backendPluginApi.coreServices.httpRouter,
        lifecycle: backendPluginApi.coreServices.rootLifecycle,
        scheduler: backendPluginApi.coreServices.scheduler,
        discovery: backendPluginApi.coreServices.discovery,
        auth: backendPluginApi.coreServices.auth,
        httpAuth: backendPluginApi.coreServices.httpAuth,
        events: pluginEventsNode.eventsServiceRef
      },
      async init({
        logger,
        config,
        reader,
        database,
        permissions,
        httpRouter,
        lifecycle,
        scheduler,
        discovery,
        auth,
        httpAuth,
        events
      }) {
        const builder = await CatalogBuilder.CatalogBuilder.create({
          config,
          reader,
          permissions,
          database,
          scheduler,
          logger,
          discovery,
          auth,
          httpAuth
        });
        builder.setEventBroker(events);
        if (processingExtensions.onProcessingErrorHandler) {
          builder.subscribe({
            onProcessingError: processingExtensions.onProcessingErrorHandler
          });
        }
        builder.addProcessor(...processingExtensions.processors);
        builder.addEntityProvider(...processingExtensions.entityProviders);
        if (modelExtensions.entityDataParser) {
          builder.setEntityDataParser(modelExtensions.entityDataParser);
        }
        Object.entries(processingExtensions.placeholderResolvers).forEach(
          ([key, resolver]) => builder.setPlaceholderResolver(key, resolver)
        );
        if (locationAnalyzerFactory) {
          const { locationAnalyzer } = await locationAnalyzerFactory({
            scmLocationAnalyzers
          }).catch((e) => {
            throw new errors.ForwardedError("Failed to create LocationAnalyzer", e);
          });
          builder.setLocationAnalyzer(locationAnalyzer);
        } else {
          builder.addLocationAnalyzers(...scmLocationAnalyzers);
        }
        builder.addPermissions(...permissionExtensions.permissions);
        builder.addPermissionRules(...permissionExtensions.permissionRules);
        builder.setFieldFormatValidators(modelExtensions.fieldValidators);
        if (locationTypeExtensions.allowedLocationTypes) {
          builder.setAllowedLocationTypes(
            locationTypeExtensions.allowedLocationTypes
          );
        }
        const { processingEngine, router } = await builder.build();
        if (config.getOptional("catalog.processingInterval") ?? true) {
          lifecycle.addStartupHook(async () => {
            await processingEngine.start();
          });
          lifecycle.addShutdownHook(() => processingEngine.stop());
        }
        httpRouter.use(router);
      }
    });
  }
});

exports.catalogPlugin = catalogPlugin;
//# sourceMappingURL=CatalogPlugin.cjs.js.map
