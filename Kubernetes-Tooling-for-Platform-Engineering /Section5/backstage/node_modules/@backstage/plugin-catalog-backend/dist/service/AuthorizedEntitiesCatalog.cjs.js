'use strict';

var errors = require('@backstage/errors');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var catalogModel = require('@backstage/catalog-model');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
require('./request/entitiesBatchRequest.cjs.js');
var basicEntityFilter = require('./request/basicEntityFilter.cjs.js');
require('lodash');
var util = require('./util.cjs.js');

class AuthorizedEntitiesCatalog {
  constructor(entitiesCatalog, permissionApi, transformConditions) {
    this.entitiesCatalog = entitiesCatalog;
    this.permissionApi = permissionApi;
    this.transformConditions = transformConditions;
  }
  async entities(request) {
    const authorizeDecision = (await this.permissionApi.authorizeConditional(
      [{ permission: alpha.catalogEntityReadPermission }],
      { credentials: request.credentials }
    ))[0];
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      return {
        entities: { type: "object", entities: [] },
        pageInfo: { hasNextPage: false }
      };
    }
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
      const permissionFilter = this.transformConditions(
        authorizeDecision.conditions
      );
      return this.entitiesCatalog.entities({
        ...request,
        filter: request?.filter ? { allOf: [permissionFilter, request.filter] } : permissionFilter
      });
    }
    return this.entitiesCatalog.entities(request);
  }
  async entitiesBatch(request) {
    const authorizeDecision = (await this.permissionApi.authorizeConditional(
      [{ permission: alpha.catalogEntityReadPermission }],
      { credentials: request.credentials }
    ))[0];
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      return {
        items: {
          type: "object",
          entities: new Array(request.entityRefs.length).fill(null)
        }
      };
    }
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
      const permissionFilter = this.transformConditions(
        authorizeDecision.conditions
      );
      return this.entitiesCatalog.entitiesBatch({
        ...request,
        filter: request?.filter ? { allOf: [permissionFilter, request.filter] } : permissionFilter
      });
    }
    return this.entitiesCatalog.entitiesBatch(request);
  }
  async queryEntities(request) {
    const authorizeDecision = (await this.permissionApi.authorizeConditional(
      [{ permission: alpha.catalogEntityReadPermission }],
      { credentials: request.credentials }
    ))[0];
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      return {
        items: { type: "object", entities: [] },
        pageInfo: {},
        totalItems: 0
      };
    }
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
      const permissionFilter = this.transformConditions(
        authorizeDecision.conditions
      );
      let permissionedRequest;
      let requestFilter;
      if (util.isQueryEntitiesCursorRequest(request)) {
        requestFilter = request.cursor.filter;
        permissionedRequest = {
          ...request,
          cursor: {
            ...request.cursor,
            filter: request.cursor.filter ? { allOf: [permissionFilter, request.cursor.filter] } : permissionFilter
          }
        };
      } else {
        permissionedRequest = {
          ...request,
          filter: request.filter ? { allOf: [permissionFilter, request.filter] } : permissionFilter
        };
        requestFilter = request.filter;
      }
      const response = await this.entitiesCatalog.queryEntities(
        permissionedRequest
      );
      const prevCursor = response.pageInfo.prevCursor && {
        ...response.pageInfo.prevCursor,
        filter: requestFilter
      };
      const nextCursor = response.pageInfo.nextCursor && {
        ...response.pageInfo.nextCursor,
        filter: requestFilter
      };
      return {
        ...response,
        pageInfo: {
          prevCursor,
          nextCursor
        }
      };
    }
    return this.entitiesCatalog.queryEntities(request);
  }
  async removeEntityByUid(uid, options) {
    const authorizeResponse = (await this.permissionApi.authorizeConditional(
      [{ permission: alpha.catalogEntityDeletePermission }],
      { credentials: options.credentials }
    ))[0];
    if (authorizeResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      throw new errors.NotAllowedError();
    }
    if (authorizeResponse.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
      const permissionFilter = this.transformConditions(
        authorizeResponse.conditions
      );
      const { entities } = await this.entitiesCatalog.entities({
        credentials: options.credentials,
        filter: {
          allOf: [permissionFilter, basicEntityFilter.basicEntityFilter({ "metadata.uid": uid })]
        }
      });
      if (entities.entities.length === 0) {
        throw new errors.NotAllowedError();
      }
    }
    return this.entitiesCatalog.removeEntityByUid(uid, {
      credentials: options.credentials
    });
  }
  async entityAncestry(entityRef, options) {
    const rootEntityAuthorizeResponse = (await this.permissionApi.authorize(
      [{ permission: alpha.catalogEntityReadPermission, resourceRef: entityRef }],
      { credentials: options.credentials }
    ))[0];
    if (rootEntityAuthorizeResponse.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      throw new errors.NotAllowedError();
    }
    const ancestryResult = await this.entitiesCatalog.entityAncestry(
      entityRef,
      { credentials: options.credentials }
    );
    const authorizeResponse = await this.permissionApi.authorize(
      ancestryResult.items.map((item) => ({
        permission: alpha.catalogEntityReadPermission,
        resourceRef: catalogModel.stringifyEntityRef(item.entity)
      })),
      { credentials: options.credentials }
    );
    const unauthorizedAncestryItems = ancestryResult.items.filter(
      (_, index) => authorizeResponse[index].result === pluginPermissionCommon.AuthorizeResult.DENY
    );
    if (unauthorizedAncestryItems.length === 0) {
      return ancestryResult;
    }
    const rootUnauthorizedEntityRefs = unauthorizedAncestryItems.map(
      (ancestryItem) => catalogModel.stringifyEntityRef(ancestryItem.entity)
    );
    const allUnauthorizedEntityRefs = new Set(
      rootUnauthorizedEntityRefs.flatMap(
        (rootEntityRef) => this.findParents(
          rootEntityRef,
          ancestryResult.items,
          new Set(rootUnauthorizedEntityRefs)
        )
      )
    );
    return {
      rootEntityRef: ancestryResult.rootEntityRef,
      items: ancestryResult.items.filter(
        (ancestryItem) => !allUnauthorizedEntityRefs.has(
          catalogModel.stringifyEntityRef(ancestryItem.entity)
        )
      )
    };
  }
  async facets(request) {
    const authorizeDecision = (await this.permissionApi.authorizeConditional(
      [{ permission: alpha.catalogEntityReadPermission }],
      { credentials: request.credentials }
    ))[0];
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      return {
        facets: Object.fromEntries(request.facets.map((f) => [f, []]))
      };
    }
    if (authorizeDecision.result === pluginPermissionCommon.AuthorizeResult.CONDITIONAL) {
      const permissionFilter = this.transformConditions(
        authorizeDecision.conditions
      );
      return this.entitiesCatalog.facets({
        ...request,
        filter: request?.filter ? { allOf: [permissionFilter, request.filter] } : permissionFilter
      });
    }
    return this.entitiesCatalog.facets(request);
  }
  findParents(entityRef, allAncestryItems, seenEntityRefs) {
    const entity = allAncestryItems.find(
      (ancestryItem) => catalogModel.stringifyEntityRef(ancestryItem.entity) === entityRef
    );
    if (!entity) return [];
    const newSeenEntityRefs = new Set(seenEntityRefs);
    entity.parentEntityRefs.forEach(
      (parentRef) => newSeenEntityRefs.add(parentRef)
    );
    return [
      entityRef,
      ...entity.parentEntityRefs.flatMap(
        (parentRef) => seenEntityRefs.has(parentRef) ? [] : this.findParents(parentRef, allAncestryItems, newSeenEntityRefs)
      )
    ];
  }
}

exports.AuthorizedEntitiesCatalog = AuthorizedEntitiesCatalog;
//# sourceMappingURL=AuthorizedEntitiesCatalog.cjs.js.map
