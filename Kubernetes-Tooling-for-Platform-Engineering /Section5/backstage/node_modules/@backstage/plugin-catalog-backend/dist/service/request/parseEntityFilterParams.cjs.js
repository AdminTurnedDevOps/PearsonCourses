'use strict';

var errors = require('@backstage/errors');
var common = require('./common.cjs.js');

function parseEntityFilterParams(params) {
  const filterStrings = common.parseStringsParam(params.filter, "filter");
  if (!filterStrings) {
    return void 0;
  }
  const filters = filterStrings.map(parseEntityFilterString).filter((r) => Boolean(r));
  if (!filters.length) {
    return void 0;
  }
  const outer = filters.map(
    (inner) => inner.length === 1 ? inner[0] : { allOf: inner }
  );
  return outer.length === 1 ? outer[0] : { anyOf: outer };
}
function parseEntityFilterString(filterString) {
  const statements = filterString.split(",").map((s) => s.trim()).filter(Boolean);
  if (!statements.length) {
    return void 0;
  }
  const filtersByKey = /* @__PURE__ */ new Map();
  for (const statement of statements) {
    const equalsIndex = statement.indexOf("=");
    const key = equalsIndex === -1 ? statement : statement.substring(0, equalsIndex).trim();
    const value = equalsIndex === -1 ? void 0 : statement.substring(equalsIndex + 1).trim();
    if (!key) {
      throw new errors.InputError(
        `Invalid filter, '${statement}' is not a valid statement (expected a string on the form a=b or a= or a)`
      );
    }
    let f = filtersByKey.get(key);
    if (!f) {
      f = { key };
      filtersByKey.set(key, f);
    }
    if (value !== void 0) {
      f.values = f.values || [];
      f.values.push(value);
    }
  }
  return Array.from(filtersByKey.values());
}

exports.parseEntityFilterParams = parseEntityFilterParams;
exports.parseEntityFilterString = parseEntityFilterString;
//# sourceMappingURL=parseEntityFilterParams.cjs.js.map
