'use strict';

var errors = require('@backstage/errors');
var lodash = require('lodash');
var common = require('./common.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);

function getPathArrayAndValue(input, field) {
  return field.split(".").reduce(
    ([pathArray, inputSubset], pathPart, index, fieldParts) => {
      if (lodash__default.default.hasIn(inputSubset, pathPart)) {
        return [pathArray.concat(pathPart), inputSubset[pathPart]];
      } else if (fieldParts[index + 1] !== void 0) {
        fieldParts[index + 1] = `${pathPart}.${fieldParts[index + 1]}`;
        return [pathArray, inputSubset];
      }
      return [pathArray, void 0];
    },
    [[], input]
  );
}
function parseEntityTransformParams(params, extra) {
  const queryFields = common.parseStringsParam(params.fields, "fields");
  const fields = Array.from(
    new Set(
      [...extra ?? [], ...queryFields?.map((s) => s.split(",")) ?? []].flat().map((s) => s.trim()).filter(Boolean)
    )
  );
  if (!fields.length) {
    return void 0;
  }
  const arrayTypeField = fields.find((f) => f.includes("["));
  if (arrayTypeField) {
    throw new errors.InputError(
      `Invalid field "${arrayTypeField}", array type fields are not supported`
    );
  }
  return (input) => {
    const output = {};
    for (const field of fields) {
      const [pathArray, value] = getPathArrayAndValue(input, field);
      if (value !== void 0) {
        lodash__default.default.set(output, pathArray, value);
      }
    }
    return output;
  };
}

exports.parseEntityTransformParams = parseEntityTransformParams;
//# sourceMappingURL=parseEntityTransformParams.cjs.js.map
