'use strict';

var catalogClient = require('@backstage/catalog-client');
var catalogModel = require('@backstage/catalog-model');
var uuid = require('uuid');
var buildEntitySearch = require('./buildEntitySearch.cjs.js');
var markDeferredStitchCompleted = require('./markDeferredStitchCompleted.cjs.js');
var util = require('./util.cjs.js');

const scriptProtocolPattern = (
  // eslint-disable-next-line no-control-regex
  /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
);
async function performStitching(options) {
  const { knex, logger, entityRef } = options;
  const stitchTicket = options.stitchTicket ?? uuid.v4();
  let removeFromStitchQueueOnCompletion = options.strategy.mode === "deferred";
  try {
    const entityResult = await knex("refresh_state").where({ entity_ref: entityRef }).limit(1).select("entity_id");
    if (!entityResult.length) {
      return "abandoned";
    }
    await knex("final_entities").insert({
      entity_id: entityResult[0].entity_id,
      hash: "",
      entity_ref: entityRef,
      stitch_ticket: stitchTicket
    }).onConflict("entity_id").merge(["stitch_ticket"]);
    const [processedResult, relationsResult] = await Promise.all([
      knex.with("incoming_references", function incomingReferences(builder) {
        return builder.from("refresh_state_references").where({ target_entity_ref: entityRef }).count({ count: "*" });
      }).select({
        entityId: "refresh_state.entity_id",
        processedEntity: "refresh_state.processed_entity",
        errors: "refresh_state.errors",
        incomingReferenceCount: "incoming_references.count",
        previousHash: "final_entities.hash"
      }).from("refresh_state").where({ "refresh_state.entity_ref": entityRef }).crossJoin(knex.raw("incoming_references")).leftOuterJoin("final_entities", {
        "final_entities.entity_id": "refresh_state.entity_id"
      }),
      knex.distinct({
        relationType: "type",
        relationTarget: "target_entity_ref"
      }).from("relations").where({ source_entity_ref: entityRef }).orderBy("relationType", "asc").orderBy("relationTarget", "asc")
    ]);
    if (!processedResult.length) {
      logger.debug(
        `Unable to stitch ${entityRef}, item does not exist in refresh state table`
      );
      return "abandoned";
    }
    const {
      entityId,
      processedEntity,
      errors,
      incomingReferenceCount,
      previousHash
    } = processedResult[0];
    if (!processedEntity) {
      logger.debug(
        `Unable to stitch ${entityRef}, the entity has not yet been processed`
      );
      return "abandoned";
    }
    const entity = JSON.parse(processedEntity);
    const isOrphan = Number(incomingReferenceCount) === 0;
    let statusItems = [];
    if (isOrphan) {
      logger.debug(`${entityRef} is an orphan`);
      entity.metadata.annotations = {
        ...entity.metadata.annotations,
        ["backstage.io/orphan"]: "true"
      };
    }
    if (errors) {
      const parsedErrors = JSON.parse(errors);
      if (Array.isArray(parsedErrors) && parsedErrors.length) {
        statusItems = parsedErrors.map((e) => ({
          type: catalogClient.ENTITY_STATUS_CATALOG_PROCESSING_TYPE,
          level: "error",
          message: `${e.name}: ${e.message}`,
          error: e
        }));
      }
    }
    for (const annotation of [catalogModel.ANNOTATION_VIEW_URL, catalogModel.ANNOTATION_EDIT_URL]) {
      const value = entity.metadata.annotations?.[annotation];
      if (typeof value === "string" && scriptProtocolPattern.test(value)) {
        entity.metadata.annotations[annotation] = "https://backstage.io/annotation-rejected-for-security-reasons";
      }
    }
    entity.relations = relationsResult.filter(
      (row) => row.relationType
      /* exclude null row, if relevant */
    ).map((row) => ({
      type: row.relationType,
      targetRef: row.relationTarget
    }));
    if (statusItems.length) {
      entity.status = {
        ...entity.status,
        items: [...entity.status?.items ?? [], ...statusItems]
      };
    }
    const hash = util.generateStableHash(entity);
    if (hash === previousHash) {
      logger.debug(`Skipped stitching of ${entityRef}, no changes`);
      return "unchanged";
    }
    entity.metadata.uid = entityId;
    if (!entity.metadata.etag) {
      entity.metadata.etag = hash;
    }
    const searchEntries = buildEntitySearch.buildEntitySearch(entityId, entity);
    const amountOfRowsChanged = await knex("final_entities").update({
      final_entity: JSON.stringify(entity),
      hash,
      last_updated_at: knex.fn.now()
    }).where("entity_id", entityId).where("stitch_ticket", stitchTicket);
    if (amountOfRowsChanged === 0) {
      logger.debug(`Entity ${entityRef} is already stitched, skipping write.`);
      return "abandoned";
    }
    await knex.transaction(async (trx) => {
      await trx("search").where({ entity_id: entityId }).delete();
      await trx.batchInsert("search", searchEntries, util.BATCH_SIZE);
    });
    return "changed";
  } catch (error) {
    removeFromStitchQueueOnCompletion = false;
    throw error;
  } finally {
    if (removeFromStitchQueueOnCompletion) {
      await markDeferredStitchCompleted.markDeferredStitchCompleted({
        knex,
        entityRef,
        stitchTicket
      });
    }
  }
}

exports.performStitching = performStitching;
//# sourceMappingURL=performStitching.cjs.js.map
