'use strict';

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');

const SPECIAL_KEYS = [
  "attachments",
  "relations",
  "status",
  "metadata.name",
  "metadata.namespace",
  "metadata.uid",
  "metadata.etag"
];
const MAX_KEY_LENGTH = 200;
const MAX_VALUE_LENGTH = 200;
function traverse(root) {
  const output = [];
  function visit(path, current) {
    if (SPECIAL_KEYS.includes(path)) {
      return;
    }
    if (current === void 0 || current === null || ["string", "number", "boolean"].includes(typeof current)) {
      output.push({ key: path, value: current });
      return;
    }
    if (typeof current !== "object") {
      return;
    }
    if (Array.isArray(current)) {
      for (const item of current) {
        visit(path, item);
        if (typeof item === "string") {
          output.push({ key: `${path}.${item}`, value: true });
        }
      }
      return;
    }
    for (const [key, value] of Object.entries(current)) {
      visit(path ? `${path}.${key}` : key, value);
    }
  }
  visit("", root);
  return output;
}
function mapToRows(input, entityId) {
  const result = [];
  for (const { key: rawKey, value: rawValue } of input) {
    const key = rawKey.toLocaleLowerCase("en-US");
    if (key.length > MAX_KEY_LENGTH) {
      continue;
    }
    if (rawValue === void 0 || rawValue === null) {
      result.push({
        entity_id: entityId,
        key,
        original_value: null,
        value: null
      });
    } else {
      const value = String(rawValue).toLocaleLowerCase("en-US");
      if (value.length <= MAX_VALUE_LENGTH) {
        result.push({
          entity_id: entityId,
          key,
          original_value: String(rawValue),
          value
        });
      } else {
        result.push({
          entity_id: entityId,
          key,
          original_value: null,
          value: null
        });
      }
    }
  }
  return result;
}
function buildEntitySearch(entityId, entity) {
  const raw = traverse(entity);
  raw.push({ key: "metadata.name", value: entity.metadata.name });
  raw.push({ key: "metadata.namespace", value: entity.metadata.namespace });
  raw.push({ key: "metadata.uid", value: entity.metadata.uid });
  if (!entity.metadata.namespace) {
    raw.push({ key: "metadata.namespace", value: catalogModel.DEFAULT_NAMESPACE });
  }
  for (const relation of entity.relations ?? []) {
    raw.push({
      key: `relations.${relation.type}`,
      value: relation.targetRef
    });
  }
  const keys = new Set(raw.map((r) => r.key));
  const lowerKeys = new Set(raw.map((r) => r.key.toLocaleLowerCase("en-US")));
  if (keys.size !== lowerKeys.size) {
    const difference = [];
    for (const key of keys) {
      const lower = key.toLocaleLowerCase("en-US");
      if (!lowerKeys.delete(lower)) {
        difference.push(lower);
      }
    }
    const badKeys = `'${difference.join("', '")}'`;
    throw new errors.InputError(
      `Entity has duplicate keys that vary only in casing, ${badKeys}`
    );
  }
  return mapToRows(raw, entityId);
}

exports.buildEntitySearch = buildEntitySearch;
exports.mapToRows = mapToRows;
exports.traverse = traverse;
//# sourceMappingURL=buildEntitySearch.cjs.js.map
