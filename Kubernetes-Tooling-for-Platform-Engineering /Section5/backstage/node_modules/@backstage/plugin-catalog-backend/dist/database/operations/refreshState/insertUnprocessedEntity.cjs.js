'use strict';

var catalogModel = require('@backstage/catalog-model');
var uuid = require('uuid');
var backendPluginApi = require('@backstage/backend-plugin-api');

async function insertUnprocessedEntity(options) {
  const { tx, entity, hash, logger, locationKey } = options;
  const entityRef = catalogModel.stringifyEntityRef(entity);
  const serializedEntity = JSON.stringify(entity);
  try {
    let query = tx("refresh_state").insert({
      entity_id: uuid.v4(),
      entity_ref: entityRef,
      unprocessed_entity: serializedEntity,
      unprocessed_hash: hash,
      errors: "",
      location_key: locationKey,
      next_update_at: tx.fn.now(),
      last_discovery_at: tx.fn.now()
    });
    if (tx.client.config.client.includes("pg")) {
      query = query.onConflict("entity_ref").ignore();
    }
    const result = await query;
    return result.rowCount === 1 || result.length === 1;
  } catch (error) {
    if (!backendPluginApi.isDatabaseConflictError(error)) {
      throw error;
    } else {
      logger.debug(`Unable to insert a new refresh state row, ${error}`);
      return false;
    }
  }
}

exports.insertUnprocessedEntity = insertUnprocessedEntity;
//# sourceMappingURL=insertUnprocessedEntity.cjs.js.map
