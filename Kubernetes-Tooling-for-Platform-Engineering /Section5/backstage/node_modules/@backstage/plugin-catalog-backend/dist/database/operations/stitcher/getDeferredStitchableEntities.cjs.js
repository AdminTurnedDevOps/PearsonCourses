'use strict';

var types = require('@backstage/types');
var conversion = require('../../conversion.cjs.js');

async function getDeferredStitchableEntities(options) {
  const { knex, batchSize, stitchTimeout } = options;
  let itemsQuery = knex("refresh_state").select(
    "entity_ref",
    "next_stitch_at",
    "next_stitch_ticket"
  );
  if (["mysql", "mysql2", "pg"].includes(knex.client.config.client)) {
    itemsQuery = itemsQuery.forUpdate().skipLocked();
  }
  const items = await itemsQuery.whereNotNull("next_stitch_at").whereNotNull("next_stitch_ticket").where("next_stitch_at", "<=", knex.fn.now()).orderBy("next_stitch_at", "asc").limit(batchSize);
  if (!items.length) {
    return [];
  }
  await knex("refresh_state").whereIn(
    "entity_ref",
    items.map((i) => i.entity_ref)
  ).whereNotNull("next_stitch_ticket").update({
    next_stitch_at: nowPlus(knex, stitchTimeout)
  });
  return items.map((i) => ({
    entityRef: i.entity_ref,
    stitchTicket: i.next_stitch_ticket,
    stitchRequestedAt: conversion.timestampToDateTime(i.next_stitch_at)
  }));
}
function nowPlus(knex, duration) {
  const seconds = types.durationToMilliseconds(duration) / 1e3;
  if (knex.client.config.client.includes("sqlite3")) {
    return knex.raw(`datetime('now', ?)`, [`${seconds} seconds`]);
  } else if (knex.client.config.client.includes("mysql")) {
    return knex.raw(`now() + interval ${seconds} second`);
  }
  return knex.raw(`now() + interval '${seconds} seconds'`);
}

exports.getDeferredStitchableEntities = getDeferredStitchableEntities;
//# sourceMappingURL=getDeferredStitchableEntities.cjs.js.map
