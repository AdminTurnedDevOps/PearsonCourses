'use strict';

var lodash = require('lodash');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);

async function deleteWithEagerPruningOfChildren(options) {
  const { knex, entityRefs, sourceKey } = options;
  let removedCount = 0;
  for (const refs of lodash__default.default.chunk(entityRefs, 1e3)) {
    const { orphanEntityRefs } = await findDescendantsThatWouldHaveBeenOrphanedByDeletion({
      knex: options.knex,
      refs,
      sourceKey
    });
    for (const refsToDelete of lodash__default.default.chunk(orphanEntityRefs, 1e3)) {
      await markEntitiesAffectedByDeletionForStitching({
        knex: options.knex,
        entityRefs: refsToDelete
      });
      await knex.delete().from("refresh_state").whereIn("entity_ref", refsToDelete);
    }
    await knex("refresh_state_references").where("source_key", "=", sourceKey).whereIn("target_entity_ref", refs).delete();
    removedCount += orphanEntityRefs.length;
  }
  return removedCount;
}
async function findDescendantsThatWouldHaveBeenOrphanedByDeletion(options) {
  const { knex, refs, sourceKey } = options;
  const orphans = (
    // First find all nodes that can be reached downwards from the roots
    // (deletion targets), including the roots themselves, by traversing
    // down the refresh_state_references table. Note that this query
    // starts with a condition that source_key = our source key, and
    // target_entity_ref is one of the deletion targets. This has two
    // effects: it won't match attempts at deleting something that didn't
    // originate from us in the first place, and also won't match non-root
    // entities (source_key would be null for those).
    //
    //   KeyA - R1 - R2        Legend:
    //                 \       -----------------------------------------
    //                  R3     Key*    Source key
    //                 /       R*      Entity ref
    //   KeyA - R4 - R5        lines   Individual references; sources to
    //              /                  the left and targets to the right
    //   KeyB --- R6
    //
    // The scenario is that KeyA wants to delete R1.
    //
    // The query starts with the KeyA-R1 reference, and then traverses
    // down to also find R2 and R3. It uses union instead of union all,
    // because it wants to find the set of unique descendants even if
    // the tree has unexpected loops etc.
    await knex.withRecursive(
      "descendants",
      ["entity_ref"],
      (initial) => initial.select("target_entity_ref").from("refresh_state_references").where("source_key", "=", sourceKey).whereIn("target_entity_ref", refs).union(
        (recursive) => recursive.select("refresh_state_references.target_entity_ref").from("descendants").join(
          "refresh_state_references",
          "descendants.entity_ref",
          "refresh_state_references.source_entity_ref"
        )
      )
    ).withRecursive(
      "ancestors",
      ["source_key", "source_entity_ref", "target_entity_ref", "subject"],
      (initial) => initial.select(
        "refresh_state_references.source_key",
        "refresh_state_references.source_entity_ref",
        "refresh_state_references.target_entity_ref",
        "descendants.entity_ref"
      ).from("descendants").join(
        "refresh_state_references",
        "refresh_state_references.target_entity_ref",
        "descendants.entity_ref"
      ).union(
        (recursive) => recursive.select(
          "refresh_state_references.source_key",
          "refresh_state_references.source_entity_ref",
          "refresh_state_references.target_entity_ref",
          "ancestors.subject"
        ).from("ancestors").join(
          "refresh_state_references",
          "refresh_state_references.target_entity_ref",
          "ancestors.source_entity_ref"
        )
      )
    ).with(
      "retained",
      ["entity_ref"],
      (notPartOfDeletion) => notPartOfDeletion.select("subject").from("ancestors").whereNotNull("ancestors.source_key").where(
        (foreignKeyOrRef) => foreignKeyOrRef.where("ancestors.source_key", "!=", sourceKey).orWhereNotIn("ancestors.target_entity_ref", refs)
      )
    ).select("descendants.entity_ref AS entity_ref").from("descendants").leftOuterJoin(
      "retained",
      "retained.entity_ref",
      "descendants.entity_ref"
    ).whereNull("retained.entity_ref").then((rows) => rows.map((row) => row.entity_ref))
  );
  return { orphanEntityRefs: orphans };
}
async function markEntitiesAffectedByDeletionForStitching(options) {
  const { knex, entityRefs } = options;
  const affectedIds = await knex.select("refresh_state.entity_id AS entity_id").from("relations").join(
    "refresh_state",
    "relations.source_entity_ref",
    "refresh_state.entity_ref"
  ).whereIn("relations.target_entity_ref", entityRefs).then((rows) => rows.map((row) => row.entity_id));
  for (const ids of lodash__default.default.chunk(affectedIds, 1e3)) {
    await knex.table("final_entities").update({
      hash: "force-stitching"
    }).whereIn("entity_id", ids);
    await knex.table("refresh_state").update({
      result_hash: "force-stitching",
      next_update_at: knex.fn.now()
    }).whereIn("entity_id", ids);
  }
}

exports.deleteWithEagerPruningOfChildren = deleteWithEagerPruningOfChildren;
//# sourceMappingURL=deleteWithEagerPruningOfChildren.cjs.js.map
