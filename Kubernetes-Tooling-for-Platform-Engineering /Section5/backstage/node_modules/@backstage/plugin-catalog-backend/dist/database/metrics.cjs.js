'use strict';

var metrics = require('../util/metrics.cjs.js');
var api = require('@opentelemetry/api');

function initDatabaseMetrics(knex) {
  const seenProm = /* @__PURE__ */ new Set();
  const seen = /* @__PURE__ */ new Set();
  const meter = api.metrics.getMeter("default");
  return {
    entities_count_prom: metrics.createGaugeMetric({
      name: "catalog_entities_count",
      help: "Total amount of entities in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
      labelNames: ["kind"],
      async collect() {
        const results = await knex("search").where("key", "=", "kind").whereNotNull("value").select({ kind: "value", count: knex.raw("count(*)") }).groupBy("value");
        results.forEach(({ kind, count }) => {
          seenProm.add(kind);
          this.set({ kind }, Number(count));
        });
        seenProm.forEach((kind) => {
          if (!results.some((r) => r.kind === kind)) {
            this.set({ kind }, 0);
            seenProm.delete(kind);
          }
        });
      }
    }),
    registered_locations_prom: metrics.createGaugeMetric({
      name: "catalog_registered_locations_count",
      help: "Total amount of registered locations in the catalog. DEPRECATED: Please use opentelemetry metrics instead.",
      async collect() {
        const total = await knex("locations").count({
          count: "*"
        });
        this.set(Number(total[0].count));
      }
    }),
    relations_prom: metrics.createGaugeMetric({
      name: "catalog_relations_count",
      help: "Total amount of relations between entities. DEPRECATED: Please use opentelemetry metrics instead.",
      async collect() {
        const total = await knex("relations").count({
          count: "*"
        });
        this.set(Number(total[0].count));
      }
    }),
    entities_count: meter.createObservableGauge("catalog_entities_count", {
      description: "Total amount of entities in the catalog"
    }).addCallback(async (gauge) => {
      const results = await knex("search").where("key", "=", "kind").whereNotNull("value").select({ kind: "value", count: knex.raw("count(*)") }).groupBy("value");
      results.forEach(({ kind, count }) => {
        seen.add(kind);
        gauge.observe(Number(count), { kind });
      });
      seen.forEach((kind) => {
        if (!results.some((r) => r.kind === kind)) {
          gauge.observe(0, { kind });
          seen.delete(kind);
        }
      });
    }),
    registered_locations: meter.createObservableGauge("catalog_registered_locations_count", {
      description: "Total amount of registered locations in the catalog"
    }).addCallback(async (gauge) => {
      if (knex.client.config.client === "pg") {
        const total = await knex.raw(`
            SELECT reltuples::bigint AS estimate
            FROM   pg_class
            WHERE  oid = 'locations'::regclass;
          `);
        gauge.observe(Number(total.rows[0].estimate));
      } else {
        const total = await knex("locations").count({
          count: "*"
        });
        gauge.observe(Number(total[0].count));
      }
    }),
    relations: meter.createObservableGauge("catalog_relations_count", {
      description: "Total amount of relations between entities"
    }).addCallback(async (gauge) => {
      if (knex.client.config.client === "pg") {
        const total = await knex.raw(`
            SELECT reltuples::bigint AS estimate
            FROM   pg_class
            WHERE  oid = 'relations'::regclass;
          `);
        gauge.observe(Number(total.rows[0].estimate));
      } else {
        const total = await knex("relations").count({
          count: "*"
        });
        gauge.observe(Number(total[0].count));
      }
    })
  };
}

exports.initDatabaseMetrics = initDatabaseMetrics;
//# sourceMappingURL=metrics.cjs.js.map
