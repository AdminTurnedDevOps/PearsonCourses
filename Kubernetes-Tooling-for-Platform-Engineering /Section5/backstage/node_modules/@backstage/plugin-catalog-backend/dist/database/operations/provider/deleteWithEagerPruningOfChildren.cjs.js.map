{"version":3,"file":"deleteWithEagerPruningOfChildren.cjs.js","sources":["../../../../src/database/operations/provider/deleteWithEagerPruningOfChildren.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Knex } from 'knex';\nimport lodash from 'lodash';\nimport {\n  DbFinalEntitiesRow,\n  DbRefreshStateReferencesRow,\n  DbRefreshStateRow,\n} from '../../tables';\n\n/**\n * Given a number of entity refs originally created by a given entity provider\n * (source key), remove those entities from the refresh state, and at the same\n * time recursively remove every child that is a direct or indirect result of\n * processing those entities, if they would have otherwise become orphaned by\n * the removal of their parents.\n */\nexport async function deleteWithEagerPruningOfChildren(options: {\n  knex: Knex | Knex.Transaction;\n  entityRefs: string[];\n  sourceKey: string;\n}): Promise<number> {\n  const { knex, entityRefs, sourceKey } = options;\n\n  // Split up the operation by (large) chunks, so that we do not hit database\n  // limits for the number of permitted bindings on a precompiled statement\n  let removedCount = 0;\n  for (const refs of lodash.chunk(entityRefs, 1000)) {\n    const { orphanEntityRefs } =\n      await findDescendantsThatWouldHaveBeenOrphanedByDeletion({\n        knex: options.knex,\n        refs,\n        sourceKey,\n      });\n\n    // Chunk again - these can be many more than the outer chunk size\n    for (const refsToDelete of lodash.chunk(orphanEntityRefs, 1000)) {\n      await markEntitiesAffectedByDeletionForStitching({\n        knex: options.knex,\n        entityRefs: refsToDelete,\n      });\n      await knex\n        .delete()\n        .from('refresh_state')\n        .whereIn('entity_ref', refsToDelete);\n    }\n\n    // Delete the references that originate only from this entity provider. Note\n    // that there may be more than one entity provider making a \"claim\" for a\n    // given root entity, if they emit with the same location key.\n    await knex<DbRefreshStateReferencesRow>('refresh_state_references')\n      .where('source_key', '=', sourceKey)\n      .whereIn('target_entity_ref', refs)\n      .delete();\n\n    removedCount += orphanEntityRefs.length;\n  }\n\n  return removedCount;\n}\n\nasync function findDescendantsThatWouldHaveBeenOrphanedByDeletion(options: {\n  knex: Knex | Knex.Transaction;\n  refs: string[];\n  sourceKey: string;\n}): Promise<{ orphanEntityRefs: string[] }> {\n  const { knex, refs, sourceKey } = options;\n\n  const orphans: string[] =\n    // First find all nodes that can be reached downwards from the roots\n    // (deletion targets), including the roots themselves, by traversing\n    // down the refresh_state_references table. Note that this query\n    // starts with a condition that source_key = our source key, and\n    // target_entity_ref is one of the deletion targets. This has two\n    // effects: it won't match attempts at deleting something that didn't\n    // originate from us in the first place, and also won't match non-root\n    // entities (source_key would be null for those).\n    //\n    //   KeyA - R1 - R2        Legend:\n    //                 \\       -----------------------------------------\n    //                  R3     Key*    Source key\n    //                 /       R*      Entity ref\n    //   KeyA - R4 - R5        lines   Individual references; sources to\n    //              /                  the left and targets to the right\n    //   KeyB --- R6\n    //\n    // The scenario is that KeyA wants to delete R1.\n    //\n    // The query starts with the KeyA-R1 reference, and then traverses\n    // down to also find R2 and R3. It uses union instead of union all,\n    // because it wants to find the set of unique descendants even if\n    // the tree has unexpected loops etc.\n    await knex\n      .withRecursive('descendants', ['entity_ref'], initial =>\n        initial\n          .select('target_entity_ref')\n          .from('refresh_state_references')\n          .where('source_key', '=', sourceKey)\n          .whereIn('target_entity_ref', refs)\n          .union(recursive =>\n            recursive\n              .select('refresh_state_references.target_entity_ref')\n              .from('descendants')\n              .join(\n                'refresh_state_references',\n                'descendants.entity_ref',\n                'refresh_state_references.source_entity_ref',\n              ),\n          ),\n      )\n      // Then for each descendant, traverse all the way back upwards through\n      // the refresh_state_references table to get an exhaustive list of all\n      // references that are part of keeping that particular descendant\n      // alive.\n      //\n      // Continuing the scenario from above, starting from R3, it goes\n      // upwards to find every pair along every relation line.\n      //\n      //   Top branch:     R2-R3, R1-R2, KeyA-R1\n      //   Middle branch:  R5-R3, R4-R5, KeyA-R4\n      //   Bottom branch:  R6-R5, KeyB-R6\n      //\n      // Note that this all applied to the subject R3. The exact same thing\n      // will be done starting from each other descendant (R2 and R1). They\n      // only have one and two references to find, respectively.\n      //\n      // This query also uses union instead of union all, to get the set of\n      // distinct relations even if the tree has unexpected loops etc.\n      .withRecursive(\n        'ancestors',\n        ['source_key', 'source_entity_ref', 'target_entity_ref', 'subject'],\n        initial =>\n          initial\n            .select(\n              'refresh_state_references.source_key',\n              'refresh_state_references.source_entity_ref',\n              'refresh_state_references.target_entity_ref',\n              'descendants.entity_ref',\n            )\n            .from('descendants')\n            .join(\n              'refresh_state_references',\n              'refresh_state_references.target_entity_ref',\n              'descendants.entity_ref',\n            )\n            .union(recursive =>\n              recursive\n                .select(\n                  'refresh_state_references.source_key',\n                  'refresh_state_references.source_entity_ref',\n                  'refresh_state_references.target_entity_ref',\n                  'ancestors.subject',\n                )\n                .from('ancestors')\n                .join(\n                  'refresh_state_references',\n                  'refresh_state_references.target_entity_ref',\n                  'ancestors.source_entity_ref',\n                ),\n            ),\n      )\n      // Finally, from that list of ancestor relations per descendant, pick\n      // out the ones that are roots (have a source_key). Specifically, find\n      // ones that seem to be be either (1) from another source, or (2)\n      // aren't part of the deletion targets. Those are markers that tell us\n      // that the corresponding descendant should be kept alive and NOT\n      // subject to eager deletion, because there's \"something else\" (not\n      // targeted for deletion) that has references down through the tree to\n      // it.\n      //\n      // Continuing the scenario from above, for R3 we have\n      //\n      //   KeyA-R1, KeyA-R4, KeyB-R6\n      //\n      // This tells us that R3 should be kept alive for two reasons: it's\n      // referenced by a node that isn't being deleted (R4), and also by\n      // another source (KeyB). What about R1 and R2? They both have\n      //\n      //   KeyA-R1\n      //\n      // So those should be deleted, since they are definitely only being\n      // kept alive by something that's about to be deleted.\n      //\n      // Final shape of the tree:\n      //\n      //                  R3\n      //                 /\n      //   KeyA - R4 - R5\n      //              /\n      //   KeyB --- R6\n      .with('retained', ['entity_ref'], notPartOfDeletion =>\n        notPartOfDeletion\n          .select('subject')\n          .from('ancestors')\n          .whereNotNull('ancestors.source_key')\n          .where(foreignKeyOrRef =>\n            foreignKeyOrRef\n              .where('ancestors.source_key', '!=', sourceKey)\n              .orWhereNotIn('ancestors.target_entity_ref', refs),\n          ),\n      )\n      // Return all descendants minus the retained ones\n      .select('descendants.entity_ref AS entity_ref')\n      .from('descendants')\n      .leftOuterJoin(\n        'retained',\n        'retained.entity_ref',\n        'descendants.entity_ref',\n      )\n      .whereNull('retained.entity_ref')\n      .then(rows => rows.map(row => row.entity_ref));\n\n  return { orphanEntityRefs: orphans };\n}\n\nasync function markEntitiesAffectedByDeletionForStitching(options: {\n  knex: Knex | Knex.Transaction;\n  entityRefs: string[];\n}) {\n  const { knex, entityRefs } = options;\n\n  // We want to re-stitch anything that has a relation pointing to the\n  // soon-to-be-deleted entity. In many circumstances we also re-stitch children\n  // in the refresh_state_references graph because their orphan state might\n  // change, but not here - this code by its very definition is meant to not\n  // leave any orphans behind, so we can simplify away that.\n  const affectedIds = await knex\n    .select('refresh_state.entity_id AS entity_id')\n    .from('relations')\n    .join(\n      'refresh_state',\n      'relations.source_entity_ref',\n      'refresh_state.entity_ref',\n    )\n    .whereIn('relations.target_entity_ref', entityRefs)\n    .then(rows => rows.map(row => row.entity_id));\n\n  for (const ids of lodash.chunk(affectedIds, 1000)) {\n    await knex\n      .table<DbFinalEntitiesRow>('final_entities')\n      .update({\n        hash: 'force-stitching',\n      })\n      .whereIn('entity_id', ids);\n    await knex\n      .table<DbRefreshStateRow>('refresh_state')\n      .update({\n        result_hash: 'force-stitching',\n        next_update_at: knex.fn.now(),\n      })\n      .whereIn('entity_id', ids);\n  }\n}\n"],"names":["lodash"],"mappings":";;;;;;;;AA+BA,eAAsB,iCAAiC,OAInC,EAAA;AAClB,EAAA,MAAM,EAAE,IAAA,EAAM,UAAY,EAAA,SAAA,EAAc,GAAA,OAAA;AAIxC,EAAA,IAAI,YAAe,GAAA,CAAA;AACnB,EAAA,KAAA,MAAW,IAAQ,IAAAA,uBAAA,CAAO,KAAM,CAAA,UAAA,EAAY,GAAI,CAAG,EAAA;AACjD,IAAA,MAAM,EAAE,gBAAA,EACN,GAAA,MAAM,kDAAmD,CAAA;AAAA,MACvD,MAAM,OAAQ,CAAA,IAAA;AAAA,MACd,IAAA;AAAA,MACA;AAAA,KACD,CAAA;AAGH,IAAA,KAAA,MAAW,YAAgB,IAAAA,uBAAA,CAAO,KAAM,CAAA,gBAAA,EAAkB,GAAI,CAAG,EAAA;AAC/D,MAAA,MAAM,0CAA2C,CAAA;AAAA,QAC/C,MAAM,OAAQ,CAAA,IAAA;AAAA,QACd,UAAY,EAAA;AAAA,OACb,CAAA;AACD,MAAM,MAAA,IAAA,CACH,QACA,CAAA,IAAA,CAAK,eAAe,CACpB,CAAA,OAAA,CAAQ,cAAc,YAAY,CAAA;AAAA;AAMvC,IAAA,MAAM,IAAkC,CAAA,0BAA0B,CAC/D,CAAA,KAAA,CAAM,YAAc,EAAA,GAAA,EAAK,SAAS,CAAA,CAClC,OAAQ,CAAA,mBAAA,EAAqB,IAAI,CAAA,CACjC,MAAO,EAAA;AAEV,IAAA,YAAA,IAAgB,gBAAiB,CAAA,MAAA;AAAA;AAGnC,EAAO,OAAA,YAAA;AACT;AAEA,eAAe,mDAAmD,OAItB,EAAA;AAC1C,EAAA,MAAM,EAAE,IAAA,EAAM,IAAM,EAAA,SAAA,EAAc,GAAA,OAAA;AAElC,EAAM,MAAA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwBJ,MAAM,IACH,CAAA,aAAA;AAAA,MAAc,aAAA;AAAA,MAAe,CAAC,YAAY,CAAA;AAAA,MAAG,aAC5C,OACG,CAAA,MAAA,CAAO,mBAAmB,CAAA,CAC1B,KAAK,0BAA0B,CAAA,CAC/B,KAAM,CAAA,YAAA,EAAc,KAAK,SAAS,CAAA,CAClC,OAAQ,CAAA,mBAAA,EAAqB,IAAI,CACjC,CAAA,KAAA;AAAA,QAAM,eACL,SACG,CAAA,MAAA,CAAO,4CAA4C,CACnD,CAAA,IAAA,CAAK,aAAa,CAClB,CAAA,IAAA;AAAA,UACC,0BAAA;AAAA,UACA,wBAAA;AAAA,UACA;AAAA;AACF;AACJ,KAoBH,CAAA,aAAA;AAAA,MACC,WAAA;AAAA,MACA,CAAC,YAAA,EAAc,mBAAqB,EAAA,mBAAA,EAAqB,SAAS,CAAA;AAAA,MAClE,aACE,OACG,CAAA,MAAA;AAAA,QACC,qCAAA;AAAA,QACA,4CAAA;AAAA,QACA,4CAAA;AAAA,QACA;AAAA,OACF,CACC,IAAK,CAAA,aAAa,CAClB,CAAA,IAAA;AAAA,QACC,0BAAA;AAAA,QACA,4CAAA;AAAA,QACA;AAAA,OAED,CAAA,KAAA;AAAA,QAAM,eACL,SACG,CAAA,MAAA;AAAA,UACC,qCAAA;AAAA,UACA,4CAAA;AAAA,UACA,4CAAA;AAAA,UACA;AAAA,SACF,CACC,IAAK,CAAA,WAAW,CAChB,CAAA,IAAA;AAAA,UACC,0BAAA;AAAA,UACA,4CAAA;AAAA,UACA;AAAA;AACF;AACJ,KA+BL,CAAA,IAAA;AAAA,MAAK,UAAA;AAAA,MAAY,CAAC,YAAY,CAAA;AAAA,MAAG,CAAA,iBAAA,KAChC,iBACG,CAAA,MAAA,CAAO,SAAS,CAAA,CAChB,KAAK,WAAW,CAAA,CAChB,YAAa,CAAA,sBAAsB,CACnC,CAAA,KAAA;AAAA,QAAM,CAAA,eAAA,KACL,gBACG,KAAM,CAAA,sBAAA,EAAwB,MAAM,SAAS,CAAA,CAC7C,YAAa,CAAA,6BAAA,EAA+B,IAAI;AAAA;AACrD,MAGH,MAAO,CAAA,sCAAsC,CAC7C,CAAA,IAAA,CAAK,aAAa,CAClB,CAAA,aAAA;AAAA,MACC,UAAA;AAAA,MACA,qBAAA;AAAA,MACA;AAAA,KACF,CACC,SAAU,CAAA,qBAAqB,CAC/B,CAAA,IAAA,CAAK,CAAQ,IAAA,KAAA,IAAA,CAAK,GAAI,CAAA,CAAA,GAAA,KAAO,GAAI,CAAA,UAAU,CAAC;AAAA,GAAA;AAEjD,EAAO,OAAA,EAAE,kBAAkB,OAAQ,EAAA;AACrC;AAEA,eAAe,2CAA2C,OAGvD,EAAA;AACD,EAAM,MAAA,EAAE,IAAM,EAAA,UAAA,EAAe,GAAA,OAAA;AAO7B,EAAM,MAAA,WAAA,GAAc,MAAM,IACvB,CAAA,MAAA,CAAO,sCAAsC,CAC7C,CAAA,IAAA,CAAK,WAAW,CAChB,CAAA,IAAA;AAAA,IACC,eAAA;AAAA,IACA,6BAAA;AAAA,IACA;AAAA,GAED,CAAA,OAAA,CAAQ,6BAA+B,EAAA,UAAU,CACjD,CAAA,IAAA,CAAK,CAAQ,IAAA,KAAA,IAAA,CAAK,GAAI,CAAA,CAAA,GAAA,KAAO,GAAI,CAAA,SAAS,CAAC,CAAA;AAE9C,EAAA,KAAA,MAAW,GAAO,IAAAA,uBAAA,CAAO,KAAM,CAAA,WAAA,EAAa,GAAI,CAAG,EAAA;AACjD,IAAA,MAAM,IACH,CAAA,KAAA,CAA0B,gBAAgB,CAAA,CAC1C,MAAO,CAAA;AAAA,MACN,IAAM,EAAA;AAAA,KACP,CAAA,CACA,OAAQ,CAAA,WAAA,EAAa,GAAG,CAAA;AAC3B,IAAA,MAAM,IACH,CAAA,KAAA,CAAyB,eAAe,CAAA,CACxC,MAAO,CAAA;AAAA,MACN,WAAa,EAAA,iBAAA;AAAA,MACb,cAAA,EAAgB,IAAK,CAAA,EAAA,CAAG,GAAI;AAAA,KAC7B,CAAA,CACA,OAAQ,CAAA,WAAA,EAAa,GAAG,CAAA;AAAA;AAE/B;;;;"}