'use strict';

var errors = require('@backstage/errors');
var conversion = require('./conversion.cjs.js');

const MAX_ANCESTOR_DEPTH = 32;
class DefaultCatalogDatabase {
  constructor(options) {
    this.options = options;
  }
  async transaction(fn) {
    try {
      let result = void 0;
      await this.options.database.transaction(
        async (tx) => {
          result = await fn(tx);
        },
        {
          // If we explicitly trigger a rollback, don't fail.
          doNotRejectOnRollback: true
        }
      );
      return result;
    } catch (e) {
      this.options.logger.debug(`Error during transaction, ${e}`);
      throw conversion.rethrowError(e);
    }
  }
  async listAncestors(txOpaque, options) {
    const tx = txOpaque;
    const { entityRef } = options;
    const entityRefs = new Array();
    let currentRef = entityRef.toLocaleLowerCase("en-US");
    for (let depth = 1; depth <= MAX_ANCESTOR_DEPTH; depth += 1) {
      const rows = await tx(
        "refresh_state_references"
      ).where({ target_entity_ref: currentRef }).select();
      if (rows.length === 0) {
        if (depth === 1) {
          throw new errors.NotFoundError(`Entity ${currentRef} not found`);
        }
        throw new errors.NotFoundError(
          `Entity ${entityRef} has a broken parent reference chain at ${currentRef}`
        );
      }
      const parentRef = rows.find((r) => r.source_entity_ref)?.source_entity_ref;
      if (!parentRef) {
        return { entityRefs };
      }
      entityRefs.push(parentRef);
      currentRef = parentRef;
    }
    throw new Error(
      `Unable receive ancestors for ${entityRef}, reached maximum depth of ${MAX_ANCESTOR_DEPTH}`
    );
  }
  async refresh(txOpaque, options) {
    const tx = txOpaque;
    const { entityRef } = options;
    const updateResult = await tx("refresh_state").where({ entity_ref: entityRef.toLocaleLowerCase("en-US") }).update({ next_update_at: tx.fn.now() });
    if (updateResult === 0) {
      throw new errors.NotFoundError(`Failed to schedule ${entityRef} for refresh`);
    }
  }
}

exports.DefaultCatalogDatabase = DefaultCatalogDatabase;
//# sourceMappingURL=DefaultCatalogDatabase.cjs.js.map
