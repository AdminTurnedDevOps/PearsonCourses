{"version":3,"file":"getDeferredStitchableEntities.cjs.js","sources":["../../../../src/database/operations/stitcher/getDeferredStitchableEntities.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { durationToMilliseconds, HumanDuration } from '@backstage/types';\nimport { Knex } from 'knex';\nimport { DateTime } from 'luxon';\nimport { timestampToDateTime } from '../../conversion';\nimport { DbRefreshStateRow } from '../../tables';\n\n// TODO(freben): There is no retry counter or similar. If items start\n// perpetually crashing during stitching, they'll just get silently retried over\n// and over again, for better or worse. This will be visible in metrics though.\n\n/**\n * Finds entities that are marked for deferred stitching.\n *\n * @remarks\n *\n * This assumes that the stitching strategy is set to deferred.\n *\n * They are expected to already have the next_stitch_ticket set (by\n * markForStitching) so that their tickets can be returned with each item.\n *\n * All returned items have their next_stitch_at updated to be moved forward by\n * the given timeout duration. This has the effect that they will be picked up\n * for stitching again in the future, if it hasn't completed by that point for\n * some reason (restarts, crashes, etc).\n */\nexport async function getDeferredStitchableEntities(options: {\n  knex: Knex | Knex.Transaction;\n  batchSize: number;\n  stitchTimeout: HumanDuration;\n}): Promise<\n  Array<{\n    entityRef: string;\n    stitchTicket: string;\n    stitchRequestedAt: DateTime; // the time BEFORE moving it forward by the timeout\n  }>\n> {\n  const { knex, batchSize, stitchTimeout } = options;\n\n  let itemsQuery = knex<DbRefreshStateRow>('refresh_state').select(\n    'entity_ref',\n    'next_stitch_at',\n    'next_stitch_ticket',\n  );\n\n  // This avoids duplication of work because of race conditions and is\n  // also fast because locked rows are ignored rather than blocking.\n  // It's only available in MySQL and PostgreSQL\n  if (['mysql', 'mysql2', 'pg'].includes(knex.client.config.client)) {\n    itemsQuery = itemsQuery.forUpdate().skipLocked();\n  }\n\n  const items = await itemsQuery\n    .whereNotNull('next_stitch_at')\n    .whereNotNull('next_stitch_ticket')\n    .where('next_stitch_at', '<=', knex.fn.now())\n    .orderBy('next_stitch_at', 'asc')\n    .limit(batchSize);\n\n  if (!items.length) {\n    return [];\n  }\n\n  await knex<DbRefreshStateRow>('refresh_state')\n    .whereIn(\n      'entity_ref',\n      items.map(i => i.entity_ref),\n    )\n    // avoid race condition where someone completes a stitch right between these statements\n    .whereNotNull('next_stitch_ticket')\n    .update({\n      next_stitch_at: nowPlus(knex, stitchTimeout),\n    });\n\n  return items.map(i => ({\n    entityRef: i.entity_ref,\n    stitchTicket: i.next_stitch_ticket!,\n    stitchRequestedAt: timestampToDateTime(i.next_stitch_at!),\n  }));\n}\n\nfunction nowPlus(knex: Knex, duration: HumanDuration): Knex.Raw {\n  const seconds = durationToMilliseconds(duration) / 1000;\n  if (knex.client.config.client.includes('sqlite3')) {\n    return knex.raw(`datetime('now', ?)`, [`${seconds} seconds`]);\n  } else if (knex.client.config.client.includes('mysql')) {\n    return knex.raw(`now() + interval ${seconds} second`);\n  }\n  return knex.raw(`now() + interval '${seconds} seconds'`);\n}\n"],"names":["timestampToDateTime","durationToMilliseconds"],"mappings":";;;;;AAyCA,eAAsB,8BAA8B,OAUlD,EAAA;AACA,EAAA,MAAM,EAAE,IAAA,EAAM,SAAW,EAAA,aAAA,EAAkB,GAAA,OAAA;AAE3C,EAAI,IAAA,UAAA,GAAa,IAAwB,CAAA,eAAe,CAAE,CAAA,MAAA;AAAA,IACxD,YAAA;AAAA,IACA,gBAAA;AAAA,IACA;AAAA,GACF;AAKA,EAAI,IAAA,CAAC,OAAS,EAAA,QAAA,EAAU,IAAI,CAAA,CAAE,SAAS,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,MAAM,CAAG,EAAA;AACjE,IAAa,UAAA,GAAA,UAAA,CAAW,SAAU,EAAA,CAAE,UAAW,EAAA;AAAA;AAGjD,EAAM,MAAA,KAAA,GAAQ,MAAM,UACjB,CAAA,YAAA,CAAa,gBAAgB,CAC7B,CAAA,YAAA,CAAa,oBAAoB,CAAA,CACjC,KAAM,CAAA,gBAAA,EAAkB,MAAM,IAAK,CAAA,EAAA,CAAG,KAAK,CAAA,CAC3C,QAAQ,gBAAkB,EAAA,KAAK,CAC/B,CAAA,KAAA,CAAM,SAAS,CAAA;AAElB,EAAI,IAAA,CAAC,MAAM,MAAQ,EAAA;AACjB,IAAA,OAAO,EAAC;AAAA;AAGV,EAAM,MAAA,IAAA,CAAwB,eAAe,CAC1C,CAAA,OAAA;AAAA,IACC,YAAA;AAAA,IACA,KAAM,CAAA,GAAA,CAAI,CAAK,CAAA,KAAA,CAAA,CAAE,UAAU;AAAA,GAG5B,CAAA,YAAA,CAAa,oBAAoB,CAAA,CACjC,MAAO,CAAA;AAAA,IACN,cAAA,EAAgB,OAAQ,CAAA,IAAA,EAAM,aAAa;AAAA,GAC5C,CAAA;AAEH,EAAO,OAAA,KAAA,CAAM,IAAI,CAAM,CAAA,MAAA;AAAA,IACrB,WAAW,CAAE,CAAA,UAAA;AAAA,IACb,cAAc,CAAE,CAAA,kBAAA;AAAA,IAChB,iBAAA,EAAmBA,8BAAoB,CAAA,CAAA,CAAE,cAAe;AAAA,GACxD,CAAA,CAAA;AACJ;AAEA,SAAS,OAAA,CAAQ,MAAY,QAAmC,EAAA;AAC9D,EAAM,MAAA,OAAA,GAAUC,4BAAuB,CAAA,QAAQ,CAAI,GAAA,GAAA;AACnD,EAAA,IAAI,KAAK,MAAO,CAAA,MAAA,CAAO,MAAO,CAAA,QAAA,CAAS,SAAS,CAAG,EAAA;AACjD,IAAA,OAAO,KAAK,GAAI,CAAA,CAAA,kBAAA,CAAA,EAAsB,CAAC,CAAG,EAAA,OAAO,UAAU,CAAC,CAAA;AAAA,aACnD,IAAK,CAAA,MAAA,CAAO,OAAO,MAAO,CAAA,QAAA,CAAS,OAAO,CAAG,EAAA;AACtD,IAAA,OAAO,IAAK,CAAA,GAAA,CAAI,CAAoB,iBAAA,EAAA,OAAO,CAAS,OAAA,CAAA,CAAA;AAAA;AAEtD,EAAA,OAAO,IAAK,CAAA,GAAA,CAAI,CAAqB,kBAAA,EAAA,OAAO,CAAW,SAAA,CAAA,CAAA;AACzD;;;;"}