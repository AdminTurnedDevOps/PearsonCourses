'use strict';

var catalogModel = require('@backstage/catalog-model');

async function updateUnprocessedEntity(options) {
  const { tx, entity, hash, locationKey } = options;
  const entityRef = catalogModel.stringifyEntityRef(entity);
  const serializedEntity = JSON.stringify(entity);
  const refreshResult = await tx("refresh_state").update({
    unprocessed_entity: serializedEntity,
    unprocessed_hash: hash,
    location_key: locationKey,
    last_discovery_at: tx.fn.now(),
    // We only get to this point if a processed entity actually had any changes, or
    // if an entity provider requested this mutation, meaning that we can safely
    // bump the deferred entities to the front of the queue for immediate processing.
    next_update_at: tx.fn.now()
  }).where("entity_ref", entityRef).andWhere((inner) => {
    if (!locationKey) {
      return inner.whereNull("location_key");
    }
    return inner.where("location_key", locationKey).orWhereNull("location_key");
  });
  return refreshResult === 1;
}

exports.updateUnprocessedEntity = updateUnprocessedEntity;
//# sourceMappingURL=updateUnprocessedEntity.cjs.js.map
