{"version":3,"file":"insertUnprocessedEntity.cjs.js","sources":["../../../../src/database/operations/refreshState/insertUnprocessedEntity.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, stringifyEntityRef } from '@backstage/catalog-model';\nimport { Knex } from 'knex';\nimport { DbRefreshStateRow } from '../../tables';\nimport { v4 as uuid } from 'uuid';\nimport {\n  LoggerService,\n  isDatabaseConflictError,\n} from '@backstage/backend-plugin-api';\n\n/**\n * Attempts to insert a new refresh state row for the given entity, returning\n * true if successful and false if there was a conflict.\n */\nexport async function insertUnprocessedEntity(options: {\n  tx: Knex | Knex.Transaction;\n  entity: Entity;\n  hash: string;\n  locationKey?: string;\n  logger: LoggerService;\n}): Promise<boolean> {\n  const { tx, entity, hash, logger, locationKey } = options;\n\n  const entityRef = stringifyEntityRef(entity);\n  const serializedEntity = JSON.stringify(entity);\n\n  try {\n    let query = tx<DbRefreshStateRow>('refresh_state').insert({\n      entity_id: uuid(),\n      entity_ref: entityRef,\n      unprocessed_entity: serializedEntity,\n      unprocessed_hash: hash,\n      errors: '',\n      location_key: locationKey,\n      next_update_at: tx.fn.now(),\n      last_discovery_at: tx.fn.now(),\n    });\n\n    // TODO(Rugvip): only tested towards MySQL, Postgres and SQLite.\n    // We have to do this because the only way to detect if there was a conflict with\n    // SQLite is to catch the error, while Postgres needs to ignore the conflict to not\n    // break the ongoing transaction.\n    if (tx.client.config.client.includes('pg')) {\n      query = query.onConflict('entity_ref').ignore() as any; // type here does not match runtime\n    }\n\n    // Postgres gives as an object with rowCount, SQLite gives us an array\n    const result: { rowCount?: number; length?: number } = await query;\n    return result.rowCount === 1 || result.length === 1;\n  } catch (error) {\n    // SQLite, or MySQL reached this rather than the rowCount check above\n    if (!isDatabaseConflictError(error)) {\n      throw error;\n    } else {\n      logger.debug(`Unable to insert a new refresh state row, ${error}`);\n      return false;\n    }\n  }\n}\n"],"names":["stringifyEntityRef","uuid","isDatabaseConflictError"],"mappings":";;;;;;AA6BA,eAAsB,wBAAwB,OAMzB,EAAA;AACnB,EAAA,MAAM,EAAE,EAAI,EAAA,MAAA,EAAQ,IAAM,EAAA,MAAA,EAAQ,aAAgB,GAAA,OAAA;AAElD,EAAM,MAAA,SAAA,GAAYA,gCAAmB,MAAM,CAAA;AAC3C,EAAM,MAAA,gBAAA,GAAmB,IAAK,CAAA,SAAA,CAAU,MAAM,CAAA;AAE9C,EAAI,IAAA;AACF,IAAA,IAAI,KAAQ,GAAA,EAAA,CAAsB,eAAe,CAAA,CAAE,MAAO,CAAA;AAAA,MACxD,WAAWC,OAAK,EAAA;AAAA,MAChB,UAAY,EAAA,SAAA;AAAA,MACZ,kBAAoB,EAAA,gBAAA;AAAA,MACpB,gBAAkB,EAAA,IAAA;AAAA,MAClB,MAAQ,EAAA,EAAA;AAAA,MACR,YAAc,EAAA,WAAA;AAAA,MACd,cAAA,EAAgB,EAAG,CAAA,EAAA,CAAG,GAAI,EAAA;AAAA,MAC1B,iBAAA,EAAmB,EAAG,CAAA,EAAA,CAAG,GAAI;AAAA,KAC9B,CAAA;AAMD,IAAA,IAAI,GAAG,MAAO,CAAA,MAAA,CAAO,MAAO,CAAA,QAAA,CAAS,IAAI,CAAG,EAAA;AAC1C,MAAA,KAAA,GAAQ,KAAM,CAAA,UAAA,CAAW,YAAY,CAAA,CAAE,MAAO,EAAA;AAAA;AAIhD,IAAA,MAAM,SAAiD,MAAM,KAAA;AAC7D,IAAA,OAAO,MAAO,CAAA,QAAA,KAAa,CAAK,IAAA,MAAA,CAAO,MAAW,KAAA,CAAA;AAAA,WAC3C,KAAO,EAAA;AAEd,IAAI,IAAA,CAACC,wCAAwB,CAAA,KAAK,CAAG,EAAA;AACnC,MAAM,MAAA,KAAA;AAAA,KACD,MAAA;AACL,MAAO,MAAA,CAAA,KAAA,CAAM,CAA6C,0CAAA,EAAA,KAAK,CAAE,CAAA,CAAA;AACjE,MAAO,OAAA,KAAA;AAAA;AACT;AAEJ;;;;"}