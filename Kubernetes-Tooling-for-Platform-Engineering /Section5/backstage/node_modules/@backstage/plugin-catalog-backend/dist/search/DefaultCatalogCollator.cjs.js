'use strict';

var catalogModel = require('@backstage/catalog-model');
var catalogClient = require('@backstage/catalog-client');
var alpha = require('@backstage/plugin-catalog-common/alpha');

class DefaultCatalogCollator {
  discovery;
  locationTemplate;
  filter;
  catalogClient;
  type = "software-catalog";
  visibilityPermission = alpha.catalogEntityReadPermission;
  tokenManager;
  static fromConfig(_config, options) {
    return new DefaultCatalogCollator({
      ...options
    });
  }
  constructor(options) {
    const { discovery, locationTemplate, filter, catalogClient: catalogClient$1, tokenManager } = options;
    this.discovery = discovery;
    this.locationTemplate = locationTemplate || "/catalog/:namespace/:kind/:name";
    this.filter = filter;
    this.catalogClient = catalogClient$1 || new catalogClient.CatalogClient({ discoveryApi: discovery });
    this.tokenManager = tokenManager;
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted.toLowerCase();
  }
  getDocumentText(entity) {
    let documentText = entity.metadata.description || "";
    if (catalogModel.isUserEntity(entity)) {
      if (entity.spec?.profile?.displayName && documentText) {
        const displayName = entity.spec?.profile?.displayName;
        documentText = displayName.concat(" : ", documentText);
      } else {
        documentText = entity.spec?.profile?.displayName || documentText;
      }
    }
    return documentText;
  }
  async execute() {
    const { token } = await this.tokenManager.getToken();
    const response = await this.catalogClient.getEntities(
      {
        filter: this.filter
      },
      { token }
    );
    return response.items.map((entity) => {
      return {
        title: entity.metadata.title ? `${entity.metadata.title} (${entity.metadata.name})` : entity.metadata.name,
        location: this.applyArgsToFormat(this.locationTemplate, {
          namespace: entity.metadata.namespace || "default",
          kind: entity.kind,
          name: entity.metadata.name
        }),
        text: this.getDocumentText(entity),
        componentType: entity.spec?.type?.toString() || "other",
        type: entity.spec?.type?.toString() || "other",
        namespace: entity.metadata.namespace || "default",
        kind: entity.kind,
        lifecycle: entity.spec?.lifecycle || "",
        owner: entity.spec?.owner || "",
        authorization: {
          resourceRef: catalogModel.stringifyEntityRef(entity)
        }
      };
    });
  }
}

exports.DefaultCatalogCollator = DefaultCatalogCollator;
//# sourceMappingURL=DefaultCatalogCollator.cjs.js.map
