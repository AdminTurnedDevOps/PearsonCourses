{"version":3,"file":"PlaceholderProcessor.cjs.js","sources":["../../src/processors/PlaceholderProcessor.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { JsonValue } from '@backstage/types';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport yaml from 'yaml';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport {\n  CatalogProcessor,\n  CatalogProcessorEmit,\n  PlaceholderResolver,\n  PlaceholderResolverParams,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\nimport { UrlReaderService } from '@backstage/backend-plugin-api';\n\n/** @public */\nexport type PlaceholderProcessorOptions = {\n  resolvers: Record<string, PlaceholderResolver>;\n  reader: UrlReaderService;\n  integrations: ScmIntegrationRegistry;\n};\n\n/**\n * Traverses raw entity JSON looking for occurrences of $-prefixed placeholders\n * that it then fills in with actual data.\n * @public\n */\nexport class PlaceholderProcessor implements CatalogProcessor {\n  constructor(private readonly options: PlaceholderProcessorOptions) {}\n\n  getProcessorName(): string {\n    return 'PlaceholderProcessor';\n  }\n\n  async preProcessEntity(\n    entity: Entity,\n    location: LocationSpec,\n    emit: CatalogProcessorEmit,\n  ): Promise<Entity> {\n    const process = async (data: any): Promise<[any, boolean]> => {\n      if (!data || !(data instanceof Object)) {\n        // Scalars can't have placeholders\n        return [data, false];\n      }\n\n      if (Array.isArray(data)) {\n        // We're an array - process all entries recursively\n        const items = await Promise.all(data.map(item => process(item)));\n        return items.every(([, changed]) => !changed)\n          ? [data, false]\n          : [items.map(([item]) => item), true];\n      }\n\n      const keys = Object.keys(data);\n      if (!keys.some(k => k.startsWith('$'))) {\n        // We're an object but no placeholders at this level - process all\n        // entries recursively\n        const entries = await Promise.all(\n          Object.entries(data).map(([k, v]) =>\n            process(v).then(vp => [k, vp] as const),\n          ),\n        );\n        return entries.every(([, [, changed]]) => !changed)\n          ? [data, false]\n          : [Object.fromEntries(entries.map(([k, [v]]) => [k, v])), true];\n      } else if (keys.length !== 1) {\n        // This was an object that had more than one key, some of which were\n        // dollar prefixed. We only handle the case where there is exactly one\n        // such key; anything else is left alone.\n        return [data, false];\n      }\n\n      const resolverKey = keys[0].substring(1);\n      const resolverValue = data[keys[0]];\n\n      const resolver = this.options.resolvers[resolverKey];\n      if (!resolver) {\n        // If there was no such placeholder resolver, we err on the side of safety\n        // and assume that this is something that's best left alone. For example, if\n        // the input contains JSONSchema, there may be \"$ref\": \"#/definitions/node\"\n        // nodes in the document.\n        return [data, false];\n      }\n\n      const read = async (url: string): Promise<Buffer> => {\n        const response = await this.options.reader.readUrl(url);\n        const buffer = await response.buffer();\n        return buffer;\n      };\n\n      const resolveUrl = (url: string, base: string): string =>\n        this.options.integrations.resolveUrl({\n          url,\n          base,\n        });\n\n      return [\n        await resolver({\n          key: resolverKey,\n          value: resolverValue,\n          baseUrl: location.target,\n          read,\n          resolveUrl,\n          emit,\n        }),\n        true,\n      ];\n    };\n\n    const [result] = await process(entity);\n    return result;\n  }\n}\n\n/*\n * Resolvers\n */\n\nexport async function yamlPlaceholderResolver(\n  params: PlaceholderResolverParams,\n): Promise<JsonValue> {\n  const { content, url } = await readTextLocation(params);\n\n  params.emit(processingResult.refresh(`url:${url}`));\n\n  let documents: yaml.Document.Parsed[];\n  try {\n    documents = yaml.parseAllDocuments(content).filter(d => d);\n  } catch (e) {\n    throw new Error(\n      `Placeholder \\$${params.key} failed to parse YAML data at ${params.value}, ${e}`,\n    );\n  }\n\n  if (documents.length !== 1) {\n    throw new Error(\n      `Placeholder \\$${params.key} expected to find exactly one document of data at ${params.value}, found ${documents.length}`,\n    );\n  }\n\n  const document = documents[0];\n\n  if (document.errors?.length) {\n    throw new Error(\n      `Placeholder \\$${params.key} found an error in the data at ${params.value}, ${document.errors[0]}`,\n    );\n  }\n\n  return document.toJSON();\n}\n\nexport async function jsonPlaceholderResolver(\n  params: PlaceholderResolverParams,\n): Promise<JsonValue> {\n  const { content, url } = await readTextLocation(params);\n\n  params.emit(processingResult.refresh(`url:${url}`));\n\n  try {\n    return JSON.parse(content);\n  } catch (e) {\n    throw new Error(\n      `Placeholder \\$${params.key} failed to parse JSON data at ${params.value}, ${e}`,\n    );\n  }\n}\n\nexport async function textPlaceholderResolver(\n  params: PlaceholderResolverParams,\n): Promise<JsonValue> {\n  const { content, url } = await readTextLocation(params);\n\n  params.emit(processingResult.refresh(`url:${url}`));\n\n  return content;\n}\n\n/*\n * Helpers\n */\n\nasync function readTextLocation(\n  params: PlaceholderResolverParams,\n): Promise<{ content: string; url: string }> {\n  const newUrl = relativeUrl(params);\n\n  try {\n    const data = await params.read(newUrl);\n    return { content: data.toString('utf-8'), url: newUrl };\n  } catch (e) {\n    throw new Error(\n      `Placeholder \\$${params.key} could not read location ${params.value}, ${e}`,\n    );\n  }\n}\n\nfunction relativeUrl({\n  key,\n  value,\n  baseUrl,\n  resolveUrl,\n}: PlaceholderResolverParams): string {\n  if (typeof value !== 'string') {\n    throw new Error(\n      `Placeholder \\$${key} expected a string value parameter, in the form of an absolute URL or a relative path`,\n    );\n  }\n\n  try {\n    return resolveUrl(value, baseUrl);\n  } catch (e) {\n    // The only remaining case that isn't support is a relative file path that should be\n    // resolved using a relative file location. Accessing local file paths can lead to\n    // path traversal attacks and access to any file on the host system. Implementing this\n    // would require additional security measures.\n    throw new Error(\n      `Placeholder \\$${key} could not form a URL out of ${baseUrl} and ${value}, ${e}`,\n    );\n  }\n}\n"],"names":["processingResult","yaml"],"mappings":"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"}