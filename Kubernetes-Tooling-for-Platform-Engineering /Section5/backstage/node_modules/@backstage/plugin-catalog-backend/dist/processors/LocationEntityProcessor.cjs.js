'use strict';

var path = require('path');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

function toAbsoluteUrl(integrations, base, target) {
  try {
    if (base.type === "file") {
      if (target.startsWith(".")) {
        return path__default.default.join(path__default.default.dirname(base.target), target);
      }
      return target;
    }
    return integrations.resolveUrl({ url: target, base: base.target });
  } catch (e) {
    return target;
  }
}
class LocationEntityProcessor {
  constructor(options) {
    this.options = options;
  }
  getProcessorName() {
    return "LocationEntityProcessor";
  }
  async postProcessEntity(entity, location, emit) {
    if (entity.kind === "Location") {
      const locationEntity = entity;
      const type = locationEntity.spec.type || location.type;
      if (type === "file" && location.target.endsWith(path__default.default.sep)) {
        emit(
          pluginCatalogNode.processingResult.inputError(
            location,
            `LocationEntityProcessor cannot handle ${type} type location with target ${location.target} that ends with a path separator`
          )
        );
      }
      const targets = new Array();
      if (locationEntity.spec.target) {
        targets.push(locationEntity.spec.target);
      }
      if (locationEntity.spec.targets) {
        targets.push(...locationEntity.spec.targets);
      }
      for (const maybeRelativeTarget of targets) {
        const target = toAbsoluteUrl(
          this.options.integrations,
          location,
          maybeRelativeTarget
        );
        emit(pluginCatalogNode.processingResult.location({ type, target }));
      }
    }
    return entity;
  }
}

exports.LocationEntityProcessor = LocationEntityProcessor;
exports.toAbsoluteUrl = toAbsoluteUrl;
//# sourceMappingURL=LocationEntityProcessor.cjs.js.map
