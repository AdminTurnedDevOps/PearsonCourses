'use strict';

var errors = require('@backstage/errors');
var limiterFactory = require('p-limit');
var parseGitUrl = require('git-url-parse');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);

const CACHE_KEY = "v1";
class UrlReaderProcessor {
  constructor(options) {
    this.options = options;
    this.#limiter = limiterFactory__default.default(5);
  }
  // This limiter is used for only consuming a limited number of read streams
  // concurrently.
  #limiter;
  getProcessorName() {
    return "url-reader";
  }
  async readLocation(location, optional, emit, parser, cache) {
    if (location.type !== "url") {
      return false;
    }
    const cacheItem = await cache.get(CACHE_KEY);
    try {
      const { response, etag: newEtag } = await this.doRead(
        location.target,
        cacheItem?.etag
      );
      const parseResults = [];
      for (const item of response) {
        for await (const parseResult of parser({
          data: item.data,
          location: { type: location.type, target: item.url }
        })) {
          parseResults.push(parseResult);
          emit(parseResult);
        }
      }
      const isOnlyEntities = parseResults.every((r) => r.type === "entity");
      if (newEtag && isOnlyEntities) {
        await cache.set(CACHE_KEY, {
          etag: newEtag,
          value: parseResults
        });
      }
      emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
    } catch (error) {
      errors.assertError(error);
      const message = `Unable to read ${location.type}, ${error}`.substring(
        0,
        5e3
      );
      if (error.name === "NotModifiedError" && cacheItem) {
        for (const parseResult of cacheItem.value) {
          emit(parseResult);
        }
        emit(pluginCatalogNode.processingResult.refresh(`${location.type}:${location.target}`));
        await cache.set(CACHE_KEY, cacheItem);
      } else if (error.name === "NotFoundError") {
        if (!optional) {
          emit(pluginCatalogNode.processingResult.notFoundError(location, message));
        }
      } else {
        emit(pluginCatalogNode.processingResult.generalError(location, message));
      }
    }
    return true;
  }
  async doRead(location, etag) {
    const { filepath } = parseGitUrl__default.default(location);
    if (filepath?.match(/[*?]/)) {
      const response = await this.options.reader.search(location, { etag });
      const output = response.files.map(async (file) => ({
        url: file.url,
        data: await this.#limiter(file.content)
      }));
      return { response: await Promise.all(output), etag: response.etag };
    }
    const data = await this.options.reader.readUrl(location, { etag });
    return {
      response: [{ url: location, data: await data.buffer() }],
      etag: data.etag
    };
  }
}

exports.UrlReaderProcessor = UrlReaderProcessor;
//# sourceMappingURL=UrlReaderProcessor.cjs.js.map
