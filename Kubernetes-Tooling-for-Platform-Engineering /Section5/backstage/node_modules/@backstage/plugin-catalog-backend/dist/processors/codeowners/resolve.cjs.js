'use strict';

var codeowners = require('codeowners-utils');
var parseGitUrl = require('git-url-parse');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var codeowners__namespace = /*#__PURE__*/_interopNamespaceCompat(codeowners);
var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);

const USER_PATTERN = /^@.*/;
const GROUP_PATTERN = /^@.*\/.*/;
const EMAIL_PATTERN = /^.*@.*\..*$/;
function resolveCodeOwner(contents, catalogInfoFileUrl) {
  const codeOwnerEntries = codeowners__namespace.parse(contents);
  const { filepath } = parseGitUrl__default.default(catalogInfoFileUrl);
  const match = codeowners__namespace.matchFile(filepath, codeOwnerEntries);
  return match ? normalizeCodeOwner(match.owners[0]) : void 0;
}
function normalizeCodeOwner(owner) {
  if (owner.match(GROUP_PATTERN)) {
    return owner.split("/")[1];
  } else if (owner.match(USER_PATTERN)) {
    return `User:${owner.substring(1)}`;
  } else if (owner.match(EMAIL_PATTERN)) {
    return owner.split("@")[0];
  }
  return owner;
}

exports.normalizeCodeOwner = normalizeCodeOwner;
exports.resolveCodeOwner = resolveCodeOwner;
//# sourceMappingURL=resolve.cjs.js.map
