'use strict';

var fs = require('fs-extra');
var g = require('glob');
var path = require('path');
var util = require('util');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var g__default = /*#__PURE__*/_interopDefaultCompat(g);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const glob = util.promisify(g__default.default);
const LOCATION_TYPE = "file";
class FileReaderProcessor {
  getProcessorName() {
    return "FileReaderProcessor";
  }
  async readLocation(location, optional, emit, parser) {
    if (location.type !== LOCATION_TYPE) {
      return false;
    }
    try {
      const fileMatches = await glob(location.target);
      if (fileMatches.length > 0) {
        for (const fileMatch of fileMatches) {
          const data = await fs__default.default.readFile(fileMatch);
          const normalizedFilePath = path__default.default.normalize(fileMatch);
          for await (const parseResult of parser({
            data,
            location: {
              type: LOCATION_TYPE,
              target: normalizedFilePath
            }
          })) {
            emit(parseResult);
            emit(
              pluginCatalogNode.processingResult.refresh(
                `${LOCATION_TYPE}:${normalizedFilePath}`
              )
            );
          }
        }
      } else if (!optional) {
        const message = `${location.type} ${location.target} does not exist`;
        emit(pluginCatalogNode.processingResult.notFoundError(location, message));
      }
    } catch (e) {
      const message = `${location.type} ${location.target} could not be read, ${e}`;
      emit(pluginCatalogNode.processingResult.generalError(location, message));
    }
    return true;
  }
}

exports.FileReaderProcessor = FileReaderProcessor;
//# sourceMappingURL=FileReaderProcessor.cjs.js.map
