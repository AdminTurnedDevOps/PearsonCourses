'use strict';

var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');

const commitHashRegExp = /\b[0-9a-f]{40,}\b/;
class AnnotateLocationEntityProcessor {
  constructor(options) {
    this.options = options;
  }
  getProcessorName() {
    return "AnnotateLocationEntityProcessor";
  }
  async preProcessEntity(entity, location, _, originLocation) {
    const { integrations } = this.options;
    let viewUrl;
    let editUrl;
    let sourceLocation;
    if (location.type === "url") {
      const scmIntegration = integrations.byUrl(location.target);
      viewUrl = location.target;
      if (!commitHashRegExp.test(location.target)) {
        editUrl = scmIntegration?.resolveEditUrl(location.target);
      }
      const sourceUrl = scmIntegration?.resolveUrl({
        url: "./",
        base: location.target
      });
      if (sourceUrl) {
        sourceLocation = catalogModel.stringifyLocationRef({
          type: "url",
          target: sourceUrl
        });
      }
    }
    return lodash.merge(
      {
        metadata: {
          annotations: lodash.pickBy(
            {
              [catalogModel.ANNOTATION_LOCATION]: catalogModel.stringifyLocationRef(location),
              [catalogModel.ANNOTATION_ORIGIN_LOCATION]: catalogModel.stringifyLocationRef(originLocation),
              [catalogModel.ANNOTATION_VIEW_URL]: viewUrl,
              [catalogModel.ANNOTATION_EDIT_URL]: editUrl,
              [catalogModel.ANNOTATION_SOURCE_LOCATION]: sourceLocation
            },
            lodash.identity
          )
        }
      },
      entity
    );
  }
}

exports.AnnotateLocationEntityProcessor = AnnotateLocationEntityProcessor;
//# sourceMappingURL=AnnotateLocationEntityProcessor.cjs.js.map
