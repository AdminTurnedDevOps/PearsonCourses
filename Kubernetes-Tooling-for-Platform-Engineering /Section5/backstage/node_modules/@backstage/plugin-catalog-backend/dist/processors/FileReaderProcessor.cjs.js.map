{"version":3,"file":"FileReaderProcessor.cjs.js","sources":["../../src/processors/FileReaderProcessor.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport g from 'glob';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport {\n  CatalogProcessor,\n  CatalogProcessorEmit,\n  CatalogProcessorParser,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\n\nconst glob = promisify(g);\n\nconst LOCATION_TYPE = 'file';\n\n/** @public */\nexport class FileReaderProcessor implements CatalogProcessor {\n  getProcessorName(): string {\n    return 'FileReaderProcessor';\n  }\n\n  async readLocation(\n    location: LocationSpec,\n    optional: boolean,\n    emit: CatalogProcessorEmit,\n    parser: CatalogProcessorParser,\n  ): Promise<boolean> {\n    if (location.type !== LOCATION_TYPE) {\n      return false;\n    }\n\n    try {\n      const fileMatches = await glob(location.target);\n\n      if (fileMatches.length > 0) {\n        for (const fileMatch of fileMatches) {\n          const data = await fs.readFile(fileMatch);\n          const normalizedFilePath = path.normalize(fileMatch);\n\n          // The normalize converts to native slashes; the glob library returns\n          // forward slashes even on windows\n          for await (const parseResult of parser({\n            data: data,\n            location: {\n              type: LOCATION_TYPE,\n              target: normalizedFilePath,\n            },\n          })) {\n            emit(parseResult);\n            emit(\n              processingResult.refresh(\n                `${LOCATION_TYPE}:${normalizedFilePath}`,\n              ),\n            );\n          }\n        }\n      } else if (!optional) {\n        const message = `${location.type} ${location.target} does not exist`;\n        emit(processingResult.notFoundError(location, message));\n      }\n    } catch (e) {\n      const message = `${location.type} ${location.target} could not be read, ${e}`;\n      emit(processingResult.generalError(location, message));\n    }\n\n    return true;\n  }\n}\n"],"names":["promisify","g","fs","path","processingResult"],"mappings":";;;;;;;;;;;;;;AA4BA,MAAM,IAAA,GAAOA,eAAUC,kBAAC,CAAA;AAExB,MAAM,aAAgB,GAAA,MAAA;AAGf,MAAM,mBAAgD,CAAA;AAAA,EAC3D,gBAA2B,GAAA;AACzB,IAAO,OAAA,qBAAA;AAAA;AACT,EAEA,MAAM,YAAA,CACJ,QACA,EAAA,QAAA,EACA,MACA,MACkB,EAAA;AAClB,IAAI,IAAA,QAAA,CAAS,SAAS,aAAe,EAAA;AACnC,MAAO,OAAA,KAAA;AAAA;AAGT,IAAI,IAAA;AACF,MAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,QAAA,CAAS,MAAM,CAAA;AAE9C,MAAI,IAAA,WAAA,CAAY,SAAS,CAAG,EAAA;AAC1B,QAAA,KAAA,MAAW,aAAa,WAAa,EAAA;AACnC,UAAA,MAAM,IAAO,GAAA,MAAMC,mBAAG,CAAA,QAAA,CAAS,SAAS,CAAA;AACxC,UAAM,MAAA,kBAAA,GAAqBC,qBAAK,CAAA,SAAA,CAAU,SAAS,CAAA;AAInD,UAAA,WAAA,MAAiB,eAAe,MAAO,CAAA;AAAA,YACrC,IAAA;AAAA,YACA,QAAU,EAAA;AAAA,cACR,IAAM,EAAA,aAAA;AAAA,cACN,MAAQ,EAAA;AAAA;AACV,WACD,CAAG,EAAA;AACF,YAAA,IAAA,CAAK,WAAW,CAAA;AAChB,YAAA,IAAA;AAAA,cACEC,kCAAiB,CAAA,OAAA;AAAA,gBACf,CAAA,EAAG,aAAa,CAAA,CAAA,EAAI,kBAAkB,CAAA;AAAA;AACxC,aACF;AAAA;AACF;AACF,OACF,MAAA,IAAW,CAAC,QAAU,EAAA;AACpB,QAAA,MAAM,UAAU,CAAG,EAAA,QAAA,CAAS,IAAI,CAAA,CAAA,EAAI,SAAS,MAAM,CAAA,eAAA,CAAA;AACnD,QAAA,IAAA,CAAKA,kCAAiB,CAAA,aAAA,CAAc,QAAU,EAAA,OAAO,CAAC,CAAA;AAAA;AACxD,aACO,CAAG,EAAA;AACV,MAAM,MAAA,OAAA,GAAU,GAAG,QAAS,CAAA,IAAI,IAAI,QAAS,CAAA,MAAM,uBAAuB,CAAC,CAAA,CAAA;AAC3E,MAAA,IAAA,CAAKA,kCAAiB,CAAA,YAAA,CAAa,QAAU,EAAA,OAAO,CAAC,CAAA;AAAA;AAGvD,IAAO,OAAA,IAAA;AAAA;AAEX;;;;"}