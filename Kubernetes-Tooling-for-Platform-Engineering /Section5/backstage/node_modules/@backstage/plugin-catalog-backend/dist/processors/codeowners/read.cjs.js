'use strict';

var errors = require('@backstage/errors');
require('core-js/features/promise');
var resolve = require('./resolve.cjs.js');
var scm = require('./scm.cjs.js');

async function readCodeOwners(reader, sourceUrl, codeownersPaths) {
  const readOwnerLocation = async (path) => {
    const url = `${sourceUrl}${path}`;
    const data = await reader.readUrl(url);
    const buffer = await data.buffer();
    return buffer.toString();
  };
  const candidates = codeownersPaths.map(readOwnerLocation);
  return Promise.any(candidates).catch((aggregateError) => {
    const hardError = aggregateError.errors.find(
      (error) => !(error instanceof errors.NotFoundError)
    );
    if (hardError) {
      throw hardError;
    }
    return void 0;
  });
}
async function findCodeOwnerByTarget(reader, targetUrl, scmIntegration) {
  const codeownersPaths = scm.scmCodeOwnersPaths[scmIntegration?.type ?? ""];
  const sourceUrl = scmIntegration?.resolveUrl({
    url: "/",
    base: targetUrl
  });
  if (!sourceUrl || !codeownersPaths) {
    return void 0;
  }
  const contents = await readCodeOwners(reader, sourceUrl, codeownersPaths);
  if (!contents) {
    return void 0;
  }
  const owner = resolve.resolveCodeOwner(contents, targetUrl);
  return owner;
}

exports.findCodeOwnerByTarget = findCodeOwnerByTarget;
exports.readCodeOwners = readCodeOwners;
//# sourceMappingURL=read.cjs.js.map
