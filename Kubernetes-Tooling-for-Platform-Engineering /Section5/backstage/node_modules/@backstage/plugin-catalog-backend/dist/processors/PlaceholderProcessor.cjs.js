'use strict';

var yaml = require('yaml');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);

class PlaceholderProcessor {
  constructor(options) {
    this.options = options;
  }
  getProcessorName() {
    return "PlaceholderProcessor";
  }
  async preProcessEntity(entity, location, emit) {
    const process = async (data) => {
      if (!data || !(data instanceof Object)) {
        return [data, false];
      }
      if (Array.isArray(data)) {
        const items = await Promise.all(data.map((item) => process(item)));
        return items.every(([, changed]) => !changed) ? [data, false] : [items.map(([item]) => item), true];
      }
      const keys = Object.keys(data);
      if (!keys.some((k) => k.startsWith("$"))) {
        const entries = await Promise.all(
          Object.entries(data).map(
            ([k, v]) => process(v).then((vp) => [k, vp])
          )
        );
        return entries.every(([, [, changed]]) => !changed) ? [data, false] : [Object.fromEntries(entries.map(([k, [v]]) => [k, v])), true];
      } else if (keys.length !== 1) {
        return [data, false];
      }
      const resolverKey = keys[0].substring(1);
      const resolverValue = data[keys[0]];
      const resolver = this.options.resolvers[resolverKey];
      if (!resolver) {
        return [data, false];
      }
      const read = async (url) => {
        const response = await this.options.reader.readUrl(url);
        const buffer = await response.buffer();
        return buffer;
      };
      const resolveUrl = (url, base) => this.options.integrations.resolveUrl({
        url,
        base
      });
      return [
        await resolver({
          key: resolverKey,
          value: resolverValue,
          baseUrl: location.target,
          read,
          resolveUrl,
          emit
        }),
        true
      ];
    };
    const [result] = await process(entity);
    return result;
  }
}
async function yamlPlaceholderResolver(params) {
  const { content, url } = await readTextLocation(params);
  params.emit(pluginCatalogNode.processingResult.refresh(`url:${url}`));
  let documents;
  try {
    documents = yaml__default.default.parseAllDocuments(content).filter((d) => d);
  } catch (e) {
    throw new Error(
      `Placeholder $${params.key} failed to parse YAML data at ${params.value}, ${e}`
    );
  }
  if (documents.length !== 1) {
    throw new Error(
      `Placeholder $${params.key} expected to find exactly one document of data at ${params.value}, found ${documents.length}`
    );
  }
  const document = documents[0];
  if (document.errors?.length) {
    throw new Error(
      `Placeholder $${params.key} found an error in the data at ${params.value}, ${document.errors[0]}`
    );
  }
  return document.toJSON();
}
async function jsonPlaceholderResolver(params) {
  const { content, url } = await readTextLocation(params);
  params.emit(pluginCatalogNode.processingResult.refresh(`url:${url}`));
  try {
    return JSON.parse(content);
  } catch (e) {
    throw new Error(
      `Placeholder $${params.key} failed to parse JSON data at ${params.value}, ${e}`
    );
  }
}
async function textPlaceholderResolver(params) {
  const { content, url } = await readTextLocation(params);
  params.emit(pluginCatalogNode.processingResult.refresh(`url:${url}`));
  return content;
}
async function readTextLocation(params) {
  const newUrl = relativeUrl(params);
  try {
    const data = await params.read(newUrl);
    return { content: data.toString("utf-8"), url: newUrl };
  } catch (e) {
    throw new Error(
      `Placeholder $${params.key} could not read location ${params.value}, ${e}`
    );
  }
}
function relativeUrl({
  key,
  value,
  baseUrl,
  resolveUrl
}) {
  if (typeof value !== "string") {
    throw new Error(
      `Placeholder $${key} expected a string value parameter, in the form of an absolute URL or a relative path`
    );
  }
  try {
    return resolveUrl(value, baseUrl);
  } catch (e) {
    throw new Error(
      `Placeholder $${key} could not form a URL out of ${baseUrl} and ${value}, ${e}`
    );
  }
}

exports.PlaceholderProcessor = PlaceholderProcessor;
exports.jsonPlaceholderResolver = jsonPlaceholderResolver;
exports.textPlaceholderResolver = textPlaceholderResolver;
exports.yamlPlaceholderResolver = yamlPlaceholderResolver;
//# sourceMappingURL=PlaceholderProcessor.cjs.js.map
