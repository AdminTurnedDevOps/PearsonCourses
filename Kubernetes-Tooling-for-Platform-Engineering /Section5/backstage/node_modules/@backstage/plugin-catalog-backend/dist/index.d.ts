/// <reference types="node" />
import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { LoggerService, UrlReaderService, DatabaseService, RootConfigService, PermissionsService, SchedulerService, DiscoveryService, AuthService, HttpAuthService } from '@backstage/backend-plugin-api';
import * as _backstage_catalog_model from '@backstage/catalog-model';
import { Entity, EntityPolicy, Validators } from '@backstage/catalog-model';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { LocationSpec as LocationSpec$1, CatalogEntityDocument, AnalyzeLocationRequest as AnalyzeLocationRequest$1, AnalyzeLocationResponse as AnalyzeLocationResponse$1, AnalyzeLocationExistingEntity as AnalyzeLocationExistingEntity$1, AnalyzeLocationGenerateEntity as AnalyzeLocationGenerateEntity$1, AnalyzeLocationEntityField as AnalyzeLocationEntityField$1 } from '@backstage/plugin-catalog-common';
import { CatalogProcessor as CatalogProcessor$1, CatalogProcessorEmit as CatalogProcessorEmit$1, CatalogProcessorParser as CatalogProcessorParser$1, PlaceholderResolver as PlaceholderResolver$1, CatalogProcessorCache as CatalogProcessorCache$1, EntitiesSearchFilter as EntitiesSearchFilter$1, LocationAnalyzer as LocationAnalyzer$1, EntityProvider as EntityProvider$1, ScmLocationAnalyzer as ScmLocationAnalyzer$1, locationSpecToMetadataName as locationSpecToMetadataName$1, locationSpecToLocationEntity as locationSpecToLocationEntity$1, CatalogProcessorResult as CatalogProcessorResult$1, EntityRelationSpec as EntityRelationSpec$1, EntityFilter as EntityFilter$1, DeferredEntity as DeferredEntity$1, CatalogProcessorLocationResult as CatalogProcessorLocationResult$1, CatalogProcessorEntityResult as CatalogProcessorEntityResult$1, CatalogProcessorRelationResult as CatalogProcessorRelationResult$1, CatalogProcessorErrorResult as CatalogProcessorErrorResult$1, CatalogProcessorRefreshKeysResult as CatalogProcessorRefreshKeysResult$1, EntityProviderConnection as EntityProviderConnection$1, EntityProviderMutation as EntityProviderMutation$1, AnalyzeOptions as AnalyzeOptions$1, PlaceholderResolverParams as PlaceholderResolverParams$1, PlaceholderResolverRead as PlaceholderResolverRead$1, PlaceholderResolverResolveUrl as PlaceholderResolverResolveUrl$1 } from '@backstage/plugin-catalog-node';
import { Config } from '@backstage/config';
import { PluginEndpointDiscovery, TokenManager } from '@backstage/backend-common';
import { GetEntitiesRequest, CatalogApi } from '@backstage/catalog-client';
import { Permission, PermissionRuleParams, PermissionAuthorizer } from '@backstage/plugin-permission-common';
import { Router } from 'express';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { EventBroker, EventsService } from '@backstage/plugin-events-node';
import { DefaultCatalogCollatorFactory as DefaultCatalogCollatorFactory$1, CatalogCollatorEntityTransformer as CatalogCollatorEntityTransformer$1, DefaultCatalogCollatorFactoryOptions as DefaultCatalogCollatorFactoryOptions$1 } from '@backstage/plugin-search-backend-module-catalog';

/**
 * Catalog plugin
 * @public
 */
declare const catalogPlugin: _backstage_backend_plugin_api.BackendFeature;

/** @public */
declare class AnnotateLocationEntityProcessor implements CatalogProcessor$1 {
    private readonly options;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
    });
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec$1, _: CatalogProcessorEmit$1, originLocation: LocationSpec$1): Promise<Entity>;
}

/** @public */
declare class AnnotateScmSlugEntityProcessor implements CatalogProcessor$1 {
    private readonly opts;
    constructor(opts: {
        scmIntegrationRegistry: ScmIntegrationRegistry;
        kinds?: string[];
    });
    getProcessorName(): string;
    static fromConfig(config: Config, options?: {
        kinds?: string[];
    }): AnnotateScmSlugEntityProcessor;
    preProcessEntity(entity: Entity, location: LocationSpec$1): Promise<Entity>;
}

/** @public */
declare class BuiltinKindsEntityProcessor implements CatalogProcessor$1 {
    private readonly validators;
    getProcessorName(): string;
    validateEntityKind(entity: Entity): Promise<boolean>;
    postProcessEntity(entity: Entity, _location: LocationSpec$1, emit: CatalogProcessorEmit$1): Promise<Entity>;
}

/** @public */
declare class CodeOwnersProcessor implements CatalogProcessor$1 {
    private readonly integrations;
    private readonly logger;
    private readonly reader;
    static fromConfig(config: Config, options: {
        logger: LoggerService;
        reader: UrlReaderService;
    }): CodeOwnersProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        logger: LoggerService;
        reader: UrlReaderService;
    });
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec$1): Promise<Entity>;
}

/** @public */
declare class FileReaderProcessor implements CatalogProcessor$1 {
    getProcessorName(): string;
    readLocation(location: LocationSpec$1, optional: boolean, emit: CatalogProcessorEmit$1, parser: CatalogProcessorParser$1): Promise<boolean>;
}

/**
 * @public
 * @deprecated This processor should no longer be used
 */
type LocationEntityProcessorOptions = {
    integrations: ScmIntegrationRegistry;
};
/**
 * Legacy processor, should not be used.
 *
 * @remarks
 *
 * In the old catalog architecture, this processor translated Location entities
 * into URLs that should be fetched. This is no longer needed since the engine
 * handles this internally.
 *
 * @public
 * @deprecated This processor should no longer be used
 */
declare class LocationEntityProcessor implements CatalogProcessor$1 {
    private readonly options;
    constructor(options: LocationEntityProcessorOptions);
    getProcessorName(): string;
    postProcessEntity(entity: Entity, location: LocationSpec$1, emit: CatalogProcessorEmit$1): Promise<Entity>;
}

/** @public */
type PlaceholderProcessorOptions = {
    resolvers: Record<string, PlaceholderResolver$1>;
    reader: UrlReaderService;
    integrations: ScmIntegrationRegistry;
};
/**
 * Traverses raw entity JSON looking for occurrences of $-prefixed placeholders
 * that it then fills in with actual data.
 * @public
 */
declare class PlaceholderProcessor implements CatalogProcessor$1 {
    private readonly options;
    constructor(options: PlaceholderProcessorOptions);
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec$1, emit: CatalogProcessorEmit$1): Promise<Entity>;
}

/** @public */
declare class UrlReaderProcessor implements CatalogProcessor$1 {
    #private;
    private readonly options;
    constructor(options: {
        reader: UrlReaderService;
        logger: LoggerService;
    });
    getProcessorName(): string;
    readLocation(location: LocationSpec$1, optional: boolean, emit: CatalogProcessorEmit$1, parser: CatalogProcessorParser$1, cache: CatalogProcessorCache$1): Promise<boolean>;
    private doRead;
}

/**
 * Transform a given entity policy to an entity processor.
 * @param policy - The policy to transform
 * @returns A new entity processor that uses the entity policy.
 * @public
 */
declare function transformLegacyPolicyToProcessor(policy: EntityPolicy): CatalogProcessor$1;

/**
 * Represents the engine that drives the processing and stitching loops. Some
 * backend instances may choose to not call start, if they focus only on API
 * interactions.
 *
 * @public
 */
interface CatalogProcessingEngine {
    start(): Promise<void>;
    stop(): Promise<void>;
}

/**
 * Function that returns the catalog processing interval in seconds.
 * @public
 */
type ProcessingIntervalFunction = () => number;
/**
 * Creates a function that returns a random processing interval between minSeconds and maxSeconds.
 * @returns A {@link ProcessingIntervalFunction} that provides the next processing interval
 * @public
 */
declare function createRandomProcessingInterval(options: {
    minSeconds: number;
    maxSeconds: number;
}): ProcessingIntervalFunction;

/**
 * @public
 * @deprecated Upgrade to a more recent `@backstage/plugin-search-backend-node` and
 * use `DefaultCatalogCollatorFactory` instead.
 */
declare class DefaultCatalogCollator {
    protected discovery: PluginEndpointDiscovery;
    protected locationTemplate: string;
    protected filter?: GetEntitiesRequest['filter'];
    protected readonly catalogClient: CatalogApi;
    readonly type: string;
    readonly visibilityPermission: Permission;
    protected tokenManager: TokenManager;
    static fromConfig(_config: Config, options: {
        discovery: PluginEndpointDiscovery;
        tokenManager: TokenManager;
        filter?: GetEntitiesRequest['filter'];
    }): DefaultCatalogCollator;
    constructor(options: {
        discovery: PluginEndpointDiscovery;
        tokenManager: TokenManager;
        locationTemplate?: string;
        filter?: GetEntitiesRequest['filter'];
        catalogClient?: CatalogApi;
    });
    protected applyArgsToFormat(format: string, args: Record<string, string>): string;
    private getDocumentText;
    execute(): Promise<CatalogEntityDocument[]>;
}

/**
 * This is a duplicate of the alpha `CatalogPermissionRule` type, for use in the stable API.
 *
 * @public
 */
type CatalogPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<Entity, EntitiesSearchFilter$1, 'catalog-entity', TParams>;
/**
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 * @public
 */
type CatalogEnvironment = {
    logger: LoggerService;
    database: DatabaseService;
    config: RootConfigService;
    reader: UrlReaderService;
    permissions: PermissionsService | PermissionAuthorizer;
    scheduler?: SchedulerService;
    discovery?: DiscoveryService;
    auth?: AuthService;
    httpAuth?: HttpAuthService;
};
/**
 * A builder that helps wire up all of the component parts of the catalog.
 *
 * The touch points where you can replace or extend behavior are as follows:
 *
 * - Entity policies can be added or replaced. These are automatically run
 *   after the processors' pre-processing steps. All policies are given the
 *   chance to inspect the entity, and all of them have to pass in order for
 *   the entity to be considered valid from an overall point of view.
 * - Location analyzers can be added. These are responsible for analyzing
 *   repositories when onboarding them into the catalog, by finding
 *   catalog-info.yaml files and other artifacts that can help automatically
 *   register or create catalog data on the user's behalf.
 * - Placeholder resolvers can be replaced or added. These run on the raw
 *   structured data between the parsing and pre-processing steps, to replace
 *   dollar-prefixed entries with their actual values (like $file).
 * - Field format validators can be replaced. These check the format of
 *   individual core fields such as metadata.name, to ensure that they adhere
 *   to certain rules.
 * - Processors can be added or replaced. These implement the functionality of
 *   reading, parsing, validating, and processing the entity data before it is
 *   persisted in the catalog.
 *
 * @public
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 */
declare class CatalogBuilder {
    private readonly env;
    private entityPolicies;
    private entityPoliciesReplace;
    private placeholderResolvers;
    private fieldFormatValidators;
    private entityProviders;
    private processors;
    private locationAnalyzers;
    private processorsReplace;
    private parser;
    private onProcessingError?;
    private processingInterval;
    private locationAnalyzer;
    private readonly permissions;
    private readonly permissionRules;
    private allowedLocationType;
    private legacySingleProcessorValidation;
    private eventBroker?;
    /**
     * Creates a catalog builder.
     */
    static create(env: CatalogEnvironment): CatalogBuilder;
    private constructor();
    /**
     * Adds policies that are used to validate entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * @param policies - One or more policies
     */
    addEntityPolicy(...policies: Array<EntityPolicy | Array<EntityPolicy>>): CatalogBuilder;
    /**
     * Processing interval determines how often entities should be processed.
     * Seconds provided will be multiplied by 1.5
     * The default processing interval is 100-150 seconds.
     * setting this too low will potentially deplete request quotas to upstream services.
     */
    setProcessingIntervalSeconds(seconds: number): CatalogBuilder;
    /**
     * Overwrites the default processing interval function used to spread
     * entity updates in the catalog.
     */
    setProcessingInterval(processingInterval: ProcessingIntervalFunction): CatalogBuilder;
    /**
     * Overwrites the default location analyzer.
     */
    setLocationAnalyzer(locationAnalyzer: LocationAnalyzer$1): CatalogBuilder;
    /**
     * Sets what policies to use for validation of entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * This function replaces the default set of policies; use with care.
     *
     * @param policies - One or more policies
     */
    replaceEntityPolicies(policies: EntityPolicy[]): CatalogBuilder;
    /**
     * Adds, or overwrites, a handler for placeholders (e.g. $file) in entity
     * definition files.
     *
     * @param key - The key that identifies the placeholder, e.g. "file"
     * @param resolver - The resolver that gets values for this placeholder
     */
    setPlaceholderResolver(key: string, resolver: PlaceholderResolver$1): CatalogBuilder;
    /**
     * Sets the validator function to use for one or more special fields of an
     * entity. This is useful if the default rules for formatting of fields are
     * not sufficient.
     *
     * This function has no effect if used together with
     * {@link CatalogBuilder#replaceEntityPolicies}.
     *
     * @param validators - The (subset of) validators to set
     */
    setFieldFormatValidators(validators: Partial<Validators>): CatalogBuilder;
    /**
     * Adds or replaces entity providers. These are responsible for bootstrapping
     * the list of entities out of original data sources. For example, there is
     * one entity source for the config locations, and one for the database
     * stored locations. If you ingest entities out of a third party system, you
     * may want to implement that in terms of an entity provider as well.
     *
     * @param providers - One or more entity providers
     */
    addEntityProvider(...providers: Array<EntityProvider$1 | Array<EntityProvider$1>>): CatalogBuilder;
    /**
     * Adds entity processors. These are responsible for reading, parsing, and
     * processing entities before they are persisted in the catalog.
     *
     * @param processors - One or more processors
     */
    addProcessor(...processors: Array<CatalogProcessor$1 | Array<CatalogProcessor$1>>): CatalogBuilder;
    /**
     * Sets what entity processors to use. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog.
     *
     * This function replaces the default set of processors, consider using with
     * {@link CatalogBuilder#getDefaultProcessors}; use with care.
     *
     * @param processors - One or more processors
     */
    replaceProcessors(processors: CatalogProcessor$1[]): CatalogBuilder;
    /**
     * Returns the default list of entity processors. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog. Changing
     * the order of processing can give more control to custom processors.
     *
     * Consider using with {@link CatalogBuilder#replaceProcessors}
     *
     */
    getDefaultProcessors(): CatalogProcessor$1[];
    /**
     * Adds Location Analyzers. These are responsible for analyzing
     * repositories when onboarding them into the catalog, by finding
     * catalog-info.yaml files and other artifacts that can help automatically
     * register or create catalog data on the user's behalf.
     *
     * @param locationAnalyzers - One or more location analyzers
     */
    addLocationAnalyzers(...analyzers: Array<ScmLocationAnalyzer$1 | Array<ScmLocationAnalyzer$1>>): CatalogBuilder;
    /**
     * Sets up the catalog to use a custom parser for entity data.
     *
     * This is the function that gets called immediately after some raw entity
     * specification data has been read from a remote source, and needs to be
     * parsed and emitted as structured data.
     *
     * @param parser - The custom parser
     */
    setEntityDataParser(parser: CatalogProcessorParser$1): CatalogBuilder;
    /**
     * Adds additional permissions. See
     * {@link @backstage/plugin-permission-node#Permission}.
     *
     * @param permissions - Additional permissions
     */
    addPermissions(...permissions: Array<Permission | Array<Permission>>): this;
    /**
     * Adds additional permission rules. Permission rules are used to evaluate
     * catalog resources against queries. See
     * {@link @backstage/plugin-permission-node#PermissionRule}.
     *
     * @param permissionRules - Additional permission rules
     */
    addPermissionRules(...permissionRules: Array<CatalogPermissionRuleInput | Array<CatalogPermissionRuleInput>>): this;
    /**
     * Sets up the allowed location types from being registered via the location service.
     *
     * @param allowedLocationTypes - the allowed location types
     */
    setAllowedLocationTypes(allowedLocationTypes: string[]): CatalogBuilder;
    /**
     * Enables the legacy behaviour of canceling validation early whenever only a
     * single processor declares an entity kind to be valid.
     */
    useLegacySingleProcessorValidation(): this;
    /**
     * Enables the publishing of events for conflicts in the DefaultProcessingDatabase
     */
    setEventBroker(broker: EventBroker | EventsService): CatalogBuilder;
    /**
     * Wires up and returns all of the component parts of the catalog
     */
    build(): Promise<{
        processingEngine: CatalogProcessingEngine;
        router: Router;
    }>;
    subscribe(options: {
        onProcessingError: (event: {
            unprocessedEntity: Entity;
            errors: Error[];
        }) => Promise<void> | void;
    }): void;
    private buildEntityPolicy;
    private buildProcessors;
    private checkDeprecatedReaderProcessors;
    private checkMissingExternalProcessors;
    private static getDefaultProcessingInterval;
}

/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
declare const locationSpecToMetadataName: typeof locationSpecToMetadataName$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
declare const locationSpecToLocationEntity: typeof locationSpecToLocationEntity$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
declare const processingResult: Readonly<{
    readonly notFoundError: (atLocation: LocationSpec$1, message: string) => CatalogProcessorResult$1;
    readonly inputError: (atLocation: LocationSpec$1, message: string) => CatalogProcessorResult$1;
    readonly generalError: (atLocation: LocationSpec$1, message: string) => CatalogProcessorResult$1;
    readonly location: (newLocation: LocationSpec$1) => CatalogProcessorResult$1;
    readonly entity: (atLocation: LocationSpec$1, newEntity: _backstage_catalog_model.Entity) => CatalogProcessorResult$1;
    readonly relation: (spec: EntityRelationSpec$1) => CatalogProcessorResult$1;
    readonly refresh: (key: string) => CatalogProcessorResult$1;
}>;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntitiesSearchFilter = EntitiesSearchFilter$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntityFilter = EntityFilter$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type DeferredEntity = DeferredEntity$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntityRelationSpec = EntityRelationSpec$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessor = CatalogProcessor$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorParser = CatalogProcessorParser$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorCache = CatalogProcessorCache$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorEmit = CatalogProcessorEmit$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorLocationResult = CatalogProcessorLocationResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorEntityResult = CatalogProcessorEntityResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorRelationResult = CatalogProcessorRelationResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorErrorResult = CatalogProcessorErrorResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorRefreshKeysResult = CatalogProcessorRefreshKeysResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type CatalogProcessorResult = CatalogProcessorResult$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntityProvider = EntityProvider$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntityProviderConnection = EntityProviderConnection$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type EntityProviderMutation = EntityProviderMutation$1;
/**
 * Holds the entity location information.
 *
 * @remarks
 *
 *  `presence` flag: when using repo importer plugin, location is being created before the component yaml file is merged to the main branch.
 *  This flag is then set to indicate that the file can be not present.
 *  default value: 'required'.
 *
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type LocationSpec = LocationSpec$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type AnalyzeOptions = AnalyzeOptions$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type LocationAnalyzer = LocationAnalyzer$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type ScmLocationAnalyzer = ScmLocationAnalyzer$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type PlaceholderResolver = PlaceholderResolver$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type PlaceholderResolverParams = PlaceholderResolverParams$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type PlaceholderResolverRead = PlaceholderResolverRead$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-catalog-node` instead
 */
type PlaceholderResolverResolveUrl = PlaceholderResolverResolveUrl$1;
/**
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type AnalyzeLocationRequest = AnalyzeLocationRequest$1;
/**
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type AnalyzeLocationResponse = AnalyzeLocationResponse$1;
/**
 * If the folder pointed to already contained catalog info yaml files, they are
 * read and emitted like this so that the frontend can inform the user that it
 * located them and can make sure to register them as well if they weren't
 * already
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type AnalyzeLocationExistingEntity = AnalyzeLocationExistingEntity$1;
/**
 * This is some form of representation of what the analyzer could deduce.
 * We should probably have a chat about how this can best be conveyed to
 * the frontend. It'll probably contain a (possibly incomplete) entity, plus
 * enough info for the frontend to know what form data to show to the user
 * for overriding/completing the info.
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type AnalyzeLocationGenerateEntity = AnalyzeLocationGenerateEntity$1;
/**
 *
 * This is where I get really vague. Something like this perhaps? Or it could be
 * something like a json-schema that contains enough info for the frontend to
 * be able to present a form and explanations
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
type AnalyzeLocationEntityField = AnalyzeLocationEntityField$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-search-backend-module-catalog` instead
 */
declare const DefaultCatalogCollatorFactory: typeof DefaultCatalogCollatorFactory$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-search-backend-module-catalog` instead
 */
declare const defaultCatalogCollatorEntityTransformer: CatalogCollatorEntityTransformer$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-search-backend-module-catalog` instead
 */
type DefaultCatalogCollatorFactoryOptions = DefaultCatalogCollatorFactoryOptions$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-search-backend-module-catalog` instead
 */
type CatalogCollatorEntityTransformer = CatalogCollatorEntityTransformer$1;

/** @public */
declare const CATALOG_CONFLICTS_TOPIC = "experimental.catalog.conflict";
/** @public */
declare const CATALOG_ERRORS_TOPIC = "experimental.catalog.errors";

/** @public */
declare function parseEntityYaml(data: Buffer, location: LocationSpec$1): Iterable<CatalogProcessorResult$1>;

export { type AnalyzeLocationEntityField, type AnalyzeLocationExistingEntity, type AnalyzeLocationGenerateEntity, type AnalyzeLocationRequest, type AnalyzeLocationResponse, type AnalyzeOptions, AnnotateLocationEntityProcessor, AnnotateScmSlugEntityProcessor, BuiltinKindsEntityProcessor, CATALOG_CONFLICTS_TOPIC, CATALOG_ERRORS_TOPIC, CatalogBuilder, type CatalogCollatorEntityTransformer, type CatalogEnvironment, type CatalogPermissionRuleInput, type CatalogProcessingEngine, type CatalogProcessor, type CatalogProcessorCache, type CatalogProcessorEmit, type CatalogProcessorEntityResult, type CatalogProcessorErrorResult, type CatalogProcessorLocationResult, type CatalogProcessorParser, type CatalogProcessorRefreshKeysResult, type CatalogProcessorRelationResult, type CatalogProcessorResult, CodeOwnersProcessor, DefaultCatalogCollator, DefaultCatalogCollatorFactory, type DefaultCatalogCollatorFactoryOptions, type DeferredEntity, type EntitiesSearchFilter, type EntityFilter, type EntityProvider, type EntityProviderConnection, type EntityProviderMutation, type EntityRelationSpec, FileReaderProcessor, type LocationAnalyzer, LocationEntityProcessor, type LocationEntityProcessorOptions, type LocationSpec, PlaceholderProcessor, type PlaceholderProcessorOptions, type PlaceholderResolver, type PlaceholderResolverParams, type PlaceholderResolverRead, type PlaceholderResolverResolveUrl, type ProcessingIntervalFunction, type ScmLocationAnalyzer, UrlReaderProcessor, createRandomProcessingInterval, catalogPlugin as default, defaultCatalogCollatorEntityTransformer, locationSpecToLocationEntity, locationSpecToMetadataName, parseEntityYaml, processingResult, transformLegacyPolicyToProcessor };
