{"version":3,"file":"CatalogRules.cjs.js","sources":["../../src/ingestion/CatalogRules.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { Entity } from '@backstage/catalog-model';\nimport path from 'path';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport { minimatch } from 'minimatch';\n\n/**\n * Rules to apply to catalog entities.\n *\n * An undefined list of matchers means match all, an empty list of matchers means match none.\n */\nexport type CatalogRule = {\n  allow: Array<{\n    kind: string;\n  }>;\n  locations?: Array<{\n    exact?: string;\n    type: string;\n    pattern?: string;\n  }>;\n};\n\n/**\n * Decides whether an entity from a given location is allowed to enter the\n * catalog, according to some rule set.\n */\nexport type CatalogRulesEnforcer = {\n  isAllowed(entity: Entity, location: LocationSpec): boolean;\n};\n\n/**\n * Implements the default catalog rule set, consuming the config keys\n * `catalog.rules` and `catalog.locations.[].rules`.\n */\nexport class DefaultCatalogRulesEnforcer implements CatalogRulesEnforcer {\n  /**\n   * Default rules used by the catalog.\n   *\n   * Denies any location from specifying user or group entities.\n   */\n  static readonly defaultRules: CatalogRule[] = [\n    {\n      allow: ['Component', 'API', 'Location'].map(kind => ({ kind })),\n    },\n  ];\n\n  /**\n   * Loads catalog rules from config.\n   *\n   * This reads `catalog.rules` and defaults to the default rules if no value is present.\n   * The value of the config should be a list of config objects, each with a single `allow`\n   * field which in turn is a list of entity kinds to allow.\n   *\n   * If there is no matching rule to allow an ingested entity, it will be rejected by the catalog.\n   *\n   * It also reads in rules from `catalog.locations`, where each location can have a list\n   * of rules for that specific location, specified in a `rules` field.\n   *\n   * For example:\n   *\n   * ```yaml\n   * catalog:\n   *   rules:\n   *   - allow: [Component, API]\n   *   - allow: [Template]\n   *     locations:\n   *       - type: url\n   *         pattern: https://github.com/org/*\\/blob/master/template.yaml\n   *   - allow: [Location]\n   *     locations:\n   *       - type: url\n   *         pattern: https://github.com/org/repo/blob/master/location.yaml\n   *\n   *   locations:\n   *   - type: url\n   *     target: https://github.com/org/repo/blob/master/users.yaml\n   *     rules:\n   *       - allow: [User, Group]\n   *   - type: url\n   *     target: https://github.com/org/repo/blob/master/systems.yaml\n   *     rules:\n   *       - allow: [System]\n   * ```\n   */\n  static fromConfig(config: Config) {\n    const rules = new Array<CatalogRule>();\n\n    if (config.has('catalog.rules')) {\n      const globalRules = config\n        .getConfigArray('catalog.rules')\n        .map(ruleConf => ({\n          allow: ruleConf.getStringArray('allow').map(kind => ({ kind })),\n          locations: ruleConf\n            .getOptionalConfigArray('locations')\n            ?.map(locationConfig => {\n              const location = {\n                pattern: locationConfig.getOptionalString('pattern'),\n                type: locationConfig.getString('type'),\n                exact: locationConfig.getOptionalString('exact'),\n              };\n              if (location.pattern && location.exact) {\n                throw new Error(\n                  'A catalog rule location cannot have both exact and pattern values',\n                );\n              }\n              return location;\n            }),\n        }));\n      rules.push(...globalRules);\n    } else {\n      rules.push(...DefaultCatalogRulesEnforcer.defaultRules);\n    }\n\n    if (config.has('catalog.locations')) {\n      const locationRules = config\n        .getConfigArray('catalog.locations')\n        .flatMap(locConf => {\n          if (!locConf.has('rules')) {\n            return [];\n          }\n          const type = locConf.getString('type');\n          const exact = resolveTarget(type, locConf.getString('target'));\n\n          return locConf.getConfigArray('rules').map(ruleConf => ({\n            allow: ruleConf.getStringArray('allow').map(kind => ({ kind })),\n            locations: [{ type, exact }],\n          }));\n        });\n\n      rules.push(...locationRules);\n    }\n\n    return new DefaultCatalogRulesEnforcer(rules);\n  }\n\n  constructor(private readonly rules: CatalogRule[]) {}\n\n  /**\n   * Checks whether a specific entity/location combination is allowed\n   * according to the configured rules.\n   */\n  isAllowed(entity: Entity, location: LocationSpec) {\n    for (const rule of this.rules) {\n      if (!this.matchLocation(location, rule.locations)) {\n        continue;\n      }\n\n      if (this.matchEntity(entity, rule.allow)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private matchLocation(\n    location: LocationSpec,\n    matchers?: { exact?: string; type: string; pattern?: string }[],\n  ): boolean {\n    if (!matchers) {\n      return true;\n    }\n\n    for (const matcher of matchers) {\n      if (matcher.type !== location?.type) {\n        continue;\n      }\n      if (matcher.exact && matcher.exact !== location?.target) {\n        continue;\n      }\n      if (\n        matcher.pattern &&\n        !minimatch(location?.target, matcher.pattern, {\n          nocase: true,\n          dot: true,\n        })\n      ) {\n        continue;\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  private matchEntity(entity: Entity, matchers?: { kind: string }[]): boolean {\n    if (!matchers) {\n      return true;\n    }\n\n    for (const matcher of matchers) {\n      if (entity?.kind?.toLowerCase() !== matcher.kind.toLowerCase()) {\n        continue;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n}\n\nfunction resolveTarget(type: string, target: string): string {\n  if (type !== 'file') {\n    return target;\n  }\n\n  return path.resolve(target);\n}\n"],"names":["minimatch","path"],"mappings":"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"}