'use strict';

var errors = require('@backstage/errors');
var uuid = require('uuid');
var util = require('../processing/util.cjs.js');
var conversion = require('../util/conversion.cjs.js');
var catalogModel = require('@backstage/catalog-model');

class DefaultLocationStore {
  constructor(db) {
    this.db = db;
  }
  _connection;
  getProviderName() {
    return "DefaultLocationStore";
  }
  async createLocation(input) {
    const location = await this.db.transaction(async (tx) => {
      const previousLocations = await this.locations(tx);
      const previousLocation = previousLocations.some(
        (l) => input.type === l.type && input.target === l.target
      );
      if (previousLocation) {
        throw new errors.ConflictError(
          `Location ${input.type}:${input.target} already exists`
        );
      }
      const inner = {
        id: uuid.v4(),
        type: input.type,
        target: input.target
      };
      await tx("locations").insert(inner);
      return inner;
    });
    const entity = conversion.locationSpecToLocationEntity({ location });
    await this.connection.applyMutation({
      type: "delta",
      added: [{ entity, locationKey: util.getEntityLocationRef(entity) }],
      removed: []
    });
    return location;
  }
  async listLocations() {
    return await this.locations();
  }
  async getLocation(id) {
    const items = await this.db("locations").where({ id }).select();
    if (!items.length) {
      throw new errors.NotFoundError(`Found no location with ID ${id}`);
    }
    return items[0];
  }
  async deleteLocation(id) {
    if (!this.connection) {
      throw new Error("location store is not initialized");
    }
    const deleted = await this.db.transaction(async (tx) => {
      const [location] = await tx("locations").where({ id }).select();
      if (!location) {
        throw new errors.NotFoundError(`Found no location with ID ${id}`);
      }
      await tx("locations").where({ id }).del();
      return location;
    });
    const entity = conversion.locationSpecToLocationEntity({ location: deleted });
    await this.connection.applyMutation({
      type: "delta",
      added: [],
      removed: [{ entity, locationKey: util.getEntityLocationRef(entity) }]
    });
  }
  async getLocationByEntity(entityRef) {
    const entityRefString = catalogModel.stringifyEntityRef(entityRef);
    const [entityRow] = await this.db("refresh_state").where({ entity_ref: entityRefString }).select("entity_id").limit(1);
    if (!entityRow) {
      throw new errors.NotFoundError(`found no entity for ref ${entityRefString}`);
    }
    const [searchRow] = await this.db("search").where({
      entity_id: entityRow.entity_id,
      key: `metadata.annotations.${catalogModel.ANNOTATION_ORIGIN_LOCATION}`
    }).select("value").limit(1);
    if (!searchRow?.value) {
      throw new errors.NotFoundError(
        `found no origin annotation for ref ${entityRefString}`
      );
    }
    const { type, target } = catalogModel.parseLocationRef(searchRow.value);
    const [locationRow] = await this.db("locations").where({ type, target }).select().limit(1);
    if (!locationRow) {
      throw new errors.NotFoundError(
        `Found no location with type ${type} and target ${target}`
      );
    }
    return locationRow;
  }
  get connection() {
    if (!this._connection) {
      throw new Error("location store is not initialized");
    }
    return this._connection;
  }
  async connect(connection) {
    this._connection = connection;
    const locations = await this.locations();
    const entities = locations.map((location) => {
      const entity = conversion.locationSpecToLocationEntity({ location });
      return { entity, locationKey: util.getEntityLocationRef(entity) };
    });
    await this.connection.applyMutation({
      type: "full",
      entities
    });
  }
  async locations(dbOrTx = this.db) {
    const locations = await dbOrTx("locations").select();
    return locations.filter(({ type }) => type !== "bootstrap").map((item) => ({
      id: item.id,
      target: item.target,
      type: item.type
    }));
  }
}

exports.DefaultLocationStore = DefaultLocationStore;
//# sourceMappingURL=DefaultLocationStore.cjs.js.map
