{"version":3,"file":"parse.cjs.js","sources":["../../src/util/parse.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, stringifyLocationRef } from '@backstage/catalog-model';\nimport lodash from 'lodash';\nimport yaml from 'yaml';\nimport { LocationSpec } from '@backstage/plugin-catalog-common';\nimport {\n  CatalogProcessorParser,\n  CatalogProcessorResult,\n  processingResult,\n} from '@backstage/plugin-catalog-node';\n\n/** @public */\nexport function* parseEntityYaml(\n  data: Buffer,\n  location: LocationSpec,\n): Iterable<CatalogProcessorResult> {\n  let documents: yaml.Document.Parsed[];\n  try {\n    documents = yaml.parseAllDocuments(data.toString('utf8')).filter(d => d);\n  } catch (e) {\n    const loc = stringifyLocationRef(location);\n    const message = `Failed to parse YAML at ${loc}, ${e}`;\n    yield processingResult.generalError(location, message);\n    return;\n  }\n\n  for (const document of documents) {\n    if (document.errors?.length) {\n      const loc = stringifyLocationRef(location);\n      const message = `YAML error at ${loc}, ${document.errors[0]}`;\n      yield processingResult.generalError(location, message);\n    } else {\n      const json = document.toJSON();\n      if (lodash.isPlainObject(json)) {\n        yield processingResult.entity(location, json as Entity);\n      } else if (json === null) {\n        // Ignore null values, these happen if there is an empty document in the\n        // YAML file, for example if --- is added to the end of the file.\n      } else {\n        const message = `Expected object at root, got ${typeof json}`;\n        yield processingResult.generalError(location, message);\n      }\n    }\n  }\n}\n\nexport const defaultEntityDataParser: CatalogProcessorParser =\n  async function* defaultEntityDataParser({ data, location }) {\n    for (const e of parseEntityYaml(data, location)) {\n      yield e;\n    }\n  };\n"],"names":["yaml","stringifyLocationRef","processingResult","lodash","defaultEntityDataParser"],"mappings":";;;;;;;;;;;;AA2BiB,UAAA,eAAA,CACf,MACA,QACkC,EAAA;AAClC,EAAI,IAAA,SAAA;AACJ,EAAI,IAAA;AACF,IAAY,SAAA,GAAAA,qBAAA,CAAK,kBAAkB,IAAK,CAAA,QAAA,CAAS,MAAM,CAAC,CAAA,CAAE,MAAO,CAAA,CAAA,CAAA,KAAK,CAAC,CAAA;AAAA,WAChE,CAAG,EAAA;AACV,IAAM,MAAA,GAAA,GAAMC,kCAAqB,QAAQ,CAAA;AACzC,IAAA,MAAM,OAAU,GAAA,CAAA,wBAAA,EAA2B,GAAG,CAAA,EAAA,EAAK,CAAC,CAAA,CAAA;AACpD,IAAM,MAAAC,kCAAA,CAAiB,YAAa,CAAA,QAAA,EAAU,OAAO,CAAA;AACrD,IAAA;AAAA;AAGF,EAAA,KAAA,MAAW,YAAY,SAAW,EAAA;AAChC,IAAI,IAAA,QAAA,CAAS,QAAQ,MAAQ,EAAA;AAC3B,MAAM,MAAA,GAAA,GAAMD,kCAAqB,QAAQ,CAAA;AACzC,MAAA,MAAM,UAAU,CAAiB,cAAA,EAAA,GAAG,KAAK,QAAS,CAAA,MAAA,CAAO,CAAC,CAAC,CAAA,CAAA;AAC3D,MAAM,MAAAC,kCAAA,CAAiB,YAAa,CAAA,QAAA,EAAU,OAAO,CAAA;AAAA,KAChD,MAAA;AACL,MAAM,MAAA,IAAA,GAAO,SAAS,MAAO,EAAA;AAC7B,MAAI,IAAAC,uBAAA,CAAO,aAAc,CAAA,IAAI,CAAG,EAAA;AAC9B,QAAM,MAAAD,kCAAA,CAAiB,MAAO,CAAA,QAAA,EAAU,IAAc,CAAA;AAAA,OACxD,MAAA,IAAW,SAAS,IAAM,EAAA,CAGnB,MAAA;AACL,QAAM,MAAA,OAAA,GAAU,CAAgC,6BAAA,EAAA,OAAO,IAAI,CAAA,CAAA;AAC3D,QAAM,MAAAA,kCAAA,CAAiB,YAAa,CAAA,QAAA,EAAU,OAAO,CAAA;AAAA;AACvD;AACF;AAEJ;AAEO,MAAM,0BACX,gBAAgBE,wBAAAA,CAAwB,EAAE,IAAA,EAAM,UAAY,EAAA;AAC1D,EAAA,KAAA,MAAW,CAAK,IAAA,eAAA,CAAgB,IAAM,EAAA,QAAQ,CAAG,EAAA;AAC/C,IAAM,MAAA,CAAA;AAAA;AAEV;;;;;"}