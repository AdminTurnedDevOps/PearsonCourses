'use strict';

var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');
var yaml = require('yaml');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var lodash__default = /*#__PURE__*/_interopDefaultCompat(lodash);
var yaml__default = /*#__PURE__*/_interopDefaultCompat(yaml);

function* parseEntityYaml(data, location) {
  let documents;
  try {
    documents = yaml__default.default.parseAllDocuments(data.toString("utf8")).filter((d) => d);
  } catch (e) {
    const loc = catalogModel.stringifyLocationRef(location);
    const message = `Failed to parse YAML at ${loc}, ${e}`;
    yield pluginCatalogNode.processingResult.generalError(location, message);
    return;
  }
  for (const document of documents) {
    if (document.errors?.length) {
      const loc = catalogModel.stringifyLocationRef(location);
      const message = `YAML error at ${loc}, ${document.errors[0]}`;
      yield pluginCatalogNode.processingResult.generalError(location, message);
    } else {
      const json = document.toJSON();
      if (lodash__default.default.isPlainObject(json)) {
        yield pluginCatalogNode.processingResult.entity(location, json);
      } else if (json === null) ; else {
        const message = `Expected object at root, got ${typeof json}`;
        yield pluginCatalogNode.processingResult.generalError(location, message);
      }
    }
  }
}
const defaultEntityDataParser = async function* defaultEntityDataParser2({ data, location }) {
  for (const e of parseEntityYaml(data, location)) {
    yield e;
  }
};

exports.defaultEntityDataParser = defaultEntityDataParser;
exports.parseEntityYaml = parseEntityYaml;
//# sourceMappingURL=parse.cjs.js.map
