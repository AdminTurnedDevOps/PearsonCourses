'use strict';

var crypto = require('crypto');
var openidClient = require('openid-client');
var pluginAuthNode = require('@backstage/plugin-auth-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var crypto__default = /*#__PURE__*/_interopDefaultCompat(crypto);

const HTTP_OPTION_TIMEOUT = 1e4;
const httpOptionsProvider = (_url, options) => {
  return {
    ...options,
    timeout: HTTP_OPTION_TIMEOUT
  };
};
const oidcAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  defaultProfileTransform: async (input) => ({
    profile: {
      email: input.fullProfile.userinfo.email,
      picture: input.fullProfile.userinfo.picture,
      displayName: input.fullProfile.userinfo.name
    }
  }),
  scopes: {
    persist: true,
    required: ["openid", "profile", "email"]
  },
  initialize({ callbackUrl, config }) {
    const clientId = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const metadataUrl = config.getString("metadataUrl");
    const customCallbackUrl = config.getOptionalString("callbackUrl");
    const tokenEndpointAuthMethod = config.getOptionalString(
      "tokenEndpointAuthMethod"
    );
    const tokenSignedResponseAlg = config.getOptionalString(
      "tokenSignedResponseAlg"
    );
    const initializedPrompt = config.getOptionalString("prompt");
    if (config.has("scope")) {
      throw new Error(
        'The oidc provider no longer supports the "scope" configuration option. Please use the "additionalScopes" option instead.'
      );
    }
    openidClient.Issuer[openidClient.custom.http_options] = httpOptionsProvider;
    const promise = openidClient.Issuer.discover(metadataUrl).then((issuer) => {
      issuer[openidClient.custom.http_options] = httpOptionsProvider;
      issuer.Client[openidClient.custom.http_options] = httpOptionsProvider;
      const client = new issuer.Client({
        access_type: "offline",
        // this option must be passed to provider to receive a refresh token
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uris: [customCallbackUrl || callbackUrl],
        response_types: ["code"],
        token_endpoint_auth_method: tokenEndpointAuthMethod || "client_secret_basic",
        id_token_signed_response_alg: tokenSignedResponseAlg || "RS256"
      });
      client[openidClient.custom.http_options] = httpOptionsProvider;
      const strategy = new openidClient.Strategy(
        {
          client,
          passReqToCallback: false
        },
        (tokenset, userinfo, done) => {
          if (typeof done !== "function") {
            throw new Error(
              "OIDC IdP must provide a userinfo_endpoint in the metadata response"
            );
          }
          done(
            void 0,
            { tokenset, userinfo },
            { refreshToken: tokenset.refresh_token }
          );
        }
      );
      const helper = pluginAuthNode.PassportOAuthAuthenticatorHelper.from(strategy);
      return { helper, client, strategy };
    });
    return { initializedPrompt, promise };
  },
  async start(input, ctx) {
    const { initializedPrompt, promise } = ctx;
    const { helper, strategy } = await promise;
    const options = {
      scope: input.scope,
      state: input.state,
      nonce: crypto__default.default.randomBytes(16).toString("base64")
    };
    const prompt = initializedPrompt || "none";
    if (prompt !== "auto") {
      options.prompt = prompt;
    }
    return new Promise((resolve, reject) => {
      strategy.error = reject;
      return helper.start(input, {
        ...options
      }).then(resolve);
    });
  },
  async authenticate(input, ctx) {
    const { strategy } = await ctx.promise;
    const { result, privateInfo } = await pluginAuthNode.PassportHelpers.executeFrameHandlerStrategy(input.req, strategy);
    return {
      fullProfile: result,
      session: {
        accessToken: result.tokenset.access_token,
        tokenType: result.tokenset.token_type ?? "bearer",
        scope: result.tokenset.scope,
        expiresInSeconds: result.tokenset.expires_in,
        idToken: result.tokenset.id_token,
        refreshToken: privateInfo.refreshToken
      }
    };
  },
  async refresh(input, ctx) {
    const { client } = await ctx.promise;
    const tokenset = await client.refresh(input.refreshToken);
    if (!tokenset.access_token) {
      throw new Error("Refresh failed");
    }
    const userinfo = await client.userinfo(tokenset.access_token);
    return new Promise((resolve, reject) => {
      if (!tokenset.access_token) {
        reject(new Error("Refresh Failed"));
      }
      resolve({
        fullProfile: { userinfo, tokenset },
        session: {
          accessToken: tokenset.access_token,
          tokenType: tokenset.token_type ?? "bearer",
          scope: tokenset.scope,
          expiresInSeconds: tokenset.expires_in,
          idToken: tokenset.id_token,
          refreshToken: tokenset.refresh_token
        }
      });
    });
  },
  async logout(input, ctx) {
    const { client } = await ctx.promise;
    const issuer = client.issuer;
    if (input.refreshToken && issuer.revocation_endpoint) {
      await client.revoke(input.refreshToken);
    }
  }
});

exports.oidcAuthenticator = oidcAuthenticator;
//# sourceMappingURL=authenticator.cjs.js.map
