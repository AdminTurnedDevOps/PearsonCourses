{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";AAAA,mCAAmC;AACnC,6CAA6C;AAC7C,0DAA0D;AAC1D,oEAAoE;AACpE,qEAAqE;;;AAwLrE;;;;;;;;;;;;;;;;;;;;GAoBG;AAEH,SAAS,oBAAoB,CAC3B,gBAAyB;IAEzB,OAAO,OAAO,gBAAgB,KAAK,UAAU,CAAC;AAChD,CAAC;AAED;;;;;GAKG;AACH,SAAgB,8BAA8B,CAC5C,WAA8B;IAK9B,OAAO,CAAC,CAAC,GAAG,IAAuC,EAAE,EAAE;QACrD,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC/C,IAAI,oBAAoB,CAAC,gBAAgB,CAAC,EAAE,CAAC;YAC3C,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,WAAW,CAAC,GAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAO,CAAC,CAAC;gBACxD,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACjC,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,gBAAgB,CAAC,GAAG,YAAY,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;YAC5E,CAAC;QACH,CAAC;aAAM,CAAC;YACN,OAAO,WAAW,CAAC,GAAI,IAAU,CAAC,CAAC;QACrC,CAAC;IACH,CAAC,CAGA,CAAC;AACJ,CAAC;AAtBD,wEAsBC","sourcesContent":["/* eslint-disable no-unused-vars */\n// Type definitions for @node-saml/xml-crypto\n// Project: https://github.com/node-saml/xml-crypto#readme\n// Original definitions by: Eric Heikes <https://github.com/eheikes>\n//                          Max Chehab <https://github.com/maxchehab>\n\n/// <reference types=\"node\" />\n\nimport * as crypto from \"crypto\";\n\nexport type ErrorFirstCallback<T> = (err: Error | null, result?: T) => void;\n\nexport type CanonicalizationAlgorithmType =\n  | \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"\n  | \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\n  | \"http://www.w3.org/2001/10/xml-exc-c14n#\"\n  | \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\"\n  | string;\n\nexport type CanonicalizationOrTransformAlgorithmType =\n  | CanonicalizationAlgorithmType\n  | \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\";\n\nexport type HashAlgorithmType =\n  | \"http://www.w3.org/2000/09/xmldsig#sha1\"\n  | \"http://www.w3.org/2001/04/xmlenc#sha256\"\n  | \"http://www.w3.org/2001/04/xmlenc#sha512\"\n  | string;\n\nexport type SignatureAlgorithmType =\n  | \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"\n  | \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\n  | \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"\n  | \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\"\n  | string;\n\n/**\n * @param cert the certificate as a string or array of strings (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\n * @param prefix an optional namespace alias to be used for the generated XML\n */\nexport interface GetKeyInfoContentArgs {\n  publicCert?: crypto.KeyLike;\n  prefix?: string | null;\n}\n\n/**\n * Options for the SignedXml constructor.\n */\nexport interface SignedXmlOptions {\n  idMode?: \"wssecurity\";\n  idAttribute?: string;\n  privateKey?: crypto.KeyLike;\n  publicCert?: crypto.KeyLike;\n  signatureAlgorithm?: SignatureAlgorithmType;\n  canonicalizationAlgorithm?: CanonicalizationAlgorithmType;\n  inclusiveNamespacesPrefixList?: string | string[];\n  implicitTransforms?: ReadonlyArray<CanonicalizationOrTransformAlgorithmType>;\n  keyInfoAttributes?: Record<string, string>;\n  getKeyInfoContent?(args?: GetKeyInfoContentArgs): string | null;\n  getCertFromKeyInfo?(keyInfo?: Node | null): string | null;\n}\n\nexport interface NamespacePrefix {\n  prefix: string;\n  namespaceURI: string;\n}\n\nexport interface RenderedNamespace {\n  rendered: string;\n  newDefaultNs: string;\n}\n\nexport interface CanonicalizationOrTransformationAlgorithmProcessOptions {\n  defaultNs?: string;\n  defaultNsForPrefix?: Record<string, string>;\n  ancestorNamespaces?: NamespacePrefix[];\n  signatureNode?: Node | null;\n  inclusiveNamespacesPrefixList?: string[];\n}\n\nexport interface ComputeSignatureOptionsLocation {\n  reference?: string;\n  action?: \"append\" | \"prepend\" | \"before\" | \"after\";\n}\n\n/**\n * Options for the computeSignature method.\n *\n * - `prefix` {String} Adds a prefix for the generated signature tags\n * - `attrs` {Object} A hash of attributes and values `attrName: value` to add to the signature root node\n * - `location` {{ reference: String, action: String }}\n * - `existingPrefixes` {Object} A hash of prefixes and namespaces `prefix: namespace` already in the xml\n *   An object with a `reference` key which should\n *   contain a XPath expression, an `action` key which\n *   should contain one of the following values:\n *   `append`, `prepend`, `before`, `after`\n */\nexport interface ComputeSignatureOptions {\n  prefix?: string;\n  attrs?: Record<string, string>;\n  location?: ComputeSignatureOptionsLocation;\n  existingPrefixes?: Record<string, string>;\n}\n\n/**\n * Represents a reference node for XML digital signature.\n */\nexport interface Reference {\n  // The XPath expression that selects the data to be signed.\n  xpath?: string;\n\n  // An array of transforms to be applied to the data before signing.\n  transforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType>;\n\n  // The algorithm used to calculate the digest value of the data.\n  digestAlgorithm: HashAlgorithmType;\n\n  // The URI that identifies the data to be signed.\n  uri: string;\n\n  // Optional. The digest value of the referenced data.\n  digestValue?: unknown;\n\n  // A list of namespace prefixes to be treated as \"inclusive\" during canonicalization.\n  inclusiveNamespacesPrefixList: string[];\n\n  // Optional. Indicates whether the URI is empty.\n  isEmptyUri: boolean;\n\n  // Optional. The type of the reference node.\n  ancestorNamespaces?: NamespacePrefix[];\n\n  validationError?: Error;\n\n  getValidatedNode(xpathSelector?: string): Node | null;\n}\n\n/** Implement this to create a new CanonicalizationOrTransformationAlgorithm */\nexport interface CanonicalizationOrTransformationAlgorithm {\n  process(\n    node: Node,\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions,\n  ): Node | string;\n\n  getAlgorithmName(): CanonicalizationOrTransformAlgorithmType;\n}\n\n/** Implement this to create a new HashAlgorithm */\nexport interface HashAlgorithm {\n  getAlgorithmName(): HashAlgorithmType;\n\n  getHash(xml: string): string;\n}\n\n/** Extend this to create a new SignatureAlgorithm */\nexport interface SignatureAlgorithm {\n  /**\n   * Sign the given string using the given key\n   */\n  getSignature(signedInfo: crypto.BinaryLike, privateKey: crypto.KeyLike): string;\n  getSignature(\n    signedInfo: crypto.BinaryLike,\n    privateKey: crypto.KeyLike,\n    callback?: ErrorFirstCallback<string>,\n  ): void;\n  /**\n   * Verify the given signature of the given string using key\n   *\n   * @param key a public cert, public key, or private key can be passed here\n   */\n  verifySignature(material: string, key: crypto.KeyLike, signatureValue: string): boolean;\n  verifySignature(\n    material: string,\n    key: crypto.KeyLike,\n    signatureValue: string,\n    callback?: ErrorFirstCallback<boolean>,\n  ): void;\n\n  getAlgorithmName(): SignatureAlgorithmType;\n}\n\n/** Implement this to create a new TransformAlgorithm */\nexport interface TransformAlgorithm {\n  getAlgorithmName(): CanonicalizationOrTransformAlgorithmType;\n\n  process(node: Node): string;\n}\n\n/**\n * ### Sign\n * #### Properties\n * - {@link SignedXml#privateKey} [required]\n * - {@link SignedXml#publicCert} [optional]\n * - {@link SignedXml#signatureAlgorithm} [optional]\n * - {@link SignedXml#canonicalizationAlgorithm} [optional]\n * #### Api\n *  - {@link SignedXml#addReference}\n *  - {@link SignedXml#computeSignature}\n *  - {@link SignedXml#getSignedXml}\n *  - {@link SignedXml#getSignatureXml}\n *  - {@link SignedXml#getOriginalXmlWithIds}\n *\n * ### Verify\n * #### Properties\n * -  {@link SignedXml#publicCert} [optional]\n * #### Api\n *  - {@link SignedXml#loadSignature}\n *  - {@link SignedXml#checkSignature}\n */\n\nfunction isErrorFirstCallback<T>(\n  possibleCallback: unknown,\n): possibleCallback is ErrorFirstCallback<T> {\n  return typeof possibleCallback === \"function\";\n}\n\n/**\n * This function will add a callback version of a sync function.\n *\n * This follows the factory pattern.\n * Just call this function, passing the function that you'd like to add a callback version of.\n */\nexport function createOptionalCallbackFunction<T, A extends unknown[]>(\n  syncVersion: (...args: A) => T,\n): {\n  (...args: A): T;\n  (...args: [...A, ErrorFirstCallback<T>]): void;\n} {\n  return ((...args: A | [...A, ErrorFirstCallback<T>]) => {\n    const possibleCallback = args[args.length - 1];\n    if (isErrorFirstCallback(possibleCallback)) {\n      try {\n        const result = syncVersion(...(args.slice(0, -1) as A));\n        possibleCallback(null, result);\n      } catch (err) {\n        possibleCallback(err instanceof Error ? err : new Error(\"Unknown error\"));\n      }\n    } else {\n      return syncVersion(...(args as A));\n    }\n  }) as {\n    (...args: A): T;\n    (...args: [...A, ErrorFirstCallback<T>]): void;\n  };\n}\n"]}