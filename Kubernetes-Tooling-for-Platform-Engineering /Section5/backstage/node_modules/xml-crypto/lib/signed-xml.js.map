{"version":3,"file":"signed-xml.js","sourceRoot":"","sources":["../src/signed-xml.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CanonicalizationAlgorithmType,\n  CanonicalizationOrTransformationAlgorithm,\n  ComputeSignatureOptions,\n  GetKeyInfoContentArgs,\n  HashAlgorithm,\n  HashAlgorithmType,\n  Reference,\n  SignatureAlgorithm,\n  SignatureAlgorithmType,\n  SignedXmlOptions,\n  CanonicalizationOrTransformAlgorithmType,\n  ErrorFirstCallback,\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\n} from \"./types\";\n\nimport * as xpath from \"xpath\";\nimport * as xmldom from \"@xmldom/xmldom\";\nimport * as utils from \"./utils\";\nimport * as c14n from \"./c14n-canonicalization\";\nimport * as execC14n from \"./exclusive-canonicalization\";\nimport * as envelopedSignatures from \"./enveloped-signature\";\nimport * as hashAlgorithms from \"./hash-algorithms\";\nimport * as signatureAlgorithms from \"./signature-algorithms\";\nimport * as crypto from \"crypto\";\nimport * as isDomNode from \"@xmldom/is-dom-node\";\n\nexport class SignedXml {\n  idMode?: \"wssecurity\";\n  idAttributes: string[];\n  /**\n   * A {@link Buffer} or pem encoded {@link String} containing your private key\n   */\n  privateKey?: crypto.KeyLike;\n  publicCert?: crypto.KeyLike;\n  /**\n   * One of the supported signature algorithms.\n   * @see {@link SignatureAlgorithmType}\n   */\n  signatureAlgorithm?: SignatureAlgorithmType = undefined;\n  /**\n   * Rules used to convert an XML document into its canonical form.\n   */\n  canonicalizationAlgorithm?: CanonicalizationAlgorithmType = undefined;\n  /**\n   * It specifies a list of namespace prefixes that should be considered \"inclusive\" during the canonicalization process.\n   */\n  inclusiveNamespacesPrefixList: string[] = [];\n  namespaceResolver: XPathNSResolver = {\n    lookupNamespaceURI: function (/* prefix */) {\n      throw new Error(\"Not implemented\");\n    },\n  };\n  implicitTransforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType> = [];\n  keyInfoAttributes: { [attrName: string]: string } = {};\n  getKeyInfoContent = SignedXml.getKeyInfoContent;\n  getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;\n\n  // Internal state\n  private id = 0;\n  private signedXml = \"\";\n  private signatureXml = \"\";\n  private signatureNode: Node | null = null;\n  private signatureValue = \"\";\n  private originalXmlWithIds = \"\";\n  private keyInfo: Node | null = null;\n\n  /**\n   * Contains the references that were signed.\n   * @see {@link Reference}\n   */\n  private references: Reference[] = [];\n\n  /**\n   *  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  CanonicalizationAlgorithms: Record<\n    CanonicalizationOrTransformAlgorithmType,\n    new () => CanonicalizationOrTransformationAlgorithm\n  > = {\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\": c14n.C14nCanonicalization,\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\":\n      c14n.C14nCanonicalizationWithComments,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\": execC14n.ExclusiveCanonicalization,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\":\n      execC14n.ExclusiveCanonicalizationWithComments,\n    \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\": envelopedSignatures.EnvelopedSignature,\n  };\n\n  /**\n   * To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  HashAlgorithms: Record<HashAlgorithmType, new () => HashAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#sha1\": hashAlgorithms.Sha1,\n    \"http://www.w3.org/2001/04/xmlenc#sha256\": hashAlgorithms.Sha256,\n    \"http://www.w3.org/2001/04/xmlenc#sha512\": hashAlgorithms.Sha512,\n  };\n\n  /**\n   * To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  SignatureAlgorithms: Record<SignatureAlgorithmType, new () => SignatureAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\": signatureAlgorithms.RsaSha1,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\": signatureAlgorithms.RsaSha256,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\": signatureAlgorithms.RsaSha512,\n    // Disabled by default due to key confusion concerns.\n    // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': SignatureAlgorithms.HmacSha1\n  };\n\n  static defaultNsForPrefix = {\n    ds: \"http://www.w3.org/2000/09/xmldsig#\",\n  };\n\n  static noop = () => null;\n\n  /**\n   * The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using\n   * @param options {@link SignedXmlOptions}\n   */\n  constructor(options: SignedXmlOptions = {}) {\n    const {\n      idMode,\n      idAttribute,\n      privateKey,\n      publicCert,\n      signatureAlgorithm,\n      canonicalizationAlgorithm,\n      inclusiveNamespacesPrefixList,\n      implicitTransforms,\n      keyInfoAttributes,\n      getKeyInfoContent,\n      getCertFromKeyInfo,\n    } = options;\n\n    // Options\n    this.idMode = idMode;\n    this.idAttributes = [\"Id\", \"ID\", \"id\"];\n    if (idAttribute) {\n      this.idAttributes.unshift(idAttribute);\n    }\n    this.privateKey = privateKey;\n    this.publicCert = publicCert;\n    this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;\n    this.canonicalizationAlgorithm = canonicalizationAlgorithm;\n    if (typeof inclusiveNamespacesPrefixList === \"string\") {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(\" \");\n    } else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;\n    }\n    this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;\n    this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;\n    this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;\n    this.getCertFromKeyInfo = getCertFromKeyInfo ?? SignedXml.noop;\n    this.CanonicalizationAlgorithms;\n    this.HashAlgorithms;\n    this.SignatureAlgorithms;\n  }\n\n  /**\n   * Due to key-confusion issues, it's risky to have both hmac\n   * and digital signature algorithms enabled at the same time.\n   * This enables HMAC and disables other signing algorithms.\n   */\n  enableHMAC(): void {\n    this.SignatureAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\": signatureAlgorithms.HmacSha1,\n    };\n    this.getKeyInfoContent = SignedXml.noop;\n  }\n\n  /**\n   * Builds the contents of a KeyInfo element as an XML string.\n   *\n   * For example, if the value of the prefix argument is 'foo', then\n   * the resultant XML string will be \"<foo:X509Data></foo:X509Data>\"\n   *\n   * @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included\n   */\n  static getKeyInfoContent({ publicCert, prefix }: GetKeyInfoContentArgs): string | null {\n    if (publicCert == null) {\n      return null;\n    }\n\n    prefix = prefix ? `${prefix}:` : \"\";\n\n    let x509Certs = \"\";\n    if (Buffer.isBuffer(publicCert)) {\n      publicCert = publicCert.toString(\"latin1\");\n    }\n\n    let publicCertMatches: string[] = [];\n    if (typeof publicCert === \"string\") {\n      publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];\n    }\n\n    if (publicCertMatches.length > 0) {\n      x509Certs = publicCertMatches\n        .map(\n          (c) =>\n            `<${prefix}X509Certificate>${utils\n              .pemToDer(c)\n              .toString(\"base64\")}</${prefix}X509Certificate>`,\n        )\n        .join(\"\");\n    }\n\n    return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;\n  }\n\n  /**\n   * Returns the value of the signing certificate based on the contents of the\n   * specified KeyInfo.\n   *\n   * @param keyInfo KeyInfo element (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\n   * @return the signing certificate as a string in PEM format\n   */\n  static getCertFromKeyInfo(keyInfo?: Node | null): string | null {\n    if (keyInfo != null) {\n      const cert = xpath.select1(\".//*[local-name(.)='X509Certificate']\", keyInfo);\n      if (isDomNode.isNodeLike(cert)) {\n        return utils.derToPem(cert.textContent ?? \"\", \"CERTIFICATE\");\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @returns `true` if the signature is valid\n   * @throws Error if no key info resolver is provided.\n   */\n  checkSignature(xml: string): boolean;\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @param callback Callback function to handle the validation result asynchronously.\n   * @throws Error if the last parameter is provided and is not a function, or if no key info resolver is provided.\n   */\n  checkSignature(xml: string, callback: (error: Error | null, isValid?: boolean) => void): void;\n  checkSignature(\n    xml: string,\n    callback?: (error: Error | null, isValid?: boolean) => void,\n  ): unknown {\n    if (callback != null && typeof callback !== \"function\") {\n      throw new Error(\"Last parameter must be a callback function\");\n    }\n\n    this.signedXml = xml;\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n\n    if (!this.getReferences().every((ref) => this.validateReference(ref, doc))) {\n      if (callback) {\n        callback(new Error(\"Could not validate all references\"));\n        return;\n      }\n\n      return false;\n    }\n\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;\n    if (key == null) {\n      throw new Error(\"KeyInfo or publicCert or privateKey is required to validate signature\");\n    }\n    if (callback) {\n      signer.verifySignature(signedInfoCanon, key, this.signatureValue, callback);\n    } else {\n      const verified = signer.verifySignature(signedInfoCanon, key, this.signatureValue);\n\n      if (verified === false) {\n        throw new Error(\n          `invalid signature: the signature value ${this.signatureValue} is incorrect`,\n        );\n      }\n\n      return true;\n    }\n  }\n\n  private getCanonSignedInfoXml(doc: Document) {\n    if (this.signatureNode == null) {\n      throw new Error(\"No signature found.\");\n    }\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\"Missing canonicalizationAlgorithm when trying to get signed info for XML\");\n    }\n\n    const signedInfo = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfo.length === 0) {\n      throw new Error(\"could not find SignedInfo element in the message\");\n    }\n\n    if (\n      this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" ||\n      this.canonicalizationAlgorithm ===\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\n    ) {\n      if (!doc || typeof doc !== \"object\") {\n        throw new Error(\n          \"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\",\n        );\n      }\n    }\n\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    const ancestorNamespaces = utils.findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n\n    const c14nOptions = {\n      ancestorNamespaces: ancestorNamespaces,\n    };\n\n    return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\n  }\n\n  private getCanonReferenceXml(doc: Document, ref: Reference, node: Node) {\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    if (Array.isArray(ref.transforms)) {\n      ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);\n    }\n\n    const c14nOptions = {\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n      ancestorNamespaces: ref.ancestorNamespaces,\n    };\n\n    return this.getCanonXml(ref.transforms, node, c14nOptions);\n  }\n\n  private calculateSignatureValue(doc: Document, callback?: ErrorFirstCallback<string>) {\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    if (this.privateKey == null) {\n      throw new Error(\"Private key is required to compute signature\");\n    }\n    if (typeof callback === \"function\") {\n      signer.getSignature(signedInfoCanon, this.privateKey, callback);\n    } else {\n      this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);\n    }\n  }\n\n  private findSignatureAlgorithm(name?: SignatureAlgorithmType) {\n    if (name == null) {\n      throw new Error(\"signatureAlgorithm is required\");\n    }\n    const algo = this.SignatureAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`signature algorithm '${name}' is not supported`);\n    }\n  }\n\n  private findCanonicalizationAlgorithm(name: CanonicalizationOrTransformAlgorithmType) {\n    if (name != null) {\n      const algo = this.CanonicalizationAlgorithms[name];\n      if (algo) {\n        return new algo();\n      }\n    }\n\n    throw new Error(`canonicalization algorithm '${name}' is not supported`);\n  }\n\n  private findHashAlgorithm(name: HashAlgorithmType) {\n    const algo = this.HashAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`hash algorithm '${name}' is not supported`);\n    }\n  }\n\n  validateElementAgainstReferences(elemOrXpath: Element | string, doc: Document): Reference {\n    let elem: Element;\n    if (typeof elemOrXpath === \"string\") {\n      const firstElem = xpath.select1(elemOrXpath, doc);\n      isDomNode.assertIsElementNode(firstElem);\n      elem = firstElem;\n    } else {\n      elem = elemOrXpath;\n    }\n\n    for (const ref of this.getReferences()) {\n      const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n\n      for (const attr of this.idAttributes) {\n        const elemId = elem.getAttribute(attr);\n        if (uri === elemId) {\n          ref.xpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n          break; // found the correct element, no need to check further\n        }\n      }\n\n      const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n      const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n      const digest = hash.getHash(canonXml);\n\n      if (utils.validateDigestValue(digest, ref.digestValue)) {\n        return ref;\n      }\n    }\n\n    throw new Error(\"No references passed validation\");\n  }\n\n  private validateReference(ref: Reference, doc: Document) {\n    const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n    let elem: xpath.SelectSingleReturnType = null;\n\n    if (uri === \"\") {\n      elem = xpath.select1(\"//*\", doc);\n    } else if (uri?.indexOf(\"'\") !== -1) {\n      // xpath injection\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\n    } else {\n      let num_elements_for_id = 0;\n      for (const attr of this.idAttributes) {\n        const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n        const tmp_elem = xpath.select(tmp_elemXpath, doc);\n        if (utils.isArrayHasLength(tmp_elem)) {\n          num_elements_for_id += tmp_elem.length;\n\n          if (num_elements_for_id > 1) {\n            throw new Error(\n              \"Cannot validate a document which contains multiple elements with the \" +\n                \"same value for the ID / Id / Id attributes, in order to prevent \" +\n                \"signature wrapping attack.\",\n            );\n          }\n\n          elem = tmp_elem[0];\n          ref.xpath = tmp_elemXpath;\n        }\n      }\n    }\n\n    ref.getValidatedNode = (xpathSelector?: string) => {\n      xpathSelector = xpathSelector || ref.xpath;\n      if (typeof xpathSelector !== \"string\" || ref.validationError != null) {\n        return null;\n      }\n      const selectedValue = xpath.select1(xpathSelector, doc);\n      return isDomNode.isNodeLike(selectedValue) ? selectedValue : null;\n    };\n\n    if (!isDomNode.isNodeLike(elem)) {\n      const validationError = new Error(\n        `invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`,\n      );\n      ref.validationError = validationError;\n      return false;\n    }\n\n    const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n    const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n    const digest = hash.getHash(canonXml);\n\n    if (!utils.validateDigestValue(digest, ref.digestValue)) {\n      const validationError = new Error(\n        `invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`,\n      );\n      ref.validationError = validationError;\n\n      return false;\n    }\n\n    return true;\n  }\n\n  findSignatures(doc: Node): Node[] {\n    const nodes = xpath.select(\n      \"//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\",\n      doc,\n    );\n\n    return isDomNode.isArrayOfNodes(nodes) ? nodes : [];\n  }\n\n  /**\n   * Loads the signature information from the provided XML node or string.\n   *\n   * @param signatureNode The XML node or string representing the signature.\n   */\n  loadSignature(signatureNode: Node | string): void {\n    if (typeof signatureNode === \"string\") {\n      this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);\n    } else {\n      this.signatureNode = signatureNode;\n    }\n\n    this.signatureXml = signatureNode.toString();\n\n    const node = xpath.select1(\n      \".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\",\n      signatureNode,\n    );\n    if (!isDomNode.isNodeLike(node)) {\n      throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n    }\n\n    if (isDomNode.isAttributeNode(node)) {\n      this.canonicalizationAlgorithm = node.value as CanonicalizationAlgorithmType;\n    }\n\n    const signatureAlgorithm = xpath.select1(\n      \".//*[local-name(.)='SignatureMethod']/@Algorithm\",\n      signatureNode,\n    );\n\n    if (isDomNode.isAttributeNode(signatureAlgorithm)) {\n      this.signatureAlgorithm = signatureAlgorithm.value as SignatureAlgorithmType;\n    }\n\n    this.references = [];\n    const references = xpath.select(\n      \".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\",\n      signatureNode,\n    );\n    if (!utils.isArrayHasLength(references)) {\n      throw new Error(\"could not find any Reference elements\");\n    }\n\n    for (const reference of references) {\n      this.loadReference(reference);\n    }\n\n    const signatureValue = xpath.select1(\n      \".//*[local-name(.)='SignatureValue']/text()\",\n      signatureNode,\n    );\n\n    if (isDomNode.isTextNode(signatureValue)) {\n      this.signatureValue = signatureValue.data.replace(/\\r?\\n/g, \"\");\n    }\n\n    const keyInfo = xpath.select1(\".//*[local-name(.)='KeyInfo']\", signatureNode);\n\n    if (isDomNode.isNodeLike(keyInfo)) {\n      this.keyInfo = keyInfo;\n    }\n  }\n\n  /**\n   * Load the reference xml node to a model\n   *\n   */\n  private loadReference(refNode: Node) {\n    let nodes = utils.findChildren(refNode, \"DigestMethod\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestMethod in reference ${refNode.toString()}`);\n    }\n    const digestAlgoNode = nodes[0];\n\n    const attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n    if (!attr) {\n      throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);\n    }\n    const digestAlgo = attr.value;\n\n    nodes = utils.findChildren(refNode, \"DigestValue\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestValue node in reference ${refNode.toString()}`);\n    }\n    const firstChild = nodes[0].firstChild;\n    if (!firstChild || !(\"data\" in firstChild)) {\n      throw new Error(`could not find the value of DigestValue in ${nodes[0].toString()}`);\n    }\n    const digestValue = firstChild.data;\n\n    const transforms: string[] = [];\n    let inclusiveNamespacesPrefixList: string[] = [];\n    nodes = utils.findChildren(refNode, \"Transforms\");\n    if (nodes.length !== 0) {\n      const transformsNode = nodes[0];\n      const transformsAll = utils.findChildren(transformsNode, \"Transform\");\n      for (const transform of transformsAll) {\n        const transformAttr = utils.findAttr(transform, \"Algorithm\");\n\n        if (transformAttr) {\n          transforms.push(transformAttr.value);\n        }\n      }\n\n      // This is a little strange, we are looking for children of the last child of `transformsNode`\n      const inclusiveNamespaces = utils.findChildren(\n        transformsAll[transformsAll.length - 1],\n        \"InclusiveNamespaces\",\n      );\n      if (utils.isArrayHasLength(inclusiveNamespaces)) {\n        // Should really only be one prefix list, but maybe there's some circumstances where more than one to let's handle it\n        inclusiveNamespacesPrefixList = inclusiveNamespaces\n          .flatMap((namespace) => (namespace.getAttribute(\"PrefixList\") ?? \"\").split(\" \"))\n          .filter((value) => value.length > 0);\n      }\n    }\n\n    if (utils.isArrayHasLength(this.implicitTransforms)) {\n      this.implicitTransforms.forEach(function (t) {\n        transforms.push(t);\n      });\n    }\n\n    /**\n     * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n     * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n     * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n     * @see:\n     * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n     * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n     * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n     */\n    if (\n      transforms.length === 0 ||\n      transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\n    ) {\n      transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n    }\n\n    this.addReference({\n      transforms,\n      digestAlgorithm: digestAlgo,\n      uri: isDomNode.isElementNode(refNode) ? utils.findAttr(refNode, \"URI\")?.value : undefined,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri: false,\n    });\n  }\n\n  /**\n   * Adds a reference to the signature.\n   *\n   * @param xpath The XPath expression to select the XML nodes to be referenced.\n   * @param transforms An array of transform algorithms to be applied to the selected nodes.\n   * @param digestAlgorithm The digest algorithm to use for computing the digest value.\n   * @param uri The URI identifier for the reference. If empty, an empty URI will be used.\n   * @param digestValue The expected digest value for the reference.\n   * @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.\n   * @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.\n   */\n  addReference({\n    xpath,\n    transforms,\n    digestAlgorithm,\n    uri = \"\",\n    digestValue,\n    inclusiveNamespacesPrefixList = [],\n    isEmptyUri = false,\n  }: Partial<Reference> & Pick<Reference, \"xpath\">): void {\n    if (digestAlgorithm == null) {\n      throw new Error(\"digestAlgorithm is required\");\n    }\n\n    if (!utils.isArrayHasLength(transforms)) {\n      throw new Error(\"transforms must contain at least one transform algorithm\");\n    }\n\n    this.references.push({\n      xpath,\n      transforms,\n      digestAlgorithm,\n      uri,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri,\n      getValidatedNode: () => {\n        throw new Error(\n          \"Reference has not been validated yet; Did you call `sig.checkSignature()`?\",\n        );\n      },\n    });\n  }\n\n  getReferences(): Reference[] {\n    return this.references;\n  }\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string, callback: ErrorFirstCallback<SignedXml>): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @returns If no callback is provided, returns `this` (the instance of SignedXml).\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(xml: string, options: ComputeSignatureOptions): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(\n    xml: string,\n    options: ComputeSignatureOptions,\n    callback: ErrorFirstCallback<SignedXml>,\n  ): void;\n\n  computeSignature(\n    xml: string,\n    options?: ComputeSignatureOptions | ErrorFirstCallback<SignedXml>,\n    callbackParam?: ErrorFirstCallback<SignedXml>,\n  ): void {\n    let callback: ErrorFirstCallback<SignedXml>;\n    if (typeof options === \"function\" && callbackParam == null) {\n      callback = options as ErrorFirstCallback<SignedXml>;\n      options = {} as ComputeSignatureOptions;\n    } else {\n      callback = callbackParam as ErrorFirstCallback<SignedXml>;\n      options = (options ?? {}) as ComputeSignatureOptions;\n    }\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n    let xmlNsAttr = \"xmlns\";\n    const signatureAttrs: string[] = [];\n    let currentPrefix: string;\n\n    const validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n\n    const prefix = options.prefix;\n    const attrs = options.attrs || {};\n    const location = options.location || {};\n    const existingPrefixes = options.existingPrefixes || {};\n\n    this.namespaceResolver = {\n      lookupNamespaceURI: function (prefix) {\n        return prefix ? existingPrefixes[prefix] : null;\n      },\n    };\n\n    // defaults to the root node\n    location.reference = location.reference || \"/*\";\n    // defaults to append action\n    location.action = location.action || \"append\";\n\n    if (validActions.indexOf(location.action) === -1) {\n      const err = new Error(\n        `location.action option has an invalid action: ${\n          location.action\n        }, must be any of the following values: ${validActions.join(\", \")}`,\n      );\n      if (!callback) {\n        throw err;\n      } else {\n        callback(err);\n        return;\n      }\n    }\n\n    // automatic insertion of `:`\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      currentPrefix = `${prefix}:`;\n    } else {\n      currentPrefix = \"\";\n    }\n\n    Object.keys(attrs).forEach(function (name) {\n      if (name !== \"xmlns\" && name !== xmlNsAttr) {\n        signatureAttrs.push(`${name}=\"${attrs[name]}\"`);\n      }\n    });\n\n    // add the xml namespace attribute\n    signatureAttrs.push(`${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\"`);\n\n    let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(\" \")}>`;\n\n    signatureXml += this.createSignedInfo(doc, prefix);\n    signatureXml += this.getKeyInfo(prefix);\n    signatureXml += `</${currentPrefix}Signature>`;\n\n    this.originalXmlWithIds = doc.toString();\n\n    let existingPrefixesString = \"\";\n    Object.keys(existingPrefixes).forEach(function (key) {\n      existingPrefixesString += `xmlns:${key}=\"${existingPrefixes[key]}\" `;\n    });\n\n    // A trick to remove the namespaces that already exist in the xml\n    // This only works if the prefix and namespace match with those in the xml\n    const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;\n    const nodeXml = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const signatureDoc = nodeXml.documentElement.firstChild!;\n\n    const referenceNode = xpath.select1(location.reference, doc);\n\n    if (!isDomNode.isNodeLike(referenceNode)) {\n      const err2 = new Error(\n        `the following xpath cannot be used because it was not found: ${location.reference}`,\n      );\n      if (!callback) {\n        throw err2;\n      } else {\n        callback(err2);\n        return;\n      }\n    }\n\n    if (location.action === \"append\") {\n      referenceNode.appendChild(signatureDoc);\n    } else if (location.action === \"prepend\") {\n      referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n    } else if (location.action === \"before\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `before`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n    } else if (location.action === \"after\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `after`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n    }\n\n    this.signatureNode = signatureDoc;\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfoNodes.length === 0) {\n      const err3 = new Error(\"could not find SignedInfo element in the message\");\n      if (!callback) {\n        throw err3;\n      } else {\n        callback(err3);\n        return;\n      }\n    }\n    const signedInfoNode = signedInfoNodes[0];\n\n    if (typeof callback === \"function\") {\n      // Asynchronous flow\n      this.calculateSignatureValue(doc, (err, signature) => {\n        if (err) {\n          callback(err);\n        } else {\n          this.signatureValue = signature || \"\";\n          signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n          this.signatureXml = signatureDoc.toString();\n          this.signedXml = doc.toString();\n          callback(null, this);\n        }\n      });\n    } else {\n      // Synchronous flow\n      this.calculateSignatureValue(doc);\n      signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n      this.signatureXml = signatureDoc.toString();\n      this.signedXml = doc.toString();\n    }\n  }\n\n  private getKeyInfo(prefix) {\n    const currentPrefix = prefix ? `${prefix}:` : \"\";\n\n    let keyInfoAttrs = \"\";\n    if (this.keyInfoAttributes) {\n      Object.keys(this.keyInfoAttributes).forEach((name) => {\n        keyInfoAttrs += ` ${name}=\"${this.keyInfoAttributes[name]}\"`;\n      });\n    }\n\n    const keyInfoContent = this.getKeyInfoContent({ publicCert: this.publicCert, prefix });\n    if (keyInfoAttrs || keyInfoContent) {\n      return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Generate the Reference nodes (as part of the signature process)\n   *\n   */\n  private createReferences(doc, prefix) {\n    let res = \"\";\n\n    prefix = prefix || \"\";\n    prefix = prefix ? `${prefix}:` : prefix;\n\n    for (const ref of this.getReferences()) {\n      const nodes = xpath.selectWithResolver(ref.xpath ?? \"\", doc, this.namespaceResolver);\n\n      if (!utils.isArrayHasLength(nodes)) {\n        throw new Error(\n          `the following xpath cannot be signed because it was not found: ${ref.xpath}`,\n        );\n      }\n\n      for (const node of nodes) {\n        if (ref.isEmptyUri) {\n          res += `<${prefix}Reference URI=\"\">`;\n        } else {\n          const id = this.ensureHasId(node);\n          ref.uri = id;\n          res += `<${prefix}Reference URI=\"#${id}\">`;\n        }\n        res += `<${prefix}Transforms>`;\n        for (const trans of ref.transforms || []) {\n          const transform = this.findCanonicalizationAlgorithm(trans);\n          res += `<${prefix}Transform Algorithm=\"${transform.getAlgorithmName()}\"`;\n          if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {\n            res += \">\";\n            res += `<InclusiveNamespaces PrefixList=\"${ref.inclusiveNamespacesPrefixList.join(\n              \" \",\n            )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n            res += `</${prefix}Transform>`;\n          } else {\n            res += \" />\";\n          }\n        }\n\n        const canonXml = this.getCanonReferenceXml(doc, ref, node);\n\n        const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n        res +=\n          `</${prefix}Transforms>` +\n          `<${prefix}DigestMethod Algorithm=\"${digestAlgorithm.getAlgorithmName()}\" />` +\n          `<${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue>` +\n          `</${prefix}Reference>`;\n      }\n    }\n\n    return res;\n  }\n\n  getCanonXml(\n    transforms: Reference[\"transforms\"],\n    node: Node,\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions = {},\n  ) {\n    options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;\n    options.signatureNode = this.signatureNode;\n\n    const canonXml = node.cloneNode(true); // Deep clone\n    let transformedXml: Node | string = canonXml;\n\n    transforms.forEach((transformName) => {\n      if (isDomNode.isNodeLike(transformedXml)) {\n        // If, after processing, `transformedNode` is a string, we can't do anymore transforms on it\n        const transform = this.findCanonicalizationAlgorithm(transformName);\n        transformedXml = transform.process(transformedXml, options);\n      }\n      //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n      //This either needs to be more explicit in the API, or all should return the same.\n      //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would incorrectly minimize empty tags\n      //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n      //enveloped transformation returns Node since if it would return String consider this case:\n      //<x xmlns:p='ns'><p:y/></x>\n      //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n    });\n\n    return transformedXml.toString();\n  }\n\n  /**\n   * Ensure an element has Id attribute. If not create it with unique value.\n   * Work with both normal and wssecurity Id flavour\n   */\n  private ensureHasId(node) {\n    let attr;\n\n    if (this.idMode === \"wssecurity\") {\n      attr = utils.findAttr(\n        node,\n        \"Id\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n    } else {\n      this.idAttributes.some((idAttribute) => {\n        attr = utils.findAttr(node, idAttribute);\n        return !!attr; // This will break the loop as soon as a truthy attr is found.\n      });\n    }\n\n    if (attr) {\n      return attr.value;\n    }\n\n    //add the attribute\n    const id = `_${this.id++}`;\n\n    if (this.idMode === \"wssecurity\") {\n      node.setAttributeNS(\n        \"http://www.w3.org/2000/xmlns/\",\n        \"xmlns:wsu\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n      node.setAttributeNS(\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n        \"wsu:Id\",\n        id,\n      );\n    } else {\n      node.setAttribute(\"Id\", id);\n    }\n\n    return id;\n  }\n\n  /**\n   * Create the SignedInfo element\n   *\n   */\n  private createSignedInfo(doc, prefix) {\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\n        \"Missing canonicalizationAlgorithm when trying to create signed info for XML\",\n      );\n    }\n    const transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n    const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    let currentPrefix;\n\n    currentPrefix = prefix || \"\";\n    currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;\n\n    let res = `<${currentPrefix}SignedInfo>`;\n    res += `<${currentPrefix}CanonicalizationMethod Algorithm=\"${transform.getAlgorithmName()}\"`;\n    if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {\n      res += \">\";\n      res += `<InclusiveNamespaces PrefixList=\"${this.inclusiveNamespacesPrefixList.join(\n        \" \",\n      )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n      res += `</${currentPrefix}CanonicalizationMethod>`;\n    } else {\n      res += \" />\";\n    }\n    res += `<${currentPrefix}SignatureMethod Algorithm=\"${algo.getAlgorithmName()}\" />`;\n\n    res += this.createReferences(doc, prefix);\n    res += `</${currentPrefix}SignedInfo>`;\n    return res;\n  }\n\n  /**\n   * Create the Signature element\n   *\n   */\n  private createSignature(prefix?: string) {\n    let xmlNsAttr = \"xmlns\";\n\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      prefix += \":\";\n    } else {\n      prefix = \"\";\n    }\n\n    const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;\n    //the canonicalization requires to get a valid xml node.\n    //we need to wrap the info in a dummy signature since it contains the default namespace.\n    const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\">${signatureValueXml}</${prefix}Signature>`;\n\n    const doc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return doc.documentElement.firstChild!;\n  }\n\n  /**\n   * Returns just the signature part, must be called only after {@link computeSignature}\n   *\n   * @returns The signature XML.\n   */\n  getSignatureXml(): string {\n    return this.signatureXml;\n  }\n\n  /**\n   * Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}\n   *\n   * @returns The original XML with IDs.\n   */\n  getOriginalXmlWithIds(): string {\n    return this.originalXmlWithIds;\n  }\n\n  /**\n   * Returns the original xml document with the signature in it, must be called only after {@link computeSignature}\n   *\n   * @returns The signed XML.\n   */\n  getSignedXml(): string {\n    return this.signedXml;\n  }\n}\n"]}