const e=e=>e/1e3;function t(e,t,n){const r=Math.max(t-5,0);return a=n-e(r),(s=t-r)?a*(1e3/s):0;var a,s}const n=100,r=10,a=1;const s=e=>"string"!=typeof e,o=function(e){const n=new WeakMap;return(r={})=>{const a=new Map,o=(t=0,n=100,s=0,o=!1)=>{const c=`${t}-${n}-${s}-${o}`;return a.has(c)||a.set(c,e(Object.assign({from:t,to:n,velocity:s,restSpeed:o?.05:2,restDistance:o?.01:.5},r))),a.get(c)},c=e=>(n.has(e)||n.set(e,function(e){let t,n=10,r=e(0);const a=[r.current];for(;!r.done&&n<1e4;)r=e(n),a.push(r.done?r.target:r.current),void 0===t&&r.hasReachedTarget&&(t=n),n+=10;const s=n-10;return 1===a.length&&a.push(r.current),{keyframes:a,duration:s/1e3,overshootDuration:(null!=t?t:s)/1e3}}(e)),n.get(e));return{createAnimation:(e,n,r,a,i)=>{var u,l;let h;const d=e.length;if(r&&d<=2&&e.every(s)){const r=e[d-1],s=1===d?null:e[0];let g=0,f=0;const v=null==i?void 0:i.generator;if(v){const{animation:n,generatorStartTime:r}=i,a=(null==n?void 0:n.startTime)||r||0,o=(null==n?void 0:n.currentTime)||performance.now()-a,c=v(o).current;f=null!==(u=s)&&void 0!==u?u:c,(1===d||2===d&&null===e[0])&&(g=t((e=>v(e).current),o,c))}else f=null!==(l=s)&&void 0!==l?l:parseFloat(n());const m=o(f,r,g,null==a?void 0:a.includes("scale")),p=c(m);h=Object.assign(Object.assign({},p),{easing:"linear"}),i&&(i.generator=m,i.generatorStartTime=performance.now())}else{h={easing:"ease",duration:c(o(0,100)).overshootDuration}}return h}}}}((({stiffness:s=n,damping:o=r,mass:c=a,from:i=0,to:u=1,velocity:l=0,restSpeed:h=2,restDistance:d=.5}={})=>{l=l?e(l):0;const g={done:!1,hasReachedTarget:!1,current:i,target:u},f=u-i,v=Math.sqrt(s/c)/1e3,m=((e=n,t=r,s=a)=>t/(2*Math.sqrt(e*s)))(s,o,c);let p;if(m<1){const e=v*Math.sqrt(1-m*m);p=t=>u-Math.exp(-m*v*t)*((m*v*f-l)/e*Math.sin(e*t)+f*Math.cos(e*t))}else p=e=>u-Math.exp(-v*e)*(f+(v*f-l)*e);return e=>{g.current=p(e);const n=0===e?l:t(p,e,g.current),r=Math.abs(n)<=h,a=Math.abs(u-g.current)<=d;var s,o,c;return g.done=r&&a,g.hasReachedTarget=(s=i,o=u,c=g.current,s<o&&c>=o||s>o&&c<=o),g}}));export{o as spring};
