const uriParser=function(){const e=function(){const e=r,s=t,n=this,i="parser.js: Parser(): ";n.ast=void 0,n.stats=void 0,n.trace=void 0,n.callbacks=[];let o,a,d,c,h,l,p,u=0,m=0,g=0,y=0,T=0,f=new function(){this.state=e.ACTIVE,this.phraseLength=0,this.refresh=()=>{this.state=e.ACTIVE,this.phraseLength=0}};n.parse=(t,r,x,b)=>{const k=`${i}parse(): `;u=0,m=0,g=0,y=0,T=0,o=void 0,a=void 0,d=void 0,c=void 0,f.refresh(),h=void 0,l=void 0,p=void 0,c=s.stringToChars(x),o=t.rules,a=t.udts;const A=r.toLowerCase();let v;for(const e in o)if(o.hasOwnProperty(e)&&A===o[e].lower){v=o[e].index;break}if(void 0===v)throw new Error(`${k}start rule name '${startRule}' not recognized`);(()=>{const e=`${i}initializeCallbacks(): `;let s,t;for(h=[],l=[],s=0;s<o.length;s+=1)h[s]=void 0;for(s=0;s<a.length;s+=1)l[s]=void 0;const r=[];for(s=0;s<o.length;s+=1)r.push(o[s].lower);for(s=0;s<a.length;s+=1)r.push(a[s].lower);for(const i in n.callbacks)if(n.callbacks.hasOwnProperty(i)){if(s=r.indexOf(i.toLowerCase()),s<0)throw new Error(`${e}syntax callback '${i}' not a rule or udt name`);if(t=n.callbacks[i]?n.callbacks[i]:void 0,"function"!=typeof t&&void 0!==t)throw new Error(`${e}syntax callback[${i}] must be function reference or falsy)`);s<o.length?h[s]=t:l[s-o.length]=t}})(),n.trace&&n.trace.init(o,a,c),n.stats&&n.stats.init(o,a),n.ast&&n.ast.init(o,a,c),p=b,d=[{type:e.RNM,index:v}],w(0,0),d=void 0;let E=!1;switch(f.state){case e.ACTIVE:throw new Error(`${k}final state should never be 'ACTIVE'`);case e.NOMATCH:E=!1;break;case e.EMPTY:case e.MATCH:E=f.phraseLength===c.length;break;default:throw new Error("unrecognized state")}return{success:E,state:f.state,stateName:e.idName(f.state),length:c.length,matched:f.phraseLength,maxMatched:T,maxTreeDepth:g,nodeHits:y}};const x=(s,t,r,n)=>{if(t.phraseLength>r){let e=`${i}opRNM(${s.name}): callback function error: `;throw e+=`sysData.phraseLength: ${t.phraseLength}`,e+=` must be <= remaining chars: ${r}`,new Error(e)}switch(t.state){case e.ACTIVE:if(!n)throw new Error(`${i}opRNM(${s.name}): callback function return error. ACTIVE state not allowed.`);break;case e.EMPTY:t.phraseLength=0;break;case e.MATCH:0===t.phraseLength&&(t.state=e.EMPTY);break;case e.NOMATCH:t.phraseLength=0;break;default:throw new Error(`${i}opRNM(${s.name}): callback function return error. Unrecognized return state: ${t.state}`)}},b=(s,t)=>{let r,h,m;const g=d[s],y=a[g.index];f.UdtIndex=y.index,u||(m=n.ast&&n.ast.udtDefined(g.index),m&&(h=o.length+g.index,r=n.ast.getLength(),n.ast.down(h,y.name)));const T=c.length-t;l[g.index](f,c,t,p),((s,t,r)=>{if(t.phraseLength>r){let e=`${i}opUDT(${s.name}): callback function error: `;throw e+=`sysData.phraseLength: ${t.phraseLength}`,e+=` must be <= remaining chars: ${r}`,new Error(e)}switch(t.state){case e.ACTIVE:throw new Error(`${i}opUDT(${s.name}) ACTIVE state return not allowed.`);case e.EMPTY:if(!s.empty)throw new Error(`${i}opUDT(${s.name}) may not return EMPTY.`);t.phraseLength=0;break;case e.MATCH:if(0===t.phraseLength){if(!s.empty)throw new Error(`${i}opUDT(${s.name}) may not return EMPTY.`);t.state=e.EMPTY}break;case e.NOMATCH:t.phraseLength=0;break;default:throw new Error(`${i}opUDT(${s.name}): callback function return error. Unrecognized return state: ${t.state}`)}})(y,f,T),u||m&&(f.state===e.NOMATCH?n.ast.setLength(r):n.ast.up(h,y.name,t,f.phraseLength))},w=(s,t)=>{const r=`${i}opExecute(): `,a=d[s];switch(y+=1,m>g&&(g=m),m+=1,f.refresh(),n.trace&&n.trace.down(a,t),a.type){case e.ALT:((s,t)=>{const r=d[s];for(let s=0;s<r.children.length&&(w(r.children[s],t),f.state===e.NOMATCH);s+=1);})(s,t);break;case e.CAT:((s,t)=>{let r,i,o,a;const c=d[s];n.ast&&(i=n.ast.getLength()),r=!0,o=t,a=0;for(let s=0;s<c.children.length;s+=1){if(w(c.children[s],o),f.state===e.NOMATCH){r=!1;break}o+=f.phraseLength,a+=f.phraseLength}r?(f.state=0===a?e.EMPTY:e.MATCH,f.phraseLength=a):(f.state=e.NOMATCH,f.phraseLength=0,n.ast&&n.ast.setLength(i))})(s,t);break;case e.REP:((s,t)=>{let r,i,o,a;const h=d[s];if(0===h.max)return f.state=e.EMPTY,void(f.phraseLength=0);for(i=t,o=0,a=0,n.ast&&(r=n.ast.getLength());!(i>=c.length)&&(w(s+1,i),f.state!==e.NOMATCH)&&f.state!==e.EMPTY&&(a+=1,o+=f.phraseLength,i+=f.phraseLength,a!==h.max););f.state===e.EMPTY||a>=h.min?(f.state=0===o?e.EMPTY:e.MATCH,f.phraseLength=o):(f.state=e.NOMATCH,f.phraseLength=0,n.ast&&n.ast.setLength(r))})(s,t);break;case e.RNM:((s,t)=>{let r,i,a;const l=d[s],m=o[l.index],g=h[m.index];if(u||(i=n.ast&&n.ast.ruleDefined(l.index),i&&(r=n.ast.getLength(),n.ast.down(l.index,o[l.index].name))),g){const s=c.length-t;g(f,c,t,p),x(m,f,s,!0),f.state===e.ACTIVE&&(a=d,d=m.opcodes,w(0,t),d=a,g(f,c,t,p),x(m,f,s,!1))}else a=d,d=m.opcodes,w(0,t,f),d=a;u||i&&(f.state===e.NOMATCH?n.ast.setLength(r):n.ast.up(l.index,m.name,t,f.phraseLength))})(s,t);break;case e.TRG:((s,t)=>{const r=d[s];f.state=e.NOMATCH,t<c.length&&r.min<=c[t]&&c[t]<=r.max&&(f.state=e.MATCH,f.phraseLength=1)})(s,t);break;case e.TBS:((s,t)=>{const r=d[s],n=r.string.length;if(f.state=e.NOMATCH,t+n<=c.length){for(let e=0;e<n;e+=1)if(c[t+e]!==r.string[e])return;f.state=e.MATCH,f.phraseLength=n}})(s,t);break;case e.TLS:((s,t)=>{let r;const n=d[s];f.state=e.NOMATCH;const i=n.string.length;if(0!==i){if(t+i<=c.length){for(let e=0;e<i;e+=1)if(r=c[t+e],r>=65&&r<=90&&(r+=32),r!==n.string[e])return;f.state=e.MATCH,f.phraseLength=i}}else f.state=e.EMPTY})(s,t);break;case e.UDT:b(s,t);break;case e.AND:((s,t)=>{switch(u+=1,w(s+1,t),u-=1,f.phraseLength=0,f.state){case e.EMPTY:case e.MATCH:f.state=e.EMPTY;break;case e.NOMATCH:f.state=e.NOMATCH;break;default:throw new Error(`opAND: invalid state ${f.state}`)}})(s,t);break;case e.NOT:((s,t)=>{switch(u+=1,w(s+1,t),u-=1,f.phraseLength=0,f.state){case e.EMPTY:case e.MATCH:f.state=e.NOMATCH;break;case e.NOMATCH:f.state=e.EMPTY;break;default:throw new Error(`opNOT: invalid state ${f.state}`)}})(s,t);break;default:throw new Error(`${r}unrecognized operator`)}u||t+f.phraseLength>T&&(T=t+f.phraseLength),n.stats&&n.stats.collect(a,f),n.trace&&n.trace.up(a,f.state,t,f.phraseLength),m-=1}},s=function(){const e=r,s=t,n="parser.js: Trace(): ";let i,o,a,d="",c=0;const h=this,l=e=>{let s="",t=0;if(e>=0)for(;e--;)t+=1,5===t?(s+="|",t=0):s+=".";return s};h.init=(e,s,t)=>{o=e,a=s,i=t};const p=t=>{let r;switch(t.type){case e.ALT:r="ALT";break;case e.CAT:r="CAT";break;case e.REP:r=t.max===1/0?`REP(${t.min},inf)`:`REP(${t.min},${t.max})`;break;case e.RNM:r=`RNM(${o[t.index].name})`;break;case e.TRG:r=`TRG(${t.min},${t.max})`;break;case e.TBS:r=t.string.length>6?`TBS(${s.charsToString(t.string,0,3)}...)`:`TBS(${s.charsToString(t.string,0,6)})`;break;case e.TLS:r=t.string.length>6?`TLS(${s.charsToString(t.string,0,3)}...)`:`TLS(${s.charsToString(t.string,0,6)})`;break;case e.UDT:r=`UDT(${a[t.index].name})`;break;case e.AND:r="AND";break;case e.NOT:r="NOT";break;default:throw new Error(`${n}Trace: opName: unrecognized opcode`)}return r};h.down=(e,t)=>{const r=l(c),n=Math.min(100,i.length-t);let o=s.charsToString(i,t,n);n<i.length-t&&(o+="..."),o=`${r}|-|[${p(e)}]${o}\n`,d+=o,c+=1},h.up=(t,r,o,a)=>{const h=`${n}trace.up: `;c-=1;const u=l(c);let m,g,y;switch(r){case e.EMPTY:y="|E|",g="''";break;case e.MATCH:y="|M|",m=Math.min(100,a),g=m<a?`'${s.charsToString(i,o,m)}...'`:`'${s.charsToString(i,o,m)}'`;break;case e.NOMATCH:y="|N|",g="";break;default:throw new Error(`${h} unrecognized state`)}g=`${u}${y}[${p(t)}]${g}\n`,d+=g},h.displayTrace=()=>d},t={stringToChars:e=>[...e].map((e=>e.codePointAt(0))),charsToString:(e,s,t)=>{let r=e;for(;!(void 0===s||s<0);){if(void 0===t){r=e.slice(s);break}if(t<=0)return"";r=e.slice(s,s+t);break}return String.fromCodePoint(...r)}},r={ALT:1,CAT:2,REP:3,RNM:4,TRG:5,TBS:6,TLS:7,UDT:11,AND:12,NOT:13,ACTIVE:100,MATCH:101,EMPTY:102,NOMATCH:103,SEM_PRE:200,SEM_POST:201,SEM_OK:300,idName:e=>{switch(e){case r.ALT:return"ALT";case r.CAT:return"CAT";case r.REP:return"REP";case r.RNM:return"RNM";case r.TRG:return"TRG";case r.TBS:return"TBS";case r.TLS:return"TLS";case r.UDT:return"UDT";case r.AND:return"AND";case r.NOT:return"NOT";case r.ACTIVE:return"ACTIVE";case r.EMPTY:return"EMPTY";case r.MATCH:return"MATCH";case r.NOMATCH:return"NOMATCH";case r.SEM_PRE:return"SEM_PRE";case r.SEM_POST:return"SEM_POST";case r.SEM_OK:return"SEM_OK";default:return"UNRECOGNIZED STATE"}}},n=function(){this.grammarObject="grammarObject",this.rules=[],this.rules[0]={name:"URI",lower:"uri",index:0,isBkr:!1},this.rules[1]={name:"hier-part",lower:"hier-part",index:1,isBkr:!1},this.rules[2]={name:"scheme",lower:"scheme",index:2,isBkr:!1},this.rules[3]={name:"authority",lower:"authority",index:3,isBkr:!1},this.rules[4]={name:"path-abempty",lower:"path-abempty",index:4,isBkr:!1},this.rules[5]={name:"path-absolute",lower:"path-absolute",index:5,isBkr:!1},this.rules[6]={name:"path-rootless",lower:"path-rootless",index:6,isBkr:!1},this.rules[7]={name:"path-empty",lower:"path-empty",index:7,isBkr:!1},this.rules[8]={name:"userinfo-at",lower:"userinfo-at",index:8,isBkr:!1},this.rules[9]={name:"userinfo",lower:"userinfo",index:9,isBkr:!1},this.rules[10]={name:"host",lower:"host",index:10,isBkr:!1},this.rules[11]={name:"IP-literal",lower:"ip-literal",index:11,isBkr:!1},this.rules[12]={name:"IPvFuture",lower:"ipvfuture",index:12,isBkr:!1},this.rules[13]={name:"IPv6address",lower:"ipv6address",index:13,isBkr:!1},this.rules[14]={name:"nodcolon",lower:"nodcolon",index:14,isBkr:!1},this.rules[15]={name:"dcolon",lower:"dcolon",index:15,isBkr:!1},this.rules[16]={name:"h16",lower:"h16",index:16,isBkr:!1},this.rules[17]={name:"h16c",lower:"h16c",index:17,isBkr:!1},this.rules[18]={name:"h16n",lower:"h16n",index:18,isBkr:!1},this.rules[19]={name:"h16cn",lower:"h16cn",index:19,isBkr:!1},this.rules[20]={name:"IPv4address",lower:"ipv4address",index:20,isBkr:!1},this.rules[21]={name:"dec-octet",lower:"dec-octet",index:21,isBkr:!1},this.rules[22]={name:"dec-digit",lower:"dec-digit",index:22,isBkr:!1},this.rules[23]={name:"reg-name",lower:"reg-name",index:23,isBkr:!1},this.rules[24]={name:"reg-name-char",lower:"reg-name-char",index:24,isBkr:!1},this.rules[25]={name:"port",lower:"port",index:25,isBkr:!1},this.rules[26]={name:"query",lower:"query",index:26,isBkr:!1},this.rules[27]={name:"fragment",lower:"fragment",index:27,isBkr:!1},this.rules[28]={name:"segment",lower:"segment",index:28,isBkr:!1},this.rules[29]={name:"segment-nz",lower:"segment-nz",index:29,isBkr:!1},this.rules[30]={name:"pchar",lower:"pchar",index:30,isBkr:!1},this.rules[31]={name:"pct-encoded",lower:"pct-encoded",index:31,isBkr:!1},this.rules[32]={name:"ALPHA",lower:"alpha",index:32,isBkr:!1},this.rules[33]={name:"LF",lower:"lf",index:33,isBkr:!1},this.rules[34]={name:"DIGIT",lower:"digit",index:34,isBkr:!1},this.rules[35]={name:"HEXDIG",lower:"hexdig",index:35,isBkr:!1},this.udts=[],this.rules[0].opcodes=[],this.rules[0].opcodes[0]={type:2,children:[1,2,3,4,8]},this.rules[0].opcodes[1]={type:4,index:2},this.rules[0].opcodes[2]={type:7,string:[58]},this.rules[0].opcodes[3]={type:4,index:1},this.rules[0].opcodes[4]={type:3,min:0,max:1},this.rules[0].opcodes[5]={type:2,children:[6,7]},this.rules[0].opcodes[6]={type:7,string:[63]},this.rules[0].opcodes[7]={type:4,index:26},this.rules[0].opcodes[8]={type:3,min:0,max:1},this.rules[0].opcodes[9]={type:2,children:[10,11]},this.rules[0].opcodes[10]={type:7,string:[35]},this.rules[0].opcodes[11]={type:4,index:27},this.rules[1].opcodes=[],this.rules[1].opcodes[0]={type:1,children:[1,5,6,7]},this.rules[1].opcodes[1]={type:2,children:[2,3,4]},this.rules[1].opcodes[2]={type:7,string:[47,47]},this.rules[1].opcodes[3]={type:4,index:3},this.rules[1].opcodes[4]={type:4,index:4},this.rules[1].opcodes[5]={type:4,index:5},this.rules[1].opcodes[6]={type:4,index:6},this.rules[1].opcodes[7]={type:4,index:7},this.rules[2].opcodes=[],this.rules[2].opcodes[0]={type:2,children:[1,2]},this.rules[2].opcodes[1]={type:4,index:32},this.rules[2].opcodes[2]={type:3,min:0,max:1/0},this.rules[2].opcodes[3]={type:1,children:[4,5,6,7]},this.rules[2].opcodes[4]={type:4,index:32},this.rules[2].opcodes[5]={type:4,index:34},this.rules[2].opcodes[6]={type:6,string:[43]},this.rules[2].opcodes[7]={type:5,min:45,max:46},this.rules[3].opcodes=[],this.rules[3].opcodes[0]={type:2,children:[1,3,4]},this.rules[3].opcodes[1]={type:3,min:0,max:1},this.rules[3].opcodes[2]={type:4,index:8},this.rules[3].opcodes[3]={type:4,index:10},this.rules[3].opcodes[4]={type:3,min:0,max:1},this.rules[3].opcodes[5]={type:2,children:[6,7]},this.rules[3].opcodes[6]={type:7,string:[58]},this.rules[3].opcodes[7]={type:4,index:25},this.rules[4].opcodes=[],this.rules[4].opcodes[0]={type:3,min:0,max:1/0},this.rules[4].opcodes[1]={type:2,children:[2,3]},this.rules[4].opcodes[2]={type:7,string:[47]},this.rules[4].opcodes[3]={type:4,index:28},this.rules[5].opcodes=[],this.rules[5].opcodes[0]={type:2,children:[1,2]},this.rules[5].opcodes[1]={type:7,string:[47]},this.rules[5].opcodes[2]={type:3,min:0,max:1},this.rules[5].opcodes[3]={type:2,children:[4,5]},this.rules[5].opcodes[4]={type:4,index:29},this.rules[5].opcodes[5]={type:3,min:0,max:1/0},this.rules[5].opcodes[6]={type:2,children:[7,8]},this.rules[5].opcodes[7]={type:7,string:[47]},this.rules[5].opcodes[8]={type:4,index:28},this.rules[6].opcodes=[],this.rules[6].opcodes[0]={type:2,children:[1,2]},this.rules[6].opcodes[1]={type:4,index:29},this.rules[6].opcodes[2]={type:3,min:0,max:1/0},this.rules[6].opcodes[3]={type:2,children:[4,5]},this.rules[6].opcodes[4]={type:7,string:[47]},this.rules[6].opcodes[5]={type:4,index:28},this.rules[7].opcodes=[],this.rules[7].opcodes[0]={type:7,string:[]},this.rules[8].opcodes=[],this.rules[8].opcodes[0]={type:2,children:[1,2]},this.rules[8].opcodes[1]={type:4,index:9},this.rules[8].opcodes[2]={type:6,string:[64]},this.rules[9].opcodes=[],this.rules[9].opcodes[0]={type:3,min:0,max:1/0},this.rules[9].opcodes[1]={type:1,children:[2,3,4,5,6,7,8,9,10,11,12]},this.rules[9].opcodes[2]={type:5,min:97,max:122},this.rules[9].opcodes[3]={type:5,min:65,max:90},this.rules[9].opcodes[4]={type:5,min:48,max:57},this.rules[9].opcodes[5]={type:4,index:31},this.rules[9].opcodes[6]={type:6,string:[33]},this.rules[9].opcodes[7]={type:6,string:[36]},this.rules[9].opcodes[8]={type:5,min:38,max:46},this.rules[9].opcodes[9]={type:5,min:58,max:59},this.rules[9].opcodes[10]={type:6,string:[61]},this.rules[9].opcodes[11]={type:6,string:[95]},this.rules[9].opcodes[12]={type:6,string:[126]},this.rules[10].opcodes=[],this.rules[10].opcodes[0]={type:1,children:[1,2,6]},this.rules[10].opcodes[1]={type:4,index:11},this.rules[10].opcodes[2]={type:2,children:[3,4]},this.rules[10].opcodes[3]={type:4,index:20},this.rules[10].opcodes[4]={type:13},this.rules[10].opcodes[5]={type:4,index:24},this.rules[10].opcodes[6]={type:4,index:23},this.rules[11].opcodes=[],this.rules[11].opcodes[0]={type:2,children:[1,2,5]},this.rules[11].opcodes[1]={type:7,string:[91]},this.rules[11].opcodes[2]={type:1,children:[3,4]},this.rules[11].opcodes[3]={type:4,index:13},this.rules[11].opcodes[4]={type:4,index:12},this.rules[11].opcodes[5]={type:7,string:[93]},this.rules[12].opcodes=[],this.rules[12].opcodes[0]={type:2,children:[1,2,4,5]},this.rules[12].opcodes[1]={type:7,string:[118]},this.rules[12].opcodes[2]={type:3,min:1,max:1/0},this.rules[12].opcodes[3]={type:4,index:35},this.rules[12].opcodes[4]={type:7,string:[46]},this.rules[12].opcodes[5]={type:3,min:1,max:1/0},this.rules[12].opcodes[6]={type:1,children:[7,8,9,10,11,12,13,14,15,16]},this.rules[12].opcodes[7]={type:5,min:97,max:122},this.rules[12].opcodes[8]={type:5,min:65,max:90},this.rules[12].opcodes[9]={type:5,min:48,max:57},this.rules[12].opcodes[10]={type:6,string:[33]},this.rules[12].opcodes[11]={type:6,string:[36]},this.rules[12].opcodes[12]={type:5,min:38,max:46},this.rules[12].opcodes[13]={type:5,min:58,max:59},this.rules[12].opcodes[14]={type:6,string:[61]},this.rules[12].opcodes[15]={type:6,string:[95]},this.rules[12].opcodes[16]={type:6,string:[126]},this.rules[13].opcodes=[],this.rules[13].opcodes[0]={type:1,children:[1,2]},this.rules[13].opcodes[1]={type:4,index:14},this.rules[13].opcodes[2]={type:4,index:15},this.rules[14].opcodes=[],this.rules[14].opcodes[0]={type:2,children:[1,5]},this.rules[14].opcodes[1]={type:2,children:[2,3]},this.rules[14].opcodes[2]={type:4,index:18},this.rules[14].opcodes[3]={type:3,min:0,max:1/0},this.rules[14].opcodes[4]={type:4,index:19},this.rules[14].opcodes[5]={type:3,min:0,max:1},this.rules[14].opcodes[6]={type:2,children:[7,8]},this.rules[14].opcodes[7]={type:6,string:[58]},this.rules[14].opcodes[8]={type:4,index:20},this.rules[15].opcodes=[],this.rules[15].opcodes[0]={type:2,children:[1,6,7]},this.rules[15].opcodes[1]={type:3,min:0,max:1},this.rules[15].opcodes[2]={type:2,children:[3,4]},this.rules[15].opcodes[3]={type:4,index:16},this.rules[15].opcodes[4]={type:3,min:0,max:1/0},this.rules[15].opcodes[5]={type:4,index:17},this.rules[15].opcodes[6]={type:6,string:[58,58]},this.rules[15].opcodes[7]={type:1,children:[8,17]},this.rules[15].opcodes[8]={type:2,children:[9,13]},this.rules[15].opcodes[9]={type:2,children:[10,11]},this.rules[15].opcodes[10]={type:4,index:18},this.rules[15].opcodes[11]={type:3,min:0,max:1/0},this.rules[15].opcodes[12]={type:4,index:19},this.rules[15].opcodes[13]={type:3,min:0,max:1},this.rules[15].opcodes[14]={type:2,children:[15,16]},this.rules[15].opcodes[15]={type:6,string:[58]},this.rules[15].opcodes[16]={type:4,index:20},this.rules[15].opcodes[17]={type:3,min:0,max:1},this.rules[15].opcodes[18]={type:4,index:20},this.rules[16].opcodes=[],this.rules[16].opcodes[0]={type:3,min:1,max:4},this.rules[16].opcodes[1]={type:4,index:35},this.rules[17].opcodes=[],this.rules[17].opcodes[0]={type:2,children:[1,2]},this.rules[17].opcodes[1]={type:6,string:[58]},this.rules[17].opcodes[2]={type:3,min:1,max:4},this.rules[17].opcodes[3]={type:4,index:35},this.rules[18].opcodes=[],this.rules[18].opcodes[0]={type:2,children:[1,3]},this.rules[18].opcodes[1]={type:3,min:1,max:4},this.rules[18].opcodes[2]={type:4,index:35},this.rules[18].opcodes[3]={type:13},this.rules[18].opcodes[4]={type:6,string:[46]},this.rules[19].opcodes=[],this.rules[19].opcodes[0]={type:2,children:[1,2,4]},this.rules[19].opcodes[1]={type:6,string:[58]},this.rules[19].opcodes[2]={type:3,min:1,max:4},this.rules[19].opcodes[3]={type:4,index:35},this.rules[19].opcodes[4]={type:13},this.rules[19].opcodes[5]={type:6,string:[46]},this.rules[20].opcodes=[],this.rules[20].opcodes[0]={type:2,children:[1,2,3,4,5,6,7]},this.rules[20].opcodes[1]={type:4,index:21},this.rules[20].opcodes[2]={type:7,string:[46]},this.rules[20].opcodes[3]={type:4,index:21},this.rules[20].opcodes[4]={type:7,string:[46]},this.rules[20].opcodes[5]={type:4,index:21},this.rules[20].opcodes[6]={type:7,string:[46]},this.rules[20].opcodes[7]={type:4,index:21},this.rules[21].opcodes=[],this.rules[21].opcodes[0]={type:3,min:0,max:3},this.rules[21].opcodes[1]={type:4,index:22},this.rules[22].opcodes=[],this.rules[22].opcodes[0]={type:5,min:48,max:57},this.rules[23].opcodes=[],this.rules[23].opcodes[0]={type:3,min:0,max:1/0},this.rules[23].opcodes[1]={type:4,index:24},this.rules[24].opcodes=[],this.rules[24].opcodes[0]={type:1,children:[1,2,3,4,5,6,7,8,9,10,11]},this.rules[24].opcodes[1]={type:5,min:97,max:122},this.rules[24].opcodes[2]={type:5,min:65,max:90},this.rules[24].opcodes[3]={type:5,min:48,max:57},this.rules[24].opcodes[4]={type:4,index:31},this.rules[24].opcodes[5]={type:6,string:[33]},this.rules[24].opcodes[6]={type:6,string:[36]},this.rules[24].opcodes[7]={type:5,min:38,max:46},this.rules[24].opcodes[8]={type:6,string:[59]},this.rules[24].opcodes[9]={type:6,string:[61]},this.rules[24].opcodes[10]={type:6,string:[95]},this.rules[24].opcodes[11]={type:6,string:[126]},this.rules[25].opcodes=[],this.rules[25].opcodes[0]={type:3,min:0,max:1/0},this.rules[25].opcodes[1]={type:4,index:34},this.rules[26].opcodes=[],this.rules[26].opcodes[0]={type:3,min:0,max:1/0},this.rules[26].opcodes[1]={type:1,children:[2,3,4]},this.rules[26].opcodes[2]={type:4,index:30},this.rules[26].opcodes[3]={type:6,string:[47]},this.rules[26].opcodes[4]={type:6,string:[63]},this.rules[27].opcodes=[],this.rules[27].opcodes[0]={type:3,min:0,max:1/0},this.rules[27].opcodes[1]={type:1,children:[2,3,4]},this.rules[27].opcodes[2]={type:4,index:30},this.rules[27].opcodes[3]={type:6,string:[47]},this.rules[27].opcodes[4]={type:6,string:[63]},this.rules[28].opcodes=[],this.rules[28].opcodes[0]={type:3,min:0,max:1/0},this.rules[28].opcodes[1]={type:4,index:30},this.rules[29].opcodes=[],this.rules[29].opcodes[0]={type:3,min:1,max:1/0},this.rules[29].opcodes[1]={type:4,index:30},this.rules[30].opcodes=[],this.rules[30].opcodes[0]={type:1,children:[1,2,3,4,5,6,7,8,9,10,11,12]},this.rules[30].opcodes[1]={type:5,min:97,max:122},this.rules[30].opcodes[2]={type:5,min:65,max:90},this.rules[30].opcodes[3]={type:5,min:48,max:57},this.rules[30].opcodes[4]={type:4,index:31},this.rules[30].opcodes[5]={type:6,string:[33]},this.rules[30].opcodes[6]={type:6,string:[36]},this.rules[30].opcodes[7]={type:5,min:38,max:46},this.rules[30].opcodes[8]={type:5,min:58,max:59},this.rules[30].opcodes[9]={type:6,string:[61]},this.rules[30].opcodes[10]={type:6,string:[64]},this.rules[30].opcodes[11]={type:6,string:[95]},this.rules[30].opcodes[12]={type:6,string:[126]},this.rules[31].opcodes=[],this.rules[31].opcodes[0]={type:2,children:[1,2,3]},this.rules[31].opcodes[1]={type:6,string:[37]},this.rules[31].opcodes[2]={type:4,index:35},this.rules[31].opcodes[3]={type:4,index:35},this.rules[32].opcodes=[],this.rules[32].opcodes[0]={type:1,children:[1,2]},this.rules[32].opcodes[1]={type:5,min:65,max:90},this.rules[32].opcodes[2]={type:5,min:97,max:122},this.rules[33].opcodes=[],this.rules[33].opcodes[0]={type:6,string:[10]},this.rules[34].opcodes=[],this.rules[34].opcodes[0]={type:5,min:48,max:57},this.rules[35].opcodes=[],this.rules[35].opcodes[0]={type:1,children:[1,2,3]},this.rules[35].opcodes[1]={type:5,min:48,max:57},this.rules[35].opcodes[2]={type:5,min:65,max:70},this.rules[35].opcodes[3]={type:5,min:97,max:102},this.toString=function(){let e="";return e+="; LDT 10/21/3023 \n",e+="; modified in several significant ways\n",e+="; 1) Literal strings are replaced with numbers and ranges (%d32 & %d32-126, etc.) when possible.\n",e+=";    TRB and especially TRG operators are much more efficient than TLS operators.\n",e+='; 2) RFC 3986 IPv6address does not work because of APG\'s "first-success disambiguation" and "greedy" repetitions.\n',e+=";    IPv6address redefined and validations moved to callback functions (semantic vs syntactic validation)\n",e+=";    Redefinition requires negative look-ahead operators, https://en.wikipedia.org/wiki/Syntactic_predicate\n",e+=";    That is SABNF instead of simple ABNF.\n",e+='; 3) RFC 3986 IPv4address fails because of "first-success disambiguation".\n',e+=";    This could be fixed with rearrangement of the alternative terms. However, it would still not\n",e+=";    accept zero-padded (leading zeros) decimal octets.\n",e+=";    Therefore, IPv4address is also done with callback functions and semantic validation.\n",e+="; 4) The negative look-ahead operator is also needed in the definition of host to\n",e+=";    prevent failure with a reg-name that begins with an IPv4 address.\n",e+="; 5) NOTE: host = 1.1.1.256 is a valid host name even though it is an invalid IPv4address.\n",e+=";          The IPv4address alternative fails but the reg-name alternative succeeds.\n",e+="\n",e+="\n",e+="; ------------------------------------------------------------------------------\n",e+="; RFC 3986\n",e+="\n",e+='URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]\n',e+='hier-part     = "//" authority path-abempty\n',e+="              / path-absolute\n",e+="              / path-rootless\n",e+="              / path-empty\n",e+="scheme        = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )\n",e+='authority     = [ userinfo-at ] host [ ":" port ]\n',e+='path-abempty  = *( "/" segment )\n',e+='path-absolute = "/" [ segment-nz *( "/" segment ) ]\n',e+='path-rootless = segment-nz *( "/" segment )\n',e+='path-empty    = ""\n',e+="userinfo-at   = userinfo %d64\n",e+='                ; userinfo redefined to include the "@" so that it will fail without it\n',e+="                ; otherwise userinfo can match host and then the parser will backtrack\n",e+="                ; incorrectly keeping the captured userinfo phrase\n",e+="userinfo      = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)\n",e+="host          = IP-literal / (IPv4address !reg-name-char) / reg-name\n",e+="                ; negative look-ahead required to prevent IPv4address from being recognized as first part of reg-name\n",e+="                ; same fix as https://github.com/garycourt/uri-js/issues/4\n",e+='IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"\n',e+='IPvFuture     = "v" 1*HEXDIG "." 1*( %d97-122 / %d65-90 / %d48-57 / %d33 / %d36 /%d38-46 / %d58-59 /%d61 /%d95 / %d126 )\n',e+="IPv6address   = nodcolon / dcolon\n",e+="nodcolon      = (h16n *h16cn) [%d58 IPv4address]\n",e+="dcolon        = [h16 *h16c] %d58.58 (((h16n *h16cn) [%d58 IPv4address]) / [IPv4address])\n",e+="h16           = 1*4HEXDIG\n",e+="h16c          = %d58 1*4HEXDIG\n",e+="h16n          = 1*4HEXDIG !%d46\n",e+="h16cn         = %d58 1*4HEXDIG !%d46\n",e+='IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet\n',e+="; Here we will will use callback functions to evaluate and validate the (possibly zero-padded) dec-octet.\n",e+="dec-octet     =  *3dec-digit\n",e+="dec-digit     = %d48-57\n",e+="reg-name      = *reg-name-char\n",e+="reg-name-char = %d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d59 / %d61 /%d95 / %d126\n",e+="port          = *DIGIT\n",e+="query         = *(pchar / %d47 / %d63)\n",e+="fragment      = *(pchar / %d47 / %d63)\n",e+="\n",e+="segment       = *pchar\n",e+="segment-nz    = 1*pchar\n",e+="pchar         = (%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 /%d58-59 / %d61 / %d64 / %d95 / %d126)\n",e+="pct-encoded   = %d37 HEXDIG HEXDIG\n",e+="\n",e+="; no longer needed - expanded for all usage for fewer branches in the parse there\n",e+="; and more efficient use of the TBS & TRG operators in place of TLS and rule names\n",e+='; does not work with APG probably because of "first-success disambiguation" and greedy repetitions.\n',e+="; will replace with semantic checking of valid number of h16s\n",e+=';IPv6address   =                            6( h16 ":" ) ls32\n',e+=';              /                       "::" 5( h16 ":" ) ls32\n',e+=';              / [               h16 ] "::" 4( h16 ":" ) ls32\n',e+=';              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32\n',e+=';              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32\n',e+=';              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32\n',e+=';              / [ *4( h16 ":" ) h16 ] "::"              ls32\n',e+=';              / [ *5( h16 ":" ) h16 ] "::"              h16\n',e+=';              / [ *6( h16 ":" ) h16 ] "::"\n',e+=';ls32          = ( h16 ":" h16 ) / IPv4address\n',e+='; dec-octet does not work because of "first-success disambiguation".\n',e+="; Must have the longest (3-digit) numbers first.\n",e+="; Even so, this form does not accept leading zeros.\n",e+="; There does not seem to be a clear standard for this (https://en.wikipedia.org/wiki/Dot-decimal_notation)\n",e+="; however and early RFC 790 did show leading-zero padding of the three digits.\n",e+=";dec-octet     = DIGIT                 ; 0-9\n",e+=";                 / %x31-39 DIGIT         ; 10-99\n",e+=';                 / "1" 2DIGIT            ; 100-199\n',e+=';                 / "2" %x30-34 DIGIT     ; 200-249\n',e+=';                 / "25" %x30-35          ; 250-255\n',e+=';statement = 1*( reserved / unreserved / " " )\n',e+=';scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )\n',e+=';authority     = [ userinfo "@" ] host [ ":" port ]\n',e+=';userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )\n',e+=';query         = *( pchar / "/" / "?" )\n',e+=';fragment      = *( pchar / "/" / "?" )\n',e+=';IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )\n',e+=";reg-name      = *( unreserved / pct-encoded / sub-delims )\n",e+=';pct-encoded   = "%" HEXDIG HEXDIG\n',e+=';pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"\n',e+=';path-empty    = 0pchar; deprecated - empty literal string, "", is more efficient \n',e+=';unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"\n',e+=";reserved      = gen-delims / sub-delims\n",e+=';gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"\n',e+=';sub-delims    = "!" / "$" / "&" / "\'" / "(" / ")"\n',e+=';              / "*" / "+" / "," / ";" / "="\n',e+=';HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\n',e+="\n",e+="; ------------------------------------------------------------------------------\n",e+="; RFC 5234\n",e+="\n",e+="ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\n",e+="LF             =  %x0A\n",e+="                  ; linefeed\n",e+="DIGIT          =  %x30-39\n",e+="                  ; 0-9\n",e+="HEXDIG         = %d48-57 / %d65-70 / %d97-102\n",e+="\n",'; LDT 10/21/3023 \n; modified in several significant ways\n; 1) Literal strings are replaced with numbers and ranges (%d32 & %d32-126, etc.) when possible.\n;    TRB and especially TRG operators are much more efficient than TLS operators.\n; 2) RFC 3986 IPv6address does not work because of APG\'s "first-success disambiguation" and "greedy" repetitions.\n;    IPv6address redefined and validations moved to callback functions (semantic vs syntactic validation)\n;    Redefinition requires negative look-ahead operators, https://en.wikipedia.org/wiki/Syntactic_predicate\n;    That is SABNF instead of simple ABNF.\n; 3) RFC 3986 IPv4address fails because of "first-success disambiguation".\n;    This could be fixed with rearrangement of the alternative terms. However, it would still not\n;    accept zero-padded (leading zeros) decimal octets.\n;    Therefore, IPv4address is also done with callback functions and semantic validation.\n; 4) The negative look-ahead operator is also needed in the definition of host to\n;    prevent failure with a reg-name that begins with an IPv4 address.\n; 5) NOTE: host = 1.1.1.256 is a valid host name even though it is an invalid IPv4address.\n;          The IPv4address alternative fails but the reg-name alternative succeeds.\n\n\n; ------------------------------------------------------------------------------\n; RFC 3986\n\nURI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]\nhier-part     = "//" authority path-abempty\n              / path-absolute\n              / path-rootless\n              / path-empty\nscheme        = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )\nauthority     = [ userinfo-at ] host [ ":" port ]\npath-abempty  = *( "/" segment )\npath-absolute = "/" [ segment-nz *( "/" segment ) ]\npath-rootless = segment-nz *( "/" segment )\npath-empty    = ""\nuserinfo-at   = userinfo %d64\n                ; userinfo redefined to include the "@" so that it will fail without it\n                ; otherwise userinfo can match host and then the parser will backtrack\n                ; incorrectly keeping the captured userinfo phrase\nuserinfo      = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)\nhost          = IP-literal / (IPv4address !reg-name-char) / reg-name\n                ; negative look-ahead required to prevent IPv4address from being recognized as first part of reg-name\n                ; same fix as https://github.com/garycourt/uri-js/issues/4\nIP-literal    = "[" ( IPv6address / IPvFuture  ) "]"\nIPvFuture     = "v" 1*HEXDIG "." 1*( %d97-122 / %d65-90 / %d48-57 / %d33 / %d36 /%d38-46 / %d58-59 /%d61 /%d95 / %d126 )\nIPv6address   = nodcolon / dcolon\nnodcolon      = (h16n *h16cn) [%d58 IPv4address]\ndcolon        = [h16 *h16c] %d58.58 (((h16n *h16cn) [%d58 IPv4address]) / [IPv4address])\nh16           = 1*4HEXDIG\nh16c          = %d58 1*4HEXDIG\nh16n          = 1*4HEXDIG !%d46\nh16cn         = %d58 1*4HEXDIG !%d46\nIPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet\n; Here we will will use callback functions to evaluate and validate the (possibly zero-padded) dec-octet.\ndec-octet     =  *3dec-digit\ndec-digit     = %d48-57\nreg-name      = *reg-name-char\nreg-name-char = %d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d59 / %d61 /%d95 / %d126\nport          = *DIGIT\nquery         = *(pchar / %d47 / %d63)\nfragment      = *(pchar / %d47 / %d63)\n\nsegment       = *pchar\nsegment-nz    = 1*pchar\npchar         = (%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 /%d58-59 / %d61 / %d64 / %d95 / %d126)\npct-encoded   = %d37 HEXDIG HEXDIG\n\n; no longer needed - expanded for all usage for fewer branches in the parse there\n; and more efficient use of the TBS & TRG operators in place of TLS and rule names\n; does not work with APG probably because of "first-success disambiguation" and greedy repetitions.\n; will replace with semantic checking of valid number of h16s\n;IPv6address   =                            6( h16 ":" ) ls32\n;              /                       "::" 5( h16 ":" ) ls32\n;              / [               h16 ] "::" 4( h16 ":" ) ls32\n;              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32\n;              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32\n;              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32\n;              / [ *4( h16 ":" ) h16 ] "::"              ls32\n;              / [ *5( h16 ":" ) h16 ] "::"              h16\n;              / [ *6( h16 ":" ) h16 ] "::"\n;ls32          = ( h16 ":" h16 ) / IPv4address\n; dec-octet does not work because of "first-success disambiguation".\n; Must have the longest (3-digit) numbers first.\n; Even so, this form does not accept leading zeros.\n; There does not seem to be a clear standard for this (https://en.wikipedia.org/wiki/Dot-decimal_notation)\n; however and early RFC 790 did show leading-zero padding of the three digits.\n;dec-octet     = DIGIT                 ; 0-9\n;                 / %x31-39 DIGIT         ; 10-99\n;                 / "1" 2DIGIT            ; 100-199\n;                 / "2" %x30-34 DIGIT     ; 200-249\n;                 / "25" %x30-35          ; 250-255\n;statement = 1*( reserved / unreserved / " " )\n;scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )\n;authority     = [ userinfo "@" ] host [ ":" port ]\n;userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )\n;query         = *( pchar / "/" / "?" )\n;fragment      = *( pchar / "/" / "?" )\n;IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )\n;reg-name      = *( unreserved / pct-encoded / sub-delims )\n;pct-encoded   = "%" HEXDIG HEXDIG\n;pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"\n;path-empty    = 0pchar; deprecated - empty literal string, "", is more efficient \n;unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"\n;reserved      = gen-delims / sub-delims\n;gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"\n;sub-delims    = "!" / "$" / "&" / "\'" / "(" / ")"\n;              / "*" / "+" / "," / ";" / "="\n;HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\n\n; ------------------------------------------------------------------------------\n; RFC 5234\n\nALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\nLF             =  %x0A\n                  ; linefeed\nDIGIT          =  %x30-39\n                  ; 0-9\nHEXDIG         = %d48-57 / %d65-70 / %d97-102\n\n'}},i=r,o=t,a={URI:function(e,s,t,r){switch(e.state){case i.ACTIVE:r.errorslength=0;break;case i.MATCH:r.uri=o.charsToString(s,t,e.phraseLength);break;case i.EMPTY:e.state=i.NOMATCH,e.phraseLength=0}},scheme:function(e,s,t,r){if(e.state===i.MATCH)r.uriElements.scheme=o.charsToString(s,t,e.phraseLength)},userinfo:function(e,s,t,r){if(e.state===i.MATCH)r.uriElements.userinfo=o.charsToString(s,t,e.phraseLength-1)},host:function(e,s,t,r){switch(e.state){case i.ACTIVE:r.iplit=!1;break;case i.MATCH:r.iplit?r.uriElements.host=o.charsToString(s,t+1,e.phraseLength-2):r.uriElements.host=o.charsToString(s,t,e.phraseLength);break;case i.EMPTY:r.uriElements.host=""}},ipLiteral:function(e,s,t,r){e.state===i.MATCH&&(r.iplit=!0)},port:function(e,s,t,r){let n=0,a="";switch(e.state){case i.MATCH:a=o.charsToString(s,t,e.phraseLength),n=parseInt(a),Number.isNaN(n)?(e.state=i.NOMATCH,e.phraseLength=0):r.uriElements.port=n;break;case i.EMPTY:r.uriElements.port=""}},pathAbempty:function(e,s,t,r){switch(e.state){case i.MATCH:r.uriElements.path=o.charsToString(s,t,e.phraseLength);break;case i.EMPTY:r.uriElements.path=""}},pathAbsolute:function(e,s,t,r){if(e.state===i.MATCH)r.uriElements.path=o.charsToString(s,t,e.phraseLength)},pathRootless:function(e,s,t,r){if(e.state===i.MATCH)r.uriElements.path=o.charsToString(s,t,e.phraseLength)},pathEmpty:function(e,s,t,r){switch(e.state){case i.MATCH:case i.NOMATCH:e.state=i.NOMATCH,e.phraseLength=0;case i.EMPTY:r.uriElements.path=""}},query:function(e,s,t,r){switch(e.state){case i.MATCH:r.uriElements.query=o.charsToString(s,t,e.phraseLength);break;case i.EMPTY:r.uriElements.query=""}},fragment:function(e,s,t,r){switch(e.state){case i.MATCH:r.uriElements.fragment=o.charsToString(s,t,e.phraseLength);break;case i.EMPTY:r.uriElements.fragment=""}},ipv4:function(e,s,t,r){e.state===i.MATCH&&(r.ipv4=!0)},h16:function(e,s,t,r){e.state===i.MATCH&&(r.h16count+=1)},nodcolon:function(e,s,t,r){switch(e.state){case i.ACTIVE:r.h16count=0,r.ipv4=!1;break;case i.MATCH:r.ipv4?6===r.h16count?e.state=i.MATCH:(e.state=i.NOMATCH,e.phraseLength=0):8===r.h16count?e.state=i.MATCH:(e.state=i.NOMATCH,e.phraseLength=0)}},dcolon:function(e,s,t,r){switch(e.state){case i.ACTIVE:r.h16count=0,r.ipv4=!1;break;case i.MATCH:r.ipv4?r.h16count<6?e.state=i.MATCH:(e.state=i.NOMATCH,e.phraseLength=0):r.h16count<8?e.state=i.MATCH:(e.state=i.NOMATCH,e.phraseLength=0)}},decOctet:function(e,s,t,r){switch(e.state){case i.ACTIVE:r.octet=0;break;case i.MATCH:r.octet>255&&(e.state=i.NOMATCH,e.phraseLength=0)}},decDigit:function(e,s,t,r){if(e.state===i.MATCH)r.octet=10*r.octet+s[t]-48}};return new function(){let t="",r={};const i=new e,o=new n;i.callbacks.uri=a.URI,i.callbacks.scheme=a.scheme,i.callbacks["userinfo-at"]=a.userinfo,i.callbacks.host=a.host,i.callbacks["IP-literal"]=a.ipLiteral,i.callbacks.port=a.port,i.callbacks["path-abempty"]=a.pathAbempty,i.callbacks["path-absolute"]=a.pathAbsolute,i.callbacks["path-rootless"]=a.pathRootless,i.callbacks["path-empty"]=a.pathEmpty,i.callbacks.query=a.query,i.callbacks.fragment=a.fragment,i.callbacks.IPv4address=a.ipv4,i.callbacks.nodcolon=a.nodcolon,i.callbacks.dcolon=a.dcolon,i.callbacks.h16=a.h16,i.callbacks.h16c=a.h16,i.callbacks.h16n=a.h16,i.callbacks.h16cn=a.h16,i.callbacks["dec-octet"]=a.decOctet,i.callbacks["dec-digit"]=a.decDigit,this.parse=(e,n)=>{if(i.trace=n?new s:void 0,r={uriElements:{}},t=i.parse(o,"uri",e,r),t.success)return{uri:r.uri,scheme:r.uriElements.scheme,userinfo:r.uriElements.userinfo,host:r.uriElements.host,port:r.uriElements.port,path:r.uriElements.path,query:r.uriElements.query,fragment:r.uriElements.fragment}},this.apgParserResult=()=>t,this.displayTrace=()=>{if(i.trace)return i.trace.displayTrace()}}}(),parseUri=()=>{const e=$("#uri").val(),s=uriParser.parse(e);s?$("#result").html("Result\n"+JSON.stringify(s,null,2)):$("#result").html("Result\ninvalid URI")};$(document).ready((()=>{$("#parse").click(parseUri),$("#uri").val("https://user:pass@example.com:123/one/two.three?q1=a1&q2=a2#body")}));