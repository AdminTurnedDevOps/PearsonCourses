"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAgent = getAgent;
const url = require("url");
const http = require("http");
const https = require("https");
const LRU = require("lru-cache");
const getHttpsProxyAgent = require("https-proxy-agent");
const pac_proxy_agent_1 = require("pac-proxy-agent");
const socks_proxy_agent_1 = require("socks-proxy-agent");
const getSocksProxyAgent = (opts) => new socks_proxy_agent_1.SocksProxyAgent(opts);
const util_1 = require("../util/util");
const proxy_config_1 = require("./proxy-config");
const passthrough_handling_1 = require("./passthrough-handling");
const KeepAliveAgents = util_1.isNode
    ? {
        'http:': new http.Agent({
            keepAlive: true
        }),
        'https:': new https.Agent({
            keepAlive: true
        })
    } : {};
const ProxyAgentFactoryMap = {
    'http:': getHttpsProxyAgent, // HTTPS here really means 'CONNECT-tunnelled' - it can do either
    'https:': getHttpsProxyAgent,
    'pac+http:': (...args) => new pac_proxy_agent_1.PacProxyAgent(...args),
    'pac+https:': (...args) => new pac_proxy_agent_1.PacProxyAgent(...args),
    'socks:': getSocksProxyAgent,
    'socks4:': getSocksProxyAgent,
    'socks4a:': getSocksProxyAgent,
    'socks5:': getSocksProxyAgent,
    'socks5h:': getSocksProxyAgent
};
const proxyAgentCache = new LRU({
    max: 20,
    ttl: 1000 * 60 * 5, // Drop refs to unused agents after 5 minutes
    ttlResolution: 1000 * 60, // Check for expiry once every minute maximum
    ttlAutopurge: true, // Actively drop expired agents
    updateAgeOnGet: true // Don't drop agents while they're in use
});
const getCacheKey = (options) => JSON.stringify(options);
async function getAgent({ protocol, hostname, port, tryHttp2, keepAlive, proxySettingSource }) {
    const proxySetting = await (0, proxy_config_1.getProxySetting)(proxySettingSource, { hostname });
    if (proxySetting?.proxyUrl) {
        // If there's a (non-empty) proxy configured, use it. We require non-empty because empty strings
        // will fall back to detecting from the environment, which is likely to behave unexpectedly.
        if (!(0, proxy_config_1.matchesNoProxy)(hostname, port, proxySetting.noProxy)) {
            // We notably ignore HTTP/2 upstream in this case: it's complicated to mix that up with proxying
            // so for now we ignore it entirely.
            const cacheKey = getCacheKey({
                url: proxySetting.proxyUrl,
                trustedCAs: proxySetting.trustedCAs,
                additionalTrustedCAs: proxySetting.additionalTrustedCAs
            });
            if (!proxyAgentCache.has(cacheKey)) {
                const { href, protocol, auth, hostname, port } = url.parse(proxySetting.proxyUrl);
                const buildProxyAgent = ProxyAgentFactoryMap[protocol];
                // If you specify trusted CAs, we override the CAs used for this connection, i.e. the trusted
                // CA for the certificate of an HTTPS proxy. This is *not* the CAs trusted for upstream servers
                // on the otherside of the proxy - see the corresponding passthrough options for that.
                const trustedCerts = await (0, passthrough_handling_1.getTrustedCAs)(proxySetting.trustedCAs, proxySetting.additionalTrustedCAs);
                proxyAgentCache.set(cacheKey, buildProxyAgent({
                    href,
                    protocol,
                    auth,
                    hostname,
                    port,
                    ...(trustedCerts
                        ? { ca: trustedCerts }
                        : {})
                }));
            }
            return proxyAgentCache.get(cacheKey);
        }
    }
    if (tryHttp2 && (protocol === 'https:' || protocol === 'wss:')) {
        // H2 wrapper takes multiple agents, uses the appropriate one for the detected protocol.
        // We notably never use H2 upstream for plaintext, it's rare and we can't use ALPN to detect it.
        return { https: KeepAliveAgents['https:'], http2: undefined };
    }
    else if (keepAlive && protocol !== 'wss:' && protocol !== 'ws:') {
        // HTTP/1.1 or HTTP/1 with explicit keep-alive
        return KeepAliveAgents[protocol || 'http:'];
    }
    else {
        // HTTP/1 without KA - just send the request with no agent
        return undefined;
    }
}
//# sourceMappingURL=http-agents.js.map